["```js\n<!-- Scripts -->\n<script src=\"utils.js\"></script>\n<script src=\"cards.js\"></script>\n<script src=\"state.js\"></script>\n<script src=\"main.js\"></script>\n```", "```js\nnew Vue({\n  name: 'game',\n  el: '#app',\n})\n```", "```js\nnew Vue({\n  name: 'game',\n  el: '#app',\n\n  template: `<div id=\"#app\">\n    Hello world!\n  </div>`,\n})\n```", "```js character (back quote). It allows us, among other things, to write text spanning multiple lines, without having to write verbose string concatenations.\n\nNow if you open the app, you should see the `'Hello world!'` text displayed. As you guessed, we won't inline the template in the `#app` element going forward.\n\n# The app state\n\nAs explained before, the `state.js` file will help us consolidate the main data of our application in one place. That way, it will be easier to write game logic functions without polluting the definition object with a lot of methods.\n\n1.  The `state.js` file declares a state variable that we will use as the data of our app. We can use it directly as the data option, as follows:\n\n```", "```js\n\nNow, if you open the devtools, you should see the only data property already declared in the state object:\n\n![](assets/06ba9d2b-5ad4-4ed0-ae51-c1774600dde0.png)\n\nThe world ratio is a number representing how much we should scale the game objects to fit in the window. For example, `.6` means that the world should scale at 60% of its original size. It is computed with the `getWorldRatio` function in the `utils.js` file.\n\nThere is one thing missing, though--it is not recomputed when the window is resized. This is something we have to implement ourselves. After the Vue instance constructor, add an event listener to the window object to detect when it is resized.\n\n2.  Inside the handler, update the `worldRatio` data property of the state. You can also display `worldRatio` in the template:\n\n```", "```js\n\nTry resizing your browser window horizontally--the `worldRatio` data property is updated in the Vue app.\n\n*But wait! We are modifying the state object, not the Vue instance...*\n\nYou are right! However, we have set the Vue instance `data` property with the `state` object. This means Vue has set up reactivity on it, and we can change its attributes to update our app, as we will see in a second.\n\n3.  To ensure that `state` is the app's reactive data, try comparing the instance data object and the global state object:\n\n```", "```js\n\nThese are the same objects we set with the data option. So when you do:\n\n```", "```js\n\nYou are also doing this:\n\n```", "```js\n\nThis is, in fact, the same as follows:\n\n```", "```js\n\nThis will be useful in the gameplay function that will use the state object to update the game data.\n\n# The almighty components\n\nComponents are the building blocks that will compose our app--it's the central concept of the Vue apps. They are small parts of the view, and they should be relatively small, reusable, and as self-sufficient as possible--structuring an app with components will then help maintain and evolve it, especially if it becomes large. In fact, this is becoming the standard method for creating huge web apps in an efficient and manageable way.\n\nIn concrete terms, your app will be a giant tree of smaller components:\n\n![](assets/b20410bf-c9fc-47ea-8474-f65537e325f3.png)\n\nFor example, your app could have a form component, which could contain several input components and button components. Each one would be a very specific part of the UI, and they would be reusable all across the app. Being quite small in scope, they would be easy to understand and reason about, and thus easier to maintain (issue fixing) or to evolve.\n\n# Building the user interface\n\nThe first components we will create are part of the UI layer. There will be a top bar with the players' names and a turn counter, the cards with their name and description, the hand with the current player cards, and the three overlays.\n\n# Our first component - the top bar\n\nThe top bar, our first component, will be placed at the top of the page and will display the names of the two players and a turn counter in the middle. It will also show an arrow facing the name of the player currently taking their turn.\n\nIt will look like this:\n\n![](assets/8739ced8-2ec7-4a72-af0f-fa01f814c080.png)\n\n# Adding some gameplay data to the state\n\nBefore creating the component, we need some new data properties:\n\n*   `turn`: The number of the current turn; starts at 1\n*   `players`: The array of player objects\n*   `currentPlayerIndex`: The index of the current player in the `players` array\n\nAdd them in the state in the `state.js` file:\n\n```", "```js\n\n`Math.round(Math.random())` will use `0` or `1` randomly to choose who goes first.\n\nWe will use these properties to display the player names and the turn counter in the top bar.\n\n# Defining and using the components\n\nWe will write our UI components in a new file:\n\n1.  Create a `components` folder and a new `ui.js` file inside it. Include it in the main `index.html` page, just before the main script:\n\n```", "```js\n\nIn this file, we will register our components, so it's important that the main Vue instance is created afterward, and not before. Else, we would get errors of components not being found.\n\nTo register a component, we can use the global `Vue.component()` function. It takes two arguments; the name under which we register the component, and its definition object, which is using the exact same options as the Vue instance that we already know.\n\n2.  Let's create the `top-bar` component in the `ui.js` file:\n\n```", "```js\n\nNow, we can use the `top-bar` component in our templates, just like any other HTML tags, for instance, `<top-bar>`.\n\n3.  In the main template, add a new `top-bar` tag:\n\n```", "```js\n\nThis template will create a new `top-bar` component and render it inside the `#app` element, using the definition object we just defined. If you open the devtools, you should see two entries:\n\n![](assets/8ea8c881-2a6b-4eb0-be9e-4c711323bb9c.png)\n\nEach one is a Vue instance--Vue actually created a second instance using the definition we provided for the top-bar component.\n\n# Parent-to-child communication with Props\n\nAs we saw in the The almighty components section, our component-based app will have a tree of components, and we need them to communicate with each other. For now, we will only focus on descending, parent-to-child communication. This is accomplished with \"props\".\n\nOur `top-bar` component needs to know who the players are, which one is currently playing, and what the current turn number is. So, we will need three props--`players`, `currentPlayerIndex`, and `turn`.\n\nTo add props to a component definition, use the `props` option. For now, we will simply list the names of our props. However, you should know that there is a more detailed notation with an object instead, which we will cover in the next chapters.\n\n1.  Let's add the props to our component:\n\n```", "```js\n\nIn the parent component, which is the root application, we can set the props value the exact same way we would for HTML attributes.\n\n2.  Go ahead and use the `v-bind` shorthand to wire the props value with the app data in the main template:\n\n```", "```js\n\nNote that since HTML is case-insensitive and by convention, it is recommended to use the kebab-case (with dashes) names of our props, and the camel-case names in the JavaScript code.\n\nNow, we can use the props in our `top-bar` component just like data properties. For example, you could write something like this:\n\n```", "```js\n\nThis would print the `players` array sent by the parent component (our app) in the browser console.\n\n# Props in our template\n\nWe will now use the props we created in the template of the `top-bar` component.\n\n1.  Change the `top-bar` template to display the player's name with the `players` prop:\n\n```", "```js\n\nAs you can see in the preceding code, we are also using the props like we did with properties in templates. You should see the player names displayed in the app.\n\n2.  Continue with the turn counter between `players` using the `turn` prop:\n\n```", "```js\n\nIn addition to the label, we also want to display a big arrow facing the current player to make it more obvious.\n\n3.  Add the arrow image inside the `.turn-counter` element, and add a dynamic class using the `currentPlayerIndex` prop with the `v-bind` shorthand we used in\u00a0[Chapter 2](5b490dfd-08c4-4274-8f49-ad3e385c26ef.xhtml), *Markdown Notebook*:\n\n```", "```js\n\nNow, the app should display the fully featured top bar, with the two players, names and the turn counter between them. You can test the Vue-automated reactivity by typing these commands into the browser console:\n\n```", "```js\n\nYou should see the arrow turning around to face the correct player name, which gets emphasized:\n\n![](assets/a667ef7b-5325-4e1a-bf9f-4555b64d5b38.png)\n\n# Displaying a card\n\nAll the cards are described in the card definition objects, declared in the `cards.js` file. You can open it, but you shouldn't have to modify its content. Each card definition has the following fields:\n\n*   `id`: Unique for each card\n*   `type`: Changes the color background to help distinguish the cards from each other\n*   `title`: The displayed name of the card\n*   `description`: An HTML text explaining what the card does\n*   `note`: An optional flavor text, in HTML too\n*   `play`: The function we will call when the card is played\n\nWe need a new component to display any card, either in the player hand or in the overlay, that describes what the opponent played last turn. It will look like this:\n\n![](assets/bdcb0ac6-585b-4c0f-a2e3-fdbe7c28385b.png)\n\n1.  In the `components/ui.js` file, create a new `card` component:\n\n```", "```js\n\n2.  This component will receive a `def` prop that will be the card definition object we described above. Declare it with the `props` option as we did for the `top-bar` component:\n\n```", "```js\n\n3.  Now, we can add the template. Start with the main `div` element, with the `card` class:\n\n```", "```js\n\n4.  To change the background color depending on the card type, add a dynamic CSS class that uses the `type` property of the card object:\n\n```", "```js\n\nFor example, if the card has the `'attack'` type, the element will get the `type-attack` class. Then, it will have a red background.\n\n5.  Now, add the title of the card with the corresponding class:\n\n```", "```js\n\n6.  Add the separator image, which will display some lines between the card title and the description:\n\n```", "```js\n\nAfter the image, append the description element.\n\nNote that since the `description` property of the card object is an HTML-formatted text, we need to use the special `v-html` directive introduced in the [Chapter 2](5b490dfd-08c4-4274-8f49-ad3e385c26ef.xhtml), *Markdown Notebook.*\n\n7.  Use the `v-html` directive to display the description:\n\n```", "```js\n\nYou may have noted that we added a nested `div` element, which will contain the description text. This is to center the text vertically using CSS flexbox.\n\n8.  Finally, add the card note (which is also in an HTML-formatted text). Note that some cards don't have note, so we have to use the `v-if` directive here:\n\n```", "```js\n\nThe card component should now look like this:\n\n```", "```js\n\nNow, we can try our new card component in the main application component.\n\n9.  Edit the main template as follows and add a `card` component just after the top bar:\n\n```", "```js\n\n10.  We also need to define a temporary computed property:\n\n```", "```js\n\nNow, you should see a red attack card with a title, description, and flavor text:\n\n![](assets/6b8c4676-e72a-41bb-915f-24b2ed0c0023.png)\n\n# Listening to native events on components\n\nLet's try adding a click event handler on our card:\n\n```", "```js\n\nWith a dumb method in the main component:\n\n```", "```js\n\nIf you test this in the browser, you may be surprised that it doesn't work as expected. Nothing is output to the console...\n\nThis is because Vue has its own event system for components, called \"custom events\", that we will learn about in a moment. This system is separate from the browser events, so here Vue expects a custom `'click'` event, and not the browser one. Thus, the `handler` method is not called.\n\nTo get around this, you should use the `.native` modifier on the `v-on` directive, as follows:\n\n```", "```js\n\nNow, the `handlePlay` method is called when you click on the card, as expected.\n\n# Child-to-parent communication with custom events\n\nPreviously, we used props to communicate from a parent component to its children. Now, we would like to do the opposite and communicate from one child component to its parent. For our card component, we would like to tell the parent component that the card is being played by the player when they click on it. We can't use props here, but we can use custom events. In our components, we can emit events that can be caught by the parent component with the `$emit` special method. It takes one mandatory argument, which is the event type:\n\n```", "```js\n\nWe can listen to the custom events inside the same Vue instance with the `$on` special method:\n\n```", "```js\n\nThe `$emit` method also sends a `'play'` event to the parent component. We can listen to it in the parent component template with the `v-on` directive just like we did before:\n\n```", "```js\n\nYou can also use the `v-bind` shorthand:\n\n```", "```js\n\nWe can also add as many arguments as we like that will get passed to the handler methods:\n\n```", "```js\n\nHere, we emitted a `'play'` event with the following two arguments--\u00a0`'orange'` and `42`.\n\nIn the handle, we can get them via the arguments, as follows:\n\n```", "```js\n\nThe `color` argument will have the `'orange'` value and the `number` argument will have the `42` value.\n\nLike we saw in the preceding section, custom events are completely separate from the browser event system. The special methods--`$on` and `$emit`--are not aliases to the standard `addEventListener` and `dispatchEvent`. That explains why we need the `.native` modifier on components to listen to browser events such as `'click'`.\n\nBack to our card component, we just need to emit a very simple event to tell the parent component that the card is being played:\n\n1.  First, add the method that will emit the event:\n\n```", "```js\n\n2.  We would like to call this method when the user clicks on the card. Just listen to a browser click event on the main card `div` element:\n\n```", "```js\n\n3.  We are done with the card component. To test this, listen to the `'play'` custom event in the main component template:\n\n```", "```js\n\nNow, the `handlePlay` method will be called whenever the `'play'` event is emitted.\n\nWe could just have listened to a native click event instead, but it's in most cases a good idea to use custom events to communicate between components. For example, we could also emit the `'play'` event when the user uses another method, such as using the keyboard to select the card and pressing *Enter*; we won't implement that method in this book though.\n\n# The hand\n\nOur next component will be the current player hand, holding the five cards they have. It will be animated with a 3D transition and will also be responsible for the card animations (when the card is drawn, and when it is played).\n\n1.  In the `components/ui.js` file, add a component registration with the `'hand'` ID and a basic template, with two `div` elements:\n\n```", "```js\n\nThe wrapper element will help us position and animate the cards.\n\nEach card in the hand will be represented by an object. For now, it will have the following properties:\n\n*   `id`: The card definition unique identifier\n*   `def`: The card definition object\n\nAs a reminder, all the card definitions are declared in the `cards.js` file.\n\n2.  Our hand component will receive these card objects representing the player hand via a new array prop called `cards`:\n\n```", "```js\n\n3.  We can now add the card components with the `v-for` directive:\n\n```", "```js\n\n4.  To test our hand component, we will create in the app state a temporary property called `testHand` (in the `state.js` file):\n\n```", "```js\n\n5.  Add a `createTestHand` method in the main component (in the `main.js` file):\n\n```", "```js\n\n6.  To test the hand, we also need this temporary `testDrawCard` method that simulates a random card draw:\n\n```", "```js\n\n7.  Use the `created` lifecycle hook to initialize the hand:\n\n```", "```js\n\n`cardUid` is a unique identifier on cards drawn by the players that will be useful to identify each of the cards in the hand, because many cards can share the exact same card definition, and we will need a way to differentiate them.\n\n8.  In the main template, add the hand component:\n\n```", "```js\n\nThe result in your browser should look like this:\n\n![](assets/928716a8-049d-4deb-a1f5-c3827a3f597f.png)\n\n# Animating the hand with transitions\n\nDuring a game, the hand will be hidden when any overlay is shown. To make the app prettier, we will animate the hand when it is added or removed from the DOM. To do that, we will use CSS transitions together with a powerful Vue tool--the special `<transition>` component. It will help us work with CSS transitions when adding or removing elements with the `v-if` or `v-show` directives.\n\n1.  First, add a new `activeOverlay` data property to the app state in the `state.js` file:\n\n```", "```js\n\n2.  In the main template, we will show the hand component only if `activeOverlay` is not defined, thanks to the `v-if` directive:\n\n```", "```js\n\n3.  Now, if you change `state.activeOverlay` to any truthy value in the browser console, the hand will disappear:\n\n```", "```js\n\n4.  Also, if you set it back to `null`, the hand will be shown again:\n\n```", "```js\n\n5.  To apply a transition when a component is added or removed by a `v-if` or `v-show` directive, surround it with a transition component like this:\n\n```", "```js\n\nNote that this also works on HTML elements:\n\n```", "```js\n\nThe `<transition>` special component will not appear in the DOM, like the `<template>` tag we used in [Chapter 2](5b490dfd-08c4-4274-8f49-ad3e385c26ef.xhtml), *Markdown Notebook*.\n\nWhen the element is added to the DOM (the enter phase), the transition component will automatically apply the following CSS classes to the element:\n\n*   `v-enter-active`: Apply the class while the enter transition is active. This class is added before the element is inserted to the DOM, and it is removed when the animation finishes. You should add some `transition` CSS properties in this class and define their duration.\n*   `v-enter`: The starting state of the element. This class is added before the element is inserted, and it is removed one frame after the element is inserted. For example, you could set the opacity to `0` in this class.\n*   `v-enter-to`: The target state of the element. This class is added one frame after the element is inserted, at the same time `v-enter` is removed. It is removed when the animation finishes.\n\nWhen the element is being removed from the DOM (the leave phase), they are replaced by the following:\n\n*   `v-leave-active`: Applied while the leave transition is active. This class is added when the leaving transition triggers, and it is removed after the element is removed from the DOM. You should add some `transition` CSS properties in this class and define their duration.\n*   `v-leave`: The starting state of the element when being removed. This class is also added when the leaving transition triggers and is removed one frame after.\n*   `v-leave-to`: The target state of the element. This class is added one frame after the leaving transition triggers, at the same time `v-leave` is removed. It is removed when the element is removed from the DOM.\n\nDuring the leave phase, the element is not immediately removed from the DOM. It will be removed when the transition finishes to allow the user to see the animation.\n\nHere is a schema that summarizes the two enter and leave phases, with the corresponding CSS classes:\n\n![](assets/6159a0e0-22b4-4c34-aef2-b7e7730b7cd2.png)The transition component will automatically detect the duration of the CSS transitions applied on the element.\n\n6.  We need to write some CSS to make our animation. Create a new `transitions.css` file and include it in the web page:\n\n```", "```js\n\nLet's try a basic fading animation first. We want to apply a CSS transition on the opacity CSS property for 1 second.\n\n7.  To do that, use both the `v-enter-active` and `v-leave-active` classes since it will be the same animation:\n\n```", "```js\n\nWhen the hand is either being added or removed from the DOM, we want it to have an opacity of `0` (so it will be fully transparent).\n\n8.  Use both the `v-enter` and `v-leave-to` classes to apply this full transparency:\n\n```", "```js\n\n9.  Back to the main template, surround the hand component with a transition special component:\n\n```", "```js\n\nNow, when you hide or show the hand, it will fade in and out.\n\n10.  Since we may have to reuse this animation, we should give it a name:\n\n```", "```js\n\nWe have to change our CSS classes, because Vue will now use `fade-enter-active` instead of `v-enter-active`.\n\n11.  In the `transition.css` file, modify the CSS selector to match this change:\n\n```", "```js\n\nNow, we can reuse this animation on any element with `<transition name=\"fade\">`.\n\n# A prettier animation\n\nWe will now make a more complex but better animation, with some 3D effects. In addition to the hand, we will animate the `.wrapper` element (for a 3D flip) and the `.card` elements. The cards will start being piled up and will progressively expand to their expected position in the hand. At the end, it will animate as if the player is picking up the cards from a table.\n\n1.  Start by creating new transition CSS classes with the `'hand'` name instead of `'fade'`:\n\n```", "```js\n\n2.  Change the transition name in the main template too:\n\n```", "```js\n\n3.  Let's animate the wrapper element. Use the CSS transform property to apply a 3D transformation to the element:\n\n```", "```js\n\nThe right rotating axis is the horizontal one, which is `x`. This will animate the cards just as if they were being picked up by the player. Note that there is a cubic-bezier easing function defined to make the animation smoother.\n\n4.  Finally, animate the cards themselves by setting a negative horizontal margin so that they will seem to be piled up:\n\n```", "```js\n\nNow, if you hide and show the hand with the browser console like we did before, it will have a nice animation.\n\n# Playing a card\n\nNow, we need to handle the `'play'` event in the hand component we emit in the cards when the user clicks on them, and emit a new `'card-play'` event to the main component with an additional argument--the played card in question.\n\n1.  First, create a new method called `handlePlay`. It takes a `card` argument and emits the new event to the parent component:\n\n```", "```js\n\n2.  Then, add a listener to our cards for the `'play'` event:\n\n```", "```js\n\nAs you can see here, we directly use the iterator variable `card` of the `v-for` loop. That way, we don't need the card component to emit its `card` item since we already know what it is.\n\nTo test the card play, we will only remove it from the hand for now.\n\n3.  Create a new temporary method called `testPlayCard` in the main component in the `main.js` file:\n\n```", "```js\n\n4.  Add the event listener for the `'card-play'` event on the `hand` component in the main template:\n\n```", "```js\n\nIf you click on a card, it should now emit a `'play'` event to the hand component, which will then emit a `'card-play'` event to the main component. It will, in turn, remove the card from the hand, making it disappear. To help you debug this sort of use case, the devtools have an Events tab:\n\n![](assets/32fa4cee-0203-43fe-b413-eafcccce1ea5.png)\n\n# Animating the card list\n\nThere are three missing animations for our hand--when a card is either added or removed from the player hand, and when it is moved. When the turn begins, the player will draw a card. It means that we will add a card to the hand cards list, and it will slide from the right into the hand. When a card is played, we want it to go up and grow bigger.\n\nTo animate a list of elements, we will need another special component--`<transition-group>`. It animates the children when they are added, removed, and moved. In a template, it looks like this:\n\n```", "```js\n\nUnlike the `<transition>` element, the transition group will appear in the DOM as a `<span>` element by default. You can change the HTML element with the `tag` prop:\n\n```", "```js\n\nIn the template of our `hand` component, enclose the card components with a transition group, specify the name of the transition that we will call `\"card\"`, and add the `\"cards\"` CSS class:\n\n```", "```js\n\nBefore we can continue, there is one important thing missing--the children of the transition group must be identified by a unique key.\n\n# The key special attribute\n\nWhen Vue is updating a list of DOM elements in a `v-for` loop, it tries to minimize the number of operations applied to the DOM, such as adding or removing elements. This is a very efficient way of updating the DOM in most cases and can improve the performance.\n\nIn order to do this, it reuses elements as much as it can and patches the DOM only where it is needed to have the desired result. It means repeated elements will be patched in place and won't be moved if an item is added or removed from the list. However, this also means that they won't animate if we apply transitions on them.\n\nThe following is a schema of how this works:\n\n![](assets/607e2253-c68b-41da-89b6-689de2112ef8.png)\n\nIn this schema, we remove the third item in the list, which is `c`. However, the third `div` element will not be destroyed--it will be reused with the fourth item in the list, which is `d`. Actually, this is the fourth `div` element that is destroyed.\n\nFortunately, we can tell Vue how each element is identified so that it can reuse and reorder them. To do that, we will need to specify a unique identifier with the `key` special attribute. For example, each of our items could have a unique ID that we would use as the key:\n\n![](assets/8daeec3d-58b6-44e3-a822-86c57e8e518b.png)\n\nHere, we specify keys so that Vue knows the third `div` element should be destroyed and the fourth div element moved.\n\nThe key special attribute works like a standard attribute, so we need to use the `v-bind` directive if we want to assign a dynamic value to it.\n\nBack to our cards, we can use the unique identifier on the cards as the key:\n\n```", "```js\n\nNow, if we add, move, or delete a card item in the JavaScript, it will be reflected with the right order in the DOM.\n\n# The CSS transitions\n\nLike before, we have the following six CSS classes at our disposable, prefixed with the name of our group transition, `'card'`: `card-enter-active`, `card-enter`, `card-enter-to`, `card-leave-active`, `card-leave`, and `card-leave-to`. They will be applied to the direct children of the group transition, that is, our cards components.\n\n1.  The group transition has an additional class applied to moving items--`v-move`. Vue will use the CSS `transform` property on the items to make them move, so we just need to apply a CSS transition on it with at least a duration:\n\n```", "```js\n\nNow, when you click on a card to play it, it should disappear and the remaining cards will move to their new position. You can also add cards to the hand.\n\n2.  Select the main component in the Vue devtools and execute this into the browser console:\n\n```", "```js\n\nSelecting a component in the devtools exposes it in the browser console as `$vm`.\n\nLike we did for the hand, we will also add animations for the cards when they enter the hand, and when they are played (and thus leave the hand).\n\n3.  Since we need to transition multiple CSS properties on the card with the same timings all the time (except during the leave transition), we will change the `.card-move` rule we just wrote into this:\n\n```", "```js\n\n4.  For the enter animation, specify the state of the card for the start of the transition:\n\n```", "```js\n\n5.  The leave animation requires a few more rules since the play card animation is more complex, and involves zooming the card upward:\n\n```", "```js\n\nThis is enough to make your cards all properly animated. You can try playing and adding cards to the hand again to see the result.\n\n# The overlays\n\nThe last UI elements we need are the overlays. The following are three of them:\n\n*   The 'new turn' overlay shows the name of the current player when it is their turn. Clicking on the 'new turn' player switches to the 'last play' overlay.\n*   The 'last play' overlay shows the player what their opponent did just before. It displays either of the following:\n    *   The card played by the opponent during the preceding turn\n    *   A reminder that their turn was skipped\n*   The 'game over' overlay shows whenever a player or both players lose. It displays the names of the players with the phrase \"is victorious\" or \"is defeated\". Clicking on the 'game over' overlay reloads the game.\n\nAll of these overlays have two things in common--they do something when the user clicks on them, and they have a similar layout design. So, we should be smart here and structure our components to reuse code as much as we can where it makes sense. The idea here is to create a generic overlay component, which will take care of the click event and the layout and three specific overlay-content components for each one of the overlays we need.\n\nBefore starting, add a new `activeOverlay` property to the app state in the `state.js` file:\n\n```", "```js\n\nThis will hold the name of the currently displayed overlay or will be `null` if no overlay is shown.\n\n# Content distribution with slots\n\nIt would be very convenient if we could put contents inside the overlay component in the main template, like this:\n\n```", "```js\n\nWe would encapsulate additional layout and logic inside the `overlay` component while still being able to put any content inside. This is done through a special element--the `<slot>`.\n\n1.  Let's create our `overlay` component with two `div` elements:\n\n```", "```js\n\n2.  Add a click event listener on the `.overlay` div, which calls the `handleClick` method:\n\n```", "```js\n\n3.  Then, add the mentioned method where we emit a custom `'close'` event:\n\n```", "```js\n\nThis event will be helpful to know when to switch from one overlay to the next at the start of the turn.\n\n4.  Now, put a `<slot>` element inside the `.content` div:\n\n```", "```js\n\nNow, if we put something between the `overlay` tags when using our component, it will be included in the DOM and replace the `<slot>` tag. For example, we could do this:\n\n```", "```js\n\nAlso, it will render like this in the page:\n\n```", "```js\n\nIt works with anything, so you can also put HTML or Vue components, and it will still work the same way!\n\n5.  The component is ready to be used in the main template, so add it at the end:\n\n```", "```js\n\nEach of the three overlay contents will be a separate component:\n\n*   `overlay-content-player-turn` shows the beginning of the turn\n*   `overlay-content-last-play` displays the last card played by the opponent\n*   `overlay-content-game-over` shows when the game is over\n\nBefore diving into these, we need a bit more data about the two players in our state.\n\n6.  Go back to the `state.js` file and add the following properties for each player:\n\n```", "```js\n\nYou should now have two items in the `players` array with the same properties, expect for the player names.\n\n# The 'player turn' overlay\n\nThe first overlay will display two different messages to the current player, depending on whether it is skipping their turn or not. The player prop will receive the current player so that we can access its data. We will use a `v-if` directive paired with a `v-else` directive and the `skipTurn` property we just added to the players:\n\n```", "```js\n\n# The 'last play' overlay\n\nThis one is a bit more complex. We need a new function to get the last played card by a player. In the `utils.js` file, add the new `getLastPlayedCard` function:\n\n```", "```js\n\nWe can now use this function in a `lastPlayedCard` computed property by passing the `opponent` prop:\n\n```", "```js\n\nNote that we are directly reusing the `card` component we made earlier to display the card.\n\n# The 'game over' overlay\n\nFor this one, we will create another component called `player-result` that will show whether a player is victorious or defeated. We will display the name of the player passed with a prop. We will compute the result for this player with a computed property, which we will also use as a dynamic CSS class:\n\n```", "```js\n\nNow, we can create the game over overlay by looping over the `players` props and using the `player-result` component:\n\n```", "```js\n\n# Dynamic component\n\nNow, it is time to put all of these into our overlay component and use the `activeOverlay` property we defined earlier.\n\n1.  Add the components and display them with the corresponding value of `activeOverlay` in the main template:\n\n```", "```js\n\nWe will remove the overlay completely if the `activeOverlay` property is equal to `null`.\n\nBefore adding the props, we will need to modify the app state in the `state.js` file with a few getters.\n\n2.  The first one will return the `player` object from the `currentPlayerIndex` property:\n\n```", "```js\n\n3.  The second one will return the opposing `player` index:\n\n```", "```js\n\n4.  Finally, the third one will return the corresponding player object:\n\n```", "```js\n\n5.  Now, we can add the props to the overlay contents:\n\n```", "```js\n\nYou can test the overlays by setting the `activeOverlay` property in the browser console:\n\n```", "```js\n\nIf you want to test the `last-play` overlay, you need to specify a valid value to the player `lastPlayedCardId` property, such as `'catapult'` or `'farm'`.\n\nOur code is starting to be messy, with three conditionals. Thankfully, there is a special component that can turn itself into any component--it is the `component` component. You just have to set its `is` prop to a component name, a component definition object, or even an HTML tag, and it will morph into it:\n\n```", "```js\n\nIt's a prop like any other, so we can use the `v-bind` directive to dynamically change the very nature of the component with a JavaScript expression. What if we used our `activeOverlay` property to do just that? Are our overlay content components conveniently named with the same `'over-content-'` prefix? Take a look:\n\n```", "```js\n\nThat's it. Now, by changing the value of the `activeOverlay` property, we will change the component displayed inside the overlay.\n\n6.  After adding back the props, the overlay should look like this in the main template:\n\n```", "```js\n\nDon't worry, unused props won't interfere with the different overlays workings.\n\n# The overlay animation\n\nLike we did with the hand, we will use a transition to animate the overlay.\n\n1.  Add a transition called \"zoom\" around the overlay component:\n\n```", "```js\n\n2.  Add the following CSS rules in the `transition.css` file:\n\n```", "```js\n\nThis is a simple animation that will zoom out the overlay while fading it out.\n\n# Key attribute\n\nFor now, if you try the animation in the browser, it should only work in two cases:\n\n*   When you don't have any overlay displayed, and you set one\n*   When you have an overlay shown and you set `activeOverlay` to `null` to hide it\n\nIf you switch between the overlays, the animation will not work. This is because of the way Vue updates the DOM; as we saw earlier in the *The key special attribute* section, it will reuse DOM elements as much as possible to optimize performance. In that case, we will need to use the key special attribute to give Vue a hint that we would like to treat the different overlays as separate elements. So, when we transition from one overlay to the other, both will be present in the DOM, and the animations can be played.\n\nLet's add the key to our overlay component so that Vue will treat it as multiple separate elements when we change the `activeOverlay` value:\n\n```", "```js\n\nNow, if we set `activeOverlay` to `'player-turn'`, the overlay will have a key of `'player-turn'`. Then, if we set `activeOverlay` to `'last-play'`, an entirely new overlay will be created with a key of `'last-play'`, and we can animate the transition between the two. You can try this in the browser by setting different values to `state.activeOverlay`.\n\n# The overlay background\n\nAt this point, there is something missing--the overlay background. We can't include it inside the overlay component because it would be zoomed during the animation--this would be quite awkward. Instead, we will use the simple `fade` animation we have created already.\n\nIn the main template, add a new `div` element with the `overlay-background` class just before the `zoom` transition and the `overlay` component:\n\n```", "```js\n\nWith the `v-if` directive, it will only be displayed when any overlay is displayed.\n\n# Game world and scenery\n\nWe are mostly done with the UI elements, so we can now go into the game scenery components. We will have some new components to do--the player castles, a health and food bubble for each one, and some animated clouds in the background for good measure.\n\nCreate a new `world.js` file in the `components` folder, and include it in the page:\n\n```", "```js\n\nWe will start with the castles.\n\n# The castles\n\nThis one is actually pretty simple since it consists of only two images and a castle-banners component that will take care of the health and food display:\n\n1.  In the `world.js` file, create a new castle component with two images that accepts a `players` and an `index` prop:\n\n```", "```js\n\nFor this component, there is a castle and a ground image for each player; that means four images in total. For example, for the player at index `0`, there are `castle0.svg` and the `ground0.svg` images.\n\n2.  In the main template, just below the `top-bar` component, create a new `div` element with the `world` CSS class, loop over the players to display the two castles, and add another `div` element with the `land` class:\n\n```", "```js\n\nIn the browser, you should see one castle for each player, as follows:\n\n![](assets/fb8e96b4-1277-46dd-b2e7-8fe28baddcad.png)\n\n# Castle banners\n\nThe castle banners will display the health and food for the castle. There will be two components inside the `castle-banners` component:\n\n*   A vertical banner whose height changes, depending of the amount of the stat\n*   A bubble with the actual number displayed\n\nIt will look like this:\n\n![](assets/9673ab25-0535-4f51-a154-facc7e9087d3.png)\n\n1.  First, create a new `castle-banners` component with only the stat icons and a `player` prop:\n\n```", "```js\n\n2.  We also need two computed properties that calculate the health and food ratios:\n\n```", "```js\n\nThe `maxFood` and `maxHealth` variables are defined at the beginning of the `state.js` file.\n\n3.  In the `castle` component, add the new `castle-banners` component:\n\n```", "```js\n\n# Food and health bubbles\n\nThis component contains an image and a text that displays the current amount for either the food or health of the castle. Its position will change depending on this amount--it will go up as the amount diminishes and will go down when it replenishes.\n\nWe will need three props for this component:\n\n*   `type` is either food or health; it will used for the CSS class and for the image path\n*   `value` is the amount displayed in the bubble\n*   `ratio` is the amount divided by the maximum amount\n\nWe also need a computed property to calculate the vertical position of the bubble with the `ratio` prop. The position will range from 40 pixels to 260 pixels. So, the position value will be given by this expression:\n\n```", "```js\n\nRemember to multiply every position or size with the `worldRatio` value, so the game takes into account the window size (it gets bigger if the window is bigger, or vice versa).\n\n1.  Let's write our new `bubble` component:\n\n```", "```js\n\nIt has a root `div` element with the `stat-bubble` CSS class, a dynamic class (either `'food-bubble'` or `'health-bubble'`, depending on the `type` prop value) plus a dynamic CSS style we set with the `bubbleStyle` computed property.\n\nIt contains an SVG image, which is not the same for food and health, and a `div` element with the `counter` class that displays the amount.\n\n2.  Add a food and an health bubble to the `castle-banners` component:\n\n```", "```js\n\n# Banner bars\n\nThe other component we need is a vertical banner hanging up on one of the castle's towers. Its length will change depending on the amount of food or health. This time, we will create a dynamic SVG template so that we can modify the height of the banner.\n\n1.  First, create the component with two props (the color and the ratio) and the `height` computed property:\n\n```", "```js\n\nFor now, we defined our templates in two different ways--we either used the HTML of our page or we set a string into the `template` option of our components. We will use another method of writing component templates--a special script tag in the HTML. It works by writing the template inside this script tag with a unique ID and referencing this ID when defining the component.\n\n2.  Open the `banner-template.svg` file, which contains the SVG markup of the banner image we will use as a dynamic template. Copy the content of the file.\n3.  In the `index.html` file, after the `<div id=\"app\">` element, add a `script` tag with the `text/x-template` type and the `banner` ID, and paste the `svg` content inside:\n\n```", "```js\n\nAs you can see, this is a standard template with all the syntax and directives available to use. Here, we use the `v-bind` directive shorthand twice. Note that you can use SVG markup inside all of your Vue templates.\n\n4.  Now, back in our component definition, add the `template` option with the ID of our script tag template preceded by a hashtag:\n\n```", "```js\n\nDone! The component will now look up for a scrip tag template with the `banner` ID in the page and will use it as its template.\n\n5.  In the `castle-banners` component, add the two remaining `banner-bar` components with the corresponding colors and ratios:\n\n```", "```js\n\nYou should now see the banners that hang up on the castles and shrink if you change the food and health values.\n\n# Animating a value\n\nThese banners would be prettier if we could animate them when they shrink or grow. We can't rely on CSS transitions since we need to dynamically change the SVG path, so we need another way--we will animate the value of the `height` property used in the template.\n\n1.  First, let's rename our template computed property to `targetHeight`:\n\n```", "```js\n\nThis `targetHeight` property will be calculated only once whenever the ratio changes.\n\n2.  Add a new `height` data property that we will be able to animate each time `targetHeight` changes:\n\n```", "```js\n\n3.  Initialize the value of `height` with the value of `targetHeight` when the component has been created. Do this in the `created` hook:\n\n```", "```js\n\nTo animate the height value, we will use the popular `**TWEEN.js**` library, which is already included in the `index.html` file. This library works by creating a new `Tween` object that takes the starting values, an easing function, and the ending values. It provide callbacks such as `onUpdate` that we will use to update the `height` property from the animation.\n\n4.  We would like to start the animation whenever the `targetHeight` property changes, so add a watcher with the following animation code:\n\n```", "```js\n\nThe `this` context in the `onUpdate` callback is the `Tween` object and not the Vue component instance. That's why we need a good old temporary variable to hold the component instance `this` (here, that is the `vm` variable).\n\n5.  We need one last thing to make our animation work. In the `main.js` file, request the paint frames from the browser to make the `TWEEN.js` library tick, thanks to the browser's `requestAnimationFrame` function:\n\n```", "```js\n\nIf the tab is in the background, the `requestAnimationFrame` function will wait for the tab to become visible again. This means the animations won't play if the user doesn't see the page, saving the computer resources and battery. Note that it is also the case for CSS transitions and animations.\n\nNow when you change the food or the health of a player, the banners will progressively shrink or grow.\n\n# The animated clouds\n\nTo add some life to the game world, we will create a few clouds that will slide in the sky. Their position and animation duration will be random and they will go from the left to the right of the window.\n\n1.  In the `world.js file`, add the minimum and maximum durations for the cloud animation:\n\n```", "```js\n\n2.  Then, create the cloud component with an image and a `type` prop:\n\n```", "```js\n\nThere will be five different clouds, so the `type` prop will range from 1 to 5.\n\n3.  We will need to change the `z-index` and `transform` CSS properties of the component with a reactive `style` data property:\n\n```", "```js\n\n4.  Apply these style properties with the `v-bind` directive:\n\n```", "```js\n\n5.  Let's create a method to set the position of the cloud component using the `transform` CSS property:\n\n```", "```js\n\n6.  We need to initialize the horizontal position of the cloud when the image is loaded, so that it's outside of the viewport. Create a new `initPosition` that uses the `setPosition` method:\n\n```", "```js\n\n7.  Add an event listener on the image with the `v-on` directive shorthand that listens to the `load` event and calls the `initPosition` method:\n\n```", "```js\n\n# The animation\n\nNow, let's move on to the animation itself. Like we did for the castle banners, we will use the `TWEEN.js` library:\n\n1.  First, create a new `startAnimation` method that calculates a random animation duration and accepts a delay parameter:\n\n```", "```js\n\nThe faster a cloud is, the lower its animation duration will be. Faster clouds will be displayed before slower clouds, thanks to the `z-index` CSS property.\n\n2.  Inside the `startAnimation` method, calculate a random vertical position for the cloud and then create a `Tween` object. It will animate the horizontal position with a delay and set the position of the cloud each time it updates. When it completes, we will start another animation with a random delay:\n\n```", "```js\n\n3.  In the `mounted` hook of the component, call the `startAnimation` method to begin the initial animation (with a random delay):\n\n```", "```js\n\nOur cloud component is ready.\n\n4.  Add some clouds to the main template in the `world` element:\n\n```", "```js\n\nBe careful to pass a value to the `type` prop ranging from 1 to 5\\. Here, we use the `%` operator to return the division remainder for 5.\n\nHere is what it should look like:\n\n![](assets/52782d12-755c-4eb2-bbe8-811741339acf.png)\n\n# Gameplay\n\nAll of our components are done! We only need to add some gameplay logic for the app to be playable. When the game begins, each players draws their initial hand of cards.\n\nThen, each player's turn follows these steps:\n\n1.  The `player-turn` overlay is displayed so that the player knows it's their turn.\n2.  The `last-play` overlay shows them what the other player played during the last run.\n3.  The player plays a card by clicking on it.\n4.  The card is removed from their hand and its effects applied.\n5.  We wait a bit so that the player can see these effects in action.\n6.  Then, the turn ends, and we switch the current player to the other one.\n\n# Drawing cards\n\nBefore drawing the cards, we will need to add two properties to the app state in the `state.js` file:\n\n```", "```js\n\nThe `drawPile` property is the pile of cards that can be drawn by the players. It is initialized with the `pile` object defined in the `cards.js` file. Each key is the ID of a card definition, and the value is the amount of cards of this type in the pile.\n\nThe `discardPile` property is the equivalent of the `drawPile` property, but it serves a different purpose--all the cards played by the player will be removed from their hand and put into the discard pile. At some point, if the draw pile is empty, it will be refilled with the discard pile (which will be emptied).\n\n# The initial hand\n\nAt the beginning of the game, each player draws some cards.\n\n1.  In the `utils.js` file, there is a function that draws the hand of a player:\n\n```", "```js\n\n2.  In the `main.js` file, add a new `beginGame` function that calls the `drawInitialHand` function for each player:\n\n```", "```js\n\n3.  Call this inside the `mounted` hook of our main component in the `main.js` file, when the app is ready:\n\n```", "```js\n\n# The hand\n\nTo display the cards in the current player hand, we need a new getter in the app state:\n\n1.  Add the `currentHand` getter to the `state` object in the `state.js` file:\n\n```", "```js\n\n2.  We can now remove the `testHand` property and replace it with `currentHand` in the main template:\n\n```", "```js\n\n3.  You can also remove the `createTestHand` method and this `created` hook we wrote on the main component for testing purposes:\n\n```", "```js\n\n# Playing a card\n\nPlaying the card is split into the following three steps:\n\n1.  We remove the card from the player's hand and add it to the pile. This triggers the card animation.\n2.  We wait for the card animation to finish.\n3.  We apply the effect of the card.\n\n# No cheating allowed\n\nWhen playing, cheating shouldn't be allowed. When writing the gameplay logic, we should keep this in mind:\n\n1.  Let's start by adding a new `canPlay` property to the app state in the `state.js` file:\n\n```", "```js\n\nThis will prevent the player from playing a card, if it has been already played during their turn--we have a lot of animation and waiting going on, so we don't want them to cheat.\n\nWe will use it both when a player plays a card to check whether they played one already, and also in the CSS to disable mouse events on the hand cards.\n\n2.  So, add a `cssClass` computed property in the main component that will add the `can-play` CSS class if the `canPlay` property is true:\n\n```", "```js\n\n3.  And add a dynamic CSS class on the root `div` element in the main template:\n\n```", "```js\n\n# Removing the card from the hand\n\nWhen the card is played, it should be removed from the current player hand; follow these steps to do so:\n\n1.  Create a new `playCard` function in the `main.js` file that takes a card as an argument, checks whether the player can play a card, and then removes the card from their hand to put it into the discard pile with the `addCardToPile` function (defined in the `utils.js` file):\n\n```", "```js\n\nWe store the card the player played in the `currentPlayingCard` variable, because we need to apply its effect later.\n\n2.  In the main component, replace the `testPlayCard` method with a new `handlePlayCard` one that calls the `playCard` function:\n\n```", "```js\n\n3.  Don't forget to change the event listener on the `hand` component in the main template:\n\n```", "```js\n\n# Waiting for the card transition to end\n\nWhen the card is played, which means removed from the hand card list, it triggers a leaving animation. We would like to wait for it to finish before continuing. Fortunately, the `transition` and `transition-group` components emit events.\n\nThe one we need here is the `'after-leave'` event, but there are other events corresponding to each phase of the transitions--`'before-enter'`, `'enter'`, `'after-enter'`, and so on.\n\n1.  In the `hand` component, add an event listener of the type `'after-leave'`:\n\n```", "```js\n\n2.  Create the corresponding method that emits a `'card-leave-end'` event to the main template:\n\n```", "```js\n\n3.  In the main template, add a new event listener of the `'card-leave-end'` type on the `hand` component:\n\n```", "```js\n\n4.  Create the corresponding method:\n\n```", "```js\n\nWe will write its logic a bit later.\n\n# Applying the card effect\n\nAfter the animation is played, the card effects will be applied to the players. For example, it could increase the current player's food or decrease the opponent's health.\n\n1.  In the `main.js` file, add the `applyCard` function that uses the `applyCardEffect` defined in the `utils.js` file:\n\n```", "```js\n\nThen, we will wait for some time so that the player can see the effects being applied and understand what is going on. Then, we will check whether at least one player is dead to end the game (thanks to the `checkPlayerLost` function defined in `utils.js`) or continue to the next turn.\n\n2.  In the `applyCard` function, add the following corresponding logic:\n\n```", "```js\n\n3.  For now, add the empty `nextTurn` and `endGame` functions just after the `applyCard` one:\n\n```", "```js\n\n4.  We can now change the `handleCardLeaveEnd` method in the main component to call the `applyCard` function we just created:\n\n```", "```js\n\n# The next turn\n\nThe `nextTurn` function is quite simple--we will increment the turn counter by one, change the current player, and display the player-turn overlay.\n\nAdd the corresponding code into the `nextTurn` function:\n\n```", "```js\n\n# New turn\n\nWe also need some logic when a turn begins after the overlays:\n\n1.  First is the `newTurn` function that hides any active overlay; it either skips the turn of the current player because of a card or starts the turn:\n\n```", "```js\n\nA player will have their turn skipped if its `skipTurn` property is true--this property will be set by some of the cards. They also have a `skippedTurn` property, which we will need to show the next player that their opponent has skipped their last turn in the `last-play` overlay.\n\n2.  Create the `skipTurn` function that sets `skippedTurn` to `true` and the `skipTurn` property to `false` and go directly to the next turn:\n\n```", "```js\n\n3.  Create the `startTurn` function, which reset the `skippedTurn` property of the player and makes them draw a card if it's their second turn (so that they always have five cards at the beginning of their turn):\n\n```", "```js\n\nIt is at this moment that we can allow the player to play a card using the `canPlay` property.\n\n# Overlay close actions\n\nNow, we will need to handle the action triggered when the user clicks on each overlay. We will create a map, with the key being the type of overlay and the value a function called when the action is triggered.\n\n1.  Add it in the `main.js` file:\n\n```", "```js\n\nFor the player-turn overlay, we only switch to the `last-play` overlay if it's the second or more turn, since at the start of the very first turn, the opponent does not play any card.\n\n2.  In the main component, add the `handleOverlayClose` method that calls the action function corresponding to the currently active overlay with the `activeOverlay` property:\n\n```", "```js\n\n3.  On the overlay component, add an event listener of the `'close'` type that will be triggered when the user clicks on the overlay:\n\n```", "```js\n\n# Game Over!\n\nFinally, set the `activeOverlay` property to `'game-over'` inside the `endGame` function:\n\n```"]