- en: Project 3 - Support Center
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 3 - 支持中心
- en: 'In this chapter, we will build a more complex application with a routing system
    (this means multiple virtual pages). This is going to be a support center for
    a fictional company called "My Shirt Shop". It will have two main parts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个更复杂的应用程序，具有路由系统（这意味着多个虚拟页面）。这将是一个名为“我的衬衫店”的虚构公司的支持中心。它将有两个主要部分：
- en: An FAQ page with a few questions and answers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含一些问题和答案的常见问题页面
- en: A support ticket management page where the user will be able to display and
    create new tickets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持工单管理页面，用户将能够显示和创建新工单
- en: The application will have an authentication system that will allow users to
    create an account or log in.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将具有身份验证系统，允许用户创建帐户或登录。
- en: We will first start creating some basic routes, then we will integrate this
    account system to finish with more advanced topics regarding routing. Through
    the chapter, we will reuse our code as much as possible and apply best practices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一些基本路由，然后将集成此帐户系统，最后涉及更高级的路由主题。在整个章节中，我们将尽可能重用我们的代码并应用最佳实践。
- en: General app structure
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般应用程序结构
- en: In this first part, we are going to create the project structure and learn more
    about routing and pages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，我们将创建项目结构并了解更多关于路由和页面的知识。
- en: Setting up the project
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'For setting up the project, the following steps need to be followed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置项目，需要按照以下步骤进行操作：
- en: 'First, generate a Vue project with the `vue init webpack-simple <folder>` command,
    like we did in [Chapter 4](cb653442-5aaa-47b6-ad7b-d94ce15821b7.xhtml), *Advanced
    Project Setup*:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `vue init webpack-simple <folder>` 命令生成一个 Vue 项目，就像我们在[第 4 章](cb653442-5aaa-47b6-ad7b-d94ce15821b7.xhtml)中所做的那样，*高级项目设置*：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install the packages necessary to compile Stylus code (our style will be written
    using Stylus):'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装编译 Stylus 代码所需的软件包（我们的样式将使用 Stylus 编写）：
- en: '`stylus`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stylus`'
- en: '`stylus-loader`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stylus-loader`'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Don't forget to save the development tools packages in the development dependencies
    of your `package.json` file with the `--save-dev` flag.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用 `--save-dev` 标志将开发工具包保存在 `package.json` 文件的开发依赖项中。
- en: Remove the content of the `src` folder where we will put all the sources of
    our app.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `src` 文件夹的内容，我们将把所有应用程序源代码放在其中。
- en: 'Then create a `main.js` file with the code needed to create a Vue app:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个 `main.js` 文件，其中包含创建 Vue 应用程序所需的代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can now try to run the app with the `npm run dev` command!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用 `npm run dev` 命令运行应用程序了！
- en: Most the style for the app is already available. Download it ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)
    and extract the Stylus files into a `style` folder inside the `src` directory.Extract
    the `assets` folder too.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数应用程序的样式已经可用。下载它（[https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)
    并将 Stylus 文件提取到 `src` 目录内的 `style` 文件夹中。也提取 `assets` 文件夹。
- en: Routing and pages
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和页面
- en: 'Our app will be organized in six main pages:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将组织在六个主要页面中：
- en: The home page
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页
- en: The public FAQ page
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共常见问题页面
- en: The login page
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录页面
- en: The tickets page
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工单页面
- en: A page to send a new ticket
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送新工单的页面
- en: A page showing one ticket details and conversation
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一个工单详情和对话的页面
- en: A route is a path representing a state of the application, usually in the form
    of pages. Each route is associated with a URL pattern that will trigger the route
    when the address matches. Then, the corresponding page will be presented to the
    user.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是表示应用程序状态的路径，通常以页面的形式存在。每个路由都与一个 URL 模式相关联，当地址匹配时将触发路由。然后，相应的页面将呈现给用户。
- en: Vue plugins
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 插件
- en: 'To enable routing in our app, we need an official Vue plugin called `vue-router`.
    A Vue plugin is some JavaScript code designed to add more features to the Vue
    library. You can find many plugins on the npm registry, and I recommend the awesome–vue
    GitHub repository ([https://github.com/vuejs/awesome-vue](https://github.com/vuejs/awesome-vue))
    that lists them by category:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中启用路由，我们需要一个名为`vue-router`的官方Vue插件。Vue插件是一些设计用来为Vue库添加更多功能的JavaScript代码。您可以在npm注册表上找到许多插件，我推荐使用awesome-vue
    GitHub存储库（[https://github.com/vuejs/awesome-vue](https://github.com/vuejs/awesome-vue)）按类别列出它们：
- en: 'Download the `vue-router` package from npm with the following command in the
    project directory:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录中使用以下命令从npm下载`vue-router`包：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will put all the routing–related code in a new `router.js` file next to the
    `main.js` file, which you need to create. Then, we need to install the plugin
    we want to use (which is `vue-router` in our case) with the global `Vue.use()`
    method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把所有与路由相关的代码放在`main.js`文件旁边的新`router.js`文件中，您需要创建该文件。然后，我们需要使用全局的`Vue.use()`方法安装我们想要使用的插件（在我们的情况下是`vue-router`）。
- en: 'Create the `router.js` file and import both the `Vue` library and the `VueRouter`
    plugin from their corresponding packages:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`router.js`文件，并从它们对应的包中导入`Vue`库和`VueRouter`插件：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then install the plugin into Vue:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将插件安装到Vue中：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `vue-router` plugin is now ready to be used!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`vue-router`插件现在已准备好使用！'
- en: Our first routes with vue–router
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个使用vue-router的路由
- en: In this section, we will go through the steps required to set up routing in
    our Vue application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍在Vue应用程序中设置路由所需的步骤。
- en: Layouts with router–view
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用router-view的布局
- en: Before adding routes, we need to setup a layout for the app where the route
    components will be rendered.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加路由之前，我们需要为应用程序设置一个布局，路由组件将在其中呈现。
- en: Let's create a component called `AppLayout.vue` in a new `components` folder
    inside the `src` directory.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`src`目录内的新`components`文件夹中创建一个名为`AppLayout.vue`的组件。
- en: 'Write the template of the component--a `<div>` element containing a `<header>`
    with an image and some text. Then, add a `<router-view />` component after the
    header:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写组件的模板--包含一个带有图像和一些文本的`<header>`的`<div>`元素。然后，在标题后添加一个`<router-view />`组件：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `<router-view />` component is a special component provided by the `vue-router`
    plugin that will render the component of the current matching route. It is not
    a real component since it doesn't have its own template, and it will not appear
    in the DOM.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`<router-view />`组件是由`vue-router`插件提供的特殊组件，它将呈现当前匹配路由的组件。它不是一个真正的组件，因为它没有自己的模板，并且不会出现在DOM中。'
- en: 'After the template, add a `style` tag importing the main Stylus file from the
    `styles` folder you downloaded earlier in the *Setting up the project* section.
    Don''t forget to specify that we are using `stylus` with the `lang` attribute:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板之后，添加一个`style`标签，从*设置项目*部分中下载的`styles`文件夹中导入主Stylus文件。不要忘记使用`lang`属性指定我们正在使用`stylus`：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since we can have as many `style` tags as we need in a SFC, add another one,
    but scoped this time. We will specify the size of the `header` logo in this second
    style section:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们可以在SFC中拥有尽可能多的`style`标签，因此再添加一个，但这次是有作用域的。我们将在第二个样式部分中指定`header`标志的大小：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To improve the performance, it is recommended to use classes inside scoped styles.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，建议在有作用域的样式中使用类。
- en: Our layout component is ready to be included in our app!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的布局组件已准备好包含在我们的应用程序中！
- en: 'In the `main.js` file, import it and render it on the `root` Vue instance:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.js`文件中导入它并在`root`Vue实例上呈现它：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can't start the app yet, since we are not finished with routing!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不能启动应用程序，因为我们的路由还没有完成！
- en: If you look at the console of your browser, you might see an error message complaining
    about the `<router-view />` component being missing. This is because we don't
    have the imported `router.js` file where we installed the `vue-router` plugin
    into Vue, so the code isn't included in our app yet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看浏览器的控制台，你可能会看到一个错误消息，抱怨`<router-view />`组件丢失了。这是因为我们没有导入`router.js`文件，我们在其中将`vue-router`插件安装到Vue中，所以代码还没有包含在我们的应用程序中。
- en: Creating routes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建路由
- en: 'Let''s create a few dumb pages for test routing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为测试路由创建一些愚蠢的页面：
- en: 'In the `components` folder, create a `Home.vue` component containing a very
    simple template with a `<main>` element, a title, and some text:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹中，创建一个`Home.vue`组件，其中包含一个非常简单的模板，包括一个`<main>`元素，一个标题和一些文本：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, create an `FAQ.vue` component next to `Home.vue`. It should also contain
    a `<main>` element, inside of which you can add a simple title:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Home.vue`旁边创建一个`FAQ.vue`组件。它也应该包含一个`<main>`元素，其中你可以添加一个简单的标题：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now have what we need to create a few routes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建一些路由所需的东西。
- en: 'In the `router.js` file, import the two components we just created:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`router.js`文件中，导入我们刚刚创建的两个组件：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, create a `routes` array:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个`routes`数组：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A route is an object containing a path, a name, and a component to render:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是一个包含路径、名称和要渲染的组件的对象：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The path is the pattern that the current URL should match for the route to be
    activated. The component will be rendered in the special `<router-view />` component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是当前URL应该匹配的模式，以激活路由。组件将呈现在特殊的`<router-view />`组件中。
- en: The route name is optional, but I strongly recommend using it. It allows you
    to specify the names of the routes instead of the path, so that you can move and
    change your routes around without ending up with broken links.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 路由名称是可选的，但我强烈建议使用它。它允许您指定路由的名称而不是路径，这样您就可以移动和更改路由而不会出现断开的链接。
- en: 'With that in mind, we can now add our two routes in the `routes` array:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们现在可以在`routes`数组中添加我们的两个路由：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s review what it will do:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回顾一下它将会做什么：
- en: When the browser URL is `http://localhost:4000/`, the `Home.vue` component will
    be rendered
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当浏览器URL为`http://localhost:4000/`时，将呈现`Home.vue`组件
- en: When the URL is `http://localhost:4000/faq/`, the `FAQ.vue` component will be
    displayed
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当URL为`http://localhost:4000/faq/`时，将显示`FAQ.vue`组件
- en: The router object
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由对象
- en: 'With our routes ready, we need to create a `router` object that will take care
    of managing the routing for us. We will use the `VueRouter` constructor from the
    `vue-router` package. It takes one `options` parameter and for now, we are going
    to use the `routes` parameter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们准备好的路由，我们需要创建一个`router`对象来负责管理路由。我们将使用`vue-router`包中的`VueRouter`构造函数。它接受一个`options`参数，现在，我们将使用`routes`参数：
- en: 'After the `routes` array in the `router.js` file, create a new `router` object
    and specify the `routes` parameter:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`router.js`文件中的`routes`数组之后，创建一个新的`router`对象并指定`routes`参数：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The plugin we installed is also the router constructor, so we are using the
    same `VueRouter` variable. `VueRouter` is in fact a valid Vue plugin because it
    has an `install` method. We will create our own plugin in this chapter!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装的插件也是路由构造函数，所以我们使用相同的`VueRouter`变量。`VueRouter`实际上是一个有效的Vue插件，因为它有一个`install`方法。在本章中，我们将创建自己的插件！
- en: 'Export the `router` object as the default exported value of the module:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`router`对象导出为模块的默认导出值：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now back to our `main.js` file, we need to provide the `router` object to the
    Vue application. Import the `router` we just created:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在回到我们的`main.js`文件，我们需要将`router`对象提供给Vue应用程序。导入我们刚刚创建的`router`：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then add it as a definition option to the root Vue instance:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将其作为根Vue实例的定义选项添加：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That is all we need to have routing working! You can now try to change the
    URL in your browser to either `http://localhost:4000/#/` or `http://localhost:4000/#/faq`
    and get a different page each time:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们让路由工作所需的全部！现在你可以尝试在浏览器中更改URL为`http://localhost:4000/#/`或`http://localhost:4000/#/faq`，每次都会得到不同的页面：
- en: '![](assets/573630b2-2281-4d69-a433-340ca757d243.png)Don''t forget the sharp
    `#` character in the URL; it is needed to fake the route changes while not changing
    the real web page. This is the default router mode called `hash`, and it works
    with any browser and server.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/573630b2-2281-4d69-a433-340ca757d243.png)不要忘记URL中的尖号`#`字符；在不更改真正的网页的情况下，需要伪造路由更改。这是称为`hash`的默认路由器模式，并且可以与任何浏览器和服务器一起使用。'
- en: Router modes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器模式
- en: We can change the router mode with the `mode` parameter in the constructor options.
    It can either be `'hash'` (default), `'history'`, or `'abstract'`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过构造函数选项中的`mode`参数来更改路由器模式。它可以是`'hash'`（默认值）、`'history'`或`'abstract'`。
- en: The `hash` mode is the default we are already using. It is the "safest" choice
    since it is compatible with any browser and server. It consists of using the "hash"
    part of the URL (which means the part after the sharp character) and change it
    or react to changes to it. The big advantage is that changing the hash part will
    not change the real web page where our app is running (which would be very unfortunate).
    The obvious drawback is that it forces us to separate the URL in two with the
    not so pretty sharp symbol.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash`模式是我们已经在使用的默认模式。这是“最安全”的选择，因为它与任何浏览器和服务器兼容。它包括使用URL的“hash”部分（也就是尖号后面的部分）并更改它或对其进行反应。最大的优势是更改哈希部分不会更改我们的应用程序正在运行的真正网页（这将是非常不幸的）。显而易见的缺点是它强迫我们用不太漂亮的尖号符号将URL分成两部分。'
- en: 'Thanks to the HTML5 `history.pushState` API, we can get rid of this sharp character
    and get a real URL for our app! We need to change the mode to `''history''` in
    the constructor:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTML5的`history.pushState` API，我们可以摆脱这个尖锐字符，并为我们的应用程序获得一个真正的URL！我们需要在构造函数中将模式更改为`'history'`：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can use pretty URLs such as `http://localhost:4000/faq` in our Single-Page
    App! There are two problems though:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的单页面应用程序中使用漂亮的URL，比如`http://localhost:4000/faq`！不过有两个问题：
- en: The browser needs to support this HTML5 API, which means it won't work on Internet
    Explorer 9 or less (all other major browsers have supported it for quite some
    time).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器需要支持这个HTML5 API，这意味着它在Internet Explorer 9或更低版本上无法工作（其他主要浏览器已经支持了相当长的时间）。
- en: The server has to be configured to send the home page instead of throwing a
    404 error when accessing a route such as `/faq`, since it doesn't really exist
    (you don't have a file called `faq.html`). This also means we will have to implement
    the 404 page ourselves.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器必须配置为在访问`/faq`这样的路由时发送主页，而不是抛出404错误，因为它实际上并不存在（你没有一个名为`faq.html`的文件）。这也意味着我们将不得不自己实现404页面。
- en: Thankfully, the webpack server used by `vue build` is configured to support
    this by default. So you can go ahead and try the new `http://localhost:4000/faq`
    URL!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，由`vue build`使用的webpack服务器默认配置为支持这一点。所以你可以继续尝试新的`http://localhost:4000/faq`
    URL！
- en: There is a third mode called `abstract` that can be used in any JavaScript environment
    (including Node.js). If there is no browser API available, the router will be
    forced to use this mode.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有第三种模式称为“抽象”，可以在任何JavaScript环境中使用（包括Node.js）。如果没有浏览器API可用，路由将被迫使用此模式。
- en: Creating a navigation menu
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建导航菜单
- en: 'Instead of manually typing the URL, it would be great to have a proper navigation
    `menu` in our app! Let''s create a new `NavMenu.vue` file in our `components`
    folder:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动输入URL相比，在我们的应用程序中拥有一个合适的导航`菜单`将会很棒！让我们在我们的`components`文件夹中创建一个新的`NavMenu.vue`文件：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will add it in the layout. Import the new component in the `AppLayout`
    one:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在布局中添加它。在`AppLayout`中导入新组件：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then add it to the `AppLayout` template:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其添加到`AppLayout`模板中：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Router links
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由链接
- en: The `vue-router` plugin provides us with another handy special component--`<router-link>`.
    It is a component that will change to a specified route when clicked thanks to
    its `to` prop. By default, it will be a `<a>` HTML element, but this can be customized
    with the `tag` prop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`vue-router`插件为我们提供了另一个方便的特殊组件--`<router-link>`。这是一个组件，当单击时将切换到指定的路由，这要归功于它的`to`属性。默认情况下，它将是一个`<a>`
    HTML元素，但可以使用`tag`属性进行自定义。'
- en: 'For example, a link to the FAQ page would be:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，指向FAQ页面的链接将是：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `to` prop can also get an object with the name property instead of the
    path:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`to`属性也可以获得一个具有名称属性而不是路径的对象：'
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will dynamically generate the correct path for the route. I recommend you
    to use this second method as opposed to only specifying the path--that way, if
    you change the paths of your routes, your navigation links will still work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将动态生成路由的正确路径。我建议您使用这种第二种方法，而不是仅指定路径--这样，如果您更改路由的路径，您的导航链接仍将起作用。
- en: When using the object notation, don't forget to bind the `to` prop with `v-bind`
    or the `:` shorthand, or else the `router-link` component will get a string and
    won't understand it's an object.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用对象表示法时，不要忘记使用`v-bind`或`:`简写将`to`属性绑定到`router-link`组件，否则`router-link`组件将获得一个字符串，并且不会理解它是一个对象。
- en: 'Now we can add the links to our `NavMenu` component:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将链接添加到我们的`NavMenu`组件中：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should now have a working menu in the app:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在应用程序中有一个可用的菜单：
- en: '![](assets/09491639-cb34-4468-a2ec-e31562b55427.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/09491639-cb34-4468-a2ec-e31562b55427.png)'
- en: Active class
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动类
- en: 'A router link gets the active class when the route it is associated with is
    currently active. By default, the component gets the `router-link-active` CSS
    class, so you can change its visuals accordingly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当与其关联的路由当前处于活动状态时，路由链接将获得活动类。默认情况下，组件会获得`router-link-active` CSS类，因此您可以相应地更改其外观：
- en: 'In our `NavMenu.vue` component, declare some scoped style to add a bottom border
    to the active link using Stylus:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`NavMenu.vue`组件中，声明一些作用域样式，使用Stylus为活动链接添加底部边框：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We include the `$primary-color` variable with the `@import '../style/imports';`
    statement, which imports the `imports.styl` file containing the Stylus variables.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`@import '../style/imports';`语句中包含了`$primary-color`变量，该语句导入了包含Stylus变量的`imports.styl`文件。
- en: 'If you try the app now, you will find that something weird is happening with
    our menu. If you go to the Home page, it is working as expected:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试该应用程序，您会发现我们的菜单出现了一些奇怪的情况。如果您转到主页，它会按预期工作：
- en: '![](assets/fcd3f66c-a061-4b55-8c19-ba01405e923f.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fcd3f66c-a061-4b55-8c19-ba01405e923f.png)'
- en: 'But when you go to the FAQ page, both the Home and the FAQ links are highlighted:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但当您转到FAQ页面时，主页和FAQ链接都会被突出显示：
- en: '![](assets/8baa75ec-9101-4117-8793-7168c1a06fd4.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8baa75ec-9101-4117-8793-7168c1a06fd4.png)'
- en: This is because by default, the active class matching behavior is inclusive!
    This means `<router-link to="/faq">` will get the active class if the path is
    `/faq` or starts with `/faq/`. But it also means `<router-link to="/">` will get
    the class if the current path starts with `/`, which are all possible paths! That's
    why our Home link will always get the class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为默认情况下，活动类匹配行为是包容的！这意味着`<router-link to="/faq">`如果路径是`/faq`或以`/faq/`开头，将获得活动类。但这也意味着`<router-link
    to="/">`如果当前路径以`/`开头，将获得该类，这些都是可能的路径！这就是为什么我们的主页链接总是会获得该类。
- en: To prevent this from happening, there is the `exact` prop, which is a Boolean.
    If it is set to `true`, the link will only get the active class if the current
    path is matching exactly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，有一个`exact`属性，它是一个布尔值。如果设置为`true`，则只有在当前路径完全匹配时，链接才会获得活动类。
- en: 'Add the `exact` prop to the Home link:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`exact`属性添加到主页链接：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, only the FAQ link should be highlighted:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有FAQ链接应该被突出显示：
- en: '![](assets/218e9760-554f-4d93-bd60-423a3ca235d1.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/218e9760-554f-4d93-bd60-423a3ca235d1.png)'
- en: FAQ - Consuming an API
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FAQ - 使用API
- en: In this section, we will create the FAQ page, which will get data from the server.
    It will display a loading animation and then the list of questions and answers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建FAQ页面，该页面将从服务器获取数据。它将显示加载动画，然后显示问题和答案列表。
- en: Server setup
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器设置
- en: This is our first app that will communicate with a server. You will get a server
    with a ready-to-use API.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个与服务器通信的应用程序。您将获得一个带有可用API的服务器。
- en: 'You can download the server files ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)).
    Extract them into another folder than our app and run the following commands to
    install the dependencies and launch the server:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载服务器文件（[https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)）。将它们解压到与我们的应用程序不同的文件夹中，并运行以下命令来安装依赖项并启动服务器：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You should now have the server running on port 3000\. When this is done, we
    can continue building our app with a real backend this time!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在端口3000上运行服务器。完成后，我们可以继续构建我们的应用程序，这次使用真正的后端！
- en: Using fetch
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fetch
- en: 'In the `FAQ.vue` Single File Component, we will use the standard `fetch` API
    of the web browser to retrieve the questions from our server. The request will
    be a very simple `GET` request to `http://localhost:3000/questions` with no authentication.
    Each question object will have `title` and `content` fields:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FAQ.vue`单文件组件中，我们将使用Web浏览器的标准`fetch` API从服务器检索问题。请求将是一个非常简单的`GET`请求到`http://localhost:3000/questions`，不需要身份验证。每个问题对象将有`title`和`content`字段：
- en: 'Open `FAQ.vue` and start by adding the `questions` data property in the component
    script, which will hold the array of questions retrieved from the server. We also
    need an `error` property to display a message when something goes wrong during
    the network request:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FAQ.vue`，并首先在组件脚本中添加`questions`数据属性，该属性将保存从服务器检索的问题数组。我们还需要一个`error`属性，在网络请求期间出现问题时显示消息：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can add the questions and answers to the template with a `v-for` loop,
    and the following error message:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`v-for`循环将问题和答案添加到模板中，并显示以下错误消息：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are ready to fetch! The fetch API is promised-based and quite simple to
    use. Here is an example of `fetch` usage:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好进行获取了！fetch API是基于promise的，非常简单易用。以下是`fetch`用法示例：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first call `fetch` with the first parameter being the URL of the request.
    It returns a promise with a `response` object, which holds information about the
    request result. If it was successful, we use `response.json()`, which returns
    a new promise with the JSON parsed result object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用请求的URL作为第一个参数调用`fetch`。它返回一个带有`response`对象的promise，该对象保存有关请求结果的信息。如果成功，我们使用`response.json()`，它返回一个解析后的JSON结果对象的新promise。
- en: 'The request will be made inside the component as soon as it is created when
    the route is matched, which means that you should use the `created` life cycle
    hook in the component definition:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将在组件内部进行，一旦创建时路由匹配，这意味着您应该在组件定义中使用`created`生命周期钩子：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If everything goes well, we will set the questions property with the JSON parsed
    result. Or else we will display an error message.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将使用JSON解析后的结果设置问题属性。否则，我们将显示错误消息。
- en: 'Start by calling `fetch` with the right URL:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从正确的URL调用`fetch`开始：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the first `then` callback with the `response` object:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第一个`then`回调与`response`对象：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We need another `then` callback since `response.json()` returns a new promise:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`response.json()`返回一个新的promise，我们需要另一个`then`回调：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we catch all possible errors to display the error message:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们捕获所有可能的错误以显示错误消息：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is a summary of our `created` hook:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`created`钩子的摘要：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can rewrite this code using the `async` and `await` JavaScript keywords
    to make it look like sequential code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`async`和`await` JavaScript关键字重写此代码，使其看起来像顺序代码：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can now try the page, which should display a list of questions and answers:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以尝试该页面，该页面应该显示一个问题和答案的列表：
- en: '![](assets/ad13159c-6d51-4eaf-b5b4-bdcc1805b9ce.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ad13159c-6d51-4eaf-b5b4-bdcc1805b9ce.png)'
- en: 'To see if our error management is working, you can go to the console where
    the server is running, and stop it (for example, with the C*trl*+*C* keyboard
    shortcut). Then, you can reload the app and the following error message should
    be displayed:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们的错误管理是否有效，您可以转到运行服务器的控制台，并停止它（例如，使用C*trl*+*C*键盘快捷键）。然后，您可以重新加载应用程序，应该显示以下错误消息：
- en: '![](assets/409552ab-7806-49a0-bf57-e5ca5a8cd921.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/409552ab-7806-49a0-bf57-e5ca5a8cd921.png)'
- en: Loading animation
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载动画
- en: There is one last thing missing--we should show a loading animation to inform
    the user that an operation is in progress instead of an empty screen. To this
    effect, the server is faking a 1.5 s delay on the `/questions` request so we can
    easily see the loading animation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事情遗漏了--我们应该显示一个加载动画来通知用户操作正在进行中，而不是一个空屏幕。为此，服务器在`/questions`请求上伪造了1.5秒的延迟，这样我们就可以轻松看到加载动画。
- en: 'Since we are going to display loading animations inside multiple components,
    we are going to create a new global component:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在多个组件中显示加载动画，我们将创建一个新的全局组件：
- en: 'In the `components` folder, create a new `Loading.vue` file with the following
    template:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹中，创建一个名为`Loading.vue`的新文件，内容如下模板：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a new `global-components.js` file next to the `main.js` file in the
    `main` folder. In this file, we are going to register the `Loading` component
    globally with the `Vue.component()` method:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`文件夹中的`main.js`文件旁边创建一个新的`global-components.js`文件。在这个文件中，我们将使用`Vue.component()`方法全局注册`Loading`组件：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is the file where we will register all the global components used across
    all the application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将注册所有应用程序中使用的全局组件的文件。
- en: 'Then, in the `main.js` file, import the `global-components.js` module:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`main.js`文件中，导入`global-components.js`模块：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Back to our `FAQ.vue` component, we need a new `loading` Boolean data property
    to toggle the display of the animation:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的`FAQ.vue`组件，我们需要一个新的`loading`布尔数据属性来切换动画的显示：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the template, add the loading animation:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中添加加载动画：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, change the `created` hook a bit by setting `loading` to `true` at
    the beginning, and `false` when everything is done:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过在`created`钩子中将`loading`设置为`true`开头，当一切都完成时设置为`false`，稍微改变`created`钩子：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can now reload the page and briefly see the loading animation before the
    questions appear:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以重新加载页面，在问题出现之前短暂地看到加载动画：
- en: '![](assets/436a47ea-2274-4dbd-8f07-146d12974f14.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/436a47ea-2274-4dbd-8f07-146d12974f14.png)'
- en: Extending Vue with our own plugin
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们自己的插件扩展Vue
- en: Since we will use fetch in multiple components for our application and we want
    to reuse code as much as possible, it would be nice to have a method on all of
    our components that makes a request to the server with a predefined URL.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在应用程序的多个组件中使用fetch，并且我们希望尽可能多地重用代码，因此最好在所有组件上都有一个向服务器发出预定义URL请求的方法。
- en: This a nice use case for a custom Vue plugin! Don't worry, writing a plugin
    is actually pretty simple.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的自定义Vue插件使用案例！别担心，编写插件实际上非常简单。
- en: Creating a plugin
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建插件
- en: 'To create a plugin, there is only one rule--a plugin should be an object with
    an `install` method, which takes the Vue constructor as the first argument, and
    an optional `options` argument. This method will then add new features to the
    framework by modifying the constructor:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个插件，只有一个规则--插件应该是一个带有`install`方法的对象，该方法以Vue构造函数作为第一个参数，并且可选的`options`参数。然后，该方法将通过修改构造函数来为框架添加新功能：
- en: Create a new `plugins` folder in the `src` folder.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建一个新的`plugins`文件夹。
- en: Inside the `plugins` folder, create a `fetch.js` file where we will write our
    plugin. In this case, our plugin will add a new `$fetch` special method on all
    of our components. We will do that by changing the prototype of Vue.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`plugins`文件夹中，创建一个`fetch.js`文件，我们将在这里编写我们的插件。在这种情况下，我们的插件将在所有组件上添加一个新的`$fetch`特殊方法。我们将通过改变Vue的原型来实现这一点。
- en: 'Let''s try creating a very simple plugin, by exporting an object with an `install`
    method:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个非常简单的插件，通过导出一个带有`install`方法的对象：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That's it! We have created a Vue plugin! Now, we need to install it into our
    application.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经创建了一个Vue插件！现在，我们需要将其安装到我们的应用程序中。
- en: 'In the `main.js` file, import the plugin and then call the `Vue.use()` method
    just like we did for `vue-router`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.js`文件中，导入插件，然后调用`Vue.use()`方法，就像我们为`vue-router`做的那样：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You should now see the `'Installed!'` message in your browser console.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该在浏览器控制台中看到`'Installed!'`消息。
- en: Plugin options
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件选项
- en: 'We can configure the plugin with an `options` parameter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`options`参数配置插件：
- en: 'Edit the `install` method to add this parameter after `Vue`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`install`方法，在`Vue`之后添加这个参数：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can now add a configuration object to the `Vue.use()` method in the `main.js`
    file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`main.js`文件中的`Vue.use()`方法中添加一个配置对象。
- en: 'Let''s add a `baseUrl` property to the configuration:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在配置中添加一个`baseUrl`属性：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You should now see the `options` object in the browser console.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该在浏览器控制台中看到`options`对象。
- en: 'Store `baseUrl` into a variable so we can use it later:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`baseUrl`存储到一个变量中，以便我们以后可以使用它：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Fetch method
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取方法
- en: 'Now, we are going to write the `$fetch` method. We will take most of the code
    we used in the `created` hook of the FAQ component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写`$fetch`方法。我们将使用FAQ组件的`created`钩子中使用的大部分代码：
- en: 'Implement the `$fetch` method using `fetch`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fetch`实现`$fetch`方法：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We export it so we can use it in our plain JavaScript code too. The `url` parameter
    is now just the path of the query without the domain, which is now in our `baseUrl`
    variable--this allows us to change it easily without having to refactor each component.
    We also take care of the JSON parsing, since all the data from the server will
    be encoded in JSON.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其导出，以便我们也可以在我们的纯JavaScript代码中使用它。现在`url`参数只是查询的路径，不包括域名，域名现在在我们的`baseUrl`变量中--这使我们可以轻松地更改它，而不必重构每个组件。我们还负责JSON解析，因为服务器上的所有数据都将以JSON编码。
- en: 'To make it available in all components, simply add it to the prototype of `Vue`
    (which is the constructor used to create components):'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使它在所有组件中可用，只需将其添加到`Vue`的原型中（这是用于创建组件的构造函数）：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, refactor the FAQ component to use our new special `$fetch` method in
    the created hook:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重构FAQ组件，使用我们新的特殊`$fetch`方法在创建钩子中：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Our code in the component is now shorter, easier to read, and more scalable
    since we can change the base URL easily.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件中的代码现在更短、更易读，并且更具可扩展性，因为我们可以轻松地更改基本URL。
- en: Reusing code with mixins
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用mixin重用代码
- en: We have seen how to create plugins, but there is another way to improve our
    code--what if we could reuse component definitions such as computed properties,
    methods, or watchers across multiple components? This is what mixins are for!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建插件，但还有另一种改进我们的代码的方法--如果我们可以在多个组件之间重用组件定义，比如计算属性、方法或观察者，会怎么样？这就是mixin的作用！
- en: A mixin is a component definition object that can be applied to other definition
    objects (including other mixins). It is very simple to write, because it looks
    exactly the same as a regular component definition!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 混合是一个可以应用到其他定义对象（包括其他混合）的组件定义对象。它非常简单，因为它看起来和常规组件定义完全一样！
- en: 'Our objective here is to have a `RemoteData` mixin that will allow any component
    to make requests to the server in order to fetch data. Let''s add a new `mixins`
    folder in the `src` directory, and create a new `RemoteData.js` file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是有一个`RemoteData`混合，它将允许任何组件向服务器发出请求以获取数据。让我们在`src`目录下添加一个新的`mixins`文件夹，并创建一个新的`RemoteData.js`文件：
- en: 'We will start simple by exporting a definition with a data property:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从导出一个带有数据属性的定义开始简单：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This `remoteDataLoading` property will be used to count the number of requests
    that are currently loading, to help us display a loading animation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`remoteDataLoading`属性将用于计算当前正在加载的请求数量，以帮助我们显示加载动画。
- en: 'Now, to use this mixin in our FAQ component, we need to import it and add it
    in the `mixins` array:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要在我们的FAQ组件中使用这个混合，我们需要导入它并将其添加到`mixins`数组中：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you inspect the component, you should now see an additional `remoteDataLoading`
    property displayed:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查组件，你现在应该看到一个额外的`remoteDataLoading`属性被显示出来：
- en: '![](assets/be837ea2-b9ad-4921-9e14-2231c38ab64d.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/be837ea2-b9ad-4921-9e14-2231c38ab64d.png)'
- en: So what happened? The mixin got applied and merged into the component definition
    of `FAQ.vue`, which means that the data hook was called twice--first from the
    mixin, then from the FAQ definition and a new property was added!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？混合被应用并合并到了`FAQ.vue`的组件定义中，这意味着数据钩子被调用了两次--首先是来自混合，然后是来自FAQ定义，并且添加了一个新属性！
- en: Vue will automatically merge the standard options such as hooks, data, computed,
    methods, and watch, but if you have, for example, a property of a method with
    the same name, the last one applied will override the previous ones.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Vue将自动合并标准选项，如钩子、数据、计算属性、方法和监视器，但是如果你有，例如，一个具有相同名称的属性或方法，最后一个应用的将覆盖之前的。
- en: 'Let''s try overriding the new property in our component with another value:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试用另一个值覆盖组件中的新属性：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As you can see in the component inspector, the final component definition has
    a higher priority than the mixin. Also, you may have noticed that the `mixins`
    option is an array, thus we can apply multiple mixins to the definition, which
    will be merged in order. For example, consider we have two mixins and want to
    apply them to a component definition. Here is what will happen:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在组件检查器中所看到的，最终的组件定义比混合具有更高的优先级。另外，你可能已经注意到`mixins`选项是一个数组，因此我们可以将多个混合应用到定义中，它们将按顺序合并。例如，假设我们有两个混合并希望将它们应用到组件定义中。下面是会发生的事情：
- en: The definition object contains the options of mixin 1.
  id: totrans-239
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义对象包含混合1的选项。
- en: The options of mixin 2 are merged into the definition object (existing property/method
    names are overriden).
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 混合2的选项被合并到定义对象中（现有属性/方法名称被覆盖）。
- en: In the same way, the options of the component are merged into the final definition
    object.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，组件的选项会合并到最终的定义对象中。
- en: 'You can now remove the duplicate `remoteDataLoading: 42,` from the FAQ component
    definition.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '你现在可以从FAQ组件定义中删除重复的`remoteDataLoading: 42,`。'
- en: Hooks such as `data`, `created`, `mounted`... are each called individually in
    the order they were applied to the final definition. This also means that the
    final component definition hooks will be called last.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 像`data`、`created`、`mounted`这样的钩子会按照它们被应用到最终定义的顺序分别被调用。这也意味着最终组件定义的钩子将会最后被调用。
- en: Fetching remote data
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取远程数据
- en: We have a problem--each component using our `RemoteData` mixin will have different
    data properties to fetch. Therefore, we need to pass parameters to our mixin.
    Since a mixin is essentially a definition object, why not use a function that
    can take parameters and then return a definition object? That's what we will do
    in our case!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个问题--每个使用我们的`RemoteData` mixin的组件将具有不同的数据属性需要获取。因此，我们需要向我们的mixin传递参数。由于mixin本质上是一个定义对象，为什么不使用一个可以接受参数并返回定义对象的函数呢？这就是我们在这种情况下要做的事情！
- en: 'Wrap the object we have defined inside a function with a `resources` parameter:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们定义的对象包装在一个带有`resources`参数的函数中：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `resources` parameter will be an object with each key being the name of
    the data property we want to add, and the value being the path of the request
    that needs to be made to the server.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources`参数将是一个对象，其中每个键都是我们要添加的数据属性的名称，值是需要向服务器发出的请求的路径。'
- en: 'So we need to change the way we use the mixin in our `FAQ.vue` component to
    a function call:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们需要更改我们在`FAQ.vue`组件中使用mixin的方式，改为函数调用：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we are going to fetch the `http://localhost:3000/questions` URL (with
    the special `$fetch` method we created earlier) and put the result in the `questionList`
    property.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将获取`http://localhost:3000/questions` URL（使用我们之前创建的特殊`$fetch`方法）并将结果放入`questionList`属性中。
- en: Now onto our `RemoteData` mixin!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们的`RemoteData` mixin！
- en: 'First things first, we need to initialize each data property to a `null` value,
    so Vue can set up reactivity on them:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将每个数据属性初始化为`null`值，这样Vue才能在其上设置响应性：
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This step is important--if you don't initialize the data, it won't be made reactive
    by Vue, so the component will not be updated when the properties change.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步很重要--如果您不初始化数据，Vue不会使其具有响应性，因此当属性更改时，组件将不会更新。
- en: 'You can try the app and see in the component inspector that a new `questionList`
    data property has been added to the FAQ component:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试该应用程序，并在组件检查器中查看`FAQ`组件中已添加了一个新的`questionList`数据属性：
- en: '![](assets/3e9d5417-0726-4394-8b40-50815458cf77.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3e9d5417-0726-4394-8b40-50815458cf77.png)'
- en: 'Then, we will create a new `fetchResource` method that fetches one resource
    and update the corresponding data property:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个新的`fetchResource`方法，该方法获取一个资源并更新相应的数据属性：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Our component now has access to this new method and can use it directly.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件现在可以直接访问这个新方法并使用它。
- en: 'To make our mixin smarter, we will automatically call it inside the `created`
    hook (which will be merged):'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的mixin更智能，我们将在`created`钩子内自动调用它（将被合并）：
- en: '[PRE62]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can now verify that the `questionList` data property gets updated with
    a new request made to the server:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以验证`questionList`数据属性是否随着向服务器发出的新请求而更新：
- en: '![](assets/3eee8bfd-5850-4a4e-8d45-c5c574fd1549.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3eee8bfd-5850-4a4e-8d45-c5c574fd1549.png)'
- en: 'Then, you can remove the old code with the `questions` property in the `FAQ.vue`
    component and change the template to use the new property:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以在`FAQ.vue`组件中删除具有`questions`属性的旧代码，并更改模板以使用新属性：
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Loading management
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载管理
- en: 'The next thing we want to do is provide a way to know if the loading animation
    should be displayed. Since we could potentially have multiple requests, we are
    going to use a numeric counter instead of a Boolean--`remoteDataLoading` that
    we already declared in the `data` hook. Each time a request is made, we increment
    the counter, and when it is complete we decrement the counter. This means if it
    is equal to zero no request is currently pending, and if it is greater or equal
    to one we should display a loading animation:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情是提供一种方法来知道是否应该显示加载动画。由于我们可能会有多个请求，所以我们将使用一个数字计数器而不是布尔值--`remoteDataLoading`，我们已经在`data`钩子中声明了。每次发出请求时，我们都会递增计数器，当请求完成时，我们会递减计数器。这意味着如果它等于零，当前没有挂起的请求，如果大于或等于一，我们应该显示加载动画：
- en: 'Add the two statements incrementing and decrementing the `remoteDataLoading`
    counter in the `fetchResource` method:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“fetchResource”方法中添加两个语句，递增和递减“remoteDataLoading”计数器：
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To make our life easier when using the mixin, let''s add a computed property
    called `remoteDataBusy` that will be `true` when we need to display the loading
    animation:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在使用mixin时使我们的生活更轻松，让我们添加一个名为“remoteDataBusy”的计算属性，当我们需要显示加载动画时将为“true”：
- en: '[PRE65]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Back to our FAQ component, we can now remove the `loading` property, change
    the `v-if` expression for the `Loading` component, and use the `remoteDataLoading`
    computed property:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的FAQ组件，现在我们可以删除“loading”属性，更改“Loading”组件的“v-if”表达式，并使用“remoteDataLoading”计算属性：
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can try refreshing the page to see the loading animation displayed before
    the data is retrieved.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试刷新页面，以查看在检索数据之前显示的加载动画。
- en: Error management
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误管理
- en: 'Finally, we could manage the errors that could occur for any resource request:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以管理可能发生的任何资源请求的错误。
- en: 'We will store the errors for each resource in a new `remoteErrors` object,
    which needs to be initialized:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为每个资源存储错误在一个新的“remoteErrors”对象中，这需要初始化：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The key of the `remoteErrors` object will be the same as the resource, and the
    value will be the error or `null` if there is no error.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: “remoteErrors”对象的键将与资源相同，值将是错误或“null”（如果没有错误）。
- en: 'Next, we need to modify the `fetchResource` method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改“fetchResource”方法：
- en: Before the request, reset the error by setting it to `null`
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求之前，通过将其设置为“null”来重置错误
- en: If there is an error in the catch block, put it into the `remoteErrors` object
    at the right key
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在catch块中有错误，请将其放入正确的键的“remoteErrors”对象中
- en: 'The `fetchResource` method should now look as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “fetchResource”方法现在应该如下所示：
- en: '[PRE68]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We could now display specific error messages for each resource, but we will
    simply display a generic error message in this project. Let's add another computed
    property called `hasRemoteErrors`, which will return true if there is at least
    one error.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为每个资源显示特定的错误消息，但在这个项目中我们将简单地显示一个通用的错误消息。让我们添加另一个名为“hasRemoteErrors”的计算属性，如果至少有一个错误，则返回true。
- en: 'Using the JavaScript `Object.keys()` method, we can iterate on the keys of
    the `remoteErrors` object and check if some values are not `null` (which means
    that they are truthy):'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JavaScript的“Object.keys（）”方法，我们可以迭代“remoteErrors”对象的键，并检查某些值是否不是“null”（这意味着它们为真）：
- en: '[PRE69]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can now change the FAQ component template again by replacing the `error`
    property with the new one:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以再次通过用新的替换FAQ组件模板“error”属性：
- en: '[PRE70]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Like we did before, you can shut down the server to see the error message displayed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样，您可以关闭服务器以查看显示的错误消息。
- en: 'We have now finished the FAQ component, whose script should now look as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了FAQ组件，其脚本现在应该如下所示：
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As you can see, it is very concise now!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在非常简洁！
- en: Support tickets
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持票
- en: In this last part, we will create an authenticated section of our app, where
    the user will be able to add and view support tickets. All the necessary requests
    are available on the server you already downloaded and if you are curious about
    how this has been done in the node with `passport.js`, you can take a look at
    the sources!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一部分中，我们将创建应用程序的经过身份验证的部分，用户将能够添加和查看支持票。您已经下载的服务器上已经有所有必要的请求，如果您对在node中如何使用`passport.js`完成这些操作感到好奇，您可以查看源代码！
- en: User authentication
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户认证
- en: In this first section, we will take care of the user system of our app. We will
    have both login and sign up components, to be able to create new users.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一部分，我们将处理应用程序的用户系统。我们将有登录和注册组件，以便能够创建新用户。
- en: Storing the user in a centralized state
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户存储在集中状态中
- en: 'We will store the user data inside a state object like we did in [Chapter 3](1f1ee662-c20d-4926-9b9a-4fcfaedf4b84.xhtml),
    *Project 2* - *Castle Duel Browser Game*, so we can access it in any component
    of the app:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像我们在[第3章](1f1ee662-c20d-4926-9b9a-4fcfaedf4b84.xhtml)中所做的那样，将用户数据存储在状态对象中，*项目2*
    - *城堡决斗浏览器游戏*，这样我们就可以在应用程序的任何组件中访问它：
- en: 'Create a new `state.js` file next to `main.js`, which exports the state object:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.js`旁边创建一个新的`state.js`文件，导出状态对象：
- en: '[PRE72]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `user` property will be null when no user is logged in, or else it will
    contain the user data.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有用户登录时，`user`属性将为null，否则它将包含用户数据。
- en: 'Then, in the `main.js` file, import the state:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`main.js`文件中，导入状态：
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, use it as the data of the root instance so Vue makes it reactive:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其用作根实例的数据，这样Vue就会使其具有反应性：
- en: '[PRE74]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Another plugin
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一个插件
- en: We could then import the state in component files when we need it, but it would
    be more convenient to be able to access it with a special getter called `$state`
    on the Vue prototype like we did for the `fetch` plugin. We will pass the state
    object to the plugin options, and the getter will return it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在组件文件中导入状态，但能够像我们为`fetch`插件做的那样，在Vue原型上使用一个特殊的getter`$state`来访问它会更方便。我们将状态对象传递给插件选项，getter将返回它。
- en: 'In the `plugins` folder, create a `state.js` file that exports the new plugin:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`plugins`文件夹中，创建一个导出新插件的`state.js`文件：
- en: '[PRE75]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here we are using the JavaScript `Object.defineProperty()` method to set up
    a getter on the Vue prototype, so every component will inherit it!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用JavaScript的`Object.defineProperty()`方法在Vue原型上设置一个getter，所以每个组件都会继承它！
- en: One last thing--we need to install the state plugin!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事——我们需要安装状态插件！
- en: 'In the `main.js` file, import the new plugin:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.js`文件中，导入新插件：
- en: '[PRE76]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then install it with the state object as the options parameter:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用状态对象作为选项参数安装它：
- en: '[PRE77]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can now use `$state` in our components to access the global state! Here
    is an example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在组件中使用`$state`来访问全局状态了！这里是一个例子：
- en: '[PRE78]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This should output the state object with the `user` property.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出带有`user`属性的状态对象。
- en: Login forms
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录表单
- en: In this section, we will first create new components to help us build forms
    faster, and then we will add the sign up and the login forms to the application
    with a `Login.vue` component. In later sections, we will create another form to
    submit new support tickets.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将首先创建新的组件来帮助我们更快地构建表单，然后我们将使用`Login.vue`组件将注册和登录表单添加到应用程序中。在后面的部分，我们将创建另一个表单来提交新的支持票。
- en: Smart form
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能表单
- en: This generic component will take care of the very general structure of our form
    components, and will automatically call an `operation` function, display a loading
    animation and the eventual error messages thrown by the operation. Most of the
    time, the operation will be a `POST` request made to the server.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用组件将负责我们表单组件的非常一般的结构，并且会自动调用一个`operation`函数，显示一个加载动画和操作抛出的错误消息。大多数情况下，操作将是向服务器发出的`POST`请求。
- en: 'The template is essentially a form with a title, a default slot where the inputs
    will be rendered, an `actions` slot for the buttons, a loading animation, and
    a place for the error messages. This will be generic enough for the two forms
    we need in the application:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 模板本质上是一个带有标题的表单，一个默认插槽，用于呈现输入，一个用于按钮的`actions`插槽，一个加载动画，以及一个用于错误消息的位置。这将足够通用，适用于应用程序中我们需要的两个表单：
- en: 'Create a new `SmartForm.vue` component in the `components` folder:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹中创建一个新的`SmartForm.vue`组件：
- en: '[PRE79]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: On the `<form>` element, we set up an event listener on the `'submit'` event,
    which prevents the default behavior of the browser (reloading the page) with the
    `prevent` modifier.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<form>`元素上，我们在`'submit'`事件上设置了一个事件监听器，使用`prevent`修饰符阻止了浏览器的默认行为（重新加载页面）。
- en: 'For now, the `SmartForm` component will have three props:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`SmartForm`组件将有三个props：
- en: '`title`: This is displayed in the `<h2>` element.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题`：这将显示在`<h2>`元素中。'
- en: '`operation`: The asynchronous function called when the form is submitted. It
    should return a promise.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operation`：表单提交时调用的异步函数。它应该返回一个promise。'
- en: '`valid`: A Boolean to prevent calling the operation if the form is not valid.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valid`：一个布尔值，用于防止在表单无效时调用操作。'
- en: 'Add them to the `script` part of the component:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们添加到组件的`script`部分：
- en: '[PRE80]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'As you can see, we are now using a different way of declaring the props--by
    using an object, we can specify more details of the prop. For example, with `required:
    true`, Vue will warn us if we forget a prop. We can also put a type that Vue will
    check too. This syntax is recommended since it helps both understanding the props
    of the component and avoiding errors.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你所看到的，我们现在正在使用一种不同的方式来声明props--通过使用对象，我们可以指定props的更多细节。例如，使用`required: true`，Vue会在我们忘记一个prop时警告我们。我们还可以放置Vue将检查的类型。这种语法是推荐的，因为它既有助于理解组件的props，又能避免错误。'
- en: 'We also need two data properties:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要两个数据属性：
- en: '`busy`: A Boolean to toggle the display of the loading animation'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`busy`：一个布尔值，用于切换加载动画的显示'
- en: '`error`: This is the error message or `null` if there aren''t any'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：这是错误消息，如果没有则为`null`'
- en: 'Add them with the `data` hook:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`data`钩子添加它们：
- en: '[PRE81]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we need to write the `submit` method called when the form is submitted:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要编写在表单提交时调用的`submit`方法：
- en: '[PRE82]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If the form isn't valid or is still busy, we don't call the operation. Or else
    we reset the `error` property and then call the `operation` prop, with the `await`
    keyword since it should be an asynchronous function that returns a promise. If
    we catch an error, we set the message to the `error` property so it is displayed.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单无效或仍在忙碌中，我们不调用操作。否则，我们重置`error`属性，然后调用`operation` prop，使用`await`关键字，因为它应该是一个返回promise的异步函数。如果我们捕获到错误，我们将消息设置为`error`属性，以便显示。
- en: 'Now that our generic form is ready, we can register it in the `global-components.js`
    file:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的通用表单已经准备好了，我们可以在`global-components.js`文件中注册它：
- en: '[PRE83]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Form input component
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单输入组件
- en: 'In our forms, we will have many inputs with the same markup and functionalities.
    This is the perfect occasion to make another generic and reusable component. It
    will have a small template with mainly an `<input>` element and will be able to
    show the user that it is invalid with a red border:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的表单中，我们将有许多具有相同标记和功能的输入。这是制作另一个通用且可重用组件的绝佳机会。它将有一个小模板，主要是一个`<input>`元素，并且能够通过红色边框向用户显示它是无效的：
- en: 'Start by creating a new `FormInput.vue` component with the following props:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的`FormInput.vue`组件，具有以下props：
- en: '`name` is the HTML name of the input, needed for the browser autocompletion
    to work.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是输入的HTML名称，需要用于浏览器自动完成功能。'
- en: '`type` will be `''text''` by default, but we will need to set `''password''`
    eventually.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`默认为`''text''`，但最终我们需要设置为`''password''`。'
- en: '`value` is the current value of the input.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`是输入框的当前值。'
- en: '`placeholder` is the label displayed inside the input.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`placeholder`是显示在输入框内部的标签。'
- en: '`invalid` is a Boolean to toggle the invalid display (the red border). It will
    default to `false`.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalid`是一个布尔值，用于切换无效显示（红色边框）。它默认为`false`。'
- en: 'The script should look like this with the prop object notation:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本应该像这样使用prop对象表示法：
- en: '[PRE84]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'For the invalid display, we will add a computed property to dynamically change
    the CSS classes of the input:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于无效显示，我们将添加一个计算属性来动态更改输入框的CSS类：
- en: '[PRE85]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now we can write our template. It will have a `<div>` element containing the
    `<input>`:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编写我们的模板。它将包含一个包含`<input>`的`<div>`元素：
- en: '[PRE86]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We use the `prop` modifier on the `v-bind:value` directive to tell Vue to set
    the DOM node `value` property directly instead of setting the HTML attribute.
    This is a good practise when dealing with properties such as `value` for input
    HTML elements.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`v-bind:value`指令上使用`prop`修饰符，告诉Vue直接设置DOM节点的`value`属性，而不是设置HTML属性。在处理诸如输入HTML元素的`value`等属性时，这是一个很好的做法。
- en: 'To begin testing it, we can register the component in the `global-components.js`
    file:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了开始测试它，我们可以在`global-components.js`文件中注册组件：
- en: '[PRE87]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Create a new `Login.vue` component using the `FormInput` component:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FormInput`组件创建一个新的`Login.vue`组件：
- en: '[PRE88]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Don''t forget the corresponding route in the `router.js` file:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在`router.js`文件中添加相应的路由：
- en: '[PRE89]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You can test the component by opening the app with the `/login` path in the
    URL:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在URL中使用`/login`路径打开应用程序来测试组件：
- en: '![](assets/5730642f-6612-40ca-8845-041eaa6f0b34.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5730642f-6612-40ca-8845-041eaa6f0b34.png)'
- en: For now, the `FormInput` component is read-only because we don't do any thing
    when the user types something into the field.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`FormInput`组件是只读的，因为当用户在字段中输入时，我们不做任何操作。
- en: 'Let''s add a method to take care of that:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个方法来处理这个问题：
- en: '[PRE90]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then we can listen to the `input` event on the text field:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以监听文本字段上的`input`事件：
- en: '[PRE91]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Now if you type into the text field, the content should be printed to the console.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在文本框中输入，内容应该会打印到控制台上。
- en: 'In the `update` method, we are going to emit an event to send the new value
    to the parent component. By default, the `v-model` directive listens to the `input`
    event, with the new value being the first parameter:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们将发出一个事件来将新值发送到父组件。默认情况下，`v-model`指令监听`input`事件，新值是第一个参数：
- en: '[PRE92]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: To understand how things work, we are not going to use `v-model` yet.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解事情是如何工作的，我们暂时不会使用`v-model`。
- en: 'We can now listen to this `input` event and update the `username` prop:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以监听`input`事件并更新`username`属性：
- en: '[PRE93]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The value of the `username` prop should be updated on the `Login` component:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`username`属性的值应该在`Login`组件上更新：'
- en: '![](assets/a4105d26-4d80-40f0-9e45-8e9b20793a4e.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a4105d26-4d80-40f0-9e45-8e9b20793a4e.png)'
- en: 'Using the `v-model` directive, we can simplify this code:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`v-model`指令，我们可以简化这段代码：
- en: '[PRE94]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: It will use the `value` prop and listen to the `input` event for us!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 它将使用`value`属性并为我们监听`input`事件！
- en: Customizing v-model
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义v-model
- en: 'By default, `v-model` uses the `value` prop and the `input` event as we just
    saw, but we can customize that:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`v-model`使用`value`属性和`input`事件，正如我们刚才看到的，但我们可以自定义：
- en: 'Inside the `FormInput` component, add the `model` option:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FormInput`组件内部，添加`model`选项：
- en: '[PRE95]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We then need to change the name of our `value` prop to `text`:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要将我们的`value`属性的名称更改为`text`：
- en: '[PRE96]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And in the template:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中：
- en: '[PRE97]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Plus the `input` event should be renamed to `update`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，`input`事件应该被重命名为`update`：
- en: '[PRE98]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The component should still work in the `Login` component, since we told `v-model`
    to use the `text` prop and `update` event!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件应该仍然在`Login`组件中工作，因为我们告诉`v-model`使用`text`属性和`update`事件！
- en: Our input component is now ready! For this project, we have kept this component
    simple, but you can add more features into it if you want to, such as icons, error
    messages, floating label, and so on.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入组件现在已经准备好了！对于这个项目，我们将这个组件保持简单，但如果您愿意，您可以添加更多功能，比如图标、错误消息、浮动标签等。
- en: Login component
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录组件
- en: We can now continue building the `Login` component, which will take care of
    signing in and signing up the user.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续构建`Login`组件，该组件将负责登录和注册用户。
- en: 'There are several data properties we need for the state of this component:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件状态需要几个数据属性：
- en: '`mode`: This can either be `''login''` or `''signup''`. We will change the
    layout a bit depending on this.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模式`：这可以是`''login''`或`''signup''`。我们将根据此更改布局。'
- en: '`username`: Used in both modes.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户名`：在两种模式下使用。'
- en: '`password`: Also used in both modes.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`密码`：也在两种模式下使用。'
- en: '`password2`: Used to verify the password when signing up.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password2`：用于在注册时验证密码。'
- en: '`email`: Used in sign up mode.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件：用于注册模式。
- en: 'Our `data` hook should now look like this:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`data`钩子现在应该是这样的：
- en: '[PRE99]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We can then add a `title` computed property to change the form title depending
    on the mode:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以添加一个`title`计算属性，根据模式更改表单标题：
- en: '[PRE100]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We will also add some basic input validation. First, we would like to highlight
    the retype `password` field when it's not equal to the first password.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一些基本的输入验证。首先，当重新输入的`密码`与第一个密码不相等时，我们希望突出显示它。
- en: 'Let''s add another computed property for that:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为此添加另一个计算属性：
- en: '[PRE101]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Then, we will also check that no field is empty since they are all mandatory.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还将检查没有字段为空，因为它们都是必填的。
- en: 'This time, we will break it up into two computed properties, since we don''t
    want to check the sign up specific fields when in `login` mode:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们将将其分解为两个计算属性，因为我们不希望在`login`模式下检查注册特定字段：
- en: '[PRE102]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Next, add the methods we will use to either `login` or `sign up` the user (we
    will implement them later in the *Sign up operation* and *Login operation* sections):'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加我们将用于`登录`或`注册`用户的方法（我们将在*注册操作*和*登录操作*部分中稍后实现它们）：
- en: '[PRE103]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We can now move onto the template. Start by adding a `SmartForm` component:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以转到模板。首先添加一个`SmartForm`组件：
- en: '[PRE104]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then we can add the `input` fields:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以添加`input`字段：
- en: '[PRE105]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Don't forget the name attributes--it will allow the browser to auto-complete
    the fields.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记`name`属性--它将允许浏览器自动完成字段。
- en: 'Below the `input` fields, we need two different buttons for each mode. For
    the login mode, we need a `sign up` and `login` button. For the `sign up` mode,
    we need a Back button and a Create account button:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`input`字段下面，我们需要两个不同的按钮，用于每种模式。对于登录模式，我们需要一个`注册`和`登录`按钮。对于`注册`模式，我们需要一个返回按钮和一个创建帐户按钮：
- en: '[PRE106]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now you can test the component and switch between the `login` and `sign up`
    modes:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以测试组件并在`登录`和`注册`模式之间切换：
- en: '![](assets/472e2d84-4be7-41cf-b5dd-f4be4516d939.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/472e2d84-4be7-41cf-b5dd-f4be4516d939.png)
- en: Style children of scoped elements
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式作用域元素的子元素
- en: The form is currently taking all the space available. It would be better to
    shrink it a bit.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 表单目前占用了所有可用空间。最好将其缩小一点。
- en: For this section to work, you need the latest `vue-loader` package installed
    in your project.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本节起作用，您需要在项目中安装最新的`vue-loader`包。
- en: 'Let''s add some style to put a maximum width to the form:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些样式来给表单设置最大宽度：
- en: '[PRE107]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The `>>>` combinator allows us to target elements inside the components used
    in the template, while still scoping the rest of the `CSS` selector. In our example,
    the generated `CSS` will look as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>>`组合器允许我们定位模板中使用的组件内的元素，同时仍然限定其余的`CSS`选择器。在我们的示例中，生成的`CSS`将如下所示：'
- en: '[PRE108]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'If we didn''t use this combinator, we would have this `CSS`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用这个组合器，我们将会有这个`CSS`：
- en: '[PRE109]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This wouldn't work since the `.content` element is inside the `SmartForm` component
    we are using in the template.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这不起作用，因为`.content`元素在我们在模板中使用的`SmartForm`组件内部。
- en: If you are using SASS, you need to use the `/deep/` selector instead of the
    `>>>` combinator.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用SASS，则需要使用`/deep/`选择器而不是`>>>`组合器。
- en: 'The form should look like this now:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表单应该是这样的：
- en: '![](assets/1e6f948a-9608-463b-a8ba-db80dc50186a.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1e6f948a-9608-463b-a8ba-db80dc50186a.png)'
- en: Improving our fetch plugin
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进我们的fetch插件
- en: 'Currently, our `$fetch` method can only make `GET` requests to the server.
    It was enough for loading the FAQ, but now we need to add more features to it:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`$fetch`方法只能向服务器发出`GET`请求。对于加载FAQ来说已经足够了，但现在我们需要为其添加更多功能：
- en: 'In the `plugins/fetch.js` file, edit the signature of the function to accept
    a new `options` parameter:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`plugins/fetch.js`文件中，编辑函数的签名以接受一个新的`options`参数：
- en: '[PRE110]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The `options` argument is an optional object for the browser's `fetch` method
    that will allow us to change different parameters, such as the HTTP method used,
    the request body, and more.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`options`参数是浏览器`fetch`方法的可选对象，它允许我们更改不同的参数，比如使用的HTTP方法，请求体等。'
- en: 'At the beginning of the `$fetch` function, we would like to put some default
    values for this `options` parameter:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`$fetch`函数的开头，我们想为这个`options`参数设置一些默认值：
- en: '[PRE111]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The default options tell the server we will always send JSON in the request
    body, and tell the browser that we will also include the authorization token necessary
    to authenticate the user if they are logged in. Then, the provided `options` argument,
    if any, add its value to the `finalOptions` object (for example, the `method`
    property or the `body` property).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 默认选项告诉服务器我们将始终在请求体中发送JSON，并告诉浏览器，如果用户已登录，我们还将包括必要的授权令牌。然后，如果有提供`options`参数，将其值添加到`finalOptions`对象中（例如`method`属性或`body`属性）。
- en: 'Next, we add the new options to the `fetch` browser method:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将新的选项添加到`fetch`浏览器方法中：
- en: '[PRE112]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Also, the server will always send errors as text, so we can catch them and
    display them to the user:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，服务器将始终以文本形式发送错误，因此我们可以捕获并向用户显示它们：
- en: '[PRE113]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We are now ready to make our first `POST` request to the server in order to
    create for the user a new account and then log him in!
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备向服务器发出第一个`POST`请求，以为用户创建一个新帐户，然后登录！
- en: Sign up operation
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册操作
- en: 'We will start with the account creation, since we don''t have any user yet.
    The path to call on the server is `/signup`, and it expects a `POST` request with
    a JSON object in the request body containing the username, password, and email
    of the new account:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从帐户创建开始，因为我们还没有任何用户。在服务器上调用的路径是`/signup`，它期望一个带有新帐户的用户名、密码和电子邮件的JSON对象的`POST`请求：
- en: 'Let''s implement this using the `$fetch` method we just improved:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们刚刚改进的`$fetch`方法来实现这一点：
- en: '[PRE114]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We don't manage errors here, as it's the job of the `SmartForm` component we
    built earlier.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不在这里处理错误，因为这是我们之前构建的`SmartForm`组件的工作。
- en: That's it! You can now create a new account with a simple `password` you will
    have to remember for later. If the account creation succeeds, the form goes back
    to `login` mode.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在您可以使用一个简单的`密码`创建一个新帐户，以便以后记住。如果帐户创建成功，表单将返回到`登录`模式。
- en: One thing we don't do here, but that could be improved, is to let the user know
    their account has been created and that they can now log in. You could add a message
    below the form, or even make a floating notification appear!
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们没有做的一件事是让用户知道他们的帐户已经创建，他们现在可以登录。您可以在表单下方添加一条消息，甚至让浮动通知出现！
- en: Login operation
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录操作
- en: 'The login method will be almost identical to the sign up. The differences are:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 登录方法几乎与注册相同。区别在于：
- en: We only send the `username` and `password` in the request body, to the `/login`
    path
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只在请求体中发送`username`和`password`到`/login`路径
- en: The response is the user object we need to set into the global state so every
    component can know if there is a connected user (using the plugin we made exposing
    the `$state` property)
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应是我们需要设置到全局状态中的用户对象，以便每个组件都可以知道是否有连接的用户（使用我们制作的插件暴露的`$state`属性）
- en: Then we redirect to the home page
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后重定向到主页
- en: 'It should look like this now:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它应该是这样的：
- en: '[PRE115]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: You can now try to log in with the `username` and the `password` you used to
    create the account earlier. If the login is successful, you should be redirected
    to the home page thanks to the `router.push()` method.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以尝试使用之前用来创建帐户的`用户名`和`密码`进行登录。如果登录成功，您应该通过`router.push()`方法被重定向到主页。
- en: The `user` object returned by this request contains the `username` field that
    will be displayed in the navigation menu.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求返回的`user`对象包含将显示在导航菜单中的`username`字段。
- en: User menu
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户菜单
- en: 'Now it is time to add the user-related features to the navigation menu we made
    at the beginning in the `NavMenu.vue` file:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将与用户相关的功能添加到我们在`NavMenu.vue`文件开头制作的导航菜单中了：
- en: 'We want them to appear to the far right side of the menu, so we will add this
    element just after the router links we already wrote:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望它们出现在菜单的最右侧，因此我们将在我们已经编写的路由链接之后添加这个元素：
- en: '[PRE116]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This will simply grow to take all the available space in the menu using the
    CSS flexbox properties, so that anything we put after will be pushed to the right.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地扩展以占用菜单中所有可用的空间，使用CSS flexbox属性，这样我们放在后面的任何东西都会被推到右边。
- en: Thanks to the plugin we made earlier in the *Storing the user in a centralized
    State* section, we have access to the global state with the `$state` property.
    It contains the `user` object, which allows us to know if the user is logged in,
    and displays their `username` and a `logout` link.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在*将用户存储在集中状态*部分中制作的插件，我们可以通过`$state`属性访问全局状态。它包含`user`对象，允许我们知道用户是否已登录，并显示他们的`username`和`logout`链接。
- en: 'Add the user menu in the `NavMenu.vue` component:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NavMenu.vue`组件中添加用户菜单：
- en: '[PRE117]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'If the user isn''t connected, we just display a `login` link (add this below
    the `template` we just added):'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户未连接，我们只显示一个`登录`链接（在我们刚刚添加的`template`下面添加这个）：
- en: '[PRE118]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The `logout` link needs a new `logout` method that we will create now.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`logout`链接需要一个新的`logout`方法，我们现在将创建它。'
- en: Logout method
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登出方法
- en: 'The logout method consists of a simple call to the `/logout` path on the server,
    which should return an object with the `status` property equal to `''ok''`:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 登出方法包括简单地调用服务器上的`/logout`路径，该路径应返回一个带有`status`属性等于`'ok'`的对象：
- en: '[PRE119]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: If the user successfully logged out, we reset the `user` value in the global
    state.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户成功登出，我们会重置全局状态中的`user`值。
- en: Private routes with navigation guards
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有导航守卫的私有路由
- en: 'Now that we have an authentication system ready, we can have different types
    of routes:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好认证系统，我们可以有不同类型的路由：
- en: Public routes are always accessible
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共路由始终可访问
- en: Private routes are restricted to logged users
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有路由仅限于已登录用户
- en: Guest routes are accessible only to users that are not connected yet
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访客路由仅对尚未连接的用户可访问
- en: 'We are going to create one of the routes components ahead of time to test our
    code:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提前创建一个路由组件来测试我们的代码：
- en: 'Let''s create the `TicketsLayout.vue` component that we will use later to display
    either of the user support tickets:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建`TicketsLayout.vue`组件，稍后我们将用它来显示用户支持票据：
- en: '[PRE120]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Then, add the corresponding route in the `router.js` file:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`router.js`文件中添加相应的路由：
- en: '[PRE121]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Finally, add the link to this new page in the navigation menu:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在导航菜单中添加到这个新页面的链接：
- en: '[PRE122]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Route meta properties
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由元属性
- en: We can add the page access type information in the `meta` object on the impacted
    routes in the `router.js` file.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`router.js`文件中的受影响路由的`meta`对象中添加页面访问类型信息。
- en: 'The route we just created should be private and only accessible to connected
    users:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的路由应该是私有的，只能由已连接的用户访问：
- en: 'Add the `private` attribute to the `meta` object on the route:'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由上的`meta`对象中添加`private`属性：
- en: '[PRE123]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Now, if you go to the tickets page and inspect any component, you should see
    the `$route` object exposed by the `vue-router` plugin. It contains the `private`
    property in the `meta` object:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您转到票务页面并检查任何组件，您应该看到`vue-router`插件公开的`$route`对象。它在`meta`对象中包含`private`属性：
- en: '![](assets/febb8fe5-3e14-4956-a451-eb4cbd4a167f.png)You can put any additional
    information in the `meta` object of a route to extend the router capabilities.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/febb8fe5-3e14-4956-a451-eb4cbd4a167f.png)您可以在路由的`meta`对象中放入任何额外的信息，以扩展路由器的功能。'
- en: Router navigation guards
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器导航守卫
- en: Now that we know the tickets route is private, we would like to execute some
    logic before the route is resolved to check if the user is connected. That is
    where navigation guards come in handy--there are function hooks called when something
    happens regarding routes and they can change the behavior of the router.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道票务路线是私人的，我们想在路线解析之前执行一些逻辑，以检查用户是否已连接。这就是导航守卫派上用场的地方--它们是在路由方面发生某些事情时调用的函数钩子，它们可以改变路由器的行为。
- en: 'The navigation guard we need is `beforeEach` and it is run each time before
    a route is resolved. It allows us to replace the target route with another one
    if necessary. It accepts a callback with three arguments:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的导航守卫是`beforeEach`，它在每次解析路由之前运行。它允许我们根据需要替换目标路由。它接受一个带有三个参数的回调函数：
- en: '`to` is the route currently being targeted'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`是当前正在定位的路由'
- en: '`from` is the previous route'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`是上一个路由'
- en: '`next` is a function we have to call at some point for the resolution to proceed'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`是一个我们必须在某个时候调用以便解析继续进行的函数'
- en: If you forget to call `next` in your navigation guard, your app will be stuck.
    This is because you can do asynchronous operations before calling it, so the router
    doesn't make any assumption on its own.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您忘记在导航守卫中调用`next`，您的应用程序将会被卡住。这是因为您可以在调用它之前执行异步操作，所以路由器不会自行做出任何假设。
- en: 'Before exporting the router instance, add the `beforeEach` navigation guard:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导出路由实例之前，在`router.js`文件中添加`beforeEach`导航守卫：
- en: '[PRE124]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Now we need to determine if the route we target is a private route:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要确定我们要定位的路由是否是私有路由：
- en: '[PRE125]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'To check if the user is connected, we need the global state--you can import
    it at the start of the file:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查用户是否已连接，我们需要全局状态--您可以在文件开头导入它：
- en: '[PRE126]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Change the condition to also check for the user state:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改条件以检查用户状态：
- en: '[PRE127]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The next function can be called with a route argument, to redirect the navigation
    to another route.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数可以使用路由参数调用，将导航重定向到另一个路由。
- en: 'So here, we can redirect to the login route just like we would do with the
    `router.push()` method:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在这里，我们可以像使用`router.push()`方法一样重定向到登录路由：
- en: '[PRE128]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Don't forget to return, or you will call `next` a second time at the end of
    the function!
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记返回，否则您将在函数结束时第二次调用`next`！
- en: We can now try to log out and click on the support tickets link. You should
    be immediately redirected to the login page instead.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试注销并点击支持票链接。您应该立即被重定向到登录页面。
- en: When redirecting with `next`, no additional entry is added to the browser history
    for each redirection. Only the final route has a history entry.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`next`重定向时，每次重定向都不会向浏览器历史记录中添加额外的条目。只有最终路由有历史记录条目。
- en: 'As you can see in the browser console, the navigation guard was called each
    time we try to resolve to a route:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在浏览器控制台中所看到的，每次我们尝试解析到一个路由时，导航守卫都会被调用：
- en: '![](assets/a7f7d374-8b84-4412-80d1-1b21b70356ef.png)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a7f7d374-8b84-4412-80d1-1b21b70356ef.png)'
- en: That explains why the function is called `next`--the resolving process will
    continue until we don't redirect to another route.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这就解释了为什么这个函数被称为 `next`--解析过程将继续，直到我们不再重定向到另一个路由。
- en: This means the navigation guard can be called multiple times, but this also
    means you should be careful of not creating an infinite "loop" of resolutions!
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着导航守卫可以被多次调用，但这也意味着您应该小心，不要创建无限的解析“循环”！
- en: Redirecting to the wanted route
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向到想要的路由
- en: 'After the user is logged in, the app should redirect him to the page they initially
    wanted to browse:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录后，应用程序应将其重定向到他们最初想要浏览的页面：
- en: 'Pass the current wanted URL as a parameter to the login route:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前想要的 URL 作为参数传递给登录路由：
- en: '[PRE129]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now if you click on the support tickets link and get redirected to the login
    page, you should see the `wantedRoute` parameter in the `$route` object on any
    component:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您单击支持票链接并被重定向到登录页面，您应该在任何组件的 `$route` 对象中看到 `wantedRoute` 参数：
- en: '![](assets/d3bca6d2-077c-46fd-a9b6-f5c59b653462.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d3bca6d2-077c-46fd-a9b6-f5c59b653462.png)'
- en: 'In the `Login` component, we can change the redirection in the `login` method
    and use this parameter:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Login` 组件中，我们可以在 `login` 方法中更改重定向，并使用此参数：
- en: '[PRE130]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `router.replace()` method is very similar to the `router.push()` method,
    the difference being it replaces the current entry in the browser history with
    the new route instead of adding a new entry.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`router.replace()` 方法与 `router.push()` 方法非常相似，不同之处在于它用新路由替换浏览器历史记录中的当前条目，而不是添加新条目。'
- en: Now if you log in, you should be redirected to the support ticket page instead
    of the home page.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您登录，应该被重定向到支持票务页面，而不是主页。
- en: Initializing user authentication
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化用户身份验证
- en: 'When the page load and the application start, we need to check if the user
    is already connected. For this reason, the server has a `/user` path that returns
    the user object if they are logged in. We will put it in the global state just
    like if we logged in. Then, we will start the Vue app:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载和应用程序启动时，我们需要检查用户是否已连接。出于这个原因，服务器有一个 `/user` 路径，如果用户已登录，则返回用户对象。我们将把它放在全局状态中，就像我们已经登录一样。然后，我们将启动
    Vue 应用程序：
- en: 'In the `main.js` file, import `$fetch` from our plugin:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.js` 文件中，从我们的插件中导入 `$fetch`：
- en: '[PRE131]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Then we need to create a new asynchronous function called `main`, inside of
    which we will request the user data and then start the app:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个名为 `main` 的新异步函数，在其中我们将请求用户数据，然后启动应用程序：
- en: '[PRE132]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Now if you log in and then you refresh the page, you should still be connected!
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您登录然后刷新页面，您仍然应该保持连接！
- en: Guest routes
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访客路由
- en: There is another case we don't manage yet--we don't want an already connected
    user to access the login route!
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种情况我们尚未处理--我们不希望已连接的用户访问登录路由！
- en: 'That''s why we will mark it as a guest route:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是为什么我们将其标记为访客路由的原因：
- en: '[PRE133]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Inside the `beforeEach` navigation guard, we will check if the route is guest-only
    and if the user is already connected, then redirect to the home page:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `beforeEach` 导航守卫中，我们将检查路由是否仅限访客，以及用户是否已连接，然后重定向到主页：
- en: '[PRE134]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: If you are logged in, you can try going to the login URL--you should be immediately
    redirected to the home page! You can only access this page if you are not logged
    in.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已登录，可以尝试转到登录 URL--您应该立即被重定向到主页！只有在未登录时才能访问此页面。
- en: Displaying and adding tickets
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示和添加票务
- en: In this section, we will add the ticket support content to the app. First we
    will display them and then build a form to let the user create new ones. We will
    have two components for this, nested in the `TicketsLayout` component we made
    earlier.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向应用程序添加票务支持内容。首先我们将显示它们，然后构建一个表单让用户创建新的票务。我们将为此创建两个组件，嵌套在我们之前创建的`TicketsLayout`组件中。
- en: Don't worry! When you created your account, an example support ticket was automatically
    created for your user.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心！当您创建您的账户时，一个示例支持票务会自动为您的用户创建。
- en: Tickets list
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 票务列表
- en: 'The tickets can be requested at `/tickets` on the server:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在服务器上的`/tickets`请求票务：
- en: Create a new `Tickets.vue` component that will be pretty much like the FAQ component.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Tickets.vue`组件，它将与FAQ组件非常相似。
- en: 'Use the `RemoteData` mixin to fetch the tickets:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`RemoteData` mixin来获取票务：
- en: '[PRE135]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Then add the template with a loading animation, an empty message, and the list
    of the tickets:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加一个带有加载动画、空消息和票务列表的模板：
- en: '[PRE136]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We need a filter to display the ticket date!
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个过滤器来显示票务日期！
- en: 'Kill the client compilation and install `momentjs` with the following command:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止客户端编译，并使用以下命令安装`momentjs`：
- en: '[PRE137]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Create a new `filters.js` file next to the `main.js` file, with a `date` filter:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.js`文件旁边创建一个新的`filters.js`文件，其中包含一个`date`过滤器：
- en: '[PRE138]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Then in `main.js`, import the `filters` and register them with a handy loop:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在`main.js`中，导入`filters`并使用一个方便的循环进行注册：
- en: '[PRE139]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'We can now display the dates in a more human-friendly way in the `Tickets`
    component:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在`Tickets`组件中以更加人性化的方式显示日期：
- en: '[PRE140]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'You can then add this new component to the `TicketsLayout` component and get
    the list of tickets:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这个新组件添加到`TicketsLayout`组件中并获取票务列表：
- en: '![](assets/32ded18f-6a20-4a04-a4d2-8e5af3f44dd2.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/32ded18f-6a20-4a04-a4d2-8e5af3f44dd2.png)
- en: Don't forget to import `Tickets` and set it in the `components` option!
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记导入`Tickets`并将其设置在`components`选项中！
- en: Session expiration
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话过期
- en: 'After some time, the user session might become no longer valid. This could
    happen because of timed expiration (for this server this is set to three hours),
    or simply because the server was restarted. Let''s try to reproduce this kind
    of situation--we are going to restart the server and try to load the tickets again:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，用户会话可能会变得无效。这可能是因为定时到期（对于这个服务器，设置为三个小时），或者仅仅是因为服务器重新启动。让我们尝试重现这种情况--我们将重新启动服务器并尝试再次加载票务：
- en: Make sure you are logged into the application.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已登录到应用程序中。
- en: Type `rs` and then press `Return` in the Terminal where the server is running
    to restart it.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行服务器的终端中键入`rs`，然后按`Return`键以重新启动它。
- en: Click on the Home button in the app.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中点击主页按钮。
- en: Click on the support ticket button to go back to the tickets list page.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击支持票务按钮返回到票务列表页面。
- en: 'You should have a stuck loading animation and an error message in the console:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在控制台中看到一个卡住的加载动画和一个错误消息：
- en: '![](assets/a356239a-cb14-4919-82be-6145adbf8c1d.png)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/a356239a-cb14-4919-82be-6145adbf8c1d.png)
- en: The server has returned an unauthorized error--that's because we are no longer
    logged in!
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器返回了未经授权的错误--这是因为我们已经退出登录了！
- en: To fix this, we need to log the user out and redirect them to the login page
    if we are in a private route.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，如果我们在私人路线上，我们需要注销用户并将其重定向到登录页面。
- en: The best place to put our code is the `$fetch` method used in all our components,
    located in the `plugins/fetch.js` file. The server will always return a 403 error
    when trying to access a path restricted to connected users.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 放置我们代码的最佳位置是`plugins/fetch.js`文件中的所有组件中使用的`$fetch`方法。当尝试访问连接用户限制的路径时，服务器将始终返回403错误。
- en: 'Before modifying the method, we need to import both the state and the router:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在修改方法之前，我们需要导入状态和路由：
- en: '[PRE141]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Let''s add a new case in the response processing:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在响应处理中添加一个新的情况：
- en: '[PRE142]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: We use the `replace` method instead of `push` because we don't want to create
    a new navigation in the browser history. Imagine if the user clicks the back button,
    it will redirect again to the login page and the user will not be able to go back
    to the page before the private one.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`replace`方法而不是`push`，因为我们不希望在浏览器历史记录中创建新的导航。想象一下，如果用户单击返回按钮，它将再次重定向到登录页面，用户将无法返回到私人页面之前的页面。
- en: You can now try again--when you restart the server and click on the support
    tickets link, you should be redirected to the login page and the navigation menu
    should not display your username anymore.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以再试一次--当您重新启动服务器并单击支持票务链接时，您应该会被重定向到登录页面，并且导航菜单不应再显示您的用户名。
- en: Nested routes
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套路由
- en: 'Since we also want to switch to a form in this page, it would be a good idea
    to structure our components with nested routes--each route can have child routes
    if they have at least a router view! So under the `/tickets` router, we will have
    two children for now:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还想在此页面切换到一个表单，因此将组件结构化为嵌套路由是一个好主意--如果至少有一个路由视图，每个路由都可以有子路由！因此，在`/tickets`路由器下，我们现在将有两个子路由：
- en: '`''''` will be the tickets list (full path will be `/tickets/`). It acts like
    the default route under `/tickets`.'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''''`将是票务列表（完整路径将是`/tickets/`）。它就像是`/tickets`下的默认路由。'
- en: '`''/new''` will be the form to send new tickets (full path will be `/tickets/new/`).'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''/new''`将是发送新票务的表单（完整路径将是`/tickets/new/`）。'
- en: 'Create a new `NewTicket.vue` component with a temporary template:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个临时模板的新`NewTicket.vue`组件：
- en: '[PRE143]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'In the `routes.js` file, add the two new routes under the `/tickets` route
    inside the children attribute:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes.js`文件中，在`children`属性下的`/tickets`路由下添加两个新路由：
- en: '[PRE144]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Since the first child route is an empty string, it will be the default when
    the parent route is resolved. This means you should move the name of the route
    (`'tickets'`) from the parent to it.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个子路由是空字符串，当解析父路由时它将成为默认路由。这意味着您应该将路由的名称（`'tickets'`）从父级移到它。
- en: 'Finally, we can change the `TicketsLayout` component to use a router view along
    with a few buttons to switch between the child routes:'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以更改`TicketsLayout`组件，使用路由器视图以及一些按钮在子路由之间切换：
- en: '[PRE145]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: You can use the `tag` prop on router links to change the HTML tag used to render
    it.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在路由链接上使用`tag`属性来更改用于呈现它的HTML标签。
- en: As you can see, we hide each button depending on the current route name--we
    don't want to display the Show tickets button when we are already on the tickets
    page, and we don't want the New ticket button when we are already on the corresponding
    form!
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们根据当前路由名称隐藏每个按钮--当我们已经在票务页面时，我们不希望显示显示票务按钮，当我们已经在相应的表单上时，我们也不希望显示新票务按钮！
- en: 'You can now switch between the two child routes and see the URL change accordingly:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在两个子路由之间切换，并相应地看到URL更改：
- en: '![](assets/cf2479f9-c46e-42fc-a2b5-19b470ea7f57.png)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cf2479f9-c46e-42fc-a2b5-19b470ea7f57.png)'
- en: Fixing our navigation guard
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复我们的导航守卫
- en: If you log out and then go to the tickets page, you should be surprised to be
    able to access the page! This is because there is a flaw in the implementation
    of our `beforeEach` navigation guard--we poorly designed it without taking into
    account the fact we could have nested routes! The reason for this issue is that
    the `to` parameter is only the target route, which is the first child route of
    the `/tickets` route--it doesn't have the `private` meta attribute!
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注销然后转到票务页面，您应该会惊讶地发现能够访问该页面！这是因为我们的`beforeEach`导航守卫实现存在缺陷--我们设计不当，没有考虑到可能存在嵌套路由！出现这个问题的原因是`to`参数只是目标路由，即`/tickets`路由的第一个子路由--它没有`private`元属性！
- en: So instead of relying solely on the target route, we should also check all the
    matched nested route objects. Thankfully, every route object gives us access to
    the list of these route objects with the `matched` property. We can then use the
    `some` array method to verify if at least one route object has the desired meta
    attribute.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不应该仅仅依赖于目标路由，还应该检查所有匹配的嵌套路由对象。幸运的是，每个路由对象都可以通过`matched`属性让我们访问这些路由对象的列表。然后我们可以使用`some`数组方法来验证是否至少有一个路由对象具有所需的meta属性。
- en: 'We can change the conditions code to this in the `beforeEach` navigation guard
    in the `router.js` file:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`router.js`文件中的`beforeEach`导航守卫中将条件代码更改为这样：
- en: '[PRE146]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Now our code works regardless of the number of nested routes!
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码可以在任意嵌套路由的情况下工作了！
- en: It is strongly recommended to use this approach with the `matched` property
    every time to avoid errors.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议每次都使用`matched`属性来避免错误。
- en: Sending a form
  id: totrans-612
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送表单
- en: 'In this section, we are going to complete the `NewTicket` component that will
    allow the user to send a new support ticket. We need two fields to create a new
    ticket--`title` and `description`:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将完成`NewTicket`组件，允许用户发送新的支持票。我们需要两个字段来创建一个新的票--`title`和`description`：
- en: 'In the template of the `NewTicket.vue` component, we can already add a `SmartForm`
    component with the title `InputForm` component:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NewTicket.vue`组件的模板中，我们已经可以添加一个标题为`InputForm`的`SmartForm`组件：
- en: '[PRE147]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'We can also add the two data properties, the `operation` method and some input
    validation with the `valid` computed property:'
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以添加两个数据属性，`operation`方法和一些输入验证，使用`valid`计算属性：
- en: '[PRE148]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Form textarea
  id: totrans-618
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单文本框
- en: 'For the `description` field, we need a `<textarea>` element so the user can
    write a multiline text. Unfortunately, our `FormInput` component doesn''t support
    this yet, so we need to modify it a bit. We will use the `type` prop of the component
    with the value `''textarea''` to change the `<input>` element to a `<textarea>`
    element:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`description`字段，我们需要一个`<textarea>`元素，这样用户就可以编写多行文本。不幸的是，我们的`FormInput`组件还不支持这一点，所以我们需要稍微修改一下。我们将使用组件的`type`prop，值为`'textarea'`来将`<input>`元素更改为`<textarea>`元素：
- en: 'Let''s create a new computed property to determine which kind of HTML element
    we are going to render:'
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的计算属性来确定我们将要渲染哪种HTML元素：
- en: '[PRE149]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: So when the value `'textarea'` is passed, we need to render a `<textarea>`.
    All the other types will make the component render an `<input>` element.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递值`'textarea'`时，我们需要渲染一个`<textarea>`。所有其他类型都会使组件渲染一个`<input>`元素。
- en: We can now use the special `<component>` component, which can render either
    elements with the `is` prop, instead of the static `<input>` element.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用特殊的`<component>`组件，它可以根据`is`属性渲染元素，而不是静态的`<input>`元素。
- en: 'The line in the template should now look like this:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板中的这一行现在应该是这样的：
- en: '[PRE150]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'We can now add the `description` textarea to the `NewTicket` form just after
    the `title` input:'
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在`NewTicket`表单中添加`description`文本框，就在`title`输入框之后：
- en: '[PRE151]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Binding attributes
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定属性
- en: Among other elements, `<textarea>` has some handy attributes we would like to
    use, such as the `rows` attribute. We could create a prop for each of them, but
    this could become tedious very quickly. Instead, we are going to use the handy
    `$attrs` special property of the Vue component, which gets all the non-prop attributes
    set on the component as an object with the keys being the names of the attributes.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他元素，`<textarea>`有一些方便的属性，我们想要使用，比如`rows`属性。我们可以为每个属性创建一个prop，但这可能会很快变得乏味。相反，我们将使用Vue组件的特殊`$attrs`属性，它将所有设置在组件上的非prop属性作为一个对象获取，键是属性的名称。
- en: 'This means that if you have let''s say, one `text` prop on your component and
    that you write this in another component:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你在组件上有一个`text`prop，然后在另一个组件中写入这样的内容：
- en: '[PRE152]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Vue will treat `required` as an attribute, since it is not in the list of props
    exposed by the `FormInput` component. Then you can access it with `$attrs.required`!
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: Vue将把`required`视为属性，因为它不在`FormInput`组件公开的props列表中。然后您可以使用`$attrs.required`访问它！
- en: The `v-bind` directive can get an object with the keys being the names of the
    props and attributes to set. This will be very useful!
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-bind`指令可以获取一个对象，其中键是要设置的props和属性的名称。这将非常有用！'
- en: 'We can write this on `<component>` in the `FormInput.vue` component:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`FormInput.vue`组件中的`<component>`上写入这个：
- en: '[PRE153]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Now you can add the `rows` attribute on the `description` input in the `NewTicket.vue`
    component:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以在`NewTicket.vue`组件的`description`输入上添加`rows`属性：
- en: '[PRE154]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'You should see in the rendered HTML that the attribute has been set on the
    `<textarea>` element inside the `FormInput` component:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在渲染的HTML中看到该属性已设置在`FormInput`组件内的`<textarea>`元素上：
- en: '[PRE155]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: User actions
  id: totrans-640
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户操作
- en: 'We will now implement the few actions the users will be able to do in the form:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现用户在表单中可以执行的几个操作：
- en: 'In the `SmarForm` component, add these two buttons after the inputs:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SmarForm`组件中，在输入框后添加这两个按钮：
- en: '[PRE156]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Then implement the `operation` method, which will be similar to what we have
    done in the `Login` component. The server path we need to send the `POST` request
    to is `/tickets/new`:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后实现`operation`方法，这将类似于我们在`Login`组件中所做的。我们需要将`POST`请求发送到的服务器路径是`/tickets/new`：
- en: '[PRE157]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: You can now create new tickets!
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以创建新的票！
- en: Backup user input
  id: totrans-647
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份用户输入
- en: To improve the user experience, we should automatically back up what the user
    has typed into the form in case something goes wrong--for example, the browser
    could crash or the user could accidentally refresh the page.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善用户体验，我们应该自动备份用户在表单中输入的内容，以防出现问题--例如，浏览器可能会崩溃，或者用户可能会意外刷新页面。
- en: 'We are going to write a mixin that will automatically save some data properties
    into the browser local storage, and restore them when the component is created:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个mixin，它将自动将一些数据属性保存到浏览器本地存储中，并在组件创建时恢复它们：
- en: Create a new `PersistantData.js` file in the `mixins` folder.
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mixins`文件夹中创建一个新的`PersistantData.js`文件。
- en: 'Like the other mixin we did, it will have some parameters, so we need to export
    it as a function:'
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们之前做的另一个mixin一样，它将具有一些参数，因此我们需要将其导出为一个函数：
- en: '[PRE158]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The `id` argument is the unique identifier to store the data for this specific
    component.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`参数是用来存储这个特定组件数据的唯一标识符。'
- en: First we are going to watch all the fields passed in the mixin.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将监视mixin中传递的所有字段。
- en: 'For that, we will dynamically create the `watch` object, with each key being
    the field and the value being the handler function that will save the value into
    the local storage:'
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们将动态创建`watch`对象，每个键都是字段，值是将值保存到本地存储的处理程序函数：
- en: '[PRE159]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Go back to the `NewTicket` component and add the mixin:'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`NewTicket`组件并添加mixin：
- en: '[PRE160]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'So, the mixin added watchers to the component with the `reduce` producing the
    equivalent of this:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，mixin为组件添加了观察者，`reduce`生成了相当于这个的等价物：
- en: '[PRE161]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: We are saving the property values as JSON since the local storage only supports
    strings.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将属性值保存为JSON，因为本地存储只支持字符串。
- en: 'You can try typing into the fields, and then look at the browser dev tools
    to see that two new local storage items have been saved:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试在字段中输入，然后查看浏览器开发工具，看到已保存了两个新的本地存储项：
- en: '![](assets/f2105df0-659f-4c82-8e3f-71c21eb1e58c.png)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f2105df0-659f-4c82-8e3f-71c21eb1e58c.png)'
- en: 'In the mixin, we can also save the fields when the component is destroyed:'
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在mixin中，当组件被销毁时，我们还可以保存字段：
- en: '[PRE162]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Finally, we need to restore the values when the component is created:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在组件创建时恢复这些值：
- en: '[PRE163]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Now if you type something into the form, and then refresh the page, what you
    typed should be still in the form!
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在表单中输入一些内容，然后刷新页面，你输入的内容应该仍然在表单中！
- en: With the session expiration management we added to `$fetch`, you will be redirected
    to the login page if you try to send your new ticket while you are no longer connected.
    Then, once you're logged in again, you should be right back to the form with what
    you typed still there!
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们添加到`$fetch`的会话过期管理，如果您在不再连接的情况下尝试发送新票务，您将被重定向到登录页面。然后，一旦您再次登录，您应该回到表单，并且您输入的内容仍然存在！
- en: Advanced routing features
  id: totrans-670
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级路由功能
- en: This is the last section of this chapter, in which we will explore routing a
    bit more!
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的最后一节，我们将更深入地探讨路由！
- en: Dynamic routes with parameters
  id: totrans-672
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带参数的动态路由
- en: The last component we will add in the application is `Ticket`, which display
    a detailed view of one ticket by its ID. It will show the title and description
    inputted by the user, plus the date and the status.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用程序中添加的最后一个组件是`Ticket`，它通过其ID显示一个票务的详细视图。它将显示用户输入的标题和描述，以及日期和状态。
- en: 'Create a new `Ticket.vue` file and add this template with the usual loading
    animation and `not found` notice:'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Ticket.vue`文件，并添加这个模板，其中包括通常的加载动画和`未找到`提示：
- en: '[PRE164]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Then add an `id` prop to the component:'
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在组件中添加一个`id` prop：
- en: '[PRE165]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Dynamic remote data
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态远程数据
- en: The `id` prop will be the ID of the ticket for which we will fetch the details.
    The server provides a dynamic route in the form of `/ticket/<id>`, with `<id>`
    being the ID of the ticket.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` prop将是我们将获取详细信息的票务的ID。服务器以`/ticket/<id>`的形式提供动态路由，其中`<id>`是票务的ID。'
- en: 'It would be nice to be able to use our `RemoteData` mixin, but it currently
    lacks support for dynamic paths! What we could do is to pass a function instead
    of a plain string as the values of the mixin''s parameter:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用我们的`RemoteData` mixin会很好，但它目前不支持动态路径！我们可以做的是将函数传递给mixin参数的值，而不是普通的字符串：
- en: 'In the `RemoteData` mixin, we just need to modify the way we process the parameter
    in the `created` hook. If the value is a function, we will use the `$watch` method
    to watch its value instead of directly calling the `fetchResource` method:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RemoteData` mixin中，我们只需要修改`created`钩子中处理参数的方式。如果值是一个函数，我们将使用`$watch`方法来观察它的值，而不是直接调用`fetchResource`方法：
- en: '[PRE166]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Don''t forget the `immediate: true` option for the watcher since we want to
    call `fetchResource` a first time before watching the value.'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '不要忘记在观察者中添加`immediate: true`选项，因为我们希望在观察值之前首先调用`fetchResource`方法。'
- en: 'In the `Ticket` component, we can now use this mixin to load the data of the
    ticket depending on the `id` prop:'
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Ticket`组件中，我们现在可以使用这个mixin根据`id` prop加载票务数据：
- en: '[PRE167]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Let's try this in the `Tickets` component.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Tickets`组件中尝试这个。
- en: 'Add the new `Ticket` component to it with a new `id` data property:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`Ticket`组件添加到其中，并添加一个新的`id`数据属性：
- en: '[PRE168]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Then in the template, add a `Ticket` component:'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在模板中添加一个`Ticket`组件：
- en: '[PRE169]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'In the ticket list, change the title to a link that sets the `id` data property
    on `click`:'
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在票务列表中，将标题更改为在`click`事件上设置`id`数据属性的链接：
- en: '[PRE170]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'If you click on the tickets in the application, you should have the details
    in the following list:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在应用程序中点击票务，你应该能够在下面的列表中看到详细信息：
- en: '![](assets/291c8703-598a-43a2-b94e-af8a7c2de73e.png)'
  id: totrans-694
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/291c8703-598a-43a2-b94e-af8a7c2de73e.png)'
- en: The dynamic route
  id: totrans-695
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态路由
- en: Since we are going to put the ticket details in another route, you can undo
    what we just did in the `Tickets` component.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在另一个路由中放置票务详情，你可以撤消我们在`Tickets`组件中刚刚做的事情。
- en: The route will be a child route of the tickets route, and will be of the form
    `/tickets/<id>` where `<id>` is the ID of the ticket being displayed. This is
    possible thanks to the dynamic route matching feature of vue-router!
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 该路由将是票务路线的子路线，并且将采用`/tickets/<id>`的形式，其中`<id>`是正在显示的票的ID。这要归功于vue-router的动态路由匹配功能！
- en: 'You can add dynamic segments to your route path with the semicolon. Then, each
    segment will be exposed in the route `params` object. Here are some examples of
    routes with parameters:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用分号将动态段添加到路由路径中。然后，每个段都将暴露在路由`params`对象中。以下是一些带参数的路由示例：
- en: '| Pattern | Example path | `$route.params` value |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 示例路径 | `$route.params`值 |'
- en: '| `/tickets/:id` | `/tickets/abc` | `{ id: ''abc'' }` |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
  zh: '| `/tickets/:id` | `/tickets/abc` | `{ id: ''abc'' }` |'
- en: '| `/tickets/:id/comments/:comId` | `/tickets/abc/comments/42` | `{ id: ''abc'',
    comId: ''42'' }` |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '| `/tickets/:id/comments/:comId` | `/tickets/abc/comments/42` | `{ id: ''abc'',
    comId: ''42'' }` |'
- en: 'Let''s add the new route in the `router.js` file as a child route of `/tickets`:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将新路由添加到`router.js`文件中，作为`/tickets`的子路由：
- en: '[PRE171]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'In the `Tickets` component list, we need to change the title element to a link
    pointing to the new route:'
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tickets`组件列表中，我们需要将标题元素更改为指向新路由的链接：
- en: '[PRE172]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Now if you click on a ticket, the `$route.params` object will have the `id`
    property set to the of the ticket.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您点击一张票，`$route.params`对象将具有`id`属性设置为票的ID。
- en: 'We could change our `Ticket` component to use this with a computed property
    instead of a prop:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更改我们的`Ticket`组件，使用计算属性而不是prop：
- en: '[PRE173]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: But this is a bad idea--we are coupling the component to the route! This means
    we won't be able to reuse it in another way easily. The best practice is to use
    props to pass info to components, so let's continue to do that!
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是一个坏主意--我们正在将组件与路由耦合！这意味着我们将无法轻松地以另一种方式重用它。最佳实践是使用props将信息传递给组件，所以让我们继续这样做！
- en: 'So we are going to keep the ID prop of the `Ticket` component and tell `vue-router`
    to pass all the route parameters to it as prop with the `props` attribute:'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们将保留`Ticket`组件的ID属性，并告诉`vue-router`将所有路由参数作为带有`props`属性的prop传递给它：
- en: '[PRE174]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'This is equivalent to this more flexible syntax based on a function that gets
    the route object as the argument:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于基于函数的更灵活的语法，该函数将路由对象作为参数：
- en: '[PRE175]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Another syntax based on an object exists too (useful when the props are static):'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种基于对象的语法也存在（当props是静态的时候很有用）：
- en: '[PRE176]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: We won't use this third syntax since our `id` prop should be equal to the dynamic
    parameter of the route.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用这种第三种语法，因为我们的`id` prop应该等于路由的动态参数。
- en: If you need to combine static and dynamic props, use the function syntax! This
    is also useful if the route parameters and the component props names don't match.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要组合静态和动态props，请使用函数语法！如果路由参数和组件props名称不匹配，这也很有用。
- en: 'Now, the `id` parameter is passed as a prop to the component and you should
    see the ticket details page when clicking on a ticket in the list:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`id`参数作为prop传递给组件，当在列表中点击票时，您应该看到票的详细信息页面：
- en: '![](assets/bbad02ee-1190-4f86-9416-dafa76a361f7.png)'
  id: totrans-719
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bbad02ee-1190-4f86-9416-dafa76a361f7.png)'
- en: Not found page
  id: totrans-720
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未找到页面
- en: Currently, if you enter an invalid URL into the app, you are greeted with a
    boring blank page. This is the default behavior of `vue-router`, but it can thankfully
    be changed! We will now customize the "not found" page of our app!
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果您在应用程序中输入无效的URL，您将看到一个无聊的空白页面。这是`vue-router`的默认行为，但幸运的是它可以更改！我们现在将自定义我们应用程序的“未找到”页面！
- en: 'Let''s create a better "not found" page with a new `NotFound.vue` component:'
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个更好的“未找到”页面，使用一个新的`NotFound.vue`组件：
- en: '[PRE177]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Now in the `router.js` file, we just need to add a new route matching the `''*''`
    path:'
  id: totrans-724
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`router.js`文件中，我们只需要添加一个匹配`'*'`路径的新路由：
- en: '[PRE178]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: This means that for any route, we display the `NotFound` component. The very
    important fact is that we put this route at the end of the `routes` array--this
    ensures that all the legit routes will be matched before matching this last particular,
    catch-all route.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于任何路由，我们都会显示`NotFound`组件。非常重要的事实是，我们将这个路由放在`routes`数组的末尾 - 这确保在匹配这个最后一个特定的捕获所有路由之前，所有合法的路由都会被匹配。
- en: 'You can now try a URL that doesn''t exist, like `/foo`, to have the page displayed:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以尝试一个不存在的URL，比如`/foo`，来显示页面：
- en: '![](assets/343904f2-8f5a-4a56-9b8b-c20d75db9122.png)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/343904f2-8f5a-4a56-9b8b-c20d75db9122.png)'
- en: Transitions
  id: totrans-729
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过渡
- en: 'Animating the route changes is very easy--this is done in exactly the same
    way we did before:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 路由变化的动画非常容易 - 这与我们以前做的方式完全相同：
- en: 'In the `AppLayout` component, wrap the router view with this transition:'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AppLayout`组件中，用这个过渡包装路由视图：
- en: '[PRE179]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The `router-view` special component will be replaced by the different component
    of the routes we have, and thus trigger the transition.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`router-view`特殊组件将被路由的不同组件替换，从而触发过渡。'
- en: Scrolling behavior
  id: totrans-734
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动行为
- en: The history mode of the router allows us to manage the page scrolling when a
    route changes. We can reset the position to the top every time, or restore the
    position the user was in before changing the route (this is very useful when they
    go back in the browser).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器的历史模式允许我们在路由更改时管理页面滚动。我们可以每次重置位置到顶部，或者在更改路由之前恢复用户之前的位置（当他们在浏览器中返回时非常有用）。
- en: 'When creating the router instance, we can pass a `scrollBehavior` function
    that will get three arguments:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建路由器实例时，我们可以传递一个`scrollBehavior`函数，该函数将获得三个参数：
- en: '`to` is the target route object.'
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`是目标路由对象。'
- en: '`from` is the previous route object.'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`是先前的路由对象。'
- en: '`savedPosition` is the scroll position that has been automatically saved for
    each entry in the browser history. Each new entry will not have this until the
    route changes.'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`savedPosition`是为浏览器历史记录中的每个条目自动保存的滚动位置。直到路由更改之前，每个新条目都不会有这个。'
- en: 'The `scrollBehavior` function expects an object that can take two different
    forms. The first is the coordinate of the scroll we want to apply; for example:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrollBehavior`函数期望一个可以采用两种不同形式的对象。第一个是我们想应用的滚动的坐标；例如：'
- en: '[PRE180]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The second one is a selector of the HTML element we want the page to scroll
    to, with an optional offset:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是我们要滚动到的HTML元素的选择器，带有可选的偏移量：
- en: '[PRE181]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'So to scroll to the top of the page when the route changes, we need to write
    this:'
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，当路由更改时滚动到页面顶部，我们需要编写这样的代码：
- en: '[PRE182]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'To scroll to the `<h1>` element each time, we could do this:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 要每次滚动到`<h1>`元素，我们可以这样做：
- en: '[PRE183]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Instead, we will check if the route has a hash to mimic the browser behavior:'
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，我们将检查路由是否有哈希来模仿浏览器的行为：
- en: '[PRE184]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Finally, we can restore the scroll position if there is any:'
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果有滚动位置，我们可以恢复滚动位置：
- en: '[PRE185]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: It's that simple! The app now should behave like an old multi-page website.
    You can then customize the way the scroll behaves with offset or route meta properties.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单！现在应用程序应该像一个旧的多页面网站一样运行。然后，您可以使用偏移或路由元属性来自定义滚动行为的方式。
- en: Summary
  id: totrans-753
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we created a fairly big application with the help of Vue and
    the official `vue-router` library. We created a few routes and connected them
    with links that turned into a real navigation menu. Then, we created a generic
    and reusable component to build the application forms, which helped us make the
    login and signup forms. We then integrated the user authentication system with
    the router, so our application could react in smart ways to page refreshes or
    session expirations. Finally, we went deeper into the features and capabilities
    of `vue-router` to enhance our application and user experience even further.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们借助Vue和官方的`vue-router`库创建了一个相当大的应用程序。我们创建了一些路由，并用链接将它们连接起来，形成了一个真正的导航菜单。然后，我们创建了一个通用且可重用的组件来构建应用程序表单，这帮助我们创建了登录和注册表单。然后，我们将用户认证系统与路由器集成，这样我们的应用程序就可以智能地对页面刷新或会话过期做出反应。最后，我们深入了解了`vue-router`的功能和能力，以进一步增强我们的应用程序和用户体验。
- en: 'We are done with the app, but feel free to improve it on your own! Here are
    some ideas you could implement:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了这个应用，但请随意对其进行改进！以下是一些你可以实现的想法：
- en: Add comments to the tickets. Display the list of comments with the name of the
    corresponding user.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为工单添加评论。显示评论列表，并显示对应用户的名称。
- en: Add close this ticket button, preventing users from adding new comments.
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加关闭此工单按钮，防止用户添加新评论。
- en: Display a special icon next to a closed ticket in the tickets list!
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工单列表中，为已关闭的工单旁边显示一个特殊图标！
- en: Add roles to users. For example, normal users could open tickets, but only admin
    users could close them.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给用户添加角色。例如，普通用户可以打开工单，但只有管理员用户可以关闭工单。
- en: In the next chapter, we will create a geolocated blogging application and we
    will learn how to scale our apps more with a centralized state solution and how
    to integrate third-party libraries to extend the features of Vue.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个地理定位的博客应用程序，并学习如何通过集中式状态解决方案扩展我们的应用程序，并集成第三方库以扩展Vue的功能。
