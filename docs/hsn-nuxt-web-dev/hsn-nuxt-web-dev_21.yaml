- en: Creating an SPA with Nuxt
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nuxt创建SPA
- en: In the previous chapters, we created a variety of Nuxt apps in `universal` mode.
    These were universal server-side rendered (SSR) apps. This means they are apps
    that run on both the server and client sides. Nuxt gives us another option for
    developing **single-page apps** (**SPA**), just like we can do with Vue and other
    SPA frameworks, such as Angular and React. In this chapter, we're going to guide
    you through how to develop, build, and deploy an SPA in Nuxt and see what makes
    it differ from the traditional SPAs that are available.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们创建了各种Nuxt应用程序，以`universal`模式。这些是通用服务器端渲染（SSR）应用程序。这意味着它们是在服务器端和客户端上运行的应用程序。Nuxt为我们提供了另一种开发**单页面应用程序**（**SPA**）的选项，就像我们可以使用Vue和其他SPA框架（如Angular和React）一样。在本章中，我们将指导您如何在Nuxt中开发、构建和部署SPA，并了解它与现有的传统SPA有何不同。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Understanding classic SPAs and Nuxt SPAs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解经典SPA和Nuxt SPA
- en: Installing a Nuxt SPA
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Nuxt SPA
- en: Developing a Nuxt SPA
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发Nuxt SPA
- en: Deploying a Nuxt SPA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署Nuxt SPA
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Understanding classic SPAs and Nuxt SPAs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解经典SPA和Nuxt SPA
- en: An SPA, also referred to as a classic SPA, is an app that loads once on a browser
    and does not require us to reload and re-render the page throughout the life of
    the app. This differs from multiple-page applications (MPAs) in which every change
    and every data exchange with the server requires that we rerender the entire page
    anew, from the server to the browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SPA，也称为经典SPA，是一种应用程序，它在浏览器上加载一次，不需要我们在应用程序的整个生命周期内重新加载和重新渲染页面。这与多页面应用程序（MPA）不同，在多页面应用程序中，每次更改和与服务器的每次数据交换都需要我们重新从服务器到浏览器重新渲染整个页面。
- en: 'In a classic/traditional SPA, the HTML that''s served to the client is relatively
    empty. JavaScript will dynamically render the HTML and content once it gets to
    the client. React, Angular, and Vue are popular choices for creating classic SPAs.
    However, don''t get confused with the Nuxt app in spa mode (let''s called it **Nuxt
    SPA**), even though Nuxt offers you the option to develop an "SPA" with just one
    line of configuration, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典/传统的SPA中，提供给客户端的HTML相对为空。一旦到达客户端，JavaScript将动态渲染HTML和内容。React、Angular和Vue是创建经典SPA的流行选择。然而，不要与spa模式的Nuxt应用程序混淆（让我们称之为**Nuxt
    SPA**），尽管Nuxt为您提供了使用一行配置开发“SPA”的选项，如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Nuxt's SPA mode simply means that you lose the server-side features of Nuxt
    and Node.js, as we learned in [Chapter 14](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml), *Using
    Linters, Formatters, and Deployment Commands*, on turning a universal SSR Nuxt
    app into a static-generated (pre-rendered) Nuxt app. The same goes for the spa-mode
    Nuxt app – when you use the preceding configuration, your spa-mode Nuxt app will
    become a purely **client-side app**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt的SPA模式简单地意味着您失去了Nuxt和Node.js的服务器端特性，就像我们在[第14章](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml)中学到的，在将通用SSR
    Nuxt应用程序转换为静态生成（预渲染）Nuxt应用程序时，使用了代码检查器、格式化程序和部署命令。对于spa模式的Nuxt应用程序也是一样-当您使用上述配置时，您的spa模式Nuxt应用程序将成为纯粹的**客户端应用程序**。
- en: 'But the spa-mode Nuxt app is quite different from the classic SPA that you
    create from the Vue CLI, React, or Angular. This is because, after building the
    app, the pages and routes of your (classic) SPA will be dynamically rendered by
    JavaScript at runtime. On the other hand, the pages in a spa-mode Nuxt app will
    be pre-rendered during build time, and the HTML in each page is as "empty" as
    the classic SPA. This is where things start to get confusing. Let''s take a look
    at the following examples. Let''s say you have the following pages and routes
    in your Vue app:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，spa模式Nuxt应用程序与您从Vue CLI、React或Angular创建的经典SPA有很大不同。这是因为构建应用程序后，您（经典）SPA的页面和路由将在运行时由JavaScript动态呈现。另一方面，spa模式Nuxt应用程序中的页面将在构建时进行预渲染，并且每个页面中的HTML与经典SPA一样“空”。这就是事情开始变得混乱的地方。让我们看看以下示例。假设您的Vue应用程序中有以下页面和路由：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Your app will be built into the following distribution:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序将构建到以下分发中：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, you can see that only the `index.html`, `/css/`, and `/js/` folders are
    built into the `/dust/` folder. This means that the pages and routes of your app
    will be dynamically rendered by JavaScript at runtime. However, let''s say you
    have the following pages in your spa-mode Nuxt app:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到只有`index.html`、`/css/`和`/js/`文件夹构建到`/dust/`文件夹中。这意味着您的应用程序的页面和路由将在运行时由JavaScript动态呈现。然而，假设您的spa模式Nuxt应用程序中有以下页面：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Your app will be built into the following distribution:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序将构建到以下分发中：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, every page and route of your app is built with an `index.html` file
    and placed in the `/dust/` folder – just like the static site that you generate
    for a universal SSR Nuxt app. So, here, we can say that the spa-mode Nuxt app you
    will build and deploy is a "static" SPA, as opposed to the classic SPA, which
    is "dynamic". Of course, you can still deploy your spa-mode Nuxt app as if it
    were a universal SSR Nuxt app using the following deployment commands. This will
    make it "dynamic" at runtime:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，您应用程序的每个页面和路由都是使用`index.html`文件构建并放置在`/dust/`文件夹中 - 就像您为通用SSR Nuxt应用程序生成的静态站点一样。因此，在这里，我们可以说您将构建和部署的spa模式Nuxt应用程序是一个“静态”SPA，而不是经典的“动态”SPA。当然，您仍然可以使用以下部署命令将您的spa模式Nuxt应用程序部署为通用SSR
    Nuxt应用程序。这将使其在运行时变得“动态”：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But deploying a Nuxt SPA app on a Node.js host can be overkill because there
    must be some good reasons for you to go for a spa-mode Nuxt app and don't want
    to use a Node.js host for your SPAs. Hence, **pre-rendering** the Nuxt SPA into
    a static-generated app (let's call it a **static-generated Nuxt SPA**) is probably
    more sensible. You can pre-render your Nuxt SPA with the `nuxt export` command
    easily, just like the universal SSR Nuxt app.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在Node.js主机上部署Nuxt SPA应用可能会过度，因为您选择spa模式Nuxt应用程序并且不想为您的SPA使用Node.js主机，必须有一些充分的理由。因此，将Nuxt
    SPA**预渲染**为静态生成的应用程序（让我们称之为**静态生成的Nuxt SPA**）可能更合理。您可以像通用SSR Nuxt应用程序一样轻松地使用`nuxt
    export`命令预渲染您的Nuxt SPA。
- en: 'This is what this chapter is all about: developing a Nuxt app in spa mode and
    generating the required static HTML files before deploying them to a static hosting
    server such as GitHub Pages. So, let''s get started by installing and setting
    up the environment.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章的全部内容：在spa模式下开发Nuxt应用程序，并在部署到静态托管服务器（如GitHub Pages）之前生成所需的静态HTML文件。因此，让我们开始安装和设置环境。
- en: Installing a Nuxt SPA
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Nuxt SPA
- en: 'Installing a Nuxt SPA is the same as installing Nuxt universal SSR using the
    `create-nuxt-app` scaffolding tool. Let''s get started:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Nuxt SPA与使用`create-nuxt-app`脚手架工具安装Nuxt通用SSR相同。让我们开始吧：
- en: 'Install a Nuxt project via your terminal using the Nuxt scaffolding tool:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过终端使用Nuxt脚手架工具安装Nuxt项目：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Answer the questions that appear and pick the **Single Page App** option when
    asked for the **Rendering mode**:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回答出现的问题，并在要求**渲染模式**时选择**单页面应用**选项：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After the installation is completed, if you inspect the Nuxt config file in
    your project''s root directory, you should see that the `mode` option was configured
    as an SPA for you during the installation process:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，如果您检查项目根目录中的Nuxt配置文件，您应该会看到在安装过程中已经为您配置了`mode`选项为SPA：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Start Nuxt development mode in your terminal:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中启动Nuxt开发模式：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see that **only** the code on the client-side is compiled on your
    terminal:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到您的终端上**只有**客户端端的代码被编译：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will no longer see any code compiled on the server-side that you would
    normally see for the Nuxt app in `universal` mode:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您将不再看到在服务器端编译的代码，这是您通常在`universal`模式下看到的Nuxt应用程序的代码：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, it is rather easy to get the spa-mode environment started in
    Nuxt. You can also set up this spa-mode **manually** just by adding the `spa` value
    to the `mode` option in the Nuxt config file. Now, let's develop a Nuxt SPA.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在Nuxt中很容易启动spa模式环境。您也可以通过在Nuxt配置文件中的`mode`选项中添加`spa`值来**手动**设置spa模式。现在，让我们开发一个Nuxt
    SPA。
- en: Developing a Nuxt SPA
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发Nuxt SPA
- en: 'One major important thing to bear in mind when developing a Nuxt SPA is the
    Nuxt context that''s given to the `asyncData` and `fetch` methods, will lose their `req`
    and `res` objects because these objects are Node.js HTTP objects. In this section,
    we''ll create a simple user login authentication, which you should already be
    familiar with. However, this time, we will make it in the Nuxt SPA. We will also
    create a page for listing users using dynamic routes, as we learned about in [Chapter
    4](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml),  *Adding Views, Routes, and Transitions*.
    Let''s get started:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Nuxt SPA时需要牢记的一个重要事项是，给予`asyncData`和`fetch`方法的Nuxt上下文将失去它们的`req`和`res`对象，因为这些对象是Node.js
    HTTP对象。在本节中，我们将创建一个简单的用户登录身份验证，您应该已经熟悉。但是，这一次，我们将在Nuxt SPA中进行。我们还将创建一个用于使用动态路由列出用户的页面，就像我们在[第4章](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml)中学到的那样，*添加视图、路由和过渡*。让我们开始吧：
- en: 'Prepare the following `.vue` files or just make a copy from the previous chapter,
    as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备以下`.vue`文件，或者只需从上一章中复制，如下所示：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Prepare the Vuex store with the store state, mutations, actions, and the index
    file for handling user login authentication, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备具有存储状态、突变、动作和处理用户登录身份验证的索引文件的Vuex存储，如下所示：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we mentioned in the previous chapter, we will lose the `nuxtServerInit` action
    in the store when we generate the Nuxt Universal SSR app **statically**, so it
    is the same in the Nuxt SPA – we will not have this server action on the client-side.
    Thus, we will need a client-side `nuxtServerInit` action to imitate the server-side
    `nuxtServerInit` action. We'll learn how to do this next.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中提到，当我们**静态**生成Nuxt通用SSR应用程序时，存储中的`nuxtServerInit`动作将会丢失，因此在Nuxt SPA中也是一样的-我们在客户端不会有这个服务器动作。因此，我们需要一个客户端`nuxtServerInit`动作来模拟服务器端的`nuxtServerInit`动作。我们接下来将学习如何做到这一点。
- en: Creating the client-side nuxtServerInit action
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建客户端nuxtServerInit动作
- en: 'The methods and properties in these files are the same as those we had in past
    exercises, except for the `nuxtServerInit` action:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件中的方法和属性与我们在过去的练习中所拥有的方法和属性相同，除了`nuxtServerInit`动作：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There is no server involved in the Nuxt SPA since `nuxtServerInit` is called
    by Nuxt from the server-side only. So, we will need a solution for that. We can
    use the Node.js `js-cookie` module to store the authenticated data on the client-side
    when the user logs in, which makes it the best candidate to replace the server-side
    cookie. Let''s learn how to achieve this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nuxt SPA中，没有涉及服务器，因为`nuxtServerInit`只能由Nuxt从服务器端调用。因此，我们需要一个解决方案。我们可以使用Node.js的`js-cookie`模块在用户登录时在客户端存储经过身份验证的数据，这使其成为替代服务器端cookie的最佳选择。让我们学习如何实现这一点：
- en: 'Install the Node.js `js-cookie` module via npm:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm安装Node.js的`js-cookie`模块：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a custom method called `nuxtClientInit` (you can choose any name you
    like if you wish) in the store actions to retrieve the user data in the cookie.
    Then, set it back to the desired state for the specified situation when the user
    refreshes the browser:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储操作中创建一个名为`nuxtClientInit`（如果愿意，也可以选择其他名称）的自定义方法，以从cookie中检索用户数据。然后，在用户刷新浏览器时将其设置回所需的状态。
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you may recall, the store `nuxtServerInit` action is always called on the
    server-side when refreshing the page. The same happens with this `nuxtClientInit`
    method; it should be called every time on the client-side when refreshing the
    page. However, it won't be called **automatically**, so we can use a plugin to
    call it each time **before** the Vue root is initiated.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能记得的那样，在刷新页面时，商店的`nuxtServerInit`动作总是在服务器端调用。`nuxtClientInit`方法也是如此；每次在客户端刷新页面时都应该被调用。然而，它不会被**自动**调用，因此我们可以使用插件在Vue根实例初始化之前每次调用它。
- en: 'Create a plugin called `nuxt-client-init.js` in the `/plugins/` directory that
    will call the `nuxtClientInit` method through the `dispatch` method in the store:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/plugins/`目录中创建一个名为`nuxt-client-init.js`的插件，该插件将通过存储中的`dispatch`方法调用`nuxtClientInit`方法：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that we can access the Nuxt context in plugins before the Vue root
    is initiated. The store is added to the Nuxt context, so, we can access the store
    actions and the `nuxtClientInit` method is what we are interested in here.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在Vue根实例初始化之前，我们可以在插件中访问Nuxt上下文。存储被添加到Nuxt上下文中，因此我们可以访问存储操作，而这里我们感兴趣的是`nuxtClientInit`方法。
- en: 'Now, add this plugin to the Nuxt config file in order to install the plugin:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将此插件添加到Nuxt配置文件中以安装该插件：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, every time you refresh the browser, the `nuxtClientInit` method will be
    called and the state will be repopulated by this method before the Vue root is
    initiated. As you can see, it isn't straightforward to imitate the `nuxtClientInit`
    action when we lose the full power of Nuxt as a universal JavasScript app. But
    if you must go for a Nuxt SPA, then this issue can be resolved with the `nuxtClientInit`
    method we just created.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次刷新浏览器时，`nuxtClientInit`方法都将被调用，并且在Vue根实例初始化之前，状态将被此方法重新填充。正如您所看到的，当我们失去Nuxt作为通用JavaScript应用程序的全部功能时，模仿`nuxtClientInit`动作并不是一件简单的事情。但是，如果您必须选择Nuxt
    SPA，那么我们刚刚创建的`nuxtClientInit`方法可以解决这个问题。
- en: Next, we will create some custom Axios instances using Nuxt plugins. This should
    be something that you are quite familiar with already. However, being able to
    create custom Axios instances is useful because you can always fall back to the
    **vanilla** version of Axios when you need to, even though we have the **Nuxt
    Axios module** as well. So, let's move on!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用Nuxt插件创建一些自定义的Axios实例。这应该是您已经非常熟悉的内容。然而，能够创建自定义的Axios实例是有用的，因为当需要时，您总是可以回退到**原始**版本的Axios，即使我们也有**Nuxt
    Axios模块**。所以，让我们继续！
- en: Creating multiple custom Axios instances with plugins
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用插件创建多个自定义的Axios实例
- en: 'In this spa-mode exercise, we will need two Axios instances to make API calls
    to the following addresses:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个spa模式的练习中，我们将需要两个Axios实例来对以下地址进行API调用：
- en: '`localhost:4000` for user authentication'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:4000`用于用户认证'
- en: '`jsonplaceholder.typicode.com` for fetching users'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonplaceholder.typicode.com`用于获取用户'
- en: 'We will use the vanilla Axios ([https://github.com/axios/axios](https://github.com/axios/axios))
    as it gives us the flexibility to create multiple instances of Axios with some
    custom configurations. Let''s get started:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用原始的Axios ([https://github.com/axios/axios](https://github.com/axios/axios))，因为它给了我们灵活性来创建带有一些自定义配置的多个Axios实例。让我们开始吧：
- en: 'Install the vanilla `axios` via npm:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm安装原始的`axios`：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create an `axios` instance on the page you need it:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要的页面上创建一个`axios`实例：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But creating the `axios` instance directly on a page is not ideal. Ideally,
    we should be able to extract this instance and reuse it anywhere. Through the
    Nuxt plugin, we can create the Axios extracted instance. There are two methods
    we can follow to create them. We'll look at the first method in the next section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但直接在页面上创建`axios`实例并不理想。理想情况下，我们应该能够提取这个实例并在任何地方重用它。通过Nuxt插件，我们可以创建提取的Axios实例。我们可以遵循两种方法来创建它们。我们将在下一节中看一下第一种方法。
- en: Installing the custom Axios plugin in the Nuxt config file
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件中安装自定义的Axios插件
- en: 'In previous chapters, you learned that we can create a plugin with the `inject`
    method and install the plugin through the Nuxt `config` file. Besides using the
    `inject` method, it is worth knowing that we can also inject a plugin **directly** into
    the Nuxt context. Let''s take a look at how to do this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，你学会了我们可以使用`inject`方法创建一个插件，并通过Nuxt的`config`文件安装插件。除了使用`inject`方法，值得知道的是我们也可以**直接**将插件注入到Nuxt上下文中。让我们看看如何做到这一点：
- en: 'Create an `axios-typicode.js` file in the `/plugins/` directory, import the
    vanilla `axios`, and create the instance, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/plugins/`目录下创建一个`axios-typicode.js`文件，导入原始的`axios`，并创建实例，如下所示：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, after creating the `axios` instance, we inject the plugin through
    the Nuxt context (`ctx`), use the `inject` method, and then export it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在创建了`axios`实例之后，我们通过Nuxt上下文(`ctx`)注入了插件，使用了`inject`方法，然后导出它。
- en: 'Install this plugin in the Nuxt config file:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件中安装这个插件：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You must set the `mode` option to `client` because we **only** need it on the
    client-side.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将`mode`选项设置为`client`，因为我们**只**需要它在客户端。
- en: 'You can access this plugin from anywhere you like. In this example, we want
    to use this plugin on the user index page to fetch the list of users:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在任何你喜欢的地方访问这个插件。在这个例子中，我们想在用户索引页面上使用这个插件来获取用户列表：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this plugin, we injected the custom `axios` instance into the Nuxt context
    (`ctx`) directly as `$axiosTypicode` so that we can call it directly by using
    the JavaScript destructuring assignment syntax to unpack it as `$axiosTypicode`.
    We also injected the plugin using the `inject` method, so we also call this plugin
    by using `ctx.app`, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个插件中，我们将自定义的`axios`实例直接注入到Nuxt上下文(`ctx`)中，命名为`$axiosTypicode`，这样我们可以使用JavaScript解构赋值语法直接调用它作为`$axiosTypicode`。我们还使用`inject`方法注入了插件，所以我们也可以通过`ctx.app`来调用这个插件，如下所示：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It isn't too hard to create a custom Axios plugin, is it? If you install the
    plugin through the Nuxt config file, this means it is a global JavaScript function
    and that you can access it from anywhere. But if you don't want to install it
    as a global plugin, you can skip installing it in the Nuxt config file. This brings
    us to the second method of creating a Nuxt plugin.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义的Axios插件并不太难，是吗？如果你通过Nuxt配置文件安装插件，这意味着它是一个全局的JavaScript函数，你可以从任何地方访问它。但如果你不想将它安装为全局插件，你可以跳过在Nuxt配置文件中安装它。这就引出了创建Nuxt插件的第二种方法。
- en: Importing the custom Axios plugin manually
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动导入自定义的Axios插件
- en: 'Another method of creating the custom Axios instance does not involve the Nuxt
    config at all. We can just export the custom instance as a regular JavaScript
    function and then import it directly into the page where we need it. Let''s take
    a look at how to do this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义Axios实例的另一种方法根本不涉及Nuxt配置。我们可以将自定义实例导出为常规的JavaScript函数，然后直接在需要它的页面中导入。让我们看看如何做到这一点：
- en: 'Create an `axios-api.js` file in the `/plugins/` directory, import the vanilla
    `axios`, and create the instance, as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/plugins/`目录中创建一个`axios-api.js`文件，导入原始的`axios`，并创建实例，如下所示：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we're no longer using the `inject` method; instead, we export
    the instance directly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不再使用`inject`方法；相反，我们直接导出实例。
- en: 'Now, we can import it manually when we need it. In this example, we need it
    in the `login` action method, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在需要时手动导入它。在这个例子中，我们需要在`login`动作方法中使用它，如下所示：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we must import this plugin **manually** because it is not plugged
    into the Nuxt lifecycle.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们必须**手动**导入此插件，因为它没有插入到Nuxt生命周期中。
- en: 'Import it and set the `Authorization` header on this `axios` instance in the `token`
    middleware, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入它并在`token`中间件中设置`Authorization`头部，如下所示：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Even though we have to import the plugin manually when following this method,
    at least we have extracted the following setting into a plugin that we can reuse
    wherever it is needed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在遵循这种方法时我们必须手动导入插件，但至少我们已经将以下设置提取到了一个可以在需要时重用的插件中：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can find the code for the Nuxt SPA, along with these two methods, in `/chapter-15/frontend/`
    in this book's GitHub repository.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库的`/chapter-15/frontend/`中找到Nuxt SPA的代码以及这两种方法。
- en: Once you have created, tested, and linted all the code and files, you are ready
    to deploy the Nuxt SPA. So, let's get to it!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建、测试和lint所有代码和文件，您就可以准备部署Nuxt SPA了。所以，让我们开始吧！
- en: Deploying a Nuxt SPA
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Nuxt SPA
- en: 'We can deploy a Nuxt SPA just like we can deploy universal SSR Nuxt apps if
    we have a Node.js runtime server. If we don''t, then we can only deploy the SPA
    as a static site to a static hosting server such as **GitHub Pages**. You can
    deploy a static-generated Nuxt SPA as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个Node.js运行时服务器，我们可以像部署通用SSR Nuxt应用程序一样部署Nuxt SPA。如果没有，那么我们只能将SPA部署为静态站点到静态托管服务器，比如GitHub
    Pages。您可以按照以下步骤部署静态生成的Nuxt SPA：
- en: 'Make sure that you have set the value to `spa` in the `mode` option in the
    Nuxt config file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在Nuxt配置文件的`mode`选项中将值设置为`spa`：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Make sure you have the following run scripts in the `package.json` file as
    well:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`package.json`文件中有以下运行脚本：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run `npm run generate`, just like you would for the universal SSR Nuxt app.
    You should see the following output in the terminal:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm run generate`，就像您为通用SSR Nuxt应用程序一样。您应该在终端中看到以下输出：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding output, if you navigate to the `/dist/` folder inside the project,
    you will find an `index.html` file at the root, as well as `index.html` files
    in each subfolder, along with the route name. However, you will not find any of
    these pages in the dynamic routes that were generated, such as `/users/1`. This
    is because dynamic routes are not generated in spa-mode, as opposed to universal
    mode.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，如果您导航到项目内的`/dist/`文件夹，您将在根目录找到一个`index.html`文件，以及在每个子文件夹中找到带有路由名称的`index.html`文件。但是，您将在生成的动态路由中找不到任何页面，比如`/users/1`。这是因为与通用模式相反，在spa模式下不会生成动态路由。
- en: Also, if you open the `index.html` file in the `/dist/` folder, you will find all
    the `index.html` files are exactly the same – just some "empty" HTML elements,
    similar to the classic SPA. Furthermore, each `index.html` file does not contain
    its individual meta information, only the common ones from `nuxt.config.js`. The
    meta information of these pages will be hydrated (filled and updated) at runtime.
    Due to this, it may seem counter-intuitive and "half-baked" for a "static" SPA.
    On top of that, no static payload is generated. This means that if you navigate
    to `localhost:3000/users` on your browser, you will notice that this page is still
    requesting its data from [https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)
    instead of fetching the data from the payload like the universal SSR Nuxt app
    does. This is because Nuxt does not generate the static content in spa mode, even
    though you have set `static` for the target property in the Nuxt config file. To
    overcome these issues, we can generate the static content we need from the universal
    mode.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您在“/dist/”文件夹中打开“index.html”文件，您会发现所有的“index.html”文件都是完全相同的-只是一些“空”的HTML元素，类似于经典的SPA。此外，每个“index.html”文件都不包含自己的元信息，只包含来自“nuxt.config.js”的公共元信息。这些页面的元信息将在运行时进行填充和更新。由于这个原因，对于“静态”SPA来说，这可能看起来有些违反直觉和“半成品”。除此之外，没有生成静态有效负载。这意味着，如果您在浏览器中导航到“localhost:3000/users”，您会注意到该页面仍然从[https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)请求其数据，而不是像通用SSR
    Nuxt应用程序那样从有效负载中获取数据。这是因为Nuxt在spa模式下不生成静态内容，即使您已经在Nuxt配置文件中为目标属性设置了“static”。为了解决这些问题，我们可以从通用模式生成我们需要的静态内容。
- en: 'Change `spa` to `universal` for the `mode` option in the Nuxt config file:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件中将“mode”选项的“spa”更改为“universal”：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run `npm run generate` so that Nuxt will make the REST API calls to the API
    to retrieve the users and export their contents to local static payloads. You
    will see the following output:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行“npm run generate”，这样Nuxt将对API进行REST API调用，以检索用户并将其内容导出到本地静态有效负载。您将看到以下输出：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that there is no dynamic routes are generated in the preceding output.
    If you navigate to the `/dist/` folder again, you should see that the `/users/`
    folder now contains multiple folders, each with the owns user ID. Each of these
    folders contains an `index.html` file that contains the contents for that specific
    user. Now, each `index.html` file contains its own individual meta information
    and payload generated in `/dist/_nuxt/static/`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的输出中没有生成动态路由。如果您再次导航到“/dist/”文件夹，您会看到“/users/”文件夹现在包含多个文件夹，每个文件夹都有自己的用户ID。每个文件夹都包含一个包含该特定用户内容的“index.html”文件。现在，每个“index.html”文件都包含自己的独立元信息和在“/dist/_nuxt/static/”中生成的有效负载。
- en: 'Change `universal` back to `spa` for the `mode` option in the Nuxt config file:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件中将“mode”选项的“universal”改回“spa”：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, run `npm run build` on your terminal. You should see the following output:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端上运行“npm run build”。您应该会看到以下输出：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Ignore the `Ready to run nuxt generate` message. Instead, test your production
    static SPA from the `/dist/` directory first with the `nuxt start` command on
    your terminal:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 忽略“准备运行nuxt generate”消息。相反，首先使用终端上的“nuxt start”命令从“/dist/”目录中测试您的生产静态SPA：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You should get the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下输出：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, routes such as `localhost:3000/users` will no longer request their data
    from [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
    Instead, they will fetch the data from the payload in the `/static/` folder, which
    can be found inside the `/dist/` folder.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，诸如“localhost:3000/users”之类的路由将不再从[https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)请求其数据。相反，它们将从“/dist/”文件夹中的有效负载中获取数据，该文件夹位于“/static/”文件夹内。
- en: Finally, just deploy this `/dist/` directory only to your static hosting server.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，只需将`/dist/`目录部署到您的静态托管服务器。
- en: 'If you are looking for a free static hosting server, consider using GitHub
    Pages. Using this, you can have a domain name for your site in the following format:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找免费的静态托管服务器，请考虑使用GitHub Pages。使用此功能，您可以为您的站点获得以下格式的域名：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: GitHub also allows you to serve your site with a custom domain name rather than
    using theirs. For more information, follow the guide from the GitHub Help site: [https://help.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site](https://help.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site).
    However, in this book, we will show you how to serve your site on the GitHub's
    `github.io` domain name. We'll learn how to do this in the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub还允许您使用自定义域名而不是使用他们的域名来提供站点。有关更多信息，请参阅GitHub帮助网站的指南：[https://help.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site](https://help.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site)。但是，在本书中，我们将向您展示如何在GitHub的`github.io`域名上提供站点。我们将在下一节中学习如何做到这一点。
- en: You can find the code for this section in `/chapter-15/frontend/` in this book's
    GitHub repository.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-15/frontend/`中找到此部分的代码。
- en: Deploying to GitHub Pages
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到GitHub Pages
- en: GitHub Pages is a static site hosting service from GitHub that hosts and publishes
    the static files (HTML, CSS, and JavaScript only) in your GitHub repository. You
    can get your static site hosted in GitHub Pages as long as you have a user account
    on GitHub and a GitHub repository created for your site.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Pages是GitHub提供的静态站点托管服务，用于托管和发布GitHub存储库中的静态文件（仅限HTML、CSS和JavaScript）。只要您在GitHub上拥有用户帐户并为您的站点创建了GitHub存储库，就可以在GitHub
    Pages上托管您的静态站点。
- en: Please visit [https://guides.github.com/features/pages/](https://guides.github.com/features/pages/)
    to find out how to get started with GitHub Pages.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问[https://guides.github.com/features/pages/](https://guides.github.com/features/pages/)，了解如何开始使用GitHub
    Pages。
- en: You just need to go to the **Settings** section on your GitHub repository and
    scroll down to the **GitHub Pages** section. Then, you need to click the **Choose
    a theme** button to start the process of creating your static site.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要转到GitHub存储库的**设置**部分，然后向下滚动到**GitHub Pages**部分。然后，您需要单击**选择主题**按钮，以开始创建静态站点的过程。
- en: 'Deploying the static version of your Nuxt SPA to GitHub Pages is fairly easy
    – you just need to make some minor configuration changes to the Nuxt config file
    and then use the `git push` command to upload it to your GitHub repository. When
    you create a GitHub repository and if you are creating GitHub Pages, the URL of
    the static pages, by default, will be served in the following format:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将Nuxt SPA的静态版本部署到GitHub Pages非常简单-您只需要对Nuxt配置文件进行一些微小的配置更改，然后使用`git push`命令将其上传到GitHub存储库。当您创建GitHub存储库并创建GitHub
    Pages时，默认情况下，静态页面的URL将以以下格式提供：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So, you will need to add this `<repository-name>` to the `router` base option
    in the Nuxt config file, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要将此`<repository-name>`添加到Nuxt配置文件中`router`基本选项，如下所示：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'But changing the base name will interfere with `localhost:3000` when developing
    the Nuxt app. Let''s learn how to resolve this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但是更改基本名称将干扰Nuxt应用程序的开发时的`localhost:3000`。让我们学习如何解决这个问题：
- en: 'Create an `if` condition for the development and production GitHub Pages in
    the Nuxt config file, as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件中为开发和生产GitHub Pages创建一个`if`条件，如下所示：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This condition simply adds `/<repository-name>/` to the `base` key of the `router`
    option if the `DEPLOY_ENV` option has `GH_PAGES` in the process environment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在进程环境中`DEPLOY_ENV`选项具有`GH_PAGES`，则此条件只是将`/<repository-name>/`添加到`router`选项的`base`键。
- en: 'Add this `routerBase` constant to your Nuxt configuration in the config file
    using the `spread` operator:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`spread`操作符在配置文件中的Nuxt配置中添加`routerBase`常量：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Set the `DEPLOY_ENV=''GH_PAGES''` scripts in the `package.json` file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`文件中设置`DEPLOY_ENV='GH_PAGES'`脚本：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using one of these two npm scripts, the value of `/<repository-name>/` won't
    be injected into your Nuxt configuration and interfere with the dev process when
    running `npm run dev` for development.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个npm脚本中的一个，`/<repository-name>/`的值不会被注入到你的Nuxt配置中，并且在运行`npm run dev`进行开发时不会干扰开发过程。
- en: 'Change `spa` to `universal` for the `mode` option in the Nuxt config file,
    just as in *step 4* in the previous section, to generate the static payloads and
    pages with the `nuxt generate` command:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件中，将`mode`选项更改为`universal`，就像在上一节的*步骤4*中一样，使用`nuxt generate`命令生成静态负载和页面：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Change `universal` back to `spa` for the `mode` option in the Nuxt config file,
    just as in *step 6* in the previous section, to build the SPA with the `nuxt build`
    command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Nuxt配置文件中的`mode`选项从`universal`改回`spa`，就像在上一节的*步骤6*中一样，使用`nuxt build`命令构建SPA：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Push the files in the `/dist/` folder that were generated by Nuxt to GitHub
    Pages through your GitHub repository.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过你的GitHub仓库将Nuxt生成的`/dist/`文件夹中的文件推送到GitHub Pages。
- en: That's it for deploying a Nuxt SPA to GitHub Pages. However, make sure you have
    an `empty .nojekyll` file included in the `/dist/` folder when pushing your static
    site to GitHub Pages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 部署Nuxt SPA到GitHub Pages就是这样。但是，在将静态站点推送到GitHub Pages时，请确保在`/dist/`文件夹中包含一个`empty
    .nojekyll`文件。
- en: Jekyll is a simple, blog-aware, static site generator. It transforms plain text
    into static websites and blogs. GitHub Pages is powered by Jekyll behind the scenes
    and, by default, it does not build any files or directories that start with a
    dot ".", or an underscore "_", or end with a tilde "~". This will be a problem
    when serving the static site in GitHub Pages because a subfolder called `_nuxt`
    is also generated inside the `/dist/` folder when building the Nuxt SPA; this
    `/_nuxt/` folder will be ignored by Jekyll. To fix this, we need to include an
    empty `.nojekyll` file in the `/dist/` folder to turn off Jekyll. This file is
    generated when we build the static pages for the Nuxt SPA, so make sure to push
    it to your GitHub repository as well.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Jekyll是一个简单的、博客感知的静态站点生成器。它将纯文本转换为静态网站和博客。GitHub Pages在幕后由Jekyll提供支持，默认情况下不会构建任何以点“.”、下划线“_”开头或以波浪符“~”结尾的文件或目录。这在为GitHub
    Pages提供静态站点时会成为问题，因为在构建Nuxt SPA时，`/_nuxt/`文件夹也会在`/dist/`文件夹内生成；Jekyll会忽略这个`/_nuxt/`文件夹。为了解决这个问题，我们需要在`/dist/`文件夹中包含一个空的`.nojekyll`文件来关闭Jekyll。当我们为Nuxt
    SPA构建静态页面时，会生成这个文件，所以确保将它推送到你的GitHub仓库中。
- en: Well done – you have made it through another short chapter of this book! Nuxt
    SPAs are a great option if you want to build an SPA in Nuxt instead of using Vue
    or other frameworks such as Angular and React. However, if you are offering web
    services such as social media sites that require immediate or real-time publications,
    a static-generated Nuxt SPA probably isn't a good choice. It all depends on the
    nature of your business and whether you want to go for the full power of Nuxt,
    the universal SSR, or the client-side only version of Nuxt - Nuxt SPA. Next, we'll
    summarize what we have learned in this chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好 - 你已经完成了本书的另一短章节！如果你想在Nuxt中构建SPA而不是使用Vue或其他框架（如Angular和React），Nuxt SPA是一个很好的选择。但是，如果你提供需要立即或实时发布的社交媒体等网络服务，静态生成的Nuxt
    SPA可能不是一个好选择。这完全取决于你的业务性质，以及你是想要充分利用Nuxt的全能SSR，还是只想使用Nuxt的客户端版本 - Nuxt SPA。接下来，我们将总结本章学到的内容。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to develop, build, and deploy an SPA in
    Nuxt and see what makes it different from a classic SPA. We also learned that
    Nuxt SPAs can be a good option for developing apps, but developing a Nuxt SPA
    means that we will lose the `nuxtServerInit` action and the `req` and `res` HTTP
    objects. However, we can use the client-side `js-cookies` (or `localStorage)`
    and the Nuxt plugin to imitate the `nuxtServerInit` action. Last but not least,
    we learned how to publish and serve the static-generated Nuxt SPA on GitHub Pages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Nuxt中开发、构建和部署SPA，并了解了它与经典SPA的区别。我们还了解到，Nuxt SPA可以是开发应用程序的一个很好选择，但是开发Nuxt
    SPA意味着我们将失去`nuxtServerInit`动作和`req`和`res` HTTP对象。然而，我们可以使用客户端的`js-cookies`（或`localStorage`）和Nuxt插件来模拟`nuxtServerInit`动作。最后但并非最不重要的是，我们学习了如何在GitHub
    Pages上发布和提供静态生成的Nuxt SPA。
- en: So far in this book, we have only been using JavaScript for all our Nuxt apps
    and APIs. However, in the coming chapters, we will explore how we can take Nuxt
    further so that we can work with another language, **PHP**. We will walk you through
    the HTTP messages and PHP standards, writing CRUD operations with PHP database
    frameworks, and serving a PHP API for the Nuxt app. Read on!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们一直在为所有Nuxt应用程序和API使用JavaScript。然而，在接下来的章节中，我们将探讨如何进一步使用Nuxt，以便我们可以使用另一种语言**PHP**。我们将带领您了解HTTP消息和PHP标准，使用PHP数据库框架编写CRUD操作，并为Nuxt应用程序提供PHP
    API。敬请期待！
