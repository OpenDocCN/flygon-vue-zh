- en: Adding Vue Forms
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 添加Vue表单
- en: In this chapter, you will create forms with `v-model` and `v-bind`. You will
    learn to validate forms on the client side before sending the form data to the
    server. You will create forms with basic elements, binding dynamic values and
    using modifiers to modify the input element's behavior. You will also learn to
    use the `vee-validate` plugin for validating forms and applying it to Nuxt apps. It
    is important to learn and understand how to use `v-model` and `v-bind` with Vue
    forms in this chapter because we will use forms in the coming chapters, such as
    in [Chapter 10](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml), *Adding a Vuex Store*,
    and [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml), *Creating User Logins
    and API Authentication*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用`v-model`和`v-bind`创建表单。您将学习在将表单数据发送到服务器之前在客户端验证表单。您将创建具有基本元素的表单，绑定动态值，并使用修饰符修改输入元素的行为。您还将学习如何使用`vee-validate`插件验证表单并将其应用于Nuxt应用程序。在本章中学习如何在Vue表单中使用`v-model`和`v-bind`非常重要，因为我们将在接下来的章节中使用表单，例如在“添加Vuex存储”第10章和“创建用户登录和API身份验证”第12章中。
- en: 'The topics we will cover in this chapter are the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将涵盖以下主题：
- en: Understanding `v-model`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`v-model`
- en: Validating forms with basic data bindings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本数据绑定验证表单
- en: Making dynamic value bindings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态值绑定
- en: Validating forms with `vee-validate`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`vee-validate`验证表单
- en: Applying Vue forms in Nuxt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Nuxt中应用Vue表单
- en: Understanding v-model
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`v-model`
- en: '`v-model` is a Vue directive (a custom built-in Vue HTML attribute) that allows
    us to create a two-way binding on the form''s `input`, `textarea`, and `select`
    elements. You can bind a form input with the Vue data so that the data can be
    updated when the users interact with the input field. `v-model` will always skip
    the initial value you set on the form elements but treats the Vue data as the
    source of truth. So you should declare the initial value on the Vue side, inside
    the `data` option or function.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-model`是Vue指令（自定义内置Vue HTML属性），允许我们在表单的`input`、`textarea`和`select`元素上创建双向绑定。您可以将表单输入与Vue数据绑定，以便在用户与输入字段交互时更新数据。`v-model`始终会跳过您在表单元素上设置的初始值，而将Vue数据视为真相的来源。因此，您应该在Vue端，在`data`选项或函数内声明初始值。'
- en: '`v-model` will pick the appropriate way to update the element based on the
    input type, which means that if you use it on the form input with `type="text"`,
    it will use `value` as the property and `input` as the event to perform the two-way
    binding for you. Let''s look at what falls under this directive in the coming
    sections.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-model`将根据输入类型选择适当的方式来更新元素，这意味着如果您在`type="text"`的表单输入上使用它，它将使用`value`作为属性，并使用`input`作为事件来执行双向绑定。让我们看看在接下来的部分中包括哪些内容。'
- en: Using v-model in text and textarea elements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文本和文本区域元素中使用v-model
- en: 'Remember the two-way binding that we implemented with `v-model` to create custom
    input components in [Chapter 5](099c1dc8-8dfa-46f8-bfbd-bfa036eefbb7.xhtml), *Adding
    Vue Components*? In the *Creating custom input components* section of that chapter,
    we learned that the `v-model` syntax for inputs – `<input v-model="username">` –
    is shorthand for the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在《添加Vue组件》的第5章中使用`v-model`实现双向绑定来创建自定义输入组件吗？在该章节的“创建自定义输入组件”部分，我们学到了输入框的`v-model`语法
    - `<input v-model="username">` - 实际上是以下内容的简写：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This text `input` element, behind the scene, binds the `value` attribute that
    gets the value from a handler, `username`, which gets its value from the `input`
    event. And so, a custom text input component, too, must always use the `value`
    prop and the `input` event in the `model` property as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文本`input`元素在幕后绑定了`value`属性，该属性从处理程序`username`中获取值，而`username`又从`input`事件中获取值。因此，自定义的文本输入组件也必须始终在`model`属性中使用`value`属性和`input`事件，如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is just because of the nature of a `v-model` input being made of `v-bind:value`
    and `v-on:input`. This is also the same when using the `v-model` directive in
    a `textarea` element, as in the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是因为`v-model`输入的性质是由`v-bind:value`和`v-on:input`组成。当在`textarea`元素中使用`v-model`指令时，情况也是一样的，如下例所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This `v-model` `textarea` element is shorthand for the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`v-model` `textarea`元素是以下内容的简写：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This `textarea` input element, behind the scene, binds the `value` attribute
    that gets the value from the handler, `message`, which gets its value from the
    `input` event. And so, a custom `textarea` component, too, must always comply
    with the nature of the `v-model` `textarea` element by using the `value` prop
    and the `input` event in the `model` property as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`textarea`输入元素在幕后绑定了`value`属性，该属性从处理程序`message`中获取值，而`message`又从`input`事件中获取值。因此，自定义的`textarea`组件也必须始终遵守`v-model`
    `textarea`元素的性质，通过使用`value`属性和`input`事件在`model`属性中，如下所示：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In short, the `v-model` text `input` element and the `v-model` `textarea` input
    element always bind the `value` attribute with a handler for getting the new value
    on the input event, and so must the custom input components by adopting the same
    attribute and event. What about `v-model` in checkboxes and radio buttons elements
    then? Let's dive into them in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`v-model`文本`input`元素和`v-model` `textarea`输入元素始终将`value`属性与处理程序绑定，以在输入事件上获取新值，因此自定义输入组件也必须采用相同的属性和事件。那么复选框和单选按钮元素中的`v-model`又是怎样的呢？让我们在下一节中深入了解它们。
- en: Using v-model in checkbox and radio elements
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在复选框和单选按钮元素中使用v-model
- en: 'On the other hand, `v-model` `checkbox` and `radio` button input elements always
    bind the `checked` attribute with a Boolean value that is updated on the `change`
    event, as in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`v-model`复选框和单选按钮输入元素始终将`checked`属性与在`change`事件上更新的布尔值绑定，如下例所示：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `v-model` `checkbox` input element in the preceding code snippet is indeed
    shorthand for the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，`v-model` `checkbox`输入元素确实是以下内容的简写：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And so, a custom checkbox input element, too, must always comply with the nature
    of the `v-model` checkbox input element (shown in the preceding code block) by
    adopting the `checked` prop and the `change` event in the `model` property as
    follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，自定义的复选框输入元素也必须始终遵守`v-model`复选框输入元素的性质（如前面的代码块中所示），通过在`model`属性中采用`checked`属性和`change`事件，如下所示：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The same applies to the `v-model` radio button input elements, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于`v-model`单选按钮输入元素，如下所示：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding `v-model` element is another shorthand for the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`v-model`元素是以下内容的另一种简写：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And so, a custom radio button input element, too, must always comply with the
    nature of the `v-model` element as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，自定义的单选按钮输入元素也必须始终遵守`v-model`元素的性质，如下所示：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In short, as the `v-model` `checkbox` and `radio` button input elements always
    bind the `value` attribute and are updated on the `change` event, so must the
    custom input components by adopting the same attribute and event. Now, let's take
    a look at how `v-model` works in `select` elements in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`v-model`、`checkbox` 和 `radio` 按钮输入元素总是绑定 `value` 属性，并在 `change` 事件上更新，因此自定义输入组件也必须采用相同的属性和事件。现在，让我们看看
    `v-model` 在下一节中如何在 `select` 元素中工作。
- en: Using v-model in select elements
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在选择元素中使用 v-model
- en: 'Not surprisingly, v-model `select` input elements always bind the `value` attribute
    with a handler for getting its selected value on the `change` event, as in the
    following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，`v-model` `select` 输入元素总是将 `value` 属性与在 `change` 事件上获取其选定值的处理程序绑定，如下例所示：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding `v-model` `checkbox` input element is just another shorthand
    for the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `v-model` `checkbox` 输入元素只是以下内容的另一种简写：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And so, a custom `checkbox` input element, too, must always comply with the
    nature of the `v-model` element by using the `value` prop and the `change` event
    in the `model` property as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，自定义的 `checkbox` 输入元素也必须始终遵守 `v-model` 元素的特性，使用 `value` 属性和 `model` 属性中的 `change`
    事件，如下所示：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, `v-model` is syntactic sugar on top of `v-bind`, which binds
    a value to the markup, and `v-on`, which updates data on the user input events,
    which can be either `change` or `input` events. In short, `v-model` combines `v-bind`
    and `v-on` under the hood – but it is important to understand what lies underneath
    the syntax as a Vue/Nuxt apps developer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`v-model` 在 `v-bind` 的基础上是一种语法糖，它将一个值绑定到标记上，并在用户输入事件上更新数据，这些事件可以是 `change`
    或 `input` 事件。简而言之，`v-model` 在幕后结合了 `v-bind` 和 `v-on`，但重要的是要理解语法下面的内容，作为Vue/Nuxt应用程序开发者。
- en: You can find the examples we've covered in this section in `/chapter-7/vue/html/`
    in our GitHub repository.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我们的GitHub存储库的`/chapter-7/vue/html/`目录中找到本节中涵盖的示例。
- en: Now that you have discovered how the `v-model` directive works in the form's
    input elements, let's use these `v-model` elements on a form and validate them
    in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 `v-model` 指令在表单输入元素中的工作方式，让我们在下一节中在表单上使用这些 `v-model` 元素并对其进行验证。
- en: Validating forms with basic data bindings
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本数据绑定验证表单
- en: A form is a document for collecting information. The HTML `<form>` element is
    a form where the data or information can be collected from the web user. This
    element requires `<input>` elements in it to specify what data we want to collect.
    But before accepting the data, we usually would want to validate and filter it
    so that we get genuine and correct data from the user.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是收集信息的文件。HTML `<form>` 元素是一个可以从网页用户那里收集数据或信息的表单。这个元素需要在其中使用 `<input>` 元素来指定我们想要收集的数据。但在接受数据之前，我们通常会希望对其进行验证和过滤，以便从用户那里获得真实和正确的数据。
- en: 'Vue allows us to validate the data easily from the `v-model` input elements,
    so let''s get started with a single-file components (SFC) Vue app and webpack,
    which you learned about in [Chapter 5](099c1dc8-8dfa-46f8-bfbd-bfa036eefbb7.xhtml), *Adding
    Vue Components*, in the *Compiling single-file components with webpack *section.
    First, we will create a very simple form with a `submit` button and the markups
    for displaying the error message in the `<template>` block as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Vue允许我们轻松地从 `v-model` 输入元素中验证数据，因此让我们从单文件组件（SFC）Vue应用程序和webpack开始，你可以在[第5章](099c1dc8-8dfa-46f8-bfbd-bfa036eefbb7.xhtml)中了解到，*添加Vue组件*，在*使用webpack编译单文件组件*部分。首先，我们将创建一个非常简单的表单，其中包括一个
    `submit` 按钮和在 `<template>` 块中显示错误消息的标记，如下所示：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will add the rest of the input elements inside `<form>` later. Now, let''s
    set up the basic structure and understand what we will need. We use `v-on:submit.prevent`
    to prevent the browser from sending the form data by default because we will handle
    the submission with the `checkForm` method in the Vue instance in the `<script>`
    block:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将在`<form>`中添加其余的输入元素。现在，让我们设置基本结构并了解我们将需要什么。我们使用`v-on:submit.prevent`来防止浏览器默认发送表单数据，因为我们将在Vue实例的`<script>`块中使用`checkForm`方法来处理提交：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: On the JavaScript side, we define an array to hold the errors that we might
    get in the validation process. The `checkForm` logic validates the required fields
    that we will add later in this section. If the required field fails to pass the
    validation then we push the error message to `errors`. When the form is filled
    in correctly and/or no error is found, it will be passed to the `processForm`
    logic, where we can do something further with the form data before sending it
    to the server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript方面，我们定义一个数组来保存在验证过程中可能遇到的错误。`checkForm`逻辑验证我们稍后将在本节中添加的必填字段。如果必填字段未能通过验证，我们将错误消息推送到`errors`中。当表单填写正确和/或未发现错误时，它将被传递到`processForm`逻辑，在那里我们可以在将其发送到服务器之前对表单数据进行进一步处理。
- en: Validating text elements
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证文本元素
- en: 'Let''s get started by adding an `<input>` element for single-line text:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始添加一个用于单行文本的`<input>`元素：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the `<script>` block, we define a `name` property in the `data` function
    that holds the initial `null` value and will be updated on the `input` event from
    the `<input>` element. We validate the `name` data in the `if` condition block
    when you hit the `submit` button; if it has no data provided, then we `push` the
    error message to `errors`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<script>`块中，我们在`data`函数中定义了一个`name`属性，它保存初始的`null`值，并将在`<input>`元素的`input`事件上进行更新。当您点击`submit`按钮时，我们在`if`条件块中验证`name`数据；如果没有提供数据，那么我们将错误消息`push`到`errors`中。
- en: Validating textarea elements
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证文本区域元素
- en: 'The next element we are adding is `<textarea>` for multi-line text, which works
    the same way as `<input>`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的下一个元素是`<textarea>`，用于多行文本，其工作方式与`<input>`相同：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `<script>` block, we define a `message` property in the `data` function
    that holds the initial `null` value and will be updated on the `input` event from
    the `<textarea>` element. We validate the `message` data in the `if` condition
    block when you hit the `submit` button; if it has no data provided, then we `push`
    the error message to `errors`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<script>`块中，我们在`data`函数中定义了一个`message`属性，它保存初始的`null`值，并将在`<textarea>`元素的`input`事件上进行更新。当您点击`submit`按钮时，我们在`if`条件块中验证`message`数据；如果没有提供数据，那么我们将错误消息`push`到`errors`中。
- en: Validating checkbox elements
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证复选框元素
- en: 'The next element is a single checkbox `<input>` element that will hold the
    default Boolean value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个元素是一个单个复选框`<input>`元素，它将保存默认的布尔值：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also will add the following multiple checkbox `<input>` elements that are
    bound to the same array, that is, `books: []`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还将添加以下多个复选框`<input>`元素，它们绑定到同一个数组`books: []`：'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `<script>` block, we define a `subscribe` property in the `data` function
    that holds the initial Boolean `false` value and will be updated on the `change`
    event from the checkbox `<input>` element. We validate the `subscribe` data in
    the `if` condition block when you hit the `submit` button; if it has no data provided
    or it is `false`, then we `push` the error message to `errors`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<script>`块中，我们在`data`函数中定义了一个`subscribe`属性，它保存初始的布尔值`false`，并将在复选框`<input>`元素的`change`事件上进行更新。当您点击`submit`按钮时，我们在`if`条件块中验证`subscribe`数据；如果没有提供数据或者为`false`，那么我们将错误消息`push`到`errors`中。
- en: We do the same for the multiple checkbox `<input>` elements by defining a `books`
    property that holds the initial empty array and will be updated on the `change`
    event from the checkbox `<input>` element. We validate the `books` data in the
    `if` condition block; if its length is `0` then we `push` the error message to
    `errors`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义一个`books`属性来实现多个复选框`<input>`元素的相同功能，它保存了初始的空数组，并将在复选框`<input>`元素的`change`事件上进行更新。我们在`if`条件块中验证`books`数据；如果长度为`0`，那么我们将错误消息`push`到`errors`中。
- en: Validating radio elements
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证单选按钮元素
- en: 'The next element is multiple radio button `<input>` elements that are bound
    to the same property name, that is, `gender`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是绑定到相同属性名称的多个单选按钮`<input>`元素，即`gender`：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `<script>` block, we define a `gender` property in the `data` function
    that holds the initial `null` value and will be updated on the `change` event
    from the selected `<input>` radio button element. We validate the `gender` data
    in the `if` condition block when you hit the `submit` button. If it has no data
    provided, then we `push` the error message to `errors`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<script>`块中，我们在`data`函数中定义了一个`gender`属性，它保存了初始的`null`值，并将在选定的`<input>`单选按钮元素的`change`事件上进行更新。当点击`submit`按钮时，我们在`if`条件块中验证`gender`数据。如果没有提供数据，那么我们将错误消息`push`到`errors`中。
- en: Validating select elements
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证选择元素
- en: 'The next element is a single `<select>` element with multiple `<option>` elements
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个单个`<select>`元素，其中包含多个`<option>`元素，如下所示：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the last one is multiple `<select>` elements with multiple `<option>` elements
    that are bound to the same `Array`, that is, `favourites: []`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '最后是多个绑定到相同`Array`的多个`<option>`元素的多个`<select>`元素，即`favourites: []`：'
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `<script>` block, we define a `favourites` property in the `data` function
    that holds the initial `null` value and will be updated on the `change` event
    from the `<select>` element. We validate the `favourites` data in the `if` condition
    block when you hit the `submit` button. If it has no data provided, then we `push`
    the error message to `errors`. We do the same for the multiple `<select>` elements
    by defining a `favourites` property that holds the initial empty array and will
    be updated on the `change` event from the `<select>` element. We validate the
    `favourites` data in the `if` condition block; if its length is `0` then we push
    the error message to `errors`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<script>`块中，我们在`data`函数中定义了一个`favourites`属性，它保存了初始的`null`值，并将在`<select>`元素的`change`事件上进行更新。当点击`submit`按钮时，我们在`if`条件块中验证`favourites`数据。如果没有提供数据，那么我们将错误消息`push`到`errors`中。对于多个`<select>`元素，我们也是通过定义一个`favourites`属性来实现相同的功能，它保存了初始的空数组，并将在`<select>`元素的`change`事件上进行更新。我们在`if`条件块中验证`favourites`数据；如果长度为`0`，那么我们将错误消息`push`到`errors`中。
- en: 'Then we will finish up this form with the `processForm` logic, which is called
    only when no error is found in the `checkForm` logic. We use a Node.js package,
    `qs`, to stringify the `this.form` object so we can send the data to the server in
    the following format:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用`processForm`逻辑完成这个表单，只有在`checkForm`逻辑中没有发现错误时才会调用。我们使用Node.js包`qs`对`this.form`对象进行字符串化，以便以以下格式将数据发送到服务器：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s install `qs` with npm:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用npm安装`qs`：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then we can use it as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以按照以下方式使用它：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We send the data using `axios` and get the response (usually in JSON format)
    back from the server, then you can do something with the response data, such as
    displaying a "success" or "failed" message on the server side.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`axios`发送数据，并从服务器获取响应（通常是JSON格式），然后您可以对响应数据进行操作，例如在服务器端显示“成功”或“失败”消息。
- en: For more information about `qs`, visit [https://www.npmjs.com/package/qs](https://www.npmjs.com/package/qs),
    and for `axios`, please visit [https://github.com/axios/axios](https://github.com/axios/axios).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`qs`的更多信息，请访问[https://www.npmjs.com/package/qs](https://www.npmjs.com/package/qs)，有关`axios`，请访问[https://github.com/axios/axios](https://github.com/axios/axios)。
- en: You can find the preceding example app in `/chapter-7/vue/webpack/` in our GitHub
    repository.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的GitHub存储库的`/chapter-7/vue/webpack/`中找到前面的示例应用程序。
- en: However, we are not quite finished yet, because we may want to bind dynamic
    values to the form inputs sometimes, instead of getting the default ones from
    `v-model`. For example, we only get the Boolean value for the `subscribe` property
    with a single checkbox `<input>` element in our example app, but we want to use
    a string value with `yes` or `no` instead. We will explore how we can change the
    default values in the coming section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有完全完成，因为有时我们可能希望将动态值绑定到表单输入中，而不是从`v-model`中获取默认值。例如，在我们的示例应用程序中，我们只使用单个复选框`<input>`元素获取`subscribe`属性的布尔值，但我们希望使用字符串值`yes`或`no`。我们将在接下来的部分探讨如何更改默认值。
- en: Making dynamic value bindings
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行动态值绑定
- en: In our example app in the previous section, we either get strings or Boolean
    values for the `radio`, `checkbox`, and `select` options by using `v-model` alone.
    We can change this default value by using `true-value`, `false-value`, and `v-bind`.
    Let's dive in.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节的示例应用程序中，我们仅使用`v-model`获取`radio`，`checkbox`和`select`选项的字符串或布尔值。我们可以通过使用`true-value`，`false-value`和`v-bind`来更改此默认值。让我们深入了解。
- en: Replacing Boolean – checkbox elements
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用布尔值替换-复选框元素
- en: 'We can bind our custom value to the **single** `checkbox` elements by using
    `true-value` and `false-value`. For example, we can bind the `yes` value to replace
    the default `true` Boolean value with `true-value` and `no` to replace the default `false`
    Boolean value with `false-value`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`true-value`和`false-value`将我们的自定义值绑定到**单个**`checkbox`元素。例如，我们可以使用`true-value`将`yes`值绑定到替换默认的`true`布尔值，使用`false-value`将`no`值绑定到替换默认的`false`布尔值：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, you get a response of `yes` or `no` when you send the value of the `subscribe` input
    to the server. In the `<script>` block, we now declare `no` as the initial value
    on the `subscribe` property and validate it in the `if` condition block to make
    sure it is always `yes` when you hit the `submit` button, otherwise we push the
    error message to `errors`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您将`subscribe`输入的值发送到服务器时，您将得到`yes`或`no`的响应。在`<script>`块中，我们现在将`no`声明为`subscribe`属性的初始值，并在`if`条件块中对其进行验证，以确保在点击`submit`按钮时它始终为`yes`，否则我们将错误消息推送到`errors`。
- en: Replacing strings with dynamic properties – radio elements
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用动态属性替换字符串-单选按钮元素
- en: 'As for the radio button `<input>` elements, we can bind their values to the
    dynamic property in the Vue instance by using `v-bind`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于单选按钮`<input>`元素，我们可以使用`v-bind`将它们的值绑定到Vue实例中的动态属性：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now you get `m` when this radio button is picked and the validation is the same
    as before.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当选择此单选按钮时，您将得到`m`，验证逻辑与以前相同。
- en: Replacing strings with objects – select options elements
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用对象替换字符串-选择选项元素
- en: 'We also can use `v-bind` **non-string** values such as `Object` to the form
    inputs. See the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`v-bind`将**非字符串**值（如`Object`）绑定到表单输入。请参阅以下示例：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now when this option is selected, you get `object` for `typeof this.favourite`
    and `On the Origin of Species` for `this.favourite.title`. There is no change
    in the validation logic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当选择此选项时，您将得到`typeof this.favourite`的`object`和`this.favourite.title`的`On the
    Origin of Species`。验证逻辑没有变化。
- en: 'We also can render `<option>` elements dynamically with dynamic values and
    `v-for`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用动态值和`v-for`动态呈现`<option>`元素：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we don't have to hardcode the `<option>` elements anymore. We can pull the
    `books` data from elsewhere, such as an API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不再需要硬编码`<option>`元素了。我们可以从其他地方（如API）获取`books`数据。
- en: Besides binding dynamic values to form inputs, we also can modify the default
    behavior of `v-model` on the input elements. For example, instead of syncing the
    input with the data, we can use the `change` event on them. Let's discover how
    you can do this in the next topic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将动态值绑定到表单输入外，我们还可以修改输入元素上`v-model`的默认行为。例如，我们可以使用它们上的`change`事件，而不是将输入与数据同步。让我们在下一个主题中发现如何做到这一点。
- en: Using modifiers
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用修饰符
- en: Vue provides these three modifiers, `.lazy`, `.number`, and `.trim`, that we
    can use with `v-model` to change the default events or to add extra functionality
    to the form input. Let's dive in.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Vue提供了这三个修饰符，`.lazy`、`.number`和`.trim`，我们可以与`v-model`一起使用，改变默认事件或为表单输入添加额外功能。让我们深入了解。
- en: Adding .lazy
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加`.lazy`
- en: 'We can use `.lazy` with `v-model` to change the `input` event to a `change`
    event on the `<input>` and `<textarea>` elements. See the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`.lazy`和`v-model`来将`<input>`和`<textarea>`元素上的`input`事件改为`change`事件。看下面的例子：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now the input with the data is synced after `change`, instead of the `input`
    event, which is the default.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入与数据在`change`之后同步，而不是默认的`input`事件。
- en: Adding .number
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加`.number`
- en: 'We can use `.number` with `v-model` to change the default typecast of `string`
    to `number` on `<input>` elements with `type="number"`. See the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`.number`和`v-model`来改变`<input>`元素上`type="number"`的默认类型转换，将`string`转换为`number`。看下面的例子：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now you get `number` for `typeof this.form.age` instead of `string` without
    having `.number`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你得到`typeof this.form.age`的`number`，而不是没有`.number`的`string`。
- en: Adding .trim
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加`.trim`
- en: 'We can use `.trim` with `v-model` to trim off the whitespace from the user
    input. See the following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`.trim`和`v-model`来修剪用户输入的空白。看下面的例子：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now the text from the user is trimmed automatically. Any extra whitespace at
    the beginning and end of the text will be trimmed off.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户输入的文本会自动修剪。文本开头和结尾的任何额外空白都将被修剪掉。
- en: While writing custom validation logic is possible, there is already a great
    plugin that helps validate inputs easily and displays the corresponding errors.
    This plugin is called VeeValidate and is a template-based validation framework
    for Vue. Let's discover how we can leverage this plugin in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写自定义验证逻辑是可能的，但已经有一个很棒的插件可以帮助轻松验证输入并显示相应的错误。这个插件叫做VeeValidate，是一个基于Vue的模板验证框架。让我们在下一节中发现如何利用这个插件。
- en: Validating forms with VeeValidate
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VeeValidate验证表单
- en: 'With VeeValidate, we will use VeeValidate''s components to validate our HTML
    forms and Vue''s scoped slots to expose the error messages. For example, this
    is a `v-model` input element that we are already familiar with:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用VeeValidate，我们将使用VeeValidate的组件来验证我们的HTML表单，并使用Vue的作用域插槽来暴露错误消息。例如，这是一个我们已经熟悉的`v-model`输入元素：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you want to validate it with VeeValidate, you just have to wrap the input
    with a `<ValidationProvider>` component:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用VeeValidate验证它，你只需要用`<ValidationProvider>`组件包装输入：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In general, we use the `<ValidationProvider>` component to validate `<input>`
    elements. We can attach validation rules to this component using the `rules` attribute
    and display errors with the `v-slot` directive. Let''s discover how you can make
    use of this plugin to speed up the validation process in the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们使用`<ValidationProvider>`组件来验证`<input>`元素。我们可以使用`rules`属性将验证规则附加到这个组件上，并使用`v-slot`指令显示错误。让我们在以下步骤中发现如何利用这个插件来加快验证过程：
- en: 'Install VeeValidate with npm:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用npm安装VeeValidate：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a `.js` file in the `/src/` directory and add rules by using the `extend`
    function from VeeValidate:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/src/`目录中创建一个`.js`文件，并使用VeeValidate的`extend`函数添加规则：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: VeeValidate provides many built-in validation rules in separate bundles, such
    as `required`, `email`, `min`, `regex`, and so on, so we can import the specific
    rules that we only need for our apps. So in the preceding code, we import the
    `required` rule and install it through the `extend` function, and then add our
    custom message in the `message` property.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: VeeValidate提供了许多内置的验证规则，如`required`、`email`、`min`、`regex`等，因此我们可以导入我们应用程序所需的特定规则。因此，在上述代码中，我们导入`required`规则，并通过`extend`函数安装它，然后在`message`属性中添加我们的自定义消息。
- en: 'Import `/src/vee-validate.js` into the main entry file where the Vue instance
    is initiated:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`/src/vee-validate.js`导入到初始化Vue实例的主入口文件中：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Import the `ValidationProvider` component locally into a page and start validating
    the input fields on that page:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ValidationProvider`组件本地导入到页面中，并开始验证该页面上的输入字段：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We also can register `ValidationProvider` globally in `/src/main.js` or `/src/plugins/vee-validate.js`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`/src/main.js`或`/src/plugins/vee-validate.js`中全局注册`ValidationProvider`：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: But this is probably not a good idea if you don't need this component on every
    page in your app. So if you just need it on a page, then import it locally.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您不需要在应用程序的每个页面上使用此组件，这可能不是一个好主意。因此，如果您只需要在某个页面上使用它，则将其本地导入。
- en: 'Import the `ValidationObserver` component locally and add the `passes` object
    to the `v-slot` directive. So let''s refactor theJavaScript code from *step 4*
    as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地导入`ValidationObserver`组件，并将`passes`对象添加到`v-slot`指令中。因此，让我们按照以下方式重构*步骤4*中的JavaScript代码：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We use the `<ValidationObserver>` component to wrap the `<form>` element to
    tell whether it is valid or not before submitting. We also use the `passes` property
    in the object of the scoped slot on the `<ValidationObserver>` component, which
    is used to prevent the form from submitting if it is invalid. Then we pass our
    `processForm` method to the `passes` function in the `v-on:submit` event on the
    form element. Our `processForm` method will not be called if the form is invalid.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`<ValidationObserver>`组件来包装`<form>`元素，以在提交之前告知其是否有效。我们还在`<ValidationObserver>`组件的作用域插槽对象中使用`passes`属性，该属性用于在表单无效时阻止提交。然后我们将我们的`processForm`方法传递给表单元素上的`v-on:submit`事件中的`passes`函数。如果表单无效，则不会调用我们的`processForm`方法。
- en: That's it. We are done. You can see that we no longer need the `checkForm` method
    on the `v-on:submit` event in the `methods` property because VeeValidate has done
    the heavy lifting on validating the elements for us and now our JavaScript code
    is shortened. We only need to wrap around our input fields with `<ValidationProvider>`
    and `<ValidationObserver>` components.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们完成了。您可以看到，我们不再需要`methods`属性中`v-on:submit`事件上的`checkForm`方法，因为VeeValidate已经为我们验证了元素，并且现在我们的JavaScript代码变得更短了。我们只需要使用`<ValidationProvider>`和`<ValidationObserver>`组件包装我们的输入字段。
- en: 'If you want to find out more about the Vue slots and VeeValidate, please visit
    the following links:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关Vue插槽和VeeValidate的更多信息，请访问以下链接：
- en: '[https://logaretm.github.io/vee-validate/](https://logaretm.github.io/vee-validate/) for
    VeeValidate'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://logaretm.github.io/vee-validate/](https://logaretm.github.io/vee-validate/)
    用于VeeValidate'
- en: '[https://vuejs.org/v2/guide/components-slots.html](https://vuejs.org/v2/guide/components-slots.html) for
    Vue slots'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://vuejs.org/v2/guide/components-slots.html](https://vuejs.org/v2/guide/components-slots.html)
    用于Vue插槽'
- en: You can find the example of our preceding Vue app in `/chapter-7/vue/cli/` in
    our GitHub repository.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的GitHub存储库的`/chapter-7/vue/cli/`中找到我们先前的Vue应用程序的示例。
- en: Next, we will find out how we can apply VeeValidate in Nuxt apps in the following
    section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在下一节中了解如何在Nuxt应用程序中应用VeeValidate。
- en: Applying custom validation to a Nuxt application
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义验证应用到Nuxt应用程序
- en: Let's apply the custom validation to the Contact page in the sample website
    that we already have. You have probably noticed that the existing contact form
    has already installed the validation from Foundation (Zurb). Using Foundation's
    form validation is another great way to spice up our HTML form validation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将自定义验证应用到我们已经有的示例网站中的联系页面。您可能已经注意到，现有的联系表单已经安装了Foundation（Zurb）的验证。使用Foundation的表单验证是另一种提升我们的HTML表单验证的好方法。
- en: If you are interested in knowing more about Foundation, you can find out more
    from their official guide at [https://foundation.zurb.com/sites/docs/abide.html](https://foundation.zurb.com/sites/docs/abide.html).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Foundation的信息，可以在它们的官方指南中找到更多信息：[https://foundation.zurb.com/sites/docs/abide.html](https://foundation.zurb.com/sites/docs/abide.html)。
- en: 'But if we want to do the custom validation with VeeValidate, which we have
    just learned for use in the Vue app, then let''s install and set up what we need
    for Nuxt in the following steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要在Nuxt中进行自定义验证，我们刚刚学习了在Vue应用程序中使用的VeeValidate，那么让我们按照以下步骤安装和设置我们需要的内容：
- en: 'Install VeeValidate via npm:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm安装VeeValidate：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a plugin file in the `/plugins/` directory and add the rules we need,
    as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/plugins/`目录中创建一个插件文件，并添加我们需要的规则，如下所示：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Everything in this file is the same as the file we did in the Vue app.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件中的一切都和我们在Vue应用程序中做的文件一样。
- en: 'Include the plugin path in the `plugins` option in the Nuxt config file:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件的`plugins`选项中包含插件路径：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add an exception for the `/vee-validate/dist/rules.js` file in the `build`
    option in the Nuxt config file:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件的`build`选项中为`/vee-validate/dist/rules.js`文件添加一个例外。
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In Nuxt, the `/node_modules/` folder is excluded from transpilation by default,
    and you will get an error reading `Unexpected token export` when using `vee-validate`,
    so we must add `/vee-validate/dist/rules.js` for transpilation before running
    the Nuxt app.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nuxt中，默认情况下，`/node_modules/`文件夹被排除在转译之外，当使用`vee-validate`时，您将会收到一个错误消息`Unexpected
    token export`，因此在运行Nuxt应用程序之前，我们必须将`/vee-validate/dist/rules.js`添加到转译中。
- en: 'Import the `ValidationObserver` and `ValidationProvider` components just as
    we did for the Vue app:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像我们在Vue应用程序中所做的那样，导入`ValidationObserver`和`ValidationProvider`组件：
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Remove Foundation''s `data-abide` attribute from the `<form>` element, but
    wrap it with the `<ValidationObserver>` component and bind the `submit` event
    with the `passes` and `processForm` methods to the `<form>` element as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`<form>`元素中删除Foundation的`data-abide`属性，但使用`<ValidationObserver>`组件将其包装起来，并将`submit`事件与`passes`和`processForm`方法绑定到`<form>`元素，如下所示：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This step is also the same as what we did with the Vue app, but we added `ref="observer"`
    in this example as we will need it in *step 8*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步和我们在Vue应用程序中所做的步骤是一样的，但在这个例子中，我们在*步骤8*中添加了`ref="observer"`，因为我们将在后面需要它。
- en: 'Start refactoring all the `<input>` elements inside the `<form>` element with
    the `<ValidationProvider>` component, as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始使用`<ValidationProvider>`组件重构`<form>`元素内的所有`<input>`元素，如下所示：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This step is also the same as what we did with the Vue app, but in this example,
    we added two scoped slot data properties, `invalid` and `validated`, in the `v-slot`
    directive for binding classes conditionally to the `<label>` and `<input>` elements.
    So if we get `true` for both `invalid` and `validated`, then we will bind the `is-invalid-label`
    and `is-invalid-input` classes to the elements, respectively.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步和我们在Vue应用程序中所做的步骤是一样的，但在这个例子中，我们在`v-slot`指令中添加了两个作用域插槽数据属性，`invalid`和`validated`，以便根据条件将类绑定到`<label>`和`<input>`元素。因此，如果`invalid`和`validated`都为`true`，那么我们将分别将`is-invalid-label`和`is-invalid-input`类绑定到元素上。
- en: For more information about the Validation Provider's scoped slot data properties,
    please visit [https://vee-validate.logaretm.com/v2/guide/components/validation-provider.html#scoped-slot-data](https://vee-validate.logaretm.com/v2/guide/components/validation-provider.html#scoped-slot-data).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有关验证提供程序的作用域插槽数据属性的更多信息，请访问[https://vee-validate.logaretm.com/v2/guide/components/validation-provider.html#scoped-slot-data](https://vee-validate.logaretm.com/v2/guide/components/validation-provider.html#scoped-slot-data)。
- en: 'Refactor the `data` function in the `<script>` block by adding the following
    data properties to sync up with the `v-model` input elements. We also will add
    two methods in the `methods` option, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向`<script>`块中的`data`函数添加以下数据属性来重构，以与`v-model`输入元素同步。我们还将在`methods`选项中添加两个方法，如下所示：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This step is also the same as what we did with the Vue app, but in this example,
    we added the `clear` method and the `reset` method in `processForm` for the `methods`
    options. The `<ValidationObserver>` component does not reset the state of the
    form after submitting so we have to do it manually, by passing the observer as
    a reference in *step 6*, and then we can access it from the Vue instance with
    `this.$refs`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步与我们在Vue应用中所做的相同，但在这个例子中，我们在`methods`选项中的`processForm`中添加了`clear`方法和`reset`方法。`<ValidationObserver>`组件在提交后不会重置表单的状态，因此我们必须手动进行，通过在*步骤6*中将观察者作为引用传递，然后我们可以通过`this.$refs`从Vue实例中访问它。
- en: 'Add these three scoped slot data properties, `dirty`, `invalid`, and `validated`,
    to the `<ValidationObserver>` component for toggling the alert and success messages,
    then let''s refactor this component as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这三个作用域插槽数据属性`dirty`、`invalid`和`validated`添加到`<ValidationObserver>`组件中，以切换警报和成功消息，然后让我们按照以下方式重构这个组件：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this last step, we added a `submitted` data property with a `false` Boolean
    by default, which will be set to `true` when the form is submitted in the `processForm`
    method. On the other hand, the alert message block will be visible when `invalid`
    and `validated` from the scoped slot are both `true`, and the success message
    block will be visible when both the `submitted` property is `true` and the `dirty`
    scoped slot data property is `false`. We get a `true` Boolean from the `dirty`
    property if one of the input fields is "dirty" – in other words, when a letter
    is present in the input field.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们添加了一个默认为`false`的`submitted`数据属性，当表单在`processForm`方法中提交时，它将被设置为`true`。另一方面，当作用域插槽中的`invalid`和`validated`都为`true`时，警报消息块将可见，当`submitted`属性为`true`且`dirty`作用域插槽数据属性为`false`时，成功消息块将可见。如果输入字段中有一个字母存在，我们将从`dirty`属性中得到一个`true`。换句话说，当输入字段中存在字母时。
- en: You can see that the refactored code in our Nuxt app is quite similar to what
    we did in the Vue standard app. But in the Nuxt app, we added more complex logic
    to the form such as toggling the alert and success messages, binding classes conditionally
    to the `<label>` and `<input>` elements, and resetting the `<ValidationObserver>`
    component whenever the form is submitted. The refactoring process is the same
    for the rest of the input elements, which you can find in the book's GitHub repository
    at `/chapter-7/nuxt-universal/sample-website/`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在我们的Nuxt应用中重构的代码与我们在Vue标准应用中所做的非常相似。但是在Nuxt应用中，我们为表单添加了更复杂的逻辑，例如切换警报和成功消息，有条件地将类绑定到`<label>`和`<input>`元素，并在表单提交时重置`<ValidationObserver>`组件。对于其余的输入元素，重构过程是相同的，您可以在书的GitHub存储库`/chapter-7/nuxt-universal/sample-website/`中找到。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered Vue form validation with `v-model` on the various
    form inputs. You have learned basic and dynamic value binding, and how to use
    modifiers to change the default input event and typecast. You also have learned
    to use the `vee-validate` plugin to make the validation easier. Finally, we managed
    to apply these to the Nuxt app.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了使用`v-model`在各种表单输入上进行Vue表单验证。您已经学会了基本和动态值绑定，以及如何使用修饰符来更改默认的输入事件和类型转换。您还学会了使用`vee-validate`插件来简化验证过程。最后，我们成功将这些应用到了Nuxt应用程序中。
- en: In the next chapter, we are going to explore how to add a server-side framework
    in Nuxt apps. You will learn to create a simple API with Koa and integrate it
    with Nuxt, and request the API data using `asyncData` with the HTTP client, Axios.
    Also, you will be introduced to a minimalistic build system based on webpack,
    called Backpack, which will simplify the custom webpack configuration that we
    have been using for the single-file component Vue apps. You will learn how to
    use this build system in Nuxt apps, too. So, stay tuned!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在Nuxt应用程序中添加服务器端框架。您将学会使用Koa创建一个简单的API，并将其与Nuxt集成，使用HTTP客户端Axios来请求API数据。此外，您还将介绍一个基于webpack的极简构建系统，称为Backpack，它将简化我们用于单文件组件Vue应用程序的自定义webpack配置。您还将学会如何在Nuxt应用程序中使用这个构建系统。敬请关注！
