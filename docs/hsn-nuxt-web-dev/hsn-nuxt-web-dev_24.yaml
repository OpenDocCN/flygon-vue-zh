- en: Creating a Nuxt App with a CMS and GraphQL
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CMS和GraphQL创建Nuxt应用
- en: In the previous chapters, you have been creating APIs from scratch so that they
    work with Nuxt apps. Building a personalized API can be rewarding and fulfilling,
    but it may not suit every situation. Building an API from the bottom-up is time-consuming.
    In this chapter, we are going to explore third-party systems that can provide
    us with the API services we need without having us build them from scratch. Ideally,
    we want to use a system that can help us manage our content – a **content management
    system** (**CMS**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，您一直在从头开始创建API，以便它们与Nuxt应用一起工作。构建个性化的API可能是有益的和令人满足的，但它可能并不适合每种情况。从底层构建API是耗时的。在本章中，我们将探索可以为我们提供所需API服务的第三方系统，而无需从头开始构建它们。理想情况下，我们希望使用一个可以帮助我们管理内容的系统
    - **内容管理系统**（**CMS**）。
- en: WordPress and Drupal are popular CMSes. They are packed with APIs that are worth
    looking into. In this book, we will be using **WordPress**. Besides CMSes such
    WordPress, we will also look into **headless CMSes**. A headless CMS is just like
    WordPress but is a pure API service without the frontend presentation, which can
    be done in Nuxt, just as we have been doing throughout this book. **Keystone**
    will be the headless CMS that we will explore in this book. However, the WordPress
    API and the Keystone API are two different kinds of API. Specifically, the former
    is a **REST API**, while the latter is a **GraphQL API**. But what are they? In
    short, a REST API is an API that uses HTTP requests to `GET`, `PUT`, `POST`, and
    `DELETE` data. The APIs you created in the previous chapters are REST APIs. GraphQL
    is an API that implements the GraphQL specification (technical standard).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress和Drupal是流行的CMS。它们都包含值得研究的API。在本书中，我们将使用**WordPress**。除了WordPress这样的CMS，我们还将研究**无头CMS**。无头CMS就像WordPress一样，但是是一个纯粹的API服务，没有前端呈现，这可以在Nuxt中完成，就像我们在整本书中一直在做的那样。**Keystone**将是我们在本书中探索的无头CMS。然而，WordPress
    API和Keystone API是两种不同类型的API。具体来说，前者是**REST API**，而后者是**GraphQL API**。但它们是什么？简而言之，REST
    API是使用HTTP请求来`GET`、`PUT`、`POST`和`DELETE`数据的API。您在前几章中创建的API都是REST API。GraphQL是实现GraphQL规范（技术标准）的API。
- en: GraphQL APIs are an alternative to REST APIs. To demonstrate how we can deliver
    the same result using these two different kinds of API, we will use the sample
    Nuxt app website we provided in [Chapter 4](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml),
    *Adding Views, Routes. and Transitions*. This can be found in `/chapter-4/nuxt-universal/sample-website/`
    in this book's GitHub repository. We will refactor the existing pages (home, about,
    projects, content, and the project subpages), which consist of text and images
    (featured images, fullscreen images, and individual project images). We will also
    refactor the navigation by getting data from the APIs instead of hardcoding them,
    just like we did for the other Nuxt apps in the previous chapters. With a CMS,
    we can get navigation data dynamically through the API, regardless of whether
    it is a REST or a GraphQL API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API是REST API的一种替代方案。为了演示如何使用这两种不同类型的API来实现相同的结果，我们将使用我们在[第4章](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml)中提供的示例Nuxt应用网站，*添加视图、路由和过渡*。这可以在本书的GitHub存储库中的`/chapter-4/nuxt-universal/sample-website/`中找到。我们将重构现有页面（主页、关于、项目、内容和项目子页面），这些页面包括文本和图片（特色图片、全屏图片和单独的项目图片）。我们还将通过从API获取数据而不是硬编码来重构导航，就像我们在前几章中为其他Nuxt应用所做的那样。通过CMS，我们可以通过API动态获取导航数据，无论是REST还是GraphQL
    API。
- en: Furthermore, we are going to generate static Nuxt pages (you learned about these
    in [Chapter 14](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml), *Using Linters, Formatters,
    and Deployment Commands*, and [Chapter 15](450e252f-a94b-4f7f-9762-533a150f5d19.xhtml), *Creating
    an SPA with Nuxt*) with these CMSes. So, by the end of this chapter, you will
    have a full and final view of what you have learned throughout this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用这些CMS生成静态Nuxt页面（您在[第14章](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml)中了解了这些内容，*使用Linter、格式化程序和部署命令*，以及[第15章](450e252f-a94b-4f7f-9762-533a150f5d19.xhtml)中，*使用Nuxt创建SPA*）。因此，到本章结束时，您将对本书中学到的内容有一个完整而最终的了解。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating headless REST APIs in WordPress
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WordPress中创建无头REST API
- en: Introducing Keystone
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Keystone
- en: Introducing GraphQL
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍GraphQL
- en: Integrating Keystone, GraphQL, and Nuxt
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Keystone、GraphQL和Nuxt
- en: Let's get started by looking into the WordPress REST API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始研究WordPress REST API。
- en: Creating headless REST APIs in WordPress
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WordPress中创建无头REST API
- en: 'WordPress (WordPress.org) is an open source PHP CMS for general-purpose website
    development. It is not "headless" by default; it is stacked with a template system.
    This means the view and the data are intertwined. However, since 2015 (WordPress
    4.4), the REST API infrastructure has been integrated into WordPress core for
    developers, and now all the default endpoints can be accessed if you append `/wp-json/`
    to your website-based URL. You can also extend the WordPress REST API and add
    your own custom endpoints. So, we can easily use WordPress as a "headless" REST
    API by ignoring the view. You will find out how to achieve this in the upcoming
    sections. To speed up the development process, we will install the following WordPress
    plugins:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress（WordPress.org）是一个用于通用网站开发的开源PHP CMS。它默认情况下不是“无头”的；它堆叠了一个模板系统。这意味着视图和数据是交织在一起的。然而，自2015年以来（WordPress
    4.4），REST API基础设施已经集成到WordPress核心中供开发人员使用，现在如果您在基于网站的URL后附加`/wp-json/`，则可以访问所有默认端点。您还可以扩展WordPress
    REST API并添加自己的自定义端点。因此，我们可以通过忽略视图轻松地将WordPress用作“无头”REST API。您将在接下来的章节中了解如何实现这一点。为了加快开发过程，我们将安装以下WordPress插件：
- en: '**Advanced Custom Fields (ACF)** for creating custom meta boxes. For more information
    about this plugin, please visit [https://www.advancedcustomfields.com/](https://www.advancedcustomfields.com/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级自定义字段（ACF）**用于创建自定义元框。有关此插件的更多信息，请访问[https://www.advancedcustomfields.com/](https://www.advancedcustomfields.com/)'
- en: '**The ACF Repeater Field** for creating a repeatable set of subfields. It is
    an ACF premium add-on ([https://www.advancedcustomfields.com/add-ons/](https://www.advancedcustomfields.com/add-ons/)).
    You can purchase it from [https://www.advancedcustomfields.com/add-ons/repeater-field/](https://www.advancedcustomfields.com/add-ons/repeater-field/).
    Alternatively, you can get it by default from ACF PRO at [https://www.advancedcustomfields.com/pro/](https://www.advancedcustomfields.com/pro/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACF Repeater Field**用于创建可重复的子字段集。这是一个ACF高级附加组件（[https://www.advancedcustomfields.com/add-ons/](https://www.advancedcustomfields.com/add-ons/)）。您可以从[https://www.advancedcustomfields.com/add-ons/repeater-field/](https://www.advancedcustomfields.com/add-ons/repeater-field/)购买它。或者，您可以从ACF
    PRO的[https://www.advancedcustomfields.com/pro/](https://www.advancedcustomfields.com/pro/)默认获取它。'
- en: '**Rewrite Rules Inspector** for inspecting and flushing your rewrite rules
    in WordPress. For more information about this plugin, please visit [https://wordpress.org/plugins/rewrite-rules-inspector/](https://wordpress.org/plugins/rewrite-rules-inspector/)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重写规则检查器**用于检查和刷新WordPress中的重写规则。有关此插件的更多信息，请访问[https://wordpress.org/plugins/rewrite-rules-inspector/](https://wordpress.org/plugins/rewrite-rules-inspector/)'
- en: You can create your own plugins and meta boxes if you prefer not to use any
    of these. Please check out how to create custom meta boxes at [https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/](https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/).
    Also, check out how to develop custom plugins at [https://developer.wordpress.org/plugins/intro/](https://developer.wordpress.org/plugins/intro/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用任何这些，您可以创建自己的插件和元框。请查看如何在[https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/](https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/)创建自定义元框。还可以查看如何在[https://developer.wordpress.org/plugins/intro/](https://developer.wordpress.org/plugins/intro/)开发自定义插件。
- en: For more information about the WordPress REST API, please visit [https://developer.wordpress.org/rest-api/](https://developer.wordpress.org/rest-api/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有关WordPress REST API的更多信息，请访问[https://developer.wordpress.org/rest-api/](https://developer.wordpress.org/rest-api/)。
- en: To develop and extend the WordPress REST API with these plugins or with yours,
    first, you will need to download WordPress and install the program on your machine.
    We'll learn how to do this in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些插件或您自己的插件开发和扩展WordPress REST API，首先需要下载WordPress并在您的计算机上安装该程序。我们将在下一节中学习如何做到这一点。
- en: Installing WordPress and creating our first pages
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装WordPress并创建我们的第一个页面
- en: 'There are a few ways we can install and serve WordPress:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式安装和提供WordPress：
- en: By unpacking the downloaded WordPress `.zip` file and installing it from a directory
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过解压下载的WordPress `.zip`文件并从目录中安装它
- en: By using the WordPress CLI ([https://make.wordpress.org/cli/handbook/](https://make.wordpress.org/cli/handbook/)
    or [https://wp-cli.org/](https://wp-cli.org/))
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WordPress CLI（[https://make.wordpress.org/cli/handbook/](https://make.wordpress.org/cli/handbook/)或[https://wp-cli.org/](https://wp-cli.org/)）
- en: By setting up a port using Apache (which can be a bit of pain)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用Apache设置端口（可能有点麻烦）
- en: By using the built-in PHP server
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用内置的PHP服务器
- en: 'We will use the built-in PHP server in this book as it is the simplest way
    to get WordPress started and will make it easier to move it around in the future
    if we need to, as long as it is served on the same port; for example, `localhost:4000`.
    So, let''s find out how to do this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用内置的PHP服务器，因为这是启动WordPress的最简单方式，并且如果需要的话，将来移动它会更容易，只要它在同一个端口上提供服务；例如，`localhost:4000`。因此，让我们找出如何做到这一点：
- en: Create a directory (make it writable as well) and download and unzip WordPress
    in there. You can download WordPress from [https://wordpress.org/](https://wordpress.org/).
    You should see some `.php` files with `/wp-admin/`, `/wp-content/`, and `/wp-includes/` directories
    in your unzipped WordPress directory.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录（也使其可写），并在其中下载并解压WordPress。您可以从[https://wordpress.org/](https://wordpress.org/)下载WordPress。您应该在解压后的WordPress目录中看到一些带有`/wp-admin/`，`/wp-content/`和`/wp-includes/`目录的`.php`文件。
- en: Create a MySQL database (for example, `nuxt-wordpress`) through the PHP Adminer.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过PHP Adminer创建一个MySQL数据库（例如，`nuxt-wordpress`）。
- en: 'Navigate to the directory and serve WordPress with built-in PHP, as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到目录并使用内置的PHP提供WordPress，如下所示：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Point your browser to `localhost:4000` and install WordPress with the required
    MySQL credentials (database name, username, and password) and your WordPress user
    account information (username, password, and email address).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器指向`localhost:4000`，并使用所需的MySQL凭据（数据库名称，用户名和密码）以及您的WordPress用户帐户信息（用户名，密码和电子邮件地址）安装WordPress。
- en: Log into the WordPress admin UI with your user credentials at `localhost:4000/wp-admin/`
    and create some main pages (home, about, projects, contact) under the `Pages`
    label.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的用户凭据登录到`localhost:4000/wp-admin/`的WordPress管理UI，并在“页面”标签下创建一些主要页面（主页，关于，项目，联系）。
- en: Navigate to **Menus** from under **Appearance** and create the site navigation
    by adding `menu-main` to the **Menu Name** input field.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**外观**下的**菜单**导航到**菜单**，通过将`menu-main`添加到**菜单名称**输入字段来创建站点导航。
- en: 'Select all the pages (contact, about, projects, home) that appear under Add
    menu items and click Add to Menu to add them to `menu-main` as navigation items.
    You can drag and sort the items so that they are read in this order: home, about,
    projects, contact. Then, click the Save Menu button.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有出现在“添加菜单项”下的页面（联系人、关于、项目、主页），然后点击“添加到菜单”将它们添加到`menu-main`作为导航项。您可以拖动和排序这些项目，使它们按照这个顺序排列：主页、关于、项目、联系人。然后，点击“保存菜单”按钮。
- en: (Optional) Change the WordPress permalinks from the Plain option to the Custom
    Structure (with a value of `/%postname%/`, for example) in **Permalinks**, under
    **Settings**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）将WordPress永久链接从普通选项更改为自定义结构（例如`/%postname%/`）在**永久链接**下的**设置**中。
- en: Download the plugins we mentioned previously and unpack them into a `/plugins/` directory.
    This can be found inside the `/wp-content/` directory. Then, activate them through
    the admin UI.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载我们之前提到的插件并解压缩它们到`/plugins/`目录。这可以在`/wp-content/`目录中找到。然后通过管理界面激活它们。
- en: If you inspect the `wp_options` table in the `nuxt-wordpress` database, you
    should see that port `4000` is recorded successfully in the `siteurl` and `home`
    fields. So, from now on, you can move your WordPress project directory wherever
    you like, as long as you run it with the built-in PHP server at this port.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查“nuxt-wordpress”数据库中的“wp_options”表，您应该看到端口“4000”已成功记录在“siteurl”和“home”字段中。因此，从现在开始，只要在此端口上使用内置的PHP服务器运行，您可以将WordPress项目目录移动到任何您喜欢的地方。
- en: Although we have the data of our main pages and navigation in WordPress, we
    still need the data of the subpages of the `Projects` page. We can add them to
    the `Page` label and then just attach them to the `Projects` page. But these pages
    will share an identical content type (which is called post type in WordPress)
    – the `page` post type. It is better to organize them in a separate post type
    so that they can be managed more easily. We'll find out how to create custom post
    types in WordPress in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在WordPress中有主页面和导航的数据，但我们仍然需要“项目”页面的子页面数据。我们可以将它们添加到“页面”标签，然后将它们附加到“项目”页面。但是这些页面将共享相同的内容类型（在WordPress中称为文章类型）-“页面”文章类型。最好将它们组织在一个单独的文章类型中，以便更容易管理。我们将在下一节中了解如何在WordPress中创建自定义文章类型。
- en: For more details about the WordPress installation process, please visit [https://wordpress.org/support/article/how-to-install-wordpress/](https://wordpress.org/support/article/how-to-install-wordpress/).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有关WordPress安装过程的更多详细信息，请访问[https://wordpress.org/support/article/how-to-install-wordpress/](https://wordpress.org/support/article/how-to-install-wordpress/)。
- en: Creating custom post types in WordPress
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在WordPress中创建自定义文章类型
- en: 'We can create custom post types in WordPress from the `functions.php` file
    in any WordPress theme. However, since we are not going to use the WordPress template
    system to deliver the view for our content, we can just extend a **child theme**
    from the default theme that is provided by WordPress. Then, we can just activate
    the child theme in **Themes**, under **Appearance**. We''ll use the "Twenty Nineteen"
    theme to extend our child theme and then create the custom post types from there.
    Let''s get started:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从任何WordPress主题的“functions.php”文件中创建自定义文章类型。但是，由于我们不打算使用WordPress模板系统来提供我们内容的视图，我们可以从WordPress提供的默认主题中扩展一个**子主题**。然后，在**外观**下的**主题**中激活子主题。我们将使用“Twenty
    Nineteen”主题来扩展我们的子主题，然后从那里创建自定义文章类型。让我们开始吧：
- en: 'Create a directory called `twentynineteen-child` in the `/themes/` directory
    and create a `style.css` file that contains the following content:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/themes/`目录中创建一个名为`twentynineteen-child`的目录，并创建一个包含以下内容的`style.css`文件：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Theme Name`, `Template`, and `Text Domain` are the minimum required header
    comments for extending a theme, followed by importing its parent''s `style.css`
    file. These header comments must be put at the top of the file.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Theme Name`、`Template`和`Text Domain`是扩展主题的最低要求的头部注释，然后导入其父级的`style.css`文件。这些头部注释必须放在文件顶部。'
- en: If you want to include more header comments in this child theme, please visit
    [https://developer.wordpress.org/themes/advanced-topics/child-themes/](https://developer.wordpress.org/themes/advanced-topics/child-themes/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在这个子主题中包含更多的头部注释，请访问[https://developer.wordpress.org/themes/advanced-topics/child-themes/](https://developer.wordpress.org/themes/advanced-topics/child-themes/)。
- en: 'Create a `functions.php` file in the `/twentynineteen-child/` directory and
    create the custom post type using this format and WordPress'' `register_post_type`
    function, as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/twentynineteen-child/`目录中创建一个`functions.php`文件，并使用以下格式和WordPress的`register_post_type`函数创建自定义文章类型，方法如下：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, to add our custom post type, just use `project` as the type name and provide
    some arguments:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要添加我们的自定义文章类型，只需将`project`作为类型名称，并提供一些参数：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can add labels and what content fields we want to support to the custom
    post type UI, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向自定义文章类型UI添加标签和我们想要支持的内容字段，方法如下：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more information about the `register_post_type` function, please visit [https://developer.wordpress.org/reference/functions/register_post_type/](https://developer.wordpress.org/reference/functions/register_post_type/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`register_post_type`函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/register_post_type/](https://developer.wordpress.org/reference/functions/register_post_type/)。
- en: For more information about the custom post type UI, please visit [https://wordpress.org/plugins/custom-post-type-ui/](https://wordpress.org/plugins/custom-post-type-ui/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有关自定义文章类型UI的更多信息，请访问[https://wordpress.org/plugins/custom-post-type-ui/](https://wordpress.org/plugins/custom-post-type-ui/)。
- en: '(Optional) We can also add support for `category` and `tag` for this custom
    post type, as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）我们还可以为这种自定义文章类型添加对`category`和`tag`的支持，方法如下：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, these are global category and tag instances, which means they are
    shared with other post types such as the `Page` and `Post` post types. So, if
    you want to specify specific categories for the `Project` post type only, use
    the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些是全局的类别和标签实例，这意味着它们与其他文章类型（如`Page`和`Post`文章类型）共享。因此，如果您想为`Project`文章类型指定特定的类别，只需使用以下代码：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For more information about registering taxonomies, please visit [https://developer.wordpress.org/reference/functions/register_taxonomy/](https://developer.wordpress.org/reference/functions/register_taxonomy/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有关注册分类法的更多信息，请访问[https://developer.wordpress.org/reference/functions/register_taxonomy/](https://developer.wordpress.org/reference/functions/register_taxonomy/)。
- en: '(Optional) It may be a good idea to disable Gutenberg completely for all post
    types if you find it difficult to use:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）如果您发现难以使用，可能会完全禁用Gutenberg对所有文章类型：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Activate the child theme in the WordPress admin UI and start adding `project`
    type pages to the Projects label.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在WordPress管理界面中激活子主题，并开始向“项目”标签添加`project`类型页面。
- en: You will notice that the content fields (`title`, `editor`, `thumbnail`, `page-attributes`)
    that you can use to add content to the project pages are very limited. We need
    more specific content fields, such as content fields for adding multiple project
    images and a fullscreen image. This is the same issue we had with the `home` page
    because we need another content field so that we can add multiple slide images
    as well. To add more of these content fields, we will need custom meta boxes.
    You can use the ACF plugin or create your own custom meta boxes and include them
    in the `functions.php` file or create them as a plugin. Alternatively, you can
    use another different meta box plugin such as Meta Box ([https://metabox.io/](https://metabox.io/)).
    It is entirely up to you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，您可以使用的内容字段（`title`、`editor`、`thumbnail`、`page-attributes`）非常有限，用于向项目页面添加内容。我们需要更多特定的内容字段，例如用于添加多个项目图片和全屏图片的内容字段。这与我们在`home`页面上遇到的问题相同，因为我们需要另一个内容字段，以便我们也可以添加多个幻灯片图片。要添加更多这些内容字段，我们将需要自定义元框。您可以使用ACF插件或创建自己的自定义元框并将其包含在`functions.php`文件中，或者将其创建为插件。或者，您可以使用另一个不同的元框插件，如Meta
    Box ([https://metabox.io/](https://metabox.io/))。这完全取决于您。
- en: Once you have created the custom content fields and added the required content
    to each project page, you can extend the WordPress REST API for project pages,
    main pages, and navigation. We'll learn how to do this in the next section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了自定义内容字段并向每个项目页面添加了所需的内容，您可以扩展WordPress REST API以用于项目页面、主页面和导航。我们将在下一节中学习如何做到这一点。
- en: Extending the WordPress REST API
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展WordPress REST API
- en: The WordPress REST API can be accessed with `/wp-json/` and is the entry route
    that's appended to your site-based URLs. For example, you can see all the other
    available routes by pointing your browser to `localhost:4000/wp-json/`. You will
    see what endpoints are available in every route, as these can be either GET or
    POST endpoints. For example, the `/wp-json/wp/v2/pages` route has a GET endpoint
    for listing pages and a POST endpoint for creating a page. You can find out more
    about these default routes and endpoints at [https://developer.wordpress.org/rest-api/reference/](https://developer.wordpress.org/rest-api/reference/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress REST API可以通过`/wp-json/`访问，并且是附加到基于站点的URL的入口路由。例如，您可以通过将浏览器指向`localhost:4000/wp-json/`来查看所有其他可用的路由。您将看到每个路由中可用的端点，因为这些可以是GET或POST端点。例如，`/wp-json/wp/v2/pages`路由具有用于列出页面的GET端点和用于创建页面的POST端点。您可以在[https://developer.wordpress.org/rest-api/reference/](https://developer.wordpress.org/rest-api/reference/)找到有关这些默认路由和端点的更多信息。
- en: 'However, if you have custom post types and custom content fields, then you
    will need custom routes and endpoints. We can create custom versions of these
    by registering them with the `register_rest_route` function in the `functions.php`
    file, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您有自定义的文章类型和自定义内容字段，那么您将需要自定义路由和端点。我们可以通过在`functions.php`文件中使用`register_rest_route`函数注册它们来创建这些的自定义版本，如下所示：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s learn how to extend the WordPress REST API:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何扩展WordPress REST API：
- en: 'Create a global namespace and endpoints for fetching the navigation and a single
    page:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于获取导航和单个页面的全局命名空间和端点：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we pass the global namespace to each block of `add_action` by using
    the PHP `use` keyword in the anonymous functions. For more information about the
    PHP `use` keyword and anonymous functions, please visit [https://www.php.net/manual/en/functions.anonymous.php](https://www.php.net/manual/en/functions.anonymous.php).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过在匿名函数中使用PHP的`use`关键字将全局命名空间传递给每个`add_action`块。有关PHP的`use`关键字和匿名函数的更多信息，请访问[https://www.php.net/manual/en/functions.anonymous.php](https://www.php.net/manual/en/functions.anonymous.php)。
- en: For more information about the `register_rest_route` function from WordPress,
    please visit [https://developer.wordpress.org/reference/functions/register_rest_route/](https://developer.wordpress.org/reference/functions/register_rest_route/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有关WordPress的`register_rest_route`函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/register_rest_route/](https://developer.wordpress.org/reference/functions/register_rest_route/)。
- en: 'Create endpoints for fetching a single project page and listing project pages:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为获取单个项目页面和列出项目页面创建端点：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a `fetch_menu` function for fetching the `menu-main` navigation items:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fetch_menu`函数来获取`menu-main`导航项：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use the `wp_get_nav_menu_items` function from WordPress to help us fetch
    the navigation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用WordPress的`wp_get_nav_menu_items`函数来帮助我们获取导航。
- en: For more information about the `wp_get_nav_menu_items` function, please visit
    [https://developer.wordpress.org/reference/functions/wp_get_nav_menu_items/](https://developer.wordpress.org/reference/functions/wp_get_nav_menu_items/).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`wp_get_nav_menu_items`函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/wp_get_nav_menu_items/](https://developer.wordpress.org/reference/functions/wp_get_nav_menu_items/)。
- en: 'Create a `fetch_page` function for fetching a page by slug (or path):'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fetch_page`函数来按slug（或路径）获取页面：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we use the `get_page_by_path` function from WordPress to fetch the page.
    For more information about this function, please visit [https://developer.wordpress.org/reference/functions/get_page_by_path/](https://developer.wordpress.org/reference/functions/get_page_by_path/).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用WordPress的`get_page_by_path`函数来获取页面。有关此函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/get_page_by_path/](https://developer.wordpress.org/reference/functions/get_page_by_path/)。
- en: We also use the `get_field` function from the ACF plugin to fetch the list of
    slide images that are attached to the page and then push them to the `$post` object
    as `slides`. For more information about this function, please visit [https://www.advancedcustomfields.com/resources/get_field/](https://www.advancedcustomfields.com/resources/get_field/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用ACF插件的`get_field`函数来获取附加到页面的幻灯片图片列表，然后将它们作为`slides`推送到`$post`对象中。有关此函数的更多信息，请访问[https://www.advancedcustomfields.com/resources/get_field/](https://www.advancedcustomfields.com/resources/get_field/)。
- en: 'Create a `fetch_project` function in order to fetch a single project page:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fetch_project`函数来获取单个项目页面：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, we use the WordPress `get_page_by_path` function for fetching a page
    for us and the ACF `get_field` function for fetching images (the fullscreen image
    and project images) attached to the project page and then push them to the `$post`
    object as `fullscreen` and `images`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用WordPress的`get_page_by_path`函数来为我们获取页面，并使用ACF的`get_field`函数来获取附加到项目页面的图片（全屏图片和项目图片），然后将它们作为`fullscreen`和`images`推送到`$post`对象中。
- en: 'Create a `fetch_projects` function for fetching a list of project pages, 6
    items per page:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fetch_projects`函数来获取项目页面列表，每页6个项目：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we used the `get_posts` function from WordPress with the required arguments
    to fetch the list. For more information about this function, please visit [https://developer.wordpress.org/reference/functions/get_posts/](https://developer.wordpress.org/reference/functions/get_posts/).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用WordPress的`get_posts`函数以所需的参数来获取列表。有关此函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/get_posts/](https://developer.wordpress.org/reference/functions/get_posts/)。
- en: Then, we loop each project page and push their featured images into the `get_the_post_thumbnail_url`
    function from WordPress. For more information about this function, please visit
    [https://developer.wordpress.org/reference/functions/get_the_post_thumbnail_url/](https://developer.wordpress.org/reference/functions/get_the_post_thumbnail_url/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们循环每个项目页面，并将它们的特色图片推送到WordPress的`get_the_post_thumbnail_url`函数中。有关此函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/get_the_post_thumbnail_url/](https://developer.wordpress.org/reference/functions/get_the_post_thumbnail_url/)。
- en: 'We also need to compute the data (the previous page number and next page number)
    in order to make pagination for project pages, so instead of just returning `$posts`,
    return it as `items` in the following array with the pagination data:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要计算数据（上一页编号和下一页编号），以便为项目页面进行分页，因此，不仅返回`$posts`，还要将其作为以下数组中的`items`返回，并包含分页数据：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we used the `wp_count_posts` function to count the total published project
    pages. For more information about this function, please visit [https://developer.wordpress.org/reference/functions/wp_count_posts/](https://developer.wordpress.org/reference/functions/wp_count_posts/).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`wp_count_posts`函数来计算总发布的项目页面数。有关此功能的更多信息，请访问[https://developer.wordpress.org/reference/functions/wp_count_posts/](https://developer.wordpress.org/reference/functions/wp_count_posts/)。
- en: Log into the WordPress admin UI, go to Rewrite Rules under **Tools**, and click
    the Flush Rules button to refresh the WordPress rewrite rules.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录WordPress管理界面，转到**工具**下的重写规则，并单击刷新规则按钮以刷新WordPress重写规则。
- en: 'Go to your browser and test the custom API routes that you have just created:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到浏览器，测试您刚刚创建的自定义API路由：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should see a bunch of JSON raw data printed on your browser screen. The
    JSON raw data can be difficult to read, but you can use **JSONLint**, a JSON validator,
    for pretty-printing your data at [https://jsonlint.com/](https://jsonlint.com/).
    Alternatively, you can just use **Firefox**, which has the option to pretty-print
    your data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在浏览器屏幕上看到一堆JSON原始数据。JSON原始数据可能很难阅读，但您可以使用**JSONLint**，一个JSON验证器，对您的数据进行漂亮的打印，网址是[https://jsonlint.com/](https://jsonlint.com/)。或者，您也可以使用**Firefox**，它有漂亮打印数据的选项。
- en: You can find the entire code for this in `/chapter-18/cross-domain/backend/wordpress/`,
    in this book's GitHub repository. You can find a sample database (`nuxt-wordpress.sql`)
    in it too. The default **username** and **password** in this sample database for
    logging into the WordPress admin UI is **admin**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-18/cross-domain/backend/wordpress/`中找到此代码的全部内容。您也可以在其中找到一个示例数据库（`nuxt-wordpress.sql`）。用于登录WordPress管理界面的此示例数据库的默认**用户名**和**密码**是**admin**。
- en: Well done! You have successfully extended the WordPress REST API so that it
    supports custom post types. We don't need to develop any new theme in WordPress
    to view our content because this will be handled by Nuxt. We can keep WordPress'
    existing themes for previewing the content. This means we are only using WordPress
    to host our site content remotely, including all the media files (images, videos,
    and so on). Furthermore, we can generate static pages using Nuxt (just like we
    did in the previous chapters) and stream all the media files from WordPress to
    our Nuxt project so that we can host them locally. We'll learn how to do this
    in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您已成功扩展了WordPress REST API，以便支持自定义文章类型。我们不需要在WordPress中开发任何新主题来查看我们的内容，因为这将由Nuxt处理。我们可以保留WordPress的现有主题来预览内容。这意味着我们只是使用WordPress远程托管我们网站的内容，包括所有媒体文件（图片、视频等）。此外，我们可以使用Nuxt生成静态页面（就像我们在前几章中所做的那样），并从WordPress流式传输所有媒体文件到我们的Nuxt项目，以便我们可以在本地托管它们。我们将在下一节学习如何做到这一点。
- en: Integrating with Nuxt and streaming images from WordPress
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Nuxt集成和从WordPress流式传输图像
- en: 'Integrating Nuxt with the WordPress REST API is similar to when you integrated
    with the cross-domain APIs you learned about and created in the previous chapters.
    However, in this section, we will improve the plugin that we use to load images
    by requiring them from the `/assets/` directory. But since our images are uploaded
    to the WordPress CMS and are kept in the `/uploads/` directory in our WordPress
    project, we need to refactor our asset loader plugin so that it requires the images
    from the `/assets/` directory when they are found in there; otherwise, we just
    load them remotely from WordPress. Let''s get started:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将Nuxt与WordPress REST API集成类似于您在前几章中学习和创建跨域API集成时的操作。但是，在本节中，我们将改进我们用于加载图像的插件，通过从`/assets/`目录中要求它们来加载。但由于我们的图像是上传到WordPress
    CMS并保存在我们的WordPress项目的`/uploads/`目录中，因此我们需要重构我们的资产加载器插件，以便在那里找到图像时从`/assets/`目录中要求它们；否则，我们将从WordPress远程加载它们。让我们开始吧：
- en: 'Set `remote URL` for the Axios instance in the Nuxt config file, as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件中为Axios实例设置`remote URL`，如下所示：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create an Axios instance and inject it into the Nuxt context directly as `$axios`.
    Also, add this Axios instance to the `app` option into the context using the `inject`
    function:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Axios实例，并将其直接注入到Nuxt上下文中作为`$axios`。还可以使用`inject`函数将此Axios实例添加到上下文中的`app`选项中：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Refactor the asset loader plugin, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新设计资产加载器插件，如下所示：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we split the image URL string into an array, get the image's filename
    (for example, `my-image.jpg`) from the last item in the array, and store it in
    the `last` variable. We then require the image locally using the filename (`last`).
    If an error is thrown, that means the image does not exist in the `/assets/` directory,
    so we just return the image's URL (`src`) as it is.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将图像URL字符串拆分为一个数组，从数组的最后一项中获取图像的文件名（例如`my-image.jpg`），并将其存储在`last`变量中。然后我们使用文件名（`last`）在本地获取图像。如果抛出错误，这意味着图像在`/assets/`目录中不存在，因此我们只是返回图像的URL（`src`）。
- en: However, we will stream the image from the remote URL to the `/assets/` directory
    using a `streamResource` function when our app is running on the server-side and
    the `streamRemoteResource` option is `true`. You will find out how to create this
    option (just like the `remoteURL` option) in the upcoming step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们的应用在服务器端运行且`streamRemoteResource`选项为`true`时，我们将使用`streamResource`函数从远程URL流式传输图像到`/assets/`目录。您将在接下来的步骤中了解如何创建此选项（就像`remoteURL`选项一样）。
- en: 'Create a `stream-resource.js` file with the `streamResource` function in the
    `/assets/` directory, as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/assets/`目录中创建一个带有`streamResource`函数的`stream-resource.js`文件，如下所示：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this function, we use plain Axios to request the data of the remote resource
    by specifying `stream` as the response type. We then use the `createWriteStream`
    function from the Node.js built-in File System (fs) package with the necessary
    filepath to create the image in the `/assets/` directory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们使用普通的Axios来请求远程资源的数据，并将`stream`作为响应类型。然后，我们使用Node.js内置的文件系统（fs）包中的`createWriteStream`函数以及必要的文件路径来在`/assets/`目录中创建图像。
- en: For more information about the `fs` package and its `createWriteStream` function,
    please visit [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)
    and [https://nodejs.org/api/fs.htmlfs_fs_createwritestream_path_options](https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`fs`包及其`createWriteStream`函数的更多信息，请访问[https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)和[https://nodejs.org/api/fs.htmlfs_fs_createwritestream_path_options](https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options)。
- en: For more information about the Node.js stream's `pipe` event in the response
    data and the Node.js stream itself, please visit [https://nodejs.org/api/stream.htmlstream_event_pipe](https://nodejs.org/api/stream.html#stream_event_pipe)
    and [https://nodejs.org/api/stream.htmlstream_stream](https://nodejs.org/api/stream.html#stream_stream).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Node.js流的`pipe`事件和Node.js流本身的更多信息，请访问[https://nodejs.org/api/stream.htmlstream_event_pipe](https://nodejs.org/api/stream.html#stream_event_pipe)和[https://nodejs.org/api/stream.htmlstream_stream](https://nodejs.org/api/stream.html#stream_stream)。
- en: 'Register both plugins in the Nuxt config file:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件中注册这两个插件：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Refactor the home page''s `index.vue` in the `/pages/` directory in order to
    use these two plugins, as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构`/pages/`目录中的主页`index.vue`以使用这两个插件，如下所示：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we used `$axios` from our plugin to request the WordPress API. After receiving
    the data, we populated it in the `<template>` block. The `$loadAssetImage` function
    is used to run logic on how to load and process the image for us.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了我们的插件中的`$axios`来请求WordPress API。在接收到数据后，我们将其填充到`<template>`块中。`$loadAssetImage`函数用于运行关于如何加载和处理图像的逻辑。
- en: The rest of the pages in the `/pages/` directory should be refactored and follow
    the same pattern we followed for the home page. They are `/about.vue`, `/contact.vue`,
    `/projects/index.vue`, `/projects/_slug.vue`,  and `/projects/pages/_number.vue`.
    Also, you need to do this for the component in the `/components/` directory; that
    is, `/projects/project-items.vue`. You can find the repository path to these completed
    files in the GitHub repositories provided at the end of this section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`/pages/`目录中的其余页面应该进行重构，并遵循我们为主页所遵循的相同模式。它们是`/about.vue`、`/contact.vue`、`/projects/index.vue`、`/projects/_slug.vue`和`/projects/pages/_number.vue`。此外，你还需要对`/components/`目录中的组件进行相同的操作；也就是说，`/projects/project-items.vue`。你可以在本节末尾提供的GitHub存储库中找到这些已完成文件的存储库路径。'
- en: 'Create another script command with a custom environment variable, `NUXT_ENV_GEN`,
    and put `stream` as its value in the `package.json` file in our Nuxt project:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Nuxt项目的`package.json`文件中，使用自定义环境变量`NUXT_ENV_GEN`创建另一个脚本命令，并将`stream`作为其值：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In Nuxt, if you create an environment variable prefixed with `NUXT_ENV_` in
    the `package.json` file, it will be injected into the Node.js process environment
    automatically. After doing this, you can access it throughout the app via the
    `process.env` object – including other custom properties you might set in the
    `env` property in the Nuxt config file
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nuxt中，如果你在`package.json`文件中创建一个以`NUXT_ENV_`为前缀的环境变量，它将自动注入到Node.js进程环境中。这样做后，你可以通过`process.env`对象在整个应用程序中访问它，包括你可能在Nuxt配置文件的`env`属性中设置的其他自定义属性。
- en: For more information about the `env` property in Nuxt, please visit [https://nuxtjs.org/api/configuration-env/](https://nuxtjs.org/api/configuration-env/).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Nuxt中`env`属性的更多信息，请访问[https://nuxtjs.org/api/configuration-env/](https://nuxtjs.org/api/configuration-env/)。
- en: 'Define the `streamRemoteResource` option for the asset loader plugin (which
    we refactored in *step 3*) in the `env` property in the Nuxt config file, as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件的`env`属性中为资产加载器插件（我们在*步骤3*中重构的）定义`streamRemoteResource`选项，如下所示：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This `streamRemoteResource` option will be set to `true` when we get the `stream`
    value from the `NUXT_ENV_GEN` environment variable; otherwise, it is always set
    to `false`. So, when this option is set to `true`, the asset loader plugin will
    start streaming the remote resources to the `/assets/` directory for us.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从`NUXT_ENV_GEN`环境变量获取`stream`值时，`streamRemoteResource`选项将设置为`true`；否则，它始终设置为`false`。因此，当此选项设置为`true`时，资产加载器插件将开始将远程资源流式传输到`/assets/`目录。
- en: '(Optional) If the Nuxt crawler fails to detect the dynamic routes for some
    unknown reasons, then generate these routes manually in the `generate` option
    in the Nuxt config file, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）如果Nuxt爬虫由于某些未知原因无法检测到动态路由，则可以在Nuxt配置文件的`generate`选项中手动生成这些路由，方法如下：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this optional step, we used Axios to fetch all the child pages that belong
    to the `projects` post type, and used the JavaScript `map` method to loop these
    pages in order to generate their routes. And then, we took the length of the child
    pages to work out how many maximum pages in number (`totalMaxPages`) by dividing
    the child pages by six (making six items per page). After that, we converted the `totalMaxPages` number
    into an array by using the JavaScript `Array` object, and then used the Javascript `fill`, `map`,
    and `push` methods to loop the array in order to generate the dynamic routes for
    pagination. Lastly, we concatenated the routes from the child pages and pagination
    with the JavaScript spread operator, and then return them as a single array for
    Nuxt to generate the dynamic routes for us.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个可选的步骤中，我们使用Axios来获取属于`projects`文章类型的所有子页面，并使用JavaScript的`map`方法循环这些页面以生成它们的路由。然后，我们通过将子页面除以六（每页六个项目）来计算出子页面的最大页面数（`totalMaxPages`）。然后，我们使用JavaScript的`Array`对象将`totalMaxPages`数字转换为数组，然后使用JavaScript的`fill`，`map`和`push`方法循环数组以生成分页的动态路由。最后，我们使用JavaScript的展开运算符将子页面和分页的路由连接起来，然后将它们作为单个数组返回，以便Nuxt为我们生成动态路由。
- en: For more information about the JavaScript `map`, `fill`, and `push` methods,
    please visit [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map), [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill),
    and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push),
    respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JavaScript `map`，`fill`和`push`方法的更多信息，请访问[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)，[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)，以及[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push)。
- en: 'Run the `stream` command first, followed by the `generate` command on your
    terminal, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在终端上运行`stream`命令，然后运行`generate`命令，如下所示：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We use the `stream` command to stream the remote resources to the `/assets/`
    directory by generating the first batch of static pages, then the `generate` command
    to regenerate the static pages. At this point, webpack will process the images
    in the `/assets/` directory and export them to the `/dist/` folder with the static
    pages. So, after running these two commands, you should see that the remote resources
    are streamed and processed in `/assets/` and `/dist/`. You can navigate to these
    two directories and inspect the downloaded resources.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`stream`命令将远程资源流式传输到`/assets/`目录，生成第一批静态页面，然后使用`generate`命令重新生成静态页面。此时，webpack将处理`/assets/`目录中的图像，并将其与静态页面一起导出到`/dist/`文件夹中。因此，在运行这两个命令后，您应该看到远程资源在`/assets/`和`/dist/`中被流式传输和处理。您可以转到这两个目录并检查已下载的资源。
- en: You can find the Nuxt app of this section in `/chapter-18/cross-domain/frontend/nuxt-universal/nuxt-wordpress/axios-vanilla/`
    in this book's GitHub repository.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-18/cross-domain/frontend/nuxt-universal/nuxt-wordpress/axios-vanilla/`中找到本节的Nuxt应用程序。
- en: Well done! You have successfully integrated Nuxt with the WordPress REST API
    and streamed remote resources for static pages. WordPress may not be everyone's
    choice since it does not comply with **PHP Standards Recommendations** (**PSRs**)
    ([https://www.php-fig.org/](https://www.php-fig.org/)) and has its own way of
    getting things done. But it was released in 2003 before PSR and many modern PHP
    frameworks. It has been able to support countless businesses and individuals ever
    since. Of course, it has evolved and offers one of the most user-friendly admin
    UIs for editors and developers alike.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您已成功将Nuxt与WordPress REST API集成，并为静态页面流式传输远程资源。WordPress可能不是每个人的选择，因为它不符合**PHP标准建议**（**PSRs**）([https://www.php-fig.org/](https://www.php-fig.org/))，并且有其自己的完成任务的方式。但它是在2003年发布的，早于PSR和许多现代PHP框架。自那时以来，它已能够支持无数的企业和个人。当然，它已经发展，并为编辑和开发人员提供了最用户友好的管理UI之一。
- en: If this hasn't convinced you to use WordPress as an API, there are other options.
    In the next section, we are going to look at an alternative to REST APIs – GraphQL
    APIs – and an alternative to WordPress in Node.js – Keystone. Keystone uses GraphQL
    to deliver its API. Before diving into GraphQL, we'll take a look at Keystone
    and learn how to develop customized CMS.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这没有说服您使用WordPress作为API，还有其他选择。在下一节中，我们将看看REST API的替代方案 - GraphQL API - 以及Node.js中WordPress的替代方案
    - Keystone。Keystone使用GraphQL来提供其API。在深入研究GraphQL之前，我们将看看Keystone，并学习如何开发定制的CMS。
- en: Introducing Keystone
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Keystone
- en: Keystone is a scalable headless CMS for building GraphQL APIs in Node.js. It
    is open source and equipped with a very decent admin UI where you can manage your
    content. Just like WordPress, you can create custom content types in Keystone
    called **lists** and then query your contents through the GraphQL API. You create
    lists from source, just like you create REST APIs. You add what you need for your
    API so that it is highly scalable and extensible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Keystone是一个可扩展的无头CMS，用于在Node.js中构建GraphQL API。它是开源的，并配备了一个非常体面的管理UI，您可以在其中管理您的内容。就像WordPress一样，您可以在Keystone中创建称为**列表**的自定义内容类型，然后通过GraphQL
    API查询您的内容。您可以从源代码创建列表，就像创建REST API一样。您可以为API添加所需的内容，使其具有高度可扩展性和可扩展性。
- en: To use Keystone, first, you need to prepare a database for storing your content.
    Keystone supports MongoDB and PostgreSQL. You need to install and configure one
    of them and then find out the connection string for Keystone. You learned about MongoDB
    in [Chapter 9](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml), *Adding a Server-Side
    Database*, so using it again as the database for Keystone should not be an issue
    for you. But what about PostgreSQL? Let's find out.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Keystone，首先，您需要准备一个用于存储内容的数据库。Keystone支持MongoDB和PostgreSQL。您需要安装和配置其中一个，然后找出Keystone的连接字符串。您在[第9章](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml)中了解了MongoDB，*添加服务器端数据库*，因此再次将其用作Keystone的数据库不应该成为问题。但是PostgreSQL呢？让我们找出来。
- en: For more information about Keystone, please visit [https://www.keystonejs.com/](https://www.keystonejs.com/).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Keystone的更多信息，请访问[https://www.keystonejs.com/](https://www.keystonejs.com/)。
- en: Installing and securing PostgreSQL (Ubuntu)
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和保护PostgreSQL（Ubuntu）
- en: PostgreSQL, also known as Postgres, is an object-relational database system,
    often compared with MySQL, which is a (purely) relational database management
    system (RDBMS). Both are open source and use tables but have their differences.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL，也称为Postgres，是一种面向对象的关系数据库系统，通常与MySQL进行比较，后者是一种（纯粹的）关系数据库管理系统（RDBMS）。两者都是开源的，使用表格，但它们有各自的区别。
- en: For example, Postgres is largely SQL compliant while MySQL is partially compliant,
    and MySQL performs faster in terms of read speed while PostgreSQL is faster at
    injecting complex queries. For more information about Postgres, please visit [https://www.postgresql.org/](https://www.postgresql.org/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Postgres在很大程度上符合SQL标准，而MySQL在部分方面符合标准，MySQL在读取速度方面更快，而PostgreSQL在注入复杂查询方面更快。有关Postgres的更多信息，请访问[https://www.postgresql.org/](https://www.postgresql.org/)。
- en: 'You can install Postgres on many different operating systems, including Linux,
    macOS, and Windows. Depending on your operating system, you can follow the official
    guide at [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    to install it on your machine. We will show you how to install and secure it on
    Linux, specifically Ubuntu, in the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在许多不同的操作系统上安装Postgres，包括Linux、macOS和Windows。根据您的操作系统，您可以按照官方指南在您的计算机上安装它。我们将向您展示如何在Linux上安装和保护它，特别是Ubuntu，具体步骤如下：
- en: 'Update your local package index and install Postgres from Ubuntu''s default
    repositories using Ubuntu''s `apt` packaging system:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的本地软件包索引，并使用Ubuntu的`apt`包装系统从Ubuntu的默认存储库安装Postgres：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Verify Postgres by checking its version:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查其版本来验证Postgres：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you get the following output, this means you have installed it successfully:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您获得以下输出，则表示您已成功安装：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The number **12** in the path indicates you have Postgres version 12 on your
    machine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 路径中的数字**12**表示您的计算机上安装了Postgres 12版本。
- en: 'Enter the Postgres shell from your terminal:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端输入Postgres shell：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should get an output similar to the following on your terminal:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端上获得类似以下的输出：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'List the default users using the Postgres `\du` command:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Postgres的`\du`命令列出默认用户：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should get two default users, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该获得两个默认用户，如下所示：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will add a new administrative user (or role) to the list using an interactive
    prompt on our terminal. However, we need to exit the Postgres shell first:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用终端上的交互提示向列表中添加一个新的管理用户（或角色）。但是，我们首先需要退出Postgres shell：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Type in the following command with the `--interactive` flag:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--interactive`标志输入以下命令：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see the following two questions regarding the name of the new role
    and whether the role should have superuser permissions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关于新角色名称以及角色是否应该具有超级用户权限，您应该看到以下两个问题：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we called the new user `user1`. It has superuser permissions, just like
    the default users do.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将新用户称为`user1`。它具有超级用户权限，就像默认用户一样。
- en: Log into the Postgres shell with `sudo -u postgres psql` to verify the new user
    with the `\du` command. You should see that it has been added to the list.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sudo -u postgres psql`登录Postgres shell以验证新用户是否已添加到列表中。
- en: 'Add a password to the new user with the following SQL query:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下SQL查询为新用户添加密码：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you get the following output, then you have successfully added a password
    for this user:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您获得以下输出，则已成功为此用户添加了密码：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Exit the Postgres shell. Now, you can use PHP''s Adminer ([https://www.adminer.org/](https://www.adminer.org/))
    to log into Postgres with this user and, from there, add a new database that will
    be required when you install Keystone later. Then, you can use the following format
    for the Postgres connection string for the database you have just created:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出Postgres shell。现在，您可以使用PHP的Adminer ([https://www.adminer.org/](https://www.adminer.org/))使用此用户登录Postgres，并在那里添加一个新的数据库，这将在稍后安装Keystone时需要。然后，您可以使用以下格式的Postgres连接字符串连接刚刚创建的数据库：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that a password is always required for any user to log into the database
    from Adminer for security reasons. So, it is a good practice to add security to
    your database, especially for production, regardless of whether it is a MySQL,
    Postgres, or MongoDB database. What about MongoDB? You learned to install and
    use it in previous chapters, but it hasn't been secured yet. We'll find out how
    to do this in the next section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，出于安全原因，任何用户要从Adminer登录到数据库都需要密码。因此，无论是MySQL、Postgres还是MongoDB数据库，都最好添加安全性。MongoDB呢？您在之前的章节中学习了如何安装和使用它，但尚未进行安全保护。我们将在下一节中了解如何做到这一点。
- en: Installing and securing MongoDB (Ubuntu)
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和保护MongoDB（Ubuntu）
- en: 'By now, you should know how to install MongoDB. So, in this section, we will
    focus on securing databases in MongoDB. To secure MongoDB, we will start by adding
    an administrative user to MongoDB, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该知道如何安装MongoDB。因此，在本节中，我们将专注于保护MongoDB中的数据库。为了保护MongoDB，我们将首先添加一个管理用户到MongoDB，如下所示：
- en: 'Connect to the Mongo shell from your terminal:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端连接到Mongo shell：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Select the `admin` database and add a new user with a username and password
    (for example, root and password) to this database, as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“admin”数据库，并向该数据库添加一个具有用户名和密码（例如，root和password）的新用户，如下所示：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Exit the shell and open the MongoDB configuration file from your terminal:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出shell并从终端打开MongoDB配置文件：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Look for the `security` section, remove the hash, and add the `authorization`
    setting, as shown here:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找“security”部分，删除哈希，并添加“authorization”设置，如下所示：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Save and exit the file and restart MongoDB:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并退出文件，然后重新启动MongoDB：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Verify the configuration by checking the status of MongoDB:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查MongoDB的状态来验证配置：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you see an `"active"` status, that means you have configured it correctly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果看到“active”状态，这意味着您已正确配置。
- en: 'Log in as `"root"` with the password and the `--authenticationDatabase` option.
    Also, supply the name of the database where the user is stored, which is `"admin"`
    in this case:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用密码和“--authenticationDatabase”选项以“root”身份登录。此外，在此情况下，提供存储用户的数据库的名称，即“admin”：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a new database (for example, `test`) and attach a new user to it:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的数据库（例如，`test`）并将一个新用户附加到其中：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Exit and test the database by logging in as `user1`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出并以“user1”身份登录以测试数据库：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Test whether you can access this `test` database but not other databases:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试是否可以访问此“test”数据库，但不能访问其他数据库：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you receive no output, that means you are only authorized to access this
    database after authentication. You can use the following format to supply the
    MongoDB connection string for Keystone or any other apps (for example, Express,
    Koa, and so on):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有输出，这意味着您只有在经过身份验证后才有权访问此数据库。您可以使用以下格式为Keystone或任何其他应用程序（例如Express、Koa等）提供MongoDB连接字符串：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Again, it is good practice to add security to the database, especially for production,
    but it is easier and faster to develop apps with MongoDB without authentication
    enabled. You can always disable it for local development and just enable it in
    the production server.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为数据库添加安全性是一个好习惯，尤其是对于生产环境，但在MongoDB中启用身份验证会使开发应用程序变得更加简单和快速。您可以在本地开发时始终禁用它，并在生产服务器上启用它。
- en: Now, both database systems (Postgres and MongoDB) are ready and you can choose
    either of them to build your Keystone app. So, let's get to it!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个数据库系统（Postgres和MongoDB）都已准备就绪，您可以选择其中任何一个来构建Keystone应用程序。所以，让我们开始吧！
- en: Installing and creating Keystone apps
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和创建Keystone应用程序
- en: 'There are two ways to start a Keystone project – from scratch or by using the
    Keystone scaffolding tool known as `keystone-app`. If you are going to do it from
    scratch, you need to install any Keystone-related packages manually. These include
    the minimum required Keystone''s packages and the additional Keystone packages
    that you need to build your app. Let''s take a look at this manual installation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以启动Keystone项目 - 从头开始或使用称为`keystone-app`的Keystone搭建工具。如果您要从头开始，您需要手动安装任何与Keystone相关的软件包。这些包括最低要求的Keystone软件包和您构建应用程序所需的其他Keystone软件包。让我们来看看这个手动安装：
- en: 'Create a project directory and install the minimum required packages – the
    Keystone package itself, the Keystone GraphQL package (which is considered as
    an app in Keystone), and a database adapter:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个项目目录并安装最低要求的软件包 - Keystone软件包本身，Keystone GraphQL软件包（在Keystone中被视为应用程序），以及数据库适配器：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Install the additional Keystone packages that you need, such as the Keystone
    Admin UI package (which is considered an app in Keystone) and the Keystone field
    package for registering lists:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装您需要的其他Keystone软件包，例如Keystone Admin UI软件包（在Keystone中被视为应用程序）和用于注册列表的Keystone字段软件包：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create an empty `index.js` file in your root directory and import the packages
    you have just installed:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录中创建一个空的`index.js`文件，并导入您刚刚安装的软件包：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a new instance of Keystone and pass the new instance of the database
    adapter to it, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Keystone的新实例，并将新的数据库适配器实例传递给它，如下所示：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Check out the following guide to learn how to configure the Mongoose adapter: [https://www.keystonejs.com/keystonejs/adapter-mongoose/](https://www.keystonejs.com/keystonejs/adapter-mongoose/).
    We will cover this again when we install Keystone with the scaffolding tool.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下指南，了解如何配置Mongoose适配器：[https://www.keystonejs.com/keystonejs/adapter-mongoose/](https://www.keystonejs.com/keystonejs/adapter-mongoose/)。当我们使用搭建工具安装Keystone时，我们将再次介绍这个。
- en: 'Create a simple list – a `Page` list, for example – and define the fields that
    you will need in order to store the data for every single item in this list:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的列表 - 例如`Page`列表，并定义您需要的字段，以便存储此列表中每个单个项目的数据：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It is a convention to capitalize the name of the list for GraphQL. We will cover
    this soon.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GraphQL，将列表的名称大写是一种惯例。我们很快会介绍这个。
- en: 'Export the `keystone` instance and the apps so that they can be executed:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出`keystone`实例和应用程序，以便可以执行它们：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a `package.json` file (if you haven''t done so already) and add the
    following `keystone` command to the scripts, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`package.json`文件（如果您还没有这样做），并添加以下`keystone`命令到脚本中，如下所示：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Start the app by running the `dev` script on your terminal:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端上运行`dev`脚本来启动应用程序：
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You should see the following output on your terminal. This means you have started
    the app successfully:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端上看到以下输出。这意味着您已成功启动了应用程序：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Well done! You have your first and simplest Keystone app up and running. In
    this app, you have a GraphQL API at `localhost:3000/admin/api`, a GraphQL Playground
    at `localhost:3000/admin/graphiql`, and a Keystone Admin UI at `localhost:3000/admin`.
    But how do we use the GraphQL API and GraphQL Playground? Rest assured, we will
    get to that in the upcoming section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您的第一个和最简单的Keystone应用程序已经开始运行。在这个应用程序中，您在`localhost:3000/admin/api`上有一个GraphQL
    API，在`localhost:3000/admin/graphiql`上有一个GraphQL Playground，在`localhost:3000/admin`上有一个Keystone
    Admin UI。但是我们如何使用GraphQL API和GraphQL Playground呢？放心，我们将在接下来的部分中介绍。
- en: 'It is not difficult at all to start a new Keystone app, is it? You just need
    to install what Keystone requires and what you need. However, the easiest way
    to kick off a Keystone app is by using the scaffolding tool. The benefit of using
    the scaffolding tool is that it comes with some optional samples of Keystone apps
    during the installation process and they can be very useful as guides and templates.
    These optional samples are as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的Keystone应用并不难，是吗？您只需要安装Keystone所需的内容。然而，启动Keystone应用的最简单方法是使用脚手架工具。使用脚手架工具的好处是，在安装过程中它附带了一些Keystone应用的可选示例，它们可以作为指南和模板非常有用。这些可选示例如下：
- en: '**Starter**:This example demonstrates basic user authentication using Keystone.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入门**：这个示例演示了使用Keystone进行基本用户身份验证。'
- en: '**Todo**:This example demonstrates a simple app for adding items to a `Todo`
    list, along with some frontend integration (HTML, CSS, and JavaScript).'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Todo**：这个示例演示了一个简单的应用程序，用于向`Todo`列表添加项目，以及一些前端集成（HTML、CSS和JavaScript）。'
- en: '**Blank**:This example provides a basic starting point, along with the Keystone
    Admin UI, GraphQL API, and GraphQL Playground. These are just like the ones in
    the manual installation but without the Keystone `field` package.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空白**：这个示例提供了一个基本的起点，以及Keystone管理UI、GraphQL API和GraphQL Playground。这些与手动安装中的内容一样，但没有Keystone
    `field`包。'
- en: '**Nuxt**:This example demonstrates a simple integration with Nuxt.js.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nuxt**：这个示例演示了与Nuxt.js的简单集成。'
- en: 'We will go for the **blank** option because it provides us with the basic packages
    we need so that we can build our lists on top of them. Let''s take a look:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择**空白**选项，因为它为我们提供了我们需要的基本包，这样我们就可以在其基础上构建我们的列表。让我们来看一下：
- en: 'Create a fresh Keystone app with any name on your terminal:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上创建一个任何名称的全新Keystone应用程序：
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Answer the questions that Keystone asks about, as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回答Keystone提出的问题，如下：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'After the installation is complete, move into your project directory:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，进入您的项目目录：
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you are using secured Postgres, then just provide the connection string,
    along with the username, password, and database for Keystone:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用安全的Postgres，只需提供连接字符串，以及Keystone的用户名、密码和数据库：
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note that you just have to remove `<username>:<password>@` from the string
    if you don''t have authentication enabled. Then, run the following command to
    install the database tables:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您没有启用身份验证，只需从字符串中删除`<username>:<password>@`。然后，运行以下命令来安装数据库表：
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: For more information about the Knex database adapter, please visit [https://www.keystonejs.com/quick-start/adapters](https://www.keystonejs.com/quick-start/adapters)
    or visit knex.js at [http://knexjs.org/](http://knexjs.org/). It is a query builder
    for PostgreSQL, MySQL, and SQLite3.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Knex数据库适配器的更多信息，请访问[https://www.keystonejs.com/quick-start/adapters](https://www.keystonejs.com/quick-start/adapters)或访问knex.js网站[http://knexjs.org/](http://knexjs.org/)。它是用于PostgreSQL、MySQL和SQLite3的查询构建器。
- en: 'If you are using secured MongoDB, then just provide the connection string,
    along with the username, password, and database for Keystone:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用安全的MongoDB，只需提供连接字符串，以及Keystone的用户名、密码和数据库：
- en: '[PRE65]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that you just have to remove `<username>:<password>@` from the string if
    you don't have authentication enabled.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您没有启用身份验证，只需从字符串中删除`<username>:<password>@`。
- en: For more information about the Mongoose database adapter, please visit [https://www.keystonejs.com/keystonejs/adapter-mongoose/](https://www.keystonejs.com/keystonejs/adapter-mongoose/)
    or visit Mongoose at [https://mongoosejs.com/](https://mongoosejs.com/). MongoDB
    is a **schemaless** database system by nature, so this adapter is used as a schema
    solution to model the data in our app.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Mongoose数据库适配器的更多信息，请访问[https://www.keystonejs.com/keystonejs/adapter-mongoose/](https://www.keystonejs.com/keystonejs/adapter-mongoose/)或访问Mongoose
    [https://mongoosejs.com/](https://mongoosejs.com/)。MongoDB本质上是一个**无模式**的数据库系统，因此该适配器用作模式解决方案，以对我们应用程序中的数据进行建模。
- en: 'Change the server default port from `3000` to `4000` to serve the Keystone
    app. You can do this by simply adding `PORT=4000` to the `dev` script, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将服务器默认端口从`3000`更改为`4000`以提供Keystone应用程序。您可以通过简单地将`PORT=4000`添加到`dev`脚本中来实现这一点，如下所示：
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The reason we changed the port for Keystone to `4000` is because we are reserving
    port `3000` for Nuxt apps.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将Keystone的端口更改为`4000`的原因是因为我们为Nuxt应用程序保留了端口`3000`。
- en: 'Install `nodemon` in our project. This will allow us to monitor changes in
    our Keystone app so that it can reload the server for us:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目中安装`nodemon`。这将允许我们监视Keystone应用程序中的更改，以便它可以为我们重新加载服务器：
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After installing this package, add the `nodemon --exec` command to the `dev`
    script, as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装此软件包后，将`nodemon --exec`命令添加到`dev`脚本中，如下所示：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: For more information about nodemon, please visit [https://nodemon.io/](https://nodemon.io/).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有关nodemon的更多信息，请访问[https://nodemon.io/](https://nodemon.io/)。
- en: 'Start the development server for our Keystone app with the following command:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动我们的Keystone应用程序的开发服务器：
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You should see the following output on your terminal. This means you have installed
    the Keystone app successfully:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端上看到以下输出。这意味着您已成功安装了Keystone应用程序：
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is the same as performing the manual installation but on a different port.
    In this app, you have a GraphQL API at `localhost:4000/admin/api`, a GraphQL Playground
    at `localhost:4000/admin/graphiql`, and a Keystone Admin UI at `localhost:4000/admin`.
    Before we can do anything with the GraphQL API and GraphQL Playground, we must
    add lists to our Keystone app and start injecting data from the Keystone Admin
    UI. We'll start adding lists and fields to the app in the next section.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在不同端口上执行手动安装相同。在此应用程序中，您可以在`localhost:4000/admin/api`上找到GraphQL API，在`localhost:4000/admin/graphiql`上找到GraphQL
    Playground，在`localhost:4000/admin`上找到Keystone Admin UI。在我们可以对GraphQL API和GraphQL
    Playground执行任何操作之前，我们必须向Keystone应用程序添加列表，并开始从Keystone Admin UI注入数据。我们将在下一节中开始向应用程序添加列表和字段。
- en: You can find the apps we created from both of these installation techniques
    in `/chapter-18/keystone/` in this book's GitHub repository.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库的`/chapter-18/keystone/`中找到我们从这两种安装技术创建的应用程序。
- en: Creating lists and fields
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建列表和字段
- en: 'In Keystone, lists are schemas. A schema is a data model that has types that
    describe our data. It is the same in Keystone: a list schema is composed of fields
    that have types to describe the data they accept, just like we had in the manual
    installation, in which we have a `Page` list composed of a single `name` field
    with a `Text` type.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Keystone中，列表是模式。模式是一个具有描述我们数据的类型的数据模型。在Keystone中也是一样的：列表模式由具有描述其接受的数据的类型的字段组成，就像我们在手动安装中所做的那样，在那里我们有一个由单个`Text`类型的`name`字段组成的`Page`列表。
- en: There are many different field types in Keystone, such as `File`, `Float`, `Checkbox`,
    `Content`, `DateTime`, `Slug`, and `Relationships`. You can find out about the
    rest of the Keystone field types that you need in their documentation at [https://www.keystonejs.com/](https://www.keystonejs.com/).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Keystone中有许多不同的字段类型，例如`File`、`Float`、`Checkbox`、`Content`、`DateTime`、`Slug`和`Relationships`。您可以在[https://www.keystonejs.com/](https://www.keystonejs.com/)的文档中找到您需要的其余Keystone字段类型的信息。
- en: To add fields and their types to the list, you just have to install the Keystone
    packages that hold those field types in your project directory. For example, the
    `@keystonejs/fields` package holds the `Checkbox`, `Text`, `Float`, and `DateTime`
    field types, among others. You can find out about the rest of the field types
    at [https://www.keystonejs.com/keystonejs/fields/fields](https://www.keystonejs.com/keystonejs/fields/#fields).
    After you have the required field type packages installed, you can just import
    them and unpack the field types you need by using the JavaScript destructuring
    assignment for list creation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要向列表添加字段及其类型，您只需在项目目录中安装包含这些字段类型的Keystone软件包。例如，`@keystonejs/fields`软件包包含`Checkbox`、`Text`、`Float`和`DateTime`字段类型，以及其他字段类型。您可以在[https://www.keystonejs.com/keystonejs/fields/fields](https://www.keystonejs.com/keystonejs/fields/#fields)了解其余字段类型。安装所需的字段类型软件包后，您只需导入它们，并使用JavaScript解构赋值来解压所需的字段类型，以便创建列表。
- en: 'However, lists can grow over time, which means they can become messy and difficult
    to keep up with. So, it is a good idea to create lists in **separate** files in
    a `/list/` directory for better maintainability, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，列表可能会随着时间的推移而增长，这意味着它们可能变得混乱和难以跟上。因此，最好将列表创建在`/list/`目录中的**单独**文件中，以便更好地维护，如下所示：
- en: '[PRE71]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, you just have to import it into the `index.js` file. So, let''s find
    out what schema/lists and other Keystone packages we need to build our Keystone
    app. The lists that we are going to create are as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您只需将其导入到`index.js`文件中。因此，让我们找出我们构建Keystone应用程序所需的模式/列表和其他Keystone软件包。我们将要创建的列表如下：
- en: A `Page` schema/list for storing main pages such as `home`, `about`, `contact`,
    and `projects`
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储主要页面（如`home`、`about`、`contact`和`projects`）的`Page`模式/列表
- en: A `Project` schema/list for storing project pages
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储项目页面的`Project`模式/列表
- en: An `Image` schema/list for storing images for main and project pages
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储主要和项目页面图像的`Image`模式/列表
- en: A `Slide Image` schema/list for storing images for main pages only
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于仅存储主要页面图像的`Slide Image`模式/列表
- en: A `Nav Link` schema/list for storing the site links
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储站点链接的`Nav Link`模式/列表
- en: 'The Keystone packages that we are going to use to create these lists are as
    follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的Keystone软件包来创建这些列表如下：
- en: '**Static file app**: This package is used to serve static files such as images,
    CSS, and JavaScript so that they can be accessed publicly by the client. For more
    information, please visit [https://www.keystonejs.com/keystonejs/app-static/](https://www.keystonejs.com/keystonejs/app-static/).'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态文件应用程序**：此软件包用于提供静态文件，如图像、CSS和JavaScript，以便客户端可以公开访问。有关更多信息，请访问[https://www.keystonejs.com/keystonejs/app-static/](https://www.keystonejs.com/keystonejs/app-static/)。'
- en: '**File adapters**:This package is used to support the `File` field type, which
    is used to upload files to a local or remote cloud-based location. For more information,
    please visit [https://www.keystonejs.com/keystonejs/file-adapters/](https://www.keystonejs.com/keystonejs/file-adapters/).'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件适配器**：此软件包用于支持`File`字段类型，该类型用于将文件上传到本地或远程基于云的位置。有关更多信息，请访问[https://www.keystonejs.com/keystonejs/file-adapters/](https://www.keystonejs.com/keystonejs/file-adapters/)。'
- en: '**WYSIWYG**:This package is used to render a WYSIWYG editor in the Keystone
    Admin UI using TinyMCE. For more information about this package, please visit
    [https://www.keystonejs.com/keystonejs/fields-wysiwyg-tinymce/](https://www.keystonejs.com/keystonejs/fields-wysiwyg-tinymce/).
    For the information about TinyMCE, please visit [https://www.tiny.cloud/](https://www.tiny.cloud/).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所见即所得编辑器**：此软件包用于在Keystone Admin UI中使用TinyMCE呈现所见即所得编辑器。有关此软件包的更多信息，请访问[https://www.keystonejs.com/keystonejs/fields-wysiwyg-tinymce/](https://www.keystonejs.com/keystonejs/fields-wysiwyg-tinymce/)。有关TinyMCE的信息，请访问[https://www.tiny.cloud/](https://www.tiny.cloud/)。'
- en: 'Now, let''s install and use them to create our lists:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们安装并使用它们来创建我们的列表：
- en: 'Install the Keystone packages that we mentioned previously via npm:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm安装我们之前提到的Keystone软件包：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Import `@keystonejs/app-static` into `index.js` and define the path and the
    folder name where you want to keep the static files:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@keystonejs/app-static`导入`index.js`，并定义您希望保留静态文件的路径和文件夹名称：
- en: '[PRE73]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a `File.js` file in the `/lists/` directory. Then, define the fields
    for the `Image` list using the `File`, `Text`, and `Slug` field types from `@keystonejs/fields`
    and `LocalFileAdapter` from `@keystonejs/file-adapters`. This will allow you to
    upload files to the local location; that is, `/public/files/`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/lists/`目录中创建一个`File.js`文件。然后，使用`@keystonejs/fields`中的`File`，`Text`和`Slug`字段类型以及`@keystonejs/file-adapters`中的`LocalFileAdapter`定义`Image`列表的字段。这将允许您将文件上传到本地位置；即`/public/files/`：
- en: '[PRE74]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the preceding code, we defined a list of fields (`title`, `alt`, `caption`,
    `name`, and `file`) so that we can store the meta-information about every uploaded
    file. It is good practice to have the `name` field in every list schema so that
    we can store a unique name in this field that we can use as the label in Keystone
    Admin UI. We can use it to identify each injected list item easily. To generate
    a unique name for this field, we can use the `Slug` type, which, by default, generates
    the unique name from the `title` field.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义了一系列字段（`title`，`alt`，`caption`，`name`和`file`），以便我们可以存储有关每个上传文件的元信息。在每个列表模式中都有`name`字段是一个良好的做法，以便我们可以在此字段中存储一个唯一名称，我们可以在Keystone
    Admin UI中用作标签。我们可以使用它轻松地识别每个注入的列表项。为此字段生成唯一名称，我们可以使用`Slug`类型，默认情况下，它从`title`字段生成唯一名称。
- en: 'For more information about the field types that we used in the preceding code,
    please visit the following links:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有关我们在上述代码中使用的字段类型的更多信息，请访问以下链接：
- en: '[https://www.keystonejs.com/keystonejs/fields/src/types/file/](https://www.keystonejs.com/keystonejs/fields/src/types/file/) for
    the `File` type'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.keystonejs.com/keystonejs/fields/src/types/file/](https://www.keystonejs.com/keystonejs/fields/src/types/file/) 用于`File`类型'
- en: '[https://www.keystonejs.com/keystonejs/fields/src/types/text/](https://www.keystonejs.com/keystonejs/fields/src/types/text/) for
    the `Text` type'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.keystonejs.com/keystonejs/fields/src/types/text/](https://www.keystonejs.com/keystonejs/fields/src/types/text/) 用于`Text`类型'
- en: '[https://www.keystonejs.com/keystonejs/fields/src/types/slug/](https://www.keystonejs.com/keystonejs/fields/src/types/slug/) for
    the `Slug` type'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.keystonejs.com/keystonejs/fields/src/types/slug/](https://www.keystonejs.com/keystonejs/fields/src/types/slug/) 用于`Slug`类型'
- en: For more information about `LocalFileAdapter`, please visit [https://www.keystonejs.com/keystonejs/file-adapters/localfileadapter](https://www.keystonejs.com/keystonejs/file-adapters/#localfileadapter).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`LocalFileAdapter`的更多信息，请访问[https://www.keystonejs.com/keystonejs/file-adapters/localfileadapter](https://www.keystonejs.com/keystonejs/file-adapters/#localfileadapter)。
- en: Our app files can be uploaded to Cloudinary using `CloudinaryFileAdapter`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用文件可以使用`CloudinaryFileAdapter`上传到Cloudinary。
- en: For more information about how to set up an account so that you can host files
    on Cloudinary, please visit [https://cloudinary.com/](https://cloudinary.com/).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何设置帐户以便您可以在Cloudinary上托管文件的更多信息，请访问[https://cloudinary.com/](https://cloudinary.com/)。
- en: 'Create a `SlideImage.js` file in the `/lists/` directory and define the fields
    that are identical to the ones in the `File.js` file with an additional field
    type, `Relationship`, so that you can link the slide image to the project page:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/lists/`目录中创建一个`SlideImage.js`文件，并定义与`File.js`文件中相同的字段，还有一个额外的字段类型`Relationship`，以便您可以将幻灯片图像链接到项目页面：
- en: '[PRE75]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: For more information about the `Relationship` field, please visit [https://www.keystonejs.com/keystonejs/fields/src/types/relationship/](https://www.keystonejs.com/keystonejs/fields/src/types/relationship/).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Relationship`字段的更多信息，请访问[https://www.keystonejs.com/keystonejs/fields/src/types/relationship/](https://www.keystonejs.com/keystonejs/fields/src/types/relationship/)。
- en: 'Create a `Page.js` file in the `/lists/` directory and define the fields for
    the `Page` list using the `Text`, `Relationship`, `Slug`, and `Wysiwyg` field
    types from `@keystonejs/fields` and `@keystonejs/fields-wysiwyg-tinymce`, as follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/lists/`目录中创建一个`Page.js`文件，并使用`@keystonejs/fields`和`@keystonejs/fields-wysiwyg-tinymce`中的`Text`、`Relationship`、`Slug`和`Wysiwyg`字段类型定义`Page`列表的字段，如下所示：
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the preceding code, we defined a list of fields (`title`, `excerpt`, `content`,
    `name`, `featuredImage,` and `slideImages`) so that we can store the data of every
    main page that we will inject into this content type. Note that we link `featuredImage`
    to the `Image` list and link `slideImages` to the `SlideImage` list. We want to
    allow multiple images to be placed in the `slideImages` field, so we set the `many` option
    to `true`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义了一系列字段（`title`、`excerpt`、`content`、`name`、`featuredImage`和`slideImages`），以便我们可以存储将注入到此内容类型中的每个主页面的数据。请注意，我们将`featuredImage`链接到`Image`列表，并将`slideImages`链接到`SlideImage`列表。我们希望允许将多个图像放置在`slideImages`字段中，因此我们将`many`选项设置为`true`。
- en: For more information about these one-to-many and many-to-many relationships,
    please visit [https://www.keystonejs.com/guides/new-schema-cheatsheet](https://www.keystonejs.com/guides/new-schema-cheatsheet).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些一对多和多对多关系的更多信息，请访问[https://www.keystonejs.com/guides/new-schema-cheatsheet](https://www.keystonejs.com/guides/new-schema-cheatsheet)。
- en: 'Create a `Project.js` file in the `/lists/` directory and define the fields
    that are identical to the ones in the `File.js` file for the `Project` list with
    two additional fields (`fullscreenImage` and `projectImages`):'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/lists/`目录中创建一个`Project.js`文件，并定义与`File.js`文件中的字段相同的字段，用于`Project`列表，另外再加上两个字段（`fullscreenImage`和`projectImages`）：
- en: '[PRE77]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Create a `NavLink.js` file in the `/lists/` directory and define the fields
    (`title`, `order`, `name`, `link`, `subLinks`) for the `NavLink` list using the
    `Text`, `Relationship`, `Slug`, and `Integer` field types from `@keystonejs/fields`,
    as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/lists/`目录中创建一个`NavLink.js`文件，并使用`@keystonejs/fields`中的`Text`、`Relationship`、`Slug`和`Integer`字段类型定义`NavLink`列表的字段（`title`、`order`、`name`、`link`、`subLinks`），如下所示：
- en: '[PRE78]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here, we use the `order` field to sort the link items by their numeric positions
    in the GraphQL query. You will learn about this soon. The `subLinks` field is
    an example that demonstrates how you can make simple sublinks in Keystone. So,
    we can add multiple sublinks to the main links by attaching the project pages
    to this field, which is linked to the `Project` list using the `Relationship`
    field type.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`order`字段来按照GraphQL查询中的数字位置对链接项进行排序。您很快就会了解这一点。`subLinks`字段是一个示例，演示了如何在Keystone中创建简单的子链接。因此，我们可以通过将项目页面附加到此字段来向主链接添加多个子链接，该字段使用`Relationship`字段类型与`Project`列表关联。
- en: For more information about the `Integer` field type, please visit [https://www.keystonejs.com/keystonejs/fields/src/types/integer/](https://www.keystonejs.com/keystonejs/fields/src/types/integer/).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Integer`字段类型的更多信息，请访问[https://www.keystonejs.com/keystonejs/fields/src/types/integer/](https://www.keystonejs.com/keystonejs/fields/src/types/integer/)。
- en: 'Import the files from the `/lists/` directory and start creating the list schema
    from them, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`/lists/`目录导入文件，并开始从中创建列表模式，如下所示：
- en: '[PRE79]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Start the app by running the `dev` script on your terminal:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端上运行`dev`脚本启动应用程序：
- en: '[PRE80]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You should see a list of URLs on your terminal identical to the ones shown in
    the previous section. This means you have started the app successfully on `localhost:4000`.
    So, now, you can point your browser to `localhost:4000/admin` and start injecting
    content and uploading files from the Keystone Admin UI. Once you have the content
    and data ready, you can query them using the GraphQL API and GraphQL Playground.
    But before you can do that, you should learn what a GraphQL is and how to create
    and use it independently from Keystone. So, let's find out!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端上看到与上一节中显示的相同的URL列表。这意味着您已成功在`localhost:4000`上启动了该应用程序。因此，现在，您可以将浏览器指向`localhost:4000/admin`，并开始从Keystone
    Admin UI注入内容和上传文件。一旦您准备好内容和数据，就可以使用GraphQL API和GraphQL Playground进行查询。但在这样做之前，您应该了解什么是GraphQL以及如何独立于Keystone创建和使用它。所以，让我们找出来！
- en: You can find the source code for this app in `/chapter-18/cross-domain/backend/keystone/`
    in this book's GitHub repository.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-18/cross-domain/backend/keystone/`中找到此应用程序的源代码。
- en: Introducing GraphQL
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍GraphQL
- en: 'GraphQL is an open source query language, server-side runtime (execution engine),
    and specification (technical standard). But what does it mean? What is it? GraphQL
    is a query language, which is what the "QL" part of GraphQL stands for. To be
    specific, it is a client query language. But again, what does it mean? The following
    example will address any doubts you have about GraphQL queries:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL是一种开放源查询语言、服务器端运行时（执行引擎）和规范（技术标准）。但这意味着什么？它是什么？GraphQL是一种查询语言，这就是GraphQL中“QL”部分的含义。具体来说，它是一种客户端查询语言。但再次，这意味着什么？以下示例将解决您对GraphQL查询的任何疑问：
- en: '[PRE81]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'GraphQL queries like the previous one are used in HTTP clients such as Nuxt
    or Vue to send the query to the server in exchange for a JSON response, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面的那样的GraphQL查询在HTTP客户端（如Nuxt或Vue）中使用，以交换JSON响应发送查询到服务器，如下所示：
- en: '[PRE82]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As you can see, you get the specific data for the fields (`age` and `population`)
    that you requested and nothing more. This is what makes GraphQL distinctive and
    gives the client the power to request exactly what they want. It's cool and exciting,
    isn't it? But what is it in the server that returns the GraphQL response? A GraphQL
    API server (server-side runtime).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，您获取了您请求的字段（`age`和`population`）的特定数据，而不多不少。这就是使GraphQL与众不同的地方，它赋予客户端精确请求他们想要的能力。这很酷，很令人兴奋，不是吗？但是在服务器上返回GraphQL响应的是什么？一个GraphQL
    API服务器（服务器端运行时）。
- en: GraphQL queries are sent by the client to a GraphQL API server over an HTTP
    endpoint via the `POST` method to the server as a string. The server extracts
    and processes the query string. Then, just like any typical API server, the GraphQL
    API will fetch the data from a database or other services/APIs and return it to
    the client in a JSON response.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL查询由客户端通过HTTP端点发送到GraphQL API服务器，使用`POST`方法将查询作为字符串发送到服务器。服务器提取并处理查询字符串。然后，就像任何典型的API服务器一样，GraphQL
    API将从数据库或其他服务/ API获取数据并以JSON响应返回给客户端。
- en: 'So, can we use a server such as Express as a GraphQL API server? Yes and no.
    All qualified GraphQL servers must implement two core components, as specified
    in the GraphQL specification, that validate and process and then return the data:
    a schema and resolvers.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们可以将Express等服务器用作GraphQL API服务器吗？是和否。所有合格的GraphQL服务器必须实现GraphQL规范中指定的两个核心组件，用于验证、处理和返回数据：模式和解析器。
- en: 'A GraphQL schema is a collection of type definitions that consist of objects
    that the client can request and the fields that the objects have. On the other
    hand, GraphQL resolvers are functions that are attached to the fields that return
    values when the client makes a query or mutation. For example, the following is
    the type definition for finding a planet:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL模式是一组类型定义的集合，其中包括客户端可以请求的对象以及对象具有的字段。另一方面，GraphQL解析器是附加到字段的函数，在客户端进行查询或突变时返回值。例如，以下是查找行星的类型定义：
- en: '[PRE83]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here, you can see that GraphQL uses a strongly typed schema – each field must
    be defined with a type that can be a scalar type (which is a single value that
    can be an integer, Boolean, or string) or an object type. The `Planet` and `Query` types
    are object types, while `String` and `Int` are scalar types. Each of the fields
    in the object types must be resolved with a function, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到GraphQL使用了强类型模式 - 每个字段必须用可以是标量类型（即可以是整数、布尔值或字符串的单个值）或对象类型定义。`Planet`和`Query`类型是对象类型，而`String`和`Int`是标量类型。对象类型中的每个字段都必须通过函数解析，如下所示：
- en: '[PRE84]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The preceding example was written in JavaScript, but a GraphQL server can be
    written in any programming language as long as you follow and implement what is
    outlined in the GraphQL specification at [https://spec.graphql.org/](https://spec.graphql.org/).
    The following are some examples of GraphQL implementations in different languages:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例是用JavaScript编写的，但是GraphQL服务器可以用任何编程语言编写，只要您遵循并实现了GraphQL规范中概述的内容。以下是不同语言中的一些GraphQL实现的示例：
- en: GraphQL.js (JavaScript) at [https://github.com/graphql/graphql-js](https://github.com/graphql/graphql-js)
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL.js（JavaScript）在[https://github.com/graphql/graphql-js](https://github.com/graphql/graphql-js)
- en: graphql-php (PHP) at [https://github.com/webonyx/graphql-php](https://github.com/webonyx/graphql-php)
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: graphql-php（PHP）在[https://github.com/webonyx/graphql-php](https://github.com/webonyx/graphql-php)
- en: Graphene (Python) at [https://github.com/graphql-python/graphene](https://github.com/graphql-python/graphene)
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Graphene（Python）在[https://github.com/graphql-python/graphene](https://github.com/graphql-python/graphene)
- en: GraphQL Ruby (Ruby) at [https://github.com/rmosolgo/graphql-ruby](https://github.com/rmosolgo/graphql-ruby)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL Ruby（Ruby）在[https://github.com/rmosolgo/graphql-ruby](https://github.com/rmosolgo/graphql-ruby)
- en: You are free to create a new implementation as long as you comply with the GraphQL
    specification, but we're only going to use GraphQL.js in this book. Now, you probably
    have some deeper questions – what exactly is the query type? We know that it is
    an `object` type, but why do we need it? Do we need to have it in the schema?
    The short answer is yes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 只要符合GraphQL规范，您可以自由创建新的实现，但是在本书中我们只会使用GraphQL.js。现在，您可能有一些更深入的问题 - 查询类型到底是什么？我们知道它是一个`object`类型，但为什么我们需要它？我们需要在模式中拥有它吗？简短的答案是是。
- en: We'll look at this in more detail in the next section and find out why it is
    required regardless. We will also find out how to use Express as a GraphQL API
    server. So, keep reading.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更详细地讨论这个问题，并找出为什么无论如何都需要它。我们还将找出如何将Express用作GraphQL API服务器。所以，请继续阅读。
- en: Understanding the GraphQL schema and resolvers
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解GraphQL模式和解析器
- en: The example schema and resolvers for finding a planet that we discussed in the
    previous section presume that we use the GraphQL schema language, which helps
    us create the GraphQL schema required by the GraphQL server. We can easily create
    a GraphQL.js `GraphQLSchema` instance from the GraphQL schema language using the
    `makeExecutableSchema` function from a Node.js package called GraphQL Tools.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们讨论了查找行星的示例模式和解析器，假设我们使用GraphQL模式语言，这有助于我们创建GraphQL服务器所需的GraphQL模式。我们可以使用Node.js包GraphQL
    Tools中的`makeExecutableSchema`函数从GraphQL模式语言轻松创建一个GraphQL.js `GraphQLSchema`实例。
- en: You can find out more information about this package at [https://www.graphql-tools.com/](https://www.graphql-tools.com/)
    or [https://github.com/ardatan/graphql-tools](https://github.com/ardatan/graphql-tools).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.graphql-tools.com/](https://www.graphql-tools.com/)或[https://github.com/ardatan/graphql-tools](https://github.com/ardatan/graphql-tools)找到有关此包的更多信息。
- en: 'The GraphQL schema language is a "shortcut" – a shorthand notation for constructing
    your GraphQL schema and its type system. Before making use of this shorthand notation,
    we should take a look at how a GraphQL schema is built from the low-level objects
    and functions such as `GraphQLObjectType`, `GraphQLString`, `GraphQLList`, and
    so on from GraphQL.js, which implements the GraphQL specification. Let''s install
    these packages and create a simple GraphQL API server with Express:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL模式语言是一种“快捷方式” - 一种用于构建GraphQL模式和其类型系统的简写符号。在使用这种简写符号之前，我们应该看一下GraphQL模式是如何从低级对象和函数（如`GraphQLObjectType`、`GraphQLString`、`GraphQLList`等）构建的，这些函数来自实现了GraphQL规范的GraphQL.js。让我们安装这些包并使用Express创建一个简单的GraphQL
    API服务器：
- en: 'Install Express, GraphQL.js, and GraphQL HTTP Server Middleware via npm:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm安装Express、GraphQL.js和GraphQL HTTP服务器中间件：
- en: '[PRE85]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: GraphQL HTTP Server Middleware is a piece of middleware that allows us to create
    a GraphQL HTTP server with any HTTP web framework that implements the way Connect
    supports a middleware, such as Express, Restify, and Connect itself.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL HTTP服务器中间件是一种中间件，允许我们使用任何实现了Connect支持中间件的HTTP Web框架（如Express、Restify和Connect本身）创建GraphQL
    HTTP服务器。
- en: 'For more information about these packages, please visit the following links:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些包的更多信息，请访问以下链接：
- en: '[https://github.com/graphql/express-graphql](https://github.com/graphql/express-graphql) for
    GraphQL HTTP Server Middleware'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/graphql/express-graphql](https://github.com/graphql/express-graphql) 用于GraphQL
    HTTP服务器中间件'
- en: '[https://github.com/senchalabs/connect](https://github.com/senchalabs/connect) for
    Connect'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/senchalabs/connect](https://github.com/senchalabs/connect) 用于Connect'
- en: '[https://expressjs.com/](https://expressjs.com/) for Express'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://expressjs.com/](https://expressjs.com/) 用于Express'
- en: '[http://restify.com/](http://restify.com/) for Restify'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://restify.com/](http://restify.com/) 用于Restify'
- en: 'Create an `index.js` file in the project''s root and import `express`, `express-graphql`
    and `graphql`, using the `require` method:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个`index.js`文件，并使用`require`方法导入`express`、`express-graphql`和`graphql`：
- en: '[PRE86]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Create a dummy data with a list of planets:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含行星列表的虚拟数据：
- en: '[PRE87]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Define the `Planet` object type and the fields that the client can query:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Planet`对象类型以及客户端可以查询的字段：
- en: '[PRE88]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note that it is a convention to capitalize the object type in the `name` field
    for the GraphQL schema's creation.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在GraphQL模式创建时，将对象类型在`name`字段中大写是一种约定。
- en: 'Define various types and how you want to resolve the value for each field:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义各种类型以及如何解析每个字段的值：
- en: '[PRE89]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Notice that every resolver function accepts the following four arguments:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个解析器函数都接受以下四个参数：
- en: '`root`: The object or value that''s resolved from the parent object type (the
    Query in *step 6*).'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root`：从父对象类型（*步骤6*中的查询）解析出的对象或值。'
- en: '`args`: Arguments that the field can receive if they are set. See *step 8*.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`：如果设置了，字段可以接收的参数。见*步骤8*。'
- en: '`context`: A mutable JavaScript object that holds the top-level data that is
    shared across all the resolvers. It is the Node.js HTTP request object (`IncomingMessage`)
    by default in our case when using Express. We can modify this context object and
    add general data that we want to be shared, such as authentication and database
    connections. See *step 10*.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`：一个可变的JavaScript对象，保存着所有解析器之间共享的顶层数据。在我们使用Express时，默认情况下是Node.js的HTTP请求对象（`IncomingMessage`）。我们可以修改这个上下文对象，并添加我们想要共享的一般数据，比如认证和数据库连接。见*步骤10*。'
- en: '`info`: A JavaScript object that holds information about the current field
    such as its field name, return type, parent type (`Planet`, in this case), and
    the general schema details.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`：一个JavaScript对象，包含有关当前字段的信息，例如字段名称、返回类型、父类型（在本例中为`Planet`）和一般模式详细信息。'
- en: We can omit them if they aren't needed for resolving the value for the current
    field.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们对于解析当前字段的值不需要，我们可以省略它们。
- en: 'Define the `Query` object type and the fields that the client can query:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Query`对象类型和客户端可以查询的字段：
- en: '[PRE90]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Define the type and resolve how you want to return the value for the `hello`
    field:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类型并解析您希望返回`hello`字段的值：
- en: '[PRE91]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Define the type and resolve how you want to return the value for the `planet`
    field:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类型并解析您希望返回`planet`字段的值：
- en: '[PRE92]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Notice that we passed the `Planet` object type that we created and stored in
    the `planetType` variable to the `planet` field in the `Query` object type so
    that a relationship between them can be established.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将创建并存储在`planetType`变量中的`Planet`对象类型传递给`Query`对象类型中的`planet`字段，以便它们之间可以建立关系。
- en: 'Construct a GraphQL schema instance with the required `query` field and the
    **`Query`** object type that you have just defined with the fields, types, arguments,
    and resolvers in it, as follows:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所需的`query`字段和您刚刚定义的带有字段、类型、参数和解析器的**`Query`**对象类型构造一个GraphQL模式实例，如下所示：
- en: '[PRE93]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note that the `query` key must be provided as the GraphQL query root type so
    that our query can be chained down to the fields in the `Planet` object type.
    We can say that the `Planet` object type is a subtype or a child of the `Query`
    object type (the root type) and that their relationship must be established in
    the parent object (`Query`) using the `type` field in the `planet` field.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，必须提供`query`键作为GraphQL查询根类型，以便我们的查询可以链接到`Planet`对象类型中的字段。我们可以说`Planet`对象类型是`Query`对象类型（根类型）的子类型或子对象，并且它们的关系必须在父对象（`Query`）中使用`planet`字段中的`type`字段来建立。
- en: 'Use the GraphQL HTTP Server Middleware as a piece of middleware with the GraphQL
    schema instance to establish the GraphQL server on an endpoint permitted by Express
    called `/graphiql`, as follows:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用GraphQL HTTP服务器中间件作为中间件与GraphQL模式实例一起，在Express允许的端点上建立GraphQL服务器，称为`/graphiql`，如下所示：
- en: '[PRE94]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: It is recommended to set the `graphiql` option to `true` so that we can use
    the GraphQL IDE when the GraphQL endpoint is loaded on the browser.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 建议将`graphiql`选项设置为`true`，以便在浏览器加载GraphQL端点时可以使用GraphQL IDE。
- en: 'At this top level, you can also modify the context of your GraphQL API by using
    the `context` option inside the `graphqlHTTP` middleware, as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个顶层，您还可以使用`graphqlHTTP`中间件内的`context`选项修改您的GraphQL API的上下文，如下所示：
- en: '[PRE95]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: By doing this, you can access this top-level data from any resolver. This can
    be very useful. Cool, isn't it?
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，您可以从任何解析器中访问这个顶层数据。这可能非常有用。很酷，不是吗？
- en: 'Finally, after all the data has been loaded, start the server with the `node
    index.js` command on your terminal with the following line in the `index.js` file:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在加载所有数据后，在终端上使用`node index.js`命令启动服务器，并在`index.js`文件中添加以下行：
- en: '[PRE96]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Point your browser to `localhost:4000/graphiql`. You should see the GraphQL
    IDE, a UI where you can test your GraphQL API. So, type the following query into
    the input area on the left-hand side:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器指向`localhost:4000/graphiql`。您应该看到GraphQL IDE，一个UI，您可以在其中测试您的GraphQL API。因此，在左侧的输入区域中键入以下查询：
- en: '[PRE97]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You should see that the preceding GraphQL query has been exchanged with a JSON
    object on the right-hand side when you hit the play button:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击播放按钮时，您应该看到前面的GraphQL查询已经在右侧与JSON对象交换：
- en: '[PRE98]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Well done – you have managed to create a basic GraphQL API server with Express
    using the low-level approach! We hope this has given you a full picture of how
    a GraphQL API server can be created with the GraphQL schema and resolvers. We
    also hope that you can see the relationship between these two core components
    in GraphQL and that we have answered yours questions; that is, what exactly is
    the `Query` type? Why do we need it? Do we need to have it in the schema? The
    answer is yes, the query (object) type is a root object type (usually called a
    root `Query` type) that must be provided when creating the GraphQL schema.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好 - 你已经成功地使用低级方法在Express中创建了一个基本的GraphQL API服务器！我们希望这给了你一个完整的图景，了解了如何使用GraphQL模式和解析器创建GraphQL
    API服务器。我们也希望你能看到GraphQL中这两个核心组件之间的关系，并且我们已经回答了你的问题；也就是说，“Query”类型到底是什么？我们为什么需要它？我们需要在模式中拥有它吗？答案是肯定的，查询（对象）类型是一个根对象类型（通常称为根“Query”类型），在创建GraphQL模式时必须提供。
- en: 'But you may still have some questions and complaints, particularly regarding
    the resolvers – surely you find it tedious and dumb to define the resolvers in
    *step 5* for the fields in the `Planet` object type because they do nothing except
    return the values that are resolved from the query object. Is there any way to
    avoid this painful repetition? The answer is yes: you don''t specify them for
    every field in your schema, and this lies in the **default resolver**. But how
    do we do this? We''ll find out in the next section.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 但是您可能仍然有一些问题和抱怨，特别是关于解析器 - 您肯定会觉得在“Planet”对象类型的字段中定义解析器在*步骤5*中是乏味和愚蠢的，因为它们除了返回从查询对象解析的值之外什么也不做。有没有办法避免这种痛苦的重复？答案是肯定的：您不需要为模式中的每个字段指定它们，这就是**默认解析器**。但是我们该如何做呢？我们将在下一节中找到答案。
- en: You can find this and other examples in `/chapter-18/graphql-api/graphql-express/`
    in this book's GitHub repository.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-18/graphql-api/graphql-express/`中找到此类示例和其他示例。
- en: Understanding GraphQL default resolvers
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解GraphQL默认解析器
- en: 'When no resolver has been specified for a field, by default, this field will
    take on the value of the property in the object that''s been resolved by the parent –
    that is, if that object has a property name that matches the field name. So, the
    fields in the `Planet` object type can be refactored as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有为字段指定解析器时，默认情况下，该字段将采用在幕后由父对象解析的对象的属性的值 - 也就是说，如果该对象具有与字段名称匹配的属性名称。因此，可以将“Planet”对象类型中的字段重构如下：
- en: '[PRE99]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The values of these fields will fall back to the properties in the object that''s
    been resolved by the parent (the query type) under the hood, as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段的值将回退到在幕后由父对象（查询类型）解析的对象的属性中，如下所示：
- en: '[PRE100]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'So, put the other way around, when a resolver is specified explicitly for a
    field, this resolver will always be used, even if the parent''s resolver returns
    any value for that field. For example, let''s specify a value explicitly for the
    `id` field in the `Planet` object type, as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当为字段明确指定解析器时，即使父解析器为该字段返回任何值，此解析器也将始终被使用。例如，让我们为“Planet”对象类型中的“id”字段明确指定一个值，如下所示：
- en: '[PRE101]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We already know that the default ID values for Earth and Mars are 3 and 4 and
    that they are resolved by the `Query` object type (the parent), as shown in *step
    8* in the previous section. But these resolved values will never be used because
    they are overridden by the value in the ID''s resolver. So, let''s query Earth
    or Mars, as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道地球和火星的默认ID值分别为3和4，并且它们由“Query”对象类型（父对象）解析，如前一节的*步骤8*所示。但这些解析的值将永远不会被使用，因为它们被ID的解析器覆盖了。因此，让我们查询地球或火星，如下所示：
- en: '[PRE102]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In this case, you will always get `2` in the JSON response:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您将始终在JSON响应中获得`2`：
- en: '[PRE103]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This is very clever, isn't it? It saves us from painful repetition – that is,
    if you have tons of fields in an object type. However, so far, we have been following
    the most painful way to construct our schema by working with GraphQL.js. This
    is because we wanted to see and understand how a GraphQL schema is created from
    the low-level types. We probably wouldn't want to take this long and winding road
    in real life, especially in a large project. Instead, we should prefer using the
    GraphQL schema language to build the schema and resolvers for us. In the next
    section, we will show you how to create a GraphQL API server easily with the GraphQL
    schema language and **Apollo Server** as an alternative to GraphQL HTTP Server
    Middleware. So, read on!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常聪明，不是吗？它可以避免我们痛苦的重复 - 也就是说，如果你在对象类型中有大量字段的话。然而，到目前为止，我们一直在用最痛苦的方式来构建我们的模式，通过使用GraphQL.js。这是因为我们想要看到并理解GraphQL模式是如何从低级类型创建的。在现实生活中，我们可能不想走这么漫长和曲折的道路，特别是在一个大项目中。相反，我们应该倾向于使用GraphQL模式语言来为我们构建模式和解析器。在下一节中，我们将向您展示如何使用GraphQL模式语言和Apollo
    Server轻松创建GraphQL API服务器，作为GraphQL HTTP服务器中间件的替代方案。所以，请继续阅读！
- en: Creating a GraphQL API with Apollo Server
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apollo Server创建GraphQL API
- en: Apollo Server is an open source and GraphQL spec-compliant server developed
    by the Apollo platform for building GraphQL APIs. We can use it standalone or
    with other Node.js web frameworks such as Express, Koa, Hapi, and so on. We will
    use Apollo Server as it is in this book, but if you want to use it with other
    frameworks, please visit [https://github.com/apollographql/apollo-serverinstallation-integrations](https://github.com/apollographql/apollo-server#installation-integrations).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Server是Apollo平台开发的符合GraphQL规范的开源服务器，用于构建GraphQL API。我们可以单独使用它，也可以与其他Node.js
    web框架一起使用，比如Express、Koa、Hapi等等。在本书中，我们将直接使用Apollo Server，但如果您想在其他框架中使用它，请访问[https://github.com/apollographql/apollo-server#installation-integrations](https://github.com/apollographql/apollo-server#installation-integrations)。
- en: 'In this GraphQL API, we will create a server that queries a collection of books
    by title and author. Let''s get started:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个GraphQL API中，我们将创建一个服务器，通过标题和作者查询一系列书籍。让我们开始吧：
- en: 'Install Apollo Server and GraphQL.js via npm as the project dependencies:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm安装Apollo Server和GraphQL.js作为项目依赖：
- en: '[PRE104]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Create an `index.js` file in the project root directory and import the `ApolloServer`
    and `gql` functions from the `apollo-server` package:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录中创建一个`index.js`文件，并从`apollo-server`包中导入`ApolloServer`和`gql`函数：
- en: '[PRE105]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The `gql` function is used to parse GraphQL operations and the schema language
    by wrapping them with template literal tags (or tagged template literals). For
    more information about template literals and tagged templates, please visit [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`gql`函数用于解析GraphQL操作和模式语言，通过使用模板文字标签（或标记模板文字）将它们包装起来。有关模板文字和标记模板的更多信息，请访问[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)。'
- en: 'Create the following static data, which holds the lists of authors and posts:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下静态数据，其中包含作者和帖子的列表：
- en: '[PRE106]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Define the `Author`, `Post`, and `Query` object types, along with the fields
    that the client can query:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Author`、`Post`和`Query`对象类型，以及客户端可以查询的字段：
- en: '[PRE107]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Note that we can shorthand the `Author`, `Post`, and `Query` object types as
    the `Author` type, the `Post` type,  and the `Query` type. It is just clearer
    than using "object type" to describe them because that is what they are. Remember
    that apart from being an object type by nature, the `Query` type is also the root
    type in GraphQL schema creation.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以将`Author`，`Post`和`Query`对象类型简写为`Author`类型，`Post`类型和`Query`类型。这比使用“对象类型”来描述它们更清晰，因为它们就是这样。请记住，除了天生是对象类型之外，`Query`类型还是GraphQL模式创建中的根类型。
- en: Notice how we establish the relationship of `Author` with `Post` and `Post`
    with `Query` – the type for the `author` field is the `Author` type. The `Author`
    type has simple scalar types for its fields (`id`, `name`), while the `Post` type
    has simple scalar types (`id`, `title`) and the `Author` type (`author`) for its
    field. The `Query` type has the `Post` type for its only field, which is `posts`,
    but it is a list of posts, so we must use the type modifier to wrap the `Post`
    type with open and closed square brackets to indicate that this `posts` field
    will resolve with an array of `Post` objects.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何建立`Author`与`Post`以及`Post`与`Query`之间的关系 - `author`字段的类型是`Author`类型。`Author`类型的字段（`id`，`name`）是简单的标量类型，而`Post`类型的字段（`id`，`title`）和`Author`类型（`author`）是简单的标量类型。`Query`类型只有一个字段，即`posts`，它是一个帖子列表，因此我们必须使用类型修饰符，用开放和关闭的方括号包裹`Post`类型，以指示这个`posts`字段将解析为一个`Post`对象数组。
- en: For more information about the type modifier, please visit [https://graphql.org/learn/schema/lists-and-non-null](https://graphql.org/learn/schema/#lists-and-non-null).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 有关类型修饰符的更多信息，请访问[https://graphql.org/learn/schema/lists-and-non-null](https://graphql.org/learn/schema/#lists-and-non-null)。
- en: 'Define resolvers to specify how you want to resolve the value for the `posts`
    field in the `Query` type and the `author` field in the `Post` type:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义解析器以指定如何解析`Query`类型中的`posts`字段和`Post`类型中的`author`字段的值：
- en: '[PRE108]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Notice how the GraphQL schema language has helped us **decouple** the resolvers
    from the object types and that they are simply defined in a single JavaScript
    object. The resolvers in the JavaScript object are "magically" connected with
    the object types, as long as the property names for our resolvers map the field
    names in the type definitions. Hence, this JavaScript object is called a resolver
    map. Before defining resolvers, we must also define the **top-level** property
    names (`Query`, `Post`) in the resolver map so that they match the object types
    (`Author`, `Post`, `Query`) in the type definitions. But we don't need to define
    any specific resolvers for the `Author` type in this resolver map because the
    values for the fields (`id`, `name`) in `Author` are resolved by the default resolvers
    automatically.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意GraphQL模式语言如何帮助我们将解析器与对象类型解耦，并且它们只是在单个JavaScript对象中简单定义。JavaScript对象中的解析器与对象类型“神奇”地连接在一起，只要解析器的属性名称与类型定义中的字段名称相匹配。因此，这个JavaScript对象被称为解析器映射。在定义解析器之前，我们还必须在解析器映射中定义顶级属性名称（`Query`，`Post`），以便它们与类型定义中的对象类型（`Author`，`Post`，`Query`）匹配。但是，在这个解析器映射中，我们不需要为`Author`类型定义任何特定的解析器，因为`Author`中字段（`id`，`name`）的值会自动由默认解析器解析。
- en: 'Another point to note is that the values for the fields (`id`, `title`) in
    the `Post` type are also resolved by the default ones. If you don''t like using
    property names to define resolvers, you can use resolver functions instead, as
    long as the function names correspond with the field names in the type definitions.
    For example, the resolvers for the `author` field can be rewritten as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的地方是`Post`类型中字段（`id`，`title`）的值也是由默认解析器解析的。如果您不喜欢使用属性名称来定义解析器，您可以改用解析器函数，只要函数名称与类型定义中的字段名称对应即可。例如，`author`字段的解析器可以重写如下：
- en: '[PRE109]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Construct a GraphQL schema instance from `ApolloServer` with the type definitions
    and resolvers. Then, start the server, as follows:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ApolloServer`从类型定义和解析器构建一个GraphQL模式实例。然后，启动服务器，如下所示：
- en: '[PRE110]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Launch your GraphQL API with the `node` command on your terminal:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用终端上的`node`命令启动您的GraphQL API：
- en: '[PRE111]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Point your browser to `localhost:4000`. You should see the GraphQL Playground
    loaded on your screen. From there, you can test your GraphQL API. So, type the
    following query into the input area on the left-hand side:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器指向`localhost:4000`。您应该在屏幕上看到加载的GraphQL Playground。从那里，您可以测试您的GraphQL API。因此，请在左侧的输入区域中输入以下查询：
- en: '[PRE112]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'You should see that the preceding GraphQL query has been exchanged with a JSON
    object on the right-hand side when you hit the play button:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击播放按钮时，您应该看到前面的GraphQL查询已经在右侧与JSON对象交换：
- en: '[PRE113]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This is beautiful and wonderful, isn't it? That's how easily we can build a
    GraphQL API with the GraphQL schema language and Apollo Server. It is worth knowing
    the long and painful way of how a GraphQL schema and resolvers are created before
    adopting the shorthand method. Once you have this basic concrete knowledge, you
    should be able to query the data you have stored with Keystone with ease. We have
    only covered a few of GraphQL's types in this book, including the scalar type,
    the object type, the query type, and the type modifier. There are a few other
    types you should check out, such as the mutation type, the enumeration type, the
    union and input types, and interface. Please check them out at [https://graphql.org/learn/schema/](https://graphql.org/learn/schema/).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这是美好而美妙的，不是吗？这就是我们如何使用GraphQL模式语言和Apollo Server轻松构建GraphQL API。在采用速记方法之前，了解创建GraphQL模式和解析器的漫长而痛苦的方式是值得的。一旦您掌握了这些基本的具体知识，您应该能够轻松查询您使用Keystone存储的数据。在本书中，我们只涵盖了GraphQL的一些类型，包括标量类型、对象类型、查询类型和类型修改器。还有一些其他类型您应该查看，例如变异类型、枚举类型、联合和输入类型以及接口。请在[https://graphql.org/learn/schema/](https://graphql.org/learn/schema/)上查看它们。
- en: If you want to learn more about GraphQL, please visit [https://graphql.org/learn/](https://graphql.org/learn/).
    For more information about Apollo Server, visit [https://www.apollographql.com/docs/apollo-server/](https://www.apollographql.com/docs/apollo-server/).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于GraphQL的信息，请访问[https://graphql.org/learn/](https://graphql.org/learn/)。有关Apollo
    Server的更多信息，请访问[https://www.apollographql.com/docs/apollo-server/](https://www.apollographql.com/docs/apollo-server/)。
- en: You can find the code that was used in this section, along with other example
    GraphQL type definitions, in `/chapter-18/graphql-api/graphql-apollo/` in this
    book's GitHub repository.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库的`/chapter-18/graphql-api/graphql-apollo/`中找到本节中使用的代码，以及其他示例GraphQL类型定义。
- en: Now, let's learn how to use the Keystone GraphQL API.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用Keystone GraphQL API。
- en: Using the Keystone GraphQL API
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Keystone GraphQL API
- en: 'The GraphQL Playground for the Keystone GraphQL API is located at `localhost:4000/admin/graphiql`.
    Here, we can test the list we created through the Keystone admin UI at `localhost:4000/admin`.
    Keystone will generate four top-level GraphQL queries automatically for **every**
    list that''s created. For example, we will get the following queries for the `page`
    list we created in the previous section:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Keystone GraphQL API的GraphQL Playground位于`localhost:4000/admin/graphiql`。在这里，我们可以在Keystone管理UI中测试我们创建的列表，位于`localhost:4000/admin`。Keystone将为**每个**创建的列表自动生成四个顶级GraphQL查询。例如，我们将在上一节中创建的`page`列表中获得以下查询：
- en: '`allPages`'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allPages`'
- en: 'This query can be used to fetch all the items from the `Page` list. We can
    also search, limit, and filter the result, as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询可用于从`Page`列表中获取所有项目。我们还可以搜索、限制和过滤结果，如下所示：
- en: '[PRE114]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '`_allPagesMeta`'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_allPagesMeta`'
- en: 'This query can be used to fetch all meta-information about items in the `Page`
    list, such as the total count of all matched items, which can be useful for pagination.
    We can also search, limit, and filter the result, as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询可用于获取`Page`列表中所有项目的所有元信息，例如所有匹配项目的总计数，这对分页可能很有用。我们还可以搜索、限制和过滤结果，如下所示：
- en: '[PRE115]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '`Page`'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Page`'
- en: 'This query can be used to fetch a single item from the `Page` list. We can **only** use
    a `where` parameter with an `id` key to fetch the page, as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询可用于从`Page`列表中获取单个项目。我们**只能**使用带有`id`键的`where`参数来获取页面，如下所示：
- en: '[PRE116]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '`_PagesMeta`'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_PagesMeta`'
- en: 'This query can be used to fetch the meta-information about the `Page` list
    itself, such as its name, access, schema, and fields, as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询可用于获取有关`Page`列表本身的元信息，例如其名称、访问权限、模式和字段，如下所示：
- en: '[PRE117]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'As you can see, these four queries, along with the filter, limit, and sorting
    parameters, provide us with enough power to fetch the specific data that we need
    and nothing more. What''s more is that, in GraphQL, we can fetch **multiple**
    resources with a **single** request, as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这四个查询以及过滤器、限制和排序参数为我们提供了足够的能力来获取我们需要的特定数据，而不多。更重要的是，在GraphQL中，我们可以通过**单个**请求获取**多个**资源，如下所示：
- en: '[PRE118]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: This is amazing and fun, isn't it? In a REST API, you may have to send multiple
    requests to multiple API endpoints for multiple resources. GraphQL offers us an
    alternative to solve this infamous issue of REST APIs that has bothered both frontend
    and backend developers. Note that these four top-level queries also apply to other
    lists we have created, including `Project`, `Image`, and `NavLink`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这很神奇和有趣，不是吗？在REST API中，您可能需要向多个API端点发送多个请求以获取多个资源。GraphQL为我们提供了一个解决这个困扰前端和后端开发人员的REST
    API的替代方案。请注意，这四个顶级查询也适用于我们创建的其他列表，包括`Project`、`Image`和`NavLink`。
- en: For more information about these four top-level queries and the filter, limit,
    and sorting parameters, as well as the GraphQL mutations and execution steps,
    which are not covered in this book, please visit [https://www.keystonejs.com/guides/intro-to-graphql/](https://www.keystonejs.com/guides/intro-to-graphql/).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这四个顶级查询以及过滤器、限制和排序参数的更多信息，以及本书未涵盖的GraphQL变异和执行步骤，请访问[https://www.keystonejs.com/guides/intro-to-graphql/](https://www.keystonejs.com/guides/intro-to-graphql/)。
- en: If you want to learn about how to query a GraphQL server in general, please
    visit [https://graphql.org/learn/queries/](https://graphql.org/learn/queries/).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解如何一般查询GraphQL服务器，请访问[https://graphql.org/learn/queries/](https://graphql.org/learn/queries/)。
- en: Now that you have basic knowledge of GraphQL and are aware of Keystone's top-levels
    GraphQL queries, it's time to learn how to use them in the Nuxt app.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对GraphQL有了基本了解，并且了解了Keystone的顶级GraphQL查询，现在是时候学习如何在Nuxt应用程序中使用它们了。
- en: Integrating Keystone, GraphQL, and Nuxt
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Keystone、GraphQL和Nuxt
- en: Keystone's GraphQL API endpoint is located at `localhost:4000/admin/api`. As
    opposed to a REST API, which usually has multiple endpoints, GraphQL API usually
    has **one single endpoint** for all queries. So, we will use this endpoint to
    send our GraphQL queries from the Nuxt app. It is good practice to always test
    our queries on the GraphQL Playground first to confirm that we get the result
    we need and then use those tested queries in our frontend apps. Besides, we should
    always use the `query` keyword in our queries in the frontend app to fetch data
    from the GraphQL API.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: Keystone的GraphQL API端点位于`localhost:4000/admin/api`。与通常具有多个端点的REST API不同，GraphQL
    API通常具有**一个单一端点**用于所有查询。因此，我们将使用此端点从Nuxt应用程序发送我们的GraphQL查询。在前端应用程序中，始终在GraphQL
    Playground上测试我们的查询以确认我们获得所需的结果，然后在前端应用程序中使用这些经过测试的查询是一个良好的做法。此外，我们应该始终在前端应用程序的查询中使用`query`关键字来从GraphQL
    API中获取数据。
- en: 'In this exercise, we will refactor the Nuxt app that we built for the WordPress
    API. We will be looking at the `/pages/index.vue`, `/pages/projects/index.vue`,
    `/pages/projects/_slug.vue`, and `/store/index.js` files. We will still be using
    Axios to help us send the GraphQL query. Let''s take a look at how to get the
    GraphQL query and Axios working together:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将重构为WordPress API构建的Nuxt应用程序。我们将查看`/pages/index.vue`、`/pages/projects/index.vue`、`/pages/projects/_slug.vue`和`/store/index.js`文件。我们仍然将使用Axios来帮助我们发送GraphQL查询。让我们看看如何让GraphQL查询和Axios一起工作：
- en: 'Create a variable that will store the GraphQL query in order to fetch the title
    of the home page and the slide images that we attached to it:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来存储GraphQL查询，以获取首页的标题和我们附加的幻灯片图片：
- en: '[PRE119]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: We only need the slug from the project page that the image will link to, so
    the `name` field is the only field we will query. And we only need the relative
    public URL of the image, so the `publicUrl` field is the only field we want from
    the image file object. Also, we use the `allPages` query instead of `Page` because
    it is easier to get the page by its slug, which is *home* in this case.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要从图片链接到的项目页面中获取slug，因此`name`字段是我们要查询的唯一字段。我们只需要图片文件对象的相对公共URL，因此`publicUrl`字段是我们想要的唯一字段。此外，我们使用`allPages`查询而不是`Page`，因为通过slug获取页面更容易，而在这种情况下slug是*home*。
- en: 'Send the query to the GraphQL API endpoint using the `post` method from Axios:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Axios的`post`方法将查询发送到GraphQL API端点：
- en: '[PRE120]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Notice that we only need the first item from the array in the data that's returned
    from the GraphQL API, so we use `0` to locate this first item.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只需要从GraphQL API返回的数据中获取数组中的第一项，因此我们使用`0`来定位这第一项。
- en: Note that we should also refactor `/pages/about.vue`, `/pages/contact.vue`,
    `/pages/projects/index.vue`, and `/pages/projects/pages/_number.vue` following
    the same pattern of how we refactored this home page. You can find the path to
    this book's GitHub repository, which contains the complete code, at the end of
    this section.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还应该重构`/pages/about.vue`、`/pages/contact.vue`、`/pages/projects/index.vue`和`/pages/projects/pages/_number.vue`，遵循我们重构首页的相同模式。你可以在本节末尾找到这本书的GitHub存储库的路径，其中包含完整的代码。
- en: 'Create a variable that will store the query and allow you to fetch multiple
    resources from the endpoint, as follows:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来存储查询，并允许你从端点获取多个资源，如下所示：
- en: '[PRE121]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: As you can see, we are fetching the total count of project pages through `_allProjectsMeta` and
    the list of project pages through `allProjects` with the `orderBy`, `skip`, and `first` filters.
    The data for the `skip` and `first` filters will be passed in as variables; that
    is, `skip` and `postsPerPage`, respectively.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们通过`_allProjectsMeta`获取项目页面的总数，并通过`allProjects`以及`orderBy`、`skip`和`first`过滤器获取项目页面的列表。`skip`和`first`过滤器的数据将作为变量传入；分别是`skip`和`postsPerPage`。
- en: 'Compute the data for the `skip` variable from the route parameters, set `6`
    to the `postsPerPage` variable, and then send the query to the GraphQL API endpoint
    using the `post` method from Axios:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从路由参数计算`skip`变量的数据，将`6`设置为`postsPerPage`变量，然后使用Axios的`post`方法将查询发送到GraphQL API端点：
- en: '[PRE122]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: As you can see, we compute the `pageNumber` data from the route parameters,
    which we can only access via `this.$route.params` in the `fetch` method. The `skip`
    data is computed from `pageNumber` and `postsPerPage` before we pass it to the
    GraphQL query and fetch our data. Here, we will get `1` for `pageNumber` and `0`
    for `skip` on the `/projects` or `/projects/pages/1` route, `2` for `pageNumber`
    and `6` for `skip` on the `/projects/pages/2` route, and so on. Also, we must
    make sure that any intentional negative data in the route (for example, `/projects/pages/-100`)
    will be made positive by using the JavaScript `Math.abs` function.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们从路由参数中的`this.$route.params`中访问`pageNumber`数据，然后在`fetch`方法中计算出来。`skip`数据是在将其传递给GraphQL查询并获取数据之前，从`pageNumber`和`postsPerPage`中计算出来的。在`/projects`或`/projects/pages/1`路由上，我们将得到`1`作为`pageNumber`和`0`作为`skip`，在`/projects/pages/2`路由上，我们将得到`2`作为`pageNumber`和`6`作为`skip`，依此类推。此外，我们必须确保路由中的任何有意的负数据（例如`/projects/pages/-100`）都将使用JavaScript的`Math.abs`函数转换为正数。
- en: For more information about the JavaScript `Math.abs` function, please visit
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JavaScript的`Math.abs`函数的更多信息，请访问[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs)。
- en: 'Create the pagination (the next page and the previous page) from the `count`
    field that''s returned from the server, and then return the data as usual for
    the `<template>` block, as follows:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从服务器返回的`count`字段创建分页（下一页和上一页），然后像往常一样返回数据给`<template>`块，如下所示：
- en: '[PRE123]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Create a variable that will store the query for fetching a single project page
    by the slug from the endpoint, as follows:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量，用于存储从端点按`slug`获取单个项目页面的查询，如下所示：
- en: '[PRE124]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Here, we are fetching the project page through `allProjects` with the `search`
    filter. The data for the `search` filter will be passed in from the `params.slug`
    parameter. The fields we will query in `fullscreenImage` and `fullscreenImage`
    are the same as the ones in `featuredImage`; you can find them in *step 3*.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过`search`过滤器从`params.slug`参数中传递数据来获取项目页面。我们将在`fullscreenImage`和`fullscreenImage`中查询的字段与`featuredImage`中的字段相同；您可以在*步骤3*中找到它们。
- en: 'Send the query to the GraphQL API endpoint using the `post` method from Axios:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Axios的`post`方法将查询发送到GraphQL API端点：
- en: '[PRE125]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Notice that you can also destructure nested objects or arrays and assign a variable
    to the value. In the preceding code, we have assigned `result` as the variable
    in order to store the value of the `data` property that's returned by GraphQL.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您还可以解构嵌套对象或数组并将变量分配给值。在前面的代码中，我们已经将`result`分配为变量，以便存储GraphQL返回的`data`属性的值。
- en: 'Create a variable that will store the query for fetching the list of `NavLinks`
    from the endpoint with the `orderBy` filter, as follows:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量，用于存储从带有`orderBy`过滤器的端点获取`NavLinks`列表的查询，如下所示：
- en: '[PRE126]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Send the query to the GraphQL API endpoint using the `post` method from Axios
    and then commit the data to the store state:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Axios的`post`方法将查询发送到GraphQL API端点，然后将数据提交到存储状态：
- en: '[PRE127]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '(Optional) Just like the *step 9* in the *Integrating with Nuxt and streaming
    images from WordPress* section, if the Nuxt crawler fails to detect the dynamic
    routes for some unknown reasons, then generate these routes manually in the generate
    option in the Nuxt config file, as follows:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）就像*在与Nuxt集成并从WordPress流式传输图像*部分的*步骤9*一样，如果Nuxt爬虫由于某些未知原因无法检测到动态路由，那么在Nuxt配置文件的生成选项中手动生成这些路由，如下所示：
- en: '[PRE128]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In this optional step, you can see that we use the same JavaScript built-in
    object and methods – `Array`, `map`, `fill` and `push`, just as in the *Integrating
    with Nuxt and streaming images from WordPress* section, to work out the dynamic
    routes for the child pages and pagination for us, and then return them as a single
    array for Nuxt to generate their dynamic routes.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个可选步骤中，您可以看到我们使用相同的JavaScript内置对象和方法 - `Array`，`map`，`fill`和`push`，就像在*与Nuxt集成并从WordPress流式传输图像*部分中一样，为我们解决子页面的动态路由和分页，然后将它们作为单个数组返回给Nuxt生成它们的动态路由。
- en: 'Run the following script commands for either development or production:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下脚本命令，无论是开发还是生产：
- en: '[PRE129]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Remember that if you want to generate static pages and host the images in the
    same location, we have the ability to stream the remote images to the `/assets/`
    directory so that webpack can process these images for us. So, if you want to
    do that, then just as we've done previously, run `npm run stream` first to stream
    the remote images to your local disc and then run `npm run generate` to regenerate
    the static pages with the images before hosting them somewhere.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您想生成静态页面并将图像托管在同一位置，我们有能力将远程图像流式传输到`/assets/`目录，以便webpack可以为我们处理这些图像。因此，如果您想这样做，那么就像我们之前做的那样，首先运行`npm
    run stream`将远程图像流式传输到本地磁盘，然后运行`npm run generate`重新生成带有图像的静态页面，然后将它们托管在某个地方。
- en: You can find the code for this exercise in `/chapter-18/cross-domain/frontend/nuxt-universal/nuxt-keystone` in
    this book's GitHub repository.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-18/cross-domain/frontend/nuxt-universal/nuxt-keystone`中找到此练习的代码。
- en: Apart from using Axios, you can also use Nuxt Apollo module to send GraphQL
    queries to the server. For more information about this module and its usage, please
    visit [https://github.com/nuxt-community/apollo-module](https://github.com/nuxt-community/apollo-module).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用Axios，您还可以使用Nuxt Apollo模块向服务器发送GraphQL查询。有关此模块及其用法的更多信息，请访问[https://github.com/nuxt-community/apollo-module](https://github.com/nuxt-community/apollo-module)。
- en: Well done! You have successfully integrated Nuxt with the Keystone GraphQL API
    and streamed remote resources for static pages – just like did with the WordPress
    REST API. We hope that Keystone and GraphQL, in particular, have shown you another
    exciting API option. You can even take the GraphQL knowledge you have learned
    in this chapter further and develop your GraphQL API for Nuxt apps. You can also
    take Nuxt to the next level with many other technologies, just like some of those
    we have walked you through in this book. This book has been quite a journey. We
    hope it has benefitted you regarding web development and that you can take what
    you have learned from this book as far as you can. Now, let's summarize what you
    have learned in this chapter.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您已成功将Nuxt与Keystone GraphQL API集成，并为静态页面流式传输远程资源 - 就像您在WordPress REST API中所做的那样。我们希望Keystone和GraphQL特别是向您展示了另一个令人兴奋的API选项。您甚至可以进一步利用本章学到的GraphQL知识，为Nuxt应用程序开发自己的GraphQL
    API。您还可以通过本书介绍的许多其他技术，将Nuxt提升到更高的水平。这本书是一次相当艰难的旅程。我们希望它对您的Web开发有所裨益，并且您可以将从本书中学到的知识应用到更广泛的领域。现在，让我们总结一下您在本章学到的内容。
- en: Summary
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you managed to create custom post types and routes to extend
    the WordPress REST API, integrated with Nuxt, and streamed the remote resources
    from WordPress to generate static pages. You also managed to customize a CMS from
    Keystone by creating lists and fields. You then learned how to create a GraphQL
    API at a low level with GraphQL.js and at a high level with the GraphQL schema
    language and Apollo Server. Now that you've grasped the foundations of GraphQL,
    you can query the Keystone GraphQL API from the Nuxt app using GraphQL queries
    and Axios. And last, not least, you can stream remote resources from the Keystone
    project to the Nuxt project to generate static pages. Well done!
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您成功创建了自定义文章类型和路由，以扩展WordPress REST API，并与Nuxt集成，并从WordPress流式传输远程资源以生成静态页面。您还成功通过创建列表和字段来定制了Keystone的CMS。然后，您学会了如何使用GraphQL.js在低级别创建GraphQL
    API，并使用GraphQL模式语言和Apollo Server在高级别创建GraphQL API。现在您已经掌握了GraphQL的基础知识，可以使用GraphQL查询和Axios从Nuxt应用程序查询Keystone
    GraphQL API。最后，您还可以从Keystone项目流式传输远程资源到Nuxt项目以生成静态页面。干得好！
- en: This has been a very long journey. You've gone from learning about the directory
    structure of Nuxt to adding pages, routes, transitions, components, Vuex stores,
    plugins, and modules, and then to creating user logins and API authentication,
    writing end-to-end tests, and creating Nuxt SPAs (static pages). You've also integrated
    Nuxt with other technologies, tools, and frameworks, including MongoDB, RethinkDB,
    MySQL, PostgreSQL, and GraphQL; Koa, Express, Keystone, and Socket.IO; PHP and
    PSRs; Zurb Foundation and Less CSS; and Prettier, ESLint, and StandardJS.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常漫长的旅程。您从了解Nuxt的目录结构到添加页面、路由、过渡、组件、Vuex存储、插件和模块，然后到创建用户登录和API身份验证，编写端到端测试，并创建Nuxt
    SPA（静态页面）。您还将Nuxt与其他技术、工具和框架集成，包括MongoDB、RethinkDB、MySQL、PostgreSQL和GraphQL；Koa、Express、Keystone和Socket.IO；PHP和PSRs；Zurb
    Foundation和Less CSS；以及Prettier、ESLint和StandardJS。
- en: We hope that this has been an inspiring journey and that you will adopt Nuxt
    in your projects wherever it fits and take it further to benefit yourself as well
    as the community. Keep coding, be inspiring, and stay inspired. We wish you all
    the best.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这是一个激励人心的旅程，希望您在项目中采用Nuxt，并进一步发展，使自己和社区受益。继续编码，激发灵感，保持激励。祝您一切顺利。
- en: Note that a final app example of this book can be found on the author's website.
    It's a solelystatic-generated web app made entirely with Nuxt's `static` target
    and GraphQL! Please have a look and explore it at [https://lauthiamkok.net/](https://lauthiamkok.net/).
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本书的最终应用程序示例可以在作者的网站上找到。这是一个完全由Nuxt的`static`目标和GraphQL制作的静态生成的网络应用程序！请查看并在[https://lauthiamkok.net/](https://lauthiamkok.net/)上探索。
