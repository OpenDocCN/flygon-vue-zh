- en: Creating a Real-Time App with Nuxt
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nuxt创建实时应用程序
- en: In this chapter, we are going to venture a bit further with Nuxt to see how
    we can use it to work with other frameworks for making real-time apps. We will
    continue using Koa as the backend API but "enhance" it with RethinkDB and Socket.IO.
    In other words, we will turn our backend API into a **real-time API** with these
    two awesome frameworks and tools. At the same time, we will turn our frontend
    Nuxt app into a **real-time Nuxt app** with help from them as well. You can develop
    these two real-time apps on the single-domain approach if you prefer. However,
    this book favors the cross-domain approach so that we don't mix up the frontend
    and the backend dependencies and get confused over time. So, this will be another
    interesting and exciting chapter for you to learn from!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步探讨Nuxt，看看如何使用它与其他框架一起制作实时应用程序。我们将继续使用Koa作为后端API，但是通过RethinkDB和Socket.IO来“增强”它。换句话说，我们将使用这两个令人敬畏的框架和工具将我们的后端API转换为**实时API**。同时，我们还将借助它们将我们的前端Nuxt应用程序转换为**实时Nuxt应用程序**。如果您愿意，您可以在单域方法上开发这两个实时应用程序。但是，本书更倾向于跨域方法，以便我们不会混淆前端和后端的依赖关系，并随着时间的推移而感到困惑。因此，这将是另一个您可以从中学习的有趣而令人兴奋的章节！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing RethinkDB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍RethinkDB
- en: Integrating RethinkDB with Koa
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将RethinkDB与Koa集成
- en: Introducing Socket.IO
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Socket.IO
- en: Integrating Socket.IO with Nuxt
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Socket.IO与Nuxt集成
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Introducing RethinkDB
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍RethinkDB
- en: RethinkDB is an open-source JSON database for real-time apps. It pushes JSON
    data to your apps in real-time from the database whenever a change occurs in the
    database tables that you subscribe to their real-time feeds – changefeeds. Despite
    that the changefeeds lies at the heart of RethinkDB's real-time functionality,
    you can skip this functionality if you want to. You can use RethinkDB just like
    MongoDB to store and query your NoSQL database.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: RethinkDB是用于实时应用程序的开源JSON数据库。每当数据库表中发生更改时，它会从数据库实时推送JSON数据到您的应用程序，您可以订阅这些实时订阅
    - changefeeds。尽管changefeeds是RethinkDB实时功能的核心，但如果您愿意，您可以跳过此功能。您可以像使用MongoDB一样使用RethinkDB来存储和查询您的NoSQL数据库。
- en: Even though you can use the Change Streams in MongoDB to access the real-time
    data changes but it requires some configuration to get it started, while the real-time
    feeds are ready for use by default in RethinkDB and you can tap in right away
    without any configuration. Let's get started by installing the **RethinkDB server**
    in your system and see how you can use it in the next section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以使用MongoDB中的更改流来访问实时数据更改，但这需要一些配置才能启动，而实时订阅在RethinkDB中默认情况下已准备就绪，您可以立即开始使用，无需任何配置。让我们首先在您的系统中安装**RethinkDB服务器**，然后看看您如何在下一节中使用它。
- en: Installing RethinkDB Server
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装RethinkDB服务器
- en: At the time of writing this book, the current stable version of RethinkDB is
    **2.4.0** (**Night Of The Living Dead**), released on 19 December 2019\. There
    are a few ways to install a RethinkDB server, depending on the platform (Ubuntu,
    or OS). You can check out the guide at [https://rethinkdb.com/docs/install/](https://rethinkdb.com/docs/install/)
    for your platform. Note Windows is not supported yet in 2.4.0. For more information
    about this issue for Windows, please visit [https://rethinkdb.com/docs/install/windows](https://rethinkdb.com/docs/install/windows).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，RethinkDB的当前稳定版本是**2.4.0**（**活死人之夜**），于2019年12月19日发布。根据平台（Ubuntu或OS），有几种安装RethinkDB服务器的方法。您可以在[https://rethinkdb.com/docs/install/](https://rethinkdb.com/docs/install/)上查看您平台的指南。请注意，Windows在2.4.0中尚不受支持。有关Windows的更多信息，请访问[https://rethinkdb.com/docs/install/windows](https://rethinkdb.com/docs/install/windows)。
- en: 'In this book, we will install RethinkDB 2.4.0 on **Ubuntu 20.04 LTS** (Focal
    Fossa). It works the same if you are on Ubuntu 19.10 (Eoan Ermine), Ubuntu 19.04
    (Disco Dingo), or the older versions of Ubuntu, such as 18.04 LTS (Bionic Beaver).
    Let''s get started:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将在**Ubuntu 20.04 LTS**（Focal Fossa）上安装RethinkDB 2.4.0。如果您使用的是Ubuntu 19.10（Eoan
    Ermine）、Ubuntu 19.04（Disco Dingo）或较旧版本的Ubuntu，如18.04 LTS（Bionic Beaver），操作方式是相同的。让我们开始吧：
- en: 'Add the RethinkDB repository to your list of Ubuntu repositories, as follows:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RethinkDB存储库添加到Ubuntu存储库列表中，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Get the public key of RethinkDB using `wget`:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`wget`获取RethinkDB的公钥：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should get an OK message on your terminal for the preceding command line.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述命令行，您应该在终端上收到一个OK消息。
- en: 'Update your version of Ubuntu and install RethinkDB:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的Ubuntu版本并安装RethinkDB：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Verify RethinkDB:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证RethinkDB：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should get the following output on the terminal:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端上获得以下输出：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'RethinkDB comes with an administrative UI for you to manage databases on a
    browser at `localhost:8080`. This can be very handy and useful during project
    development. If you ever want to uninstall RethinkDB and remove all its databases,
    you can do so with the following commands:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: RethinkDB附带了一个管理UI，供您在浏览器上管理数据库，地址为`localhost:8080`。这在项目开发过程中非常方便和有用。如果您想要卸载RethinkDB并删除所有数据库，可以使用以下命令进行操作：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The administrative UI that came with the installation is like the PHP Adminer that
    you used to manage the MySQL databases for the PHP API in the previous chapter.
    You can use the RethinkDB administrative UI to add databases and tables by using
    the graphical buttons on the UI or using the RethinkDB query language (in JavaScript),
    **ReQL**. We'll explore the administrative UI and ReQL in the following section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装时附带的管理UI类似于您在上一章中用于管理PHP API的MySQL数据库的PHP Adminer。您可以使用RethinkDB管理UI通过UI上的图形按钮或使用JavaScript中的RethinkDB查询语言（ReQL）添加数据库和表。我们将在下一节中探索管理UI和ReQL。
- en: Introducing ReQL
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍ReQL
- en: 'ReQL is the query language of RethinkDB and is used for manipulating the JSON
    documents in RethinDB databases. The queries are constructed automatically by
    calling RethinkDB''s built-in chainable functions on the server-side. These functions
    are embedded in the driver in various programming languages JavaScript, Python,
    Ruby, and Java. You can check out the ReQL commands/functions at the following
    links:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ReQL是RethinkDB的查询语言，用于操作RethinDB数据库中的JSON文档。查询是通过在服务器端调用RethinkDB的内置可链接函数自动构建的。这些函数嵌入在各种编程语言的驱动程序中，包括JavaScript、Python、Ruby和Java。您可以在以下链接中查看ReQL命令/函数：
- en: JavaScript at [https://rethinkdb.com/api/javascript/](https://rethinkdb.com/api/javascript/)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript在[https://rethinkdb.com/api/javascript/](https://rethinkdb.com/api/javascript/)上。
- en: Python at [https://rethinkdb.com/api/python/](https://rethinkdb.com/api/python/)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python在[https://rethinkdb.com/api/python/](https://rethinkdb.com/api/python/)上。
- en: Ruby at [https://rethinkdb.com/api/ruby/](https://rethinkdb.com/api/ruby/)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby在[https://rethinkdb.com/api/ruby/](https://rethinkdb.com/api/ruby/)上。
- en: Java at [https://rethinkdb.com/api/java/](https://rethinkdb.com/api/java/)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java在[https://rethinkdb.com/api/java/](https://rethinkdb.com/api/java/)上。
- en: We will be using JavaScript in this book. Let's use the Data Explorer on the
    administrative UI to perform some CRUD operations by using the respective ReQL
    commands. You can navigate to the page where the Data Explorer is or point your
    browser to `localhost:8080/#dataexplorer` and start playing with the queries,
    as shown here. The default top-level namespace on the Data Explorer is `r`, so
    the ReQL commands must be chained to this namespace.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用JavaScript。让我们在管理UI上使用数据资源管理器，通过使用相应的ReQL命令执行一些CRUD操作。您可以导航到数据资源管理器所在的页面，或者将浏览器指向`localhost:8080/#dataexplorer`并开始使用查询，如下所示。数据资源管理器上的默认顶级命名空间是`r`，因此ReQL命令必须链接到此命名空间。
- en: 'However, we can change this `r` namespace and call anything we like when using
    the driver in our app, which we will do in the next section. For now, let''s stick
    to the default namespace, `r`, for this exercise:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们的应用程序中使用驱动程序时，我们可以更改这个`r`命名空间，并在下一节中使用任何我们喜欢的名称。现在，让我们在这个练习中坚持使用默认命名空间`r`。
- en: 'Create a database:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Click the Run button. You should get a result similar to the following on the
    screen showing that one database has been created with the database name you chose
    and that an ID was generated by RethinkDB:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行按钮。您应该在屏幕上看到类似以下的结果，显示已创建一个数据库，数据库名称由您选择，并且RethinkDB生成了一个ID：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you want to find out more information about the `dbCreate` ReQL command,
    please visit [https://rethinkdb.com/api/javascript/db_create/](https://rethinkdb.com/api/javascript/db_create/).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关`dbCreate` ReQL命令的更多信息，请访问[https://rethinkdb.com/api/javascript/db_create/](https://rethinkdb.com/api/javascript/db_create/)。
- en: 'Create a table in an existing database; for example, create a `user` table
    in the `nuxtdb` database:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有数据库中创建表；例如，在`nuxtdb`数据库中创建一个`user`表：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Click the Run button. You should get a result similar to the following on the
    screen showing that one table has been created with an ID generated by RethinkDB
    for you and other information about the table that you created:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行按钮。您应该在屏幕上看到类似以下的结果，显示RethinkDB为您生成的一个带有ID的表已被创建，并显示您创建的表的其他信息：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you want to find out more information about the `tableCreate` ReQL command,
    please visit [https://rethinkdb.com/api/javascript/table_create/](https://rethinkdb.com/api/javascript/table_create/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关`tableCreate` ReQL命令的更多信息，请访问[https://rethinkdb.com/api/javascript/table_create/](https://rethinkdb.com/api/javascript/table_create/)。
- en: 'Insert new documents into the `user` table:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文档插入`user`表中：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Click the Run button. You should get a result similar to the following on the
    screen, showing that two documents have been inserted with keys generated by RethinkDB
    for you:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行按钮。您应该在屏幕上看到类似以下的结果，显示RethinkDB为您生成的两个带有键的文档已被插入：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you want to find out more information about the `table` and `insert` ReQL
    commands, please visit [https://rethinkdb.com/api/javascript/table/](https://rethinkdb.com/api/javascript/table/)
    and [https://rethinkdb.com/api/javascript/insert/](https://rethinkdb.com/api/javascript/insert/),
    respectively.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关`table`和`insert` ReQL命令的更多信息，请分别访问[https://rethinkdb.com/api/javascript/table/](https://rethinkdb.com/api/javascript/table/)和[https://rethinkdb.com/api/javascript/insert/](https://rethinkdb.com/api/javascript/insert/)。
- en: 'Retrieve documents from the `user` table:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`user`表中检索文档：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Click the Run button. You should get a result similar to the following on the
    screen, showing two documents from the `user` table:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行按钮。您应该在屏幕上看到类似以下的结果，显示`user`表中的两个文档：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can chain the `count` method to the query if you want to count the total
    documents in a table, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要计算表中的总文档数，可以将`count`方法链接到查询中，如下所示：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should get `2` in the `user` table after injecting the new documents.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在注入新文档后，`user`表中应该有`2`个文档。
- en: If you want to find out more information about the `count` ReQL command, please
    visit [https://rethinkdb.com/api/javascript/count/](https://rethinkdb.com/api/javascript/count/).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关`count` ReQL命令的更多信息，请访问[https://rethinkdb.com/api/javascript/count/](https://rethinkdb.com/api/javascript/count/)。
- en: 'Update the documents in the `user` table by filtering the table with the `slug` key:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`user`表中的文档，通过使用`slug`键过滤表：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Click the Run button. You should get the following result on the screen, showing
    that one document has been replaced:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行按钮。您应该在屏幕上看到以下结果，显示已替换一个文档：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you want to find out more information about the `filter` and `update` ReQL
    commands, please visit [https://rethinkdb.com/api/javascript/filter/](https://rethinkdb.com/api/javascript/filter/)
    and [https://rethinkdb.com/api/javascript/update/](https://rethinkdb.com/api/javascript/update/),
    respectively.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关`filter`和`update` ReQL命令的更多信息，请分别访问[https://rethinkdb.com/api/javascript/filter/](https://rethinkdb.com/api/javascript/filter/)和[https://rethinkdb.com/api/javascript/update/](https://rethinkdb.com/api/javascript/update/)。
- en: Also, if you want to find out more information about the `row` and `eq` ReQL
    commands, please visit [https://rethinkdb.com/api/javascript/row/](https://rethinkdb.com/api/javascript/row/)
    and [https://rethinkdb.com/api/javascript/eq/](https://rethinkdb.com/api/javascript/eq/),
    respectively.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果您想了解有关`row`和`eq` ReQL命令的更多信息，请分别访问[https://rethinkdb.com/api/javascript/row/](https://rethinkdb.com/api/javascript/row/)和[https://rethinkdb.com/api/javascript/eq/](https://rethinkdb.com/api/javascript/eq/)。
- en: 'Delete a document from the `user` table by filtering the table with the `slug` key:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`slug`键过滤表格来从`user`表中删除文档：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Click the Run button. You should get the following result on the screen, showing
    that one document has been deleted:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行按钮。您应该在屏幕上看到以下结果，显示已删除一个文档：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you want to delete all the documents in a table, then simply chain the `delete` method
    to the table without filtering, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想删除表中的所有文档，那么只需将`delete`方法链接到表而不进行过滤，如下所示：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you want to find out more information about the `delete` ReQL command, please
    visit [https://rethinkdb.com/api/javascript/delete/](https://rethinkdb.com/api/javascript/delete/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关`delete` ReQL命令的更多信息，请访问[https://rethinkdb.com/api/javascript/delete/](https://rethinkdb.com/api/javascript/delete/)。
- en: It is fun and easy in using ReQL commands, isn't it? You don't have to read
    through all the ReQL commands and study each of them in great detail to be productive.
    You just have to know what you want to do and find the commands you need from
    the ReQL command reference/API page based on the programming language that you
    already know about. Next, you will find out how to add the **RethinkDB client**
    or driver to your app. Let's get to it!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ReQL命令时，这很有趣也很容易，不是吗？您不必阅读所有ReQL命令并详细研究每个命令以提高生产力。您只需要知道您想要做什么，并根据您已经了解的编程语言从ReQL命令参考/API页面中找到您需要的命令。接下来，您将找出如何将**RethinkDB客户端**或驱动程序添加到您的应用程序中。让我们开始吧！
- en: Integrating RethinkDB with Koa
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将RethinkDB与Koa集成
- en: In this section, we will build a simple API following the PHP APIs that we created
    in the previous chapter to list, add, update, and delete users. In the previous
    API, we used PHP and MySQL, while in this chapter, we will use JavaScript and
    RethinkDB. We will still use Koa as the framework for our API. But this time,
    we will restructure the API directory so that the structure is consistent (as
    much as possible) with the directory structure you already familiar with for the
    Nuxt app and PHP API. So, let's get started!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个简单的API，按照我们在上一章中创建的PHP API的方式列出、添加、更新和删除用户。在之前的API中，我们使用了PHP和MySQL，而在本章中，我们将使用JavaScript和RethinkDB。我们仍将使用Koa作为API的框架。但这一次，我们将重新构建API目录，使其结构与您已经熟悉的Nuxt应用程序和PHP
    API的目录结构保持一致（尽可能）。所以，让我们开始吧！
- en: Restructuring API directories
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构API目录
- en: 'Remember the default directory structure that you get in your project when
    using Vue CLI, which you learned about in [Chapter 11](b24caa1b-6337-40ee-9c1a-c8586db1f3b2.xhtml),
    *Writing Route Middleware and Server Middleware*? After installing a project with
    Vue CLI, if you take a look inside the project directory, you will see a barebones project
    structure in which you can find a `/src/` directory to develop your components,
    pages, and routes, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当使用Vue CLI时，您在项目中获得的默认目录结构，您在[第11章](b24caa1b-6337-40ee-9c1a-c8586db1f3b2.xhtml)中了解过，*编写路由中间件和服务器中间件*？使用Vue
    CLI安装项目后，如果您查看项目目录，您将看到一个基本的项目结构，其中包含`/src/`目录，用于开发组件、页面和路由，如下所示：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have been using this kind of standard structure for the cross-domain apps
    since [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml), *Creating User
    Logins and API Authentication*. For example, the following is the directory structure
    for Koa APIs, which you made previously:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 自[第12章](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml)以来，我们一直在为跨域应用程序使用这种标准结构，*创建用户登录和API身份验证*。例如，以下是您之前创建的Koa
    API的目录结构：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But this time, we will eliminate the `/src/` directory from the APIs that we
    are going to make in this chapter. So, let''s move everything in the `/src/` directory
    up to the top level and reconfigure how we bootstrap the app, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这一次，我们将在本章中要创建的API中消除`/src/`目录。因此，让我们将`/src/`目录中的所有内容移动到顶层，并重新配置应用程序的引导方式，如下所示：
- en: 'Create the following files and folders in the project''s root directory:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中创建以下文件和文件夹：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, the directory structure here is merely a suggestion; you can design
    your directory structure as you wish so that it suits you the most. But let''s
    take a glance at this suggested directory and study what these folders and files
    are used for:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里的目录结构仅仅是一个建议；您可以根据自己的需求设计自己的目录结构，使其最适合您。但让我们来看看这个建议的目录，并研究这些文件和文件夹的用途：
- en: The `/configs/` directory is used to store the app's basic information and the
    RethinkDB database connection's details.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/configs/`目录用于存储应用程序的基本信息和RethinkDB数据库连接的详细信息。'
- en: The `/public/` directory is used to store the files for initiating the app.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/public/`目录用于存储启动应用程序的文件。'
- en: The `/modules/` directory is used to store the modules of the app, such as the
    `'user'` module, which we will create in the upcoming sections.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/modules/`目录用于存储应用程序的模块，例如我们将在接下来的章节中创建的`''user''`模块。'
- en: The `/core/` directory is used to store the common functions or classes that
    can be used throughout the app.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/core/`目录用于存储可以在整个应用程序中使用的常用函数或类。'
- en: The `middlewares.js` file is the core location for importing middleware from
    the `/middlewares/` and `/node_modules/` directories.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`middlewares.js`文件是从`/middlewares/`和`/node_modules/`目录导入中间件的核心位置。'
- en: The `routes.js` file is the core location for importing routes from the `/modules`
    directory.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes.js`文件是从`/modules`目录导入路由的核心位置。'
- en: The `backpack.config.js` file is used to customize the webpack configuration
    for our app.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backpack.config.js`文件用于自定义我们应用程序的webpack配置。'
- en: The `package.json` file contains the scripts and dependencies of our app and
    is always located at the root level.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`文件包含我们应用程序的脚本和依赖项，并始终位于根目录。'
- en: 'Point the entry file to the `index.js` file in the `/public/` directory:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将入口文件指向`/public/`目录中的`index.js`文件：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember that the default entry file in Backpack is an `index.js` file in the
    `/src/` directory. Since we have moved this index file to the `/public/` directory,
    we must configure this entry point through the Backpack config file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Backpack中的默认入口文件是`/src/`目录中的`index.js`文件。由于我们已将此索引文件移动到`/public/`目录，因此必须通过Backpack配置文件配置此入口点。
- en: If you want to know more about the entry points in webpack, please visit [https://webpack.js.org/concepts/entry-points/](https://webpack.js.org/concepts/entry-points/).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解webpack中的入口点，请访问[https://webpack.js.org/concepts/entry-points/](https://webpack.js.org/concepts/entry-points/)。
- en: 'Add aliases for the `/configs`, `/core`, `/modules`, and `/middlewares` paths
    to the `resolve` option in the webpack configuration before returning the `config`
    object in the Backpack config file:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回Backpack配置文件中的`config`对象之前，在webpack配置中的`resolve`选项中为`/configs`、`/core`、`/modules`和`/middlewares`路径添加别名：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using aliases to resolve the file path in our app is very useful and handy.
    Typically, we import files using the relative paths, like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用别名来解析文件路径非常有用和方便。通常，我们使用相对路径导入文件，就像这样：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instead of doing this, now, we can import files from anywhere with the alias
    that tucks away the relative path, thus making our code neater:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用别名从任何地方导入文件，这样可以隐藏相对路径，从而使我们的代码更整洁：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you want to find out more about the alias and resolve options in webpack,
    please visit [https://webpack.js.org/configuration/resolve/resolvealias](https://webpack.js.org/configuration/resolve/#resolvealias).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解webpack中的别名和解析选项，请访问[https://webpack.js.org/configuration/resolve/resolvealias](https://webpack.js.org/configuration/resolve/#resolvealias)。
- en: Once you have the preceding structure ready and the entry file sorted, you can
    start applying the CRUD operations with RethinkDB to this API. But first, you
    will need to install the **RethinkDB JavaScript client** into your project. So,
    let's get started!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您准备好了上述结构并且入口文件已经排序好，您就可以开始将CRUD操作应用到此API中。但首先，您需要将**RethinkDB JavaScript客户端**安装到您的项目中。所以，让我们开始吧！
- en: Adding and using the RethinkDB JavaScript client
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加并使用RethinkDB JavaScript客户端
- en: Depending on the programming knowledge you have, there are several official
    client drivers you can choose from regarding JavaScript, Ruby, Python, and Java.
    There are many community-supported drivers as well, such as PHP, Perl, and R.
    You can check them out at [https://rethinkdb.com/docs/install-drivers/](https://rethinkdb.com/docs/install-drivers/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您拥有的编程知识，您可以选择几个官方客户端驱动程序，包括JavaScript、Ruby、Python和Java。还有许多社区支持的驱动程序，如PHP、Perl和R。您可以在[https://rethinkdb.com/docs/install-drivers/](https://rethinkdb.com/docs/install-drivers/)上查看它们。
- en: 'In this book, we will be using the RethinkDB JavaScript client driver. We will
    guide you through the installation and how to use the CRUD operations using this
    driver in the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用RethinkDB JavaScript客户端驱动程序。我们将指导您通过以下步骤安装并使用此驱动程序进行CRUD操作：
- en: 'Install the RethinkDB JavaScript client driver via npm:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm安装RethinkDB JavaScript客户端驱动程序：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a `rethinkdb.js` file that will contain the RethinkDB server connection
    details in the `/configs/` directory, as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`rethinkdb.js`文件，其中包含RethinkDB服务器连接详细信息，放在`/configs/`目录中，如下所示：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a `connection.js` file for opening a RethinkDB server connection with
    the preceding connection details in the `/core/` directory, as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`connection.js`的文件，其中包含在`/core/`目录中的上述连接详细信息，用于打开RethinkDB服务器连接，如下所示：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Also, create an open connection middleware with an `open.js` file in the `/middlewares/`
    directory and bind it to the Koa context as another option to connect to RethinkDB,
    as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，还可以创建一个名为`open.js`的开放连接中间件文件，并将其绑定到Koa上下文中作为连接到RethinkDB的另一种选择，放在`/middlewares/`目录中。
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It is a good practice, which we learned from PHP's PSR-4, to use the directory
    path to describe your middleware (or CRUD operations) so that you don't have to
    use a long name to describe your file. For example, you might want to name this
    middleware `rdb-connection-open.js` to describe what it is **as clearly as possible** if
    you are not using a descriptive directory path for it. But if you are using the
    directory path to describe the middleware, then you can just name the file something
    as simple as `open.js`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用目录路径来描述你的中间件（或CRUD操作）是一个很好的做法，我们从PHP的PSR-4中学到了这一点，这样你就不必使用一个很长的名称来描述你的文件。例如，如果你没有使用描述性的目录路径，你可能想将这个中间件命名为`rdb-connection-open.js`，以尽可能清楚地描述它。但如果你使用目录路径来描述中间件，那么你可以简单地将文件命名为`open.js`。
- en: 'Create a close connection middleware with a `close.js` file in the `/middlewares/`
    directory and bind it to the Koa context as the last middleware, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/middlewares/`目录中创建一个`close.js`文件，创建一个关闭连接中间件，并将其绑定到Koa上下文作为最后一个中间件，如下所示：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Import the `open` and `close` connection middleware in the root `middlewares.js`
    file and register them to the app, as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录的`middlewares.js`文件中导入`open`和`close`连接中间件，并将它们注册到应用程序中，如下所示：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, you can see that the `open` connection middleware is registered **before**
    all the module routes and that the `close` connection middleware is registered
    **last** so that they are called first and last, respectively.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`open`连接中间件在所有模块路由之前注册，而`close`连接中间件则在最后注册，这样它们分别被首先和最后调用。
- en: 'In the upcoming steps, we will use the following template code with a Koa router
    and the RethinkDB client driver to make the CRUD operation. For example, the following
    code shows how we apply the template code for fetching all the users from the
    `user` table in the `user` module:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将使用以下模板代码与Koa路由器和RethinkDB客户端驱动进行CRUD操作。例如，以下代码显示了我们如何将模板代码应用于从`user`模块中的`user`表中获取所有用户的操作：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's go through this code and understand what it does. Here, you can see that
    we are using a custom top-level namespace, `rdb`, for the RethinkDB client driver,
    as opposed to the `r` namespace that you have practiced on `localhost:8080`. Also,
    when using the RethinkDB client driver in our app, we must always call the `run`
    method at the end of the ReQL commands with the RethinkDB server connection to
    construct the query and pass it onto the server for execution.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码，了解它的作用。在这里，你可以看到我们在应用中使用了自定义的顶级命名空间`rdb`，用于RethinkDB客户端驱动，而不是你在`localhost:8080`上练习过的`r`命名空间。此外，在我们的应用中使用RethinkDB客户端驱动时，我们必须始终在ReQL命令的末尾调用`run`方法，以及RethinkDB服务器连接，以构造查询并将其传递到服务器执行。
- en: Furthermore, we must call the `next` method at the end of the code so that we
    can pass the execution of the app to the next piece of middleware, especially
    the `close` connection middleware, which is used to close the RethinkDB connection.
    We should perform checks on the incoming parameters and data from the client before
    performing any CRUD operations. Then, we should wrap our code in `try-catch` blocks
    to catch and throw any potential errors.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须在代码的末尾调用`next`方法，以便将应用的执行传递给下一个中间件，特别是用于关闭RethinkDB连接的`close`连接中间件。在执行任何CRUD操作之前，我们应该对来自客户端的传入参数和数据进行检查。然后，我们应该将我们的代码包装在`try-catch`块中，以捕获和抛出任何潜在的错误。
- en: Note that in the upcoming steps, we will skip writing the parameter verification
    and the try-catch statement from the code to avoid lengthy and repetitive code
    lines and blocks, but you should have them included in your actual code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在接下来的步骤中，我们将跳过编写参数验证和try-catch语句的代码，以避免冗长和重复的代码行和代码块，但你应该在实际代码中包含它们。
- en: 'Create a `create-user.js` file in the `/_routes/` folder in the `user` module
    with the following code for injecting new users into the `user` table in the database:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user`模块的`/_routes/`文件夹中创建一个名为`create-user.js`的文件，其中包含以下代码，用于将新用户注入到数据库中的`user`表中：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We should throw the error if the insertion fails and pass the error message
    to the Koa `throw` method with the HTTP error code so that we can catch them with
    the `try-catch` blocks and display them on the frontend.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插入失败，我们应该抛出错误，并将错误消息传递给Koa的`throw`方法，以便我们可以在前端使用`try-catch`块捕获它们并显示出来。
- en: 'Create a `fetch-user.js` file in the `/_routes/` folder in the `user` module
    to fetch a specific user from the `user` table by using the `slug` key, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user`模块的`/_routes/`文件夹中创建一个名为`fetch-user.js`的文件，用于通过使用`slug`键从`user`表中获取特定用户，如下所示：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We added the `nth` command in the query to display the document by its position.
    In our case, we just want to get the first document, so we pass a `0` integer
    to this method. We also added the `default` command to return a `null` exception
    if no users are found in the `user` table.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在查询中添加了`nth`命令，以显示文档的位置。在我们的情况下，我们只想获取第一个文档，因此我们将一个`0`整数传递给此方法。我们还添加了`default`命令，以便在`user`表中找不到用户时返回一个`null`异常。
- en: 'Create an `update-user.js` file in the `/_routes/` folder in the `user` module
    for updating the existing user in the `user` table by using the document ID, as
    follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user`模块的`/_routes/`文件夹中创建一个名为`update-user.js`的文件，用于通过使用文档ID更新`user`表中的现有用户，如下所示：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We added the `get` command in the query to fetch the specific document by its
    ID first, before running the update.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在查询中添加了`get`命令，首先通过其ID获取特定文档，然后再运行更新。
- en: 'Create a `delete-user.js` file in the `/_routes/` folder in the `user` module
    for deleting the existing user from the `user` table by using the document ID,
    as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user`模块的`/_routes/`文件夹中创建一个名为`delete-user.js`的文件，用于通过使用文档ID从`user`表中删除现有用户，如下所示：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Lastly, refactor the CRUD operation for listing all the users from the `user`
    table that you just created in *step 7* by adding an `orderBy` command to the
    query in the `index.js` file, which is kept in the `/_routes/` folder, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`index.js`文件中对刚刚在*步骤7*中创建的用于列出`user`表中所有用户的CRUD操作进行重构，通过在查询中添加`orderBy`命令，该文件位于`/_routes/`文件夹中，如下所示：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We added the `orderBy` command to the query so that we can sort the documents
    by their creation dates descendingly (the latest first). Also, the documents returned
    by the RethinkDB database are always contained in a **cursor object** as a callback
    from the CRUD operation, so we must use the `toArray` command to iterate through
    the cursor and convert the object into an array.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在查询中添加了`orderBy`命令，以便我们可以按创建日期降序（最新的在前）对文档进行排序。此外，RethinkDB数据库返回的文档始终作为CRUD操作的回调包含在一个**游标对象**中，因此我们必须使用`toArray`命令来遍历游标并将对象转换为数组。
- en: If you want to find out more about the `orderBy` and `toArray` commands, please
    visit [https://rethinkdb.com/api/javascript/order_by/](https://rethinkdb.com/api/javascript/order_by/)
    and [https://rethinkdb.com/api/javascript/to_array/](https://rethinkdb.com/api/javascript/to_array/),
    respectively.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于`orderBy`和`toArray`命令，请访问[https://rethinkdb.com/api/javascript/order_by/](https://rethinkdb.com/api/javascript/order_by/)和[https://rethinkdb.com/api/javascript/to_array/](https://rethinkdb.com/api/javascript/to_array/)。
- en: With that, you have implemented the CRUD operations with RethinkDB in your API
    successfully. Again, this is easy and fun, isn't it? But we still can improve
    the "quality" of the document we store in the database by enforcing schema in
    the RethinkDB databases. We'll learn how to do this in the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您已成功在API中使用RethinkDB实现了CRUD操作。再次强调，这很容易且有趣，不是吗？但是我们仍然可以通过在RethinkDB数据库中强制执行模式来提高我们存储的文档的“质量”。我们将在下一部分学习如何做到这一点。
- en: Enforcing schema in RethinkDB
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在RethinkDB中强制执行模式
- en: 'Just like the BSON databases in MongoDB, the JSON databases in RethinkDB are
    also **schemaless**. This means no blueprints and no formula or integrity constraints
    are imposed on the databases. No organized rule of how the database is constructed
    can pose the issue of integrity in our databases. Certain documents can contain
    different and unwanted keys in the same table (or "collection" in MongoDB), along
    with the documents that have the correct keys. You may inject some keys by mistake
    or forget to inject the required keys and values. So, it can be a good idea to
    enforce some sort of schema in our JSON or BSON databases if you want to keep
    the data in your documents organized. There is no internal feature from RethinkDB
    (or MongoDB) for enforcing the schema, but we can create custom functions to impose
    some basic schema with the Node.js Lodash module. Let''s explore how to do this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就像MongoDB中的BSON数据库一样，RethinkDB中的JSON数据库也是**无模式**的。这意味着数据库上没有蓝图，也没有强加在数据库上的公式或完整性约束。数据库的构造方式没有组织规则可能会引发数据库完整性的问题。同一张表（或MongoDB中的“集合”）中的某些文档可能包含不同和不需要的键，以及具有正确键的文档。您可能会错误地注入一些键，或者忘记注入所需的键和值。因此，如果您希望保持文档中的数据有组织，强制执行JSON或BSON数据库中的某种模式可能是一个好主意。RethinkDB（或MongoDB）没有内部功能来强制执行模式，但我们可以使用Node.js
    Lodash模块创建自定义函数来强制执行一些基本模式。让我们探讨如何做到这一点：
- en: 'Install the Lodash module via npm:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm安装Lodash模块：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a `utils.js` file in the `/core/` directory and import `lodash` to create
    a function called `sanitise`, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/core/`目录中创建一个`utils.js`文件，并导入`lodash`以创建一个名为`sanitise`的函数，如下所示：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This function simply picks the default keys that you set and ignores any additional
    keys that are not in the "schema".
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地选择您设置的默认键，并忽略任何不在“模式”中的额外键。
- en: 'We are using the following methods from Lodash. For more information about
    each of them, please visit the following links: [https://lodash.com/docs/4.17.15#keys](https://lodash.com/docs/4.17.15#keys) for
    the `keys`method [https://lodash.com/docs/4.17.15#defaults](https://lodash.com/docs/4.17.15#defaults) for
    the `defaults`method [https://lodash.com/docs/4.17.15#pick](https://lodash.com/docs/4.17.15#pick) for
    the `pick` method'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Lodash中的以下方法。有关每种方法的更多信息，请访问以下链接：[https://lodash.com/docs/4.17.15#keys](https://lodash.com/docs/4.17.15#keys) 获取`keys`方法的信息
    [https://lodash.com/docs/4.17.15#defaults](https://lodash.com/docs/4.17.15#defaults) 获取`defaults`方法的信息
    [https://lodash.com/docs/4.17.15#pick](https://lodash.com/docs/4.17.15#pick) 获取`pick`方法的信息
- en: 'Create a `user` schema in the `user` module with the following keys that only
    you want to accept:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user`模块中创建一个`user`模式，只接受以下键：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Import the `sanitise` method and the preceding schema into the route that you
    want to enforce the schema; for example, in the `create-user.js` file:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在要强制执行模式的路由中导入`sanitise`方法和前面的模式；例如，在`create-user.js`文件中：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, the example fields, `username` and `password`, won't
    be injected into the document in the `user` table when sanitizing the data before
    insertion.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，示例字段`username`和`password`在插入数据之前对数据进行清理时不会被注入到`user`表中的文档中。
- en: You can see that this `sanitise` function only performs a simple validation.
    If you need more complicated and advanced data validation, you can use the Node.js
    joi module from the hapi web framework.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这个`sanitise`函数只执行简单的验证。如果您需要更复杂和高级的数据验证，可以使用hapi web框架的Node.js joi模块。
- en: If you want to find out more about this module, please visit [https://hapi.dev/module/joi/](https://hapi.dev/module/joi/).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于这个模块的信息，请访问[https://hapi.dev/module/joi/](https://hapi.dev/module/joi/)。
- en: The next thing you must explore is the **changefeeds** in RethinkDB. This is
    the main purpose of this chapter – to show you how to make use of the real-time
    feature of RethinkDB to create real-time apps. So, let's explore and play with
    the changefeeds in RethinkDB!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您接下来必须探索RethinkDB中的**changefeeds**。这是本章的主要目的 - 展示如何利用RethinkDB的实时功能创建实时应用程序。因此，让我们探索并玩转RethinkDB中的changefeeds！
- en: Introducing changefeeds in RethinkDB
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍RethinkDB中的changefeeds
- en: 'Before applying the changefeeds in our app with the RethinkDB client driver,
    let''s use the Data Explorer from the Administration UI again at `localhost:8080/#dataexplorer`
    to see the real-time feeds in real time on the screen:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用RethinkDB客户端驱动程序在我们的应用程序中应用changefeeds之前，让我们再次在`localhost:8080/#dataexplorer`的管理UI中使用数据浏览器，实时在屏幕上查看实时feeds：
- en: 'Paste in the following ReQL query and click the Run button:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 粘贴以下的ReQL查询，并单击“运行”按钮：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see the following information on your browser screen:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在浏览器屏幕上看到以下信息：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Open another tab on your browser and point it to `localhost:8080/#dataexplorer`.
    Now, you have two data explorers. Drag one out from the browser tab so that you
    can place them side by side. Then, insert the new documents into the `user` table
    from one of the data explorers:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器上打开另一个标签，并将其指向`localhost:8080/#dataexplorer`。现在，您有两个数据浏览器。将其中一个从浏览器标签中拖出来，以便您可以将它们并排放置。然后，从其中一个数据浏览器中将新文档插入`user`表中：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should get the following result:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下结果：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At the same time, you should see the other Data Explorer displaying the following
    feeds instantaneously in real time:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，您应该立即在另一个数据浏览器中看到以下feeds的实时显示：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Hooray! You have just made real-time feeds effortlessly with RethinkDB! Notice
    that you will always get these two keys, `new_val` and `old_val`, in each of the
    real-time feeds. They have the following implications:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！您刚刚轻松地使用RethinkDB创建了实时feeds！请注意，您将始终在每个实时feed中获得这两个键，`new_val`和`old_val`。它们具有以下含义：
- en: If you get the data in `new_val` but it's `null` in `old_val`, that means the
    new document is injected into the database.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在`new_val`中获取数据，但在`old_val`中获取的是`null`，这意味着新文档被注入到数据库中。
- en: If you get the data in both `new_val` and `old_val`, that means the existing
    document is updated in the database.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在`new_val`和`old_val`中都获取到数据，这意味着现有文档在数据库中已更新。
- en: If you get the data in `old_val` but it's `null` in `new_val`, that means the
    existing document is removed from the database.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在`old_val`中获取数据，但在`new_val`中获取的是`null`，这意味着现有文档已从数据库中删除。
- en: You will get to use these keys when we use them in the Nuxt app in the last
    section of this chapter. So, don't worry too much about them for now. Instead,
    the next challenge is to implement it in the API and the Nuxt app. To do that,
    we will need another Node.js module – **Socket.IO**. So, let's explore how this
    module can help you to achieve that.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章的最后一节中在Nuxt应用程序中使用它们时，您将可以使用这些键。因此，现在不要太担心它们。相反，下一个挑战是在API和Nuxt应用程序中实现它。为此，我们将需要另一个Node.js模块
    - **Socket.IO**。因此，让我们探索一下这个模块如何帮助您实现这一目标。
- en: Introducing Socket.IO
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Socket.IO
- en: Just like HTTP, WebSocket is a communication protocol, but it provides full-duplex
    (bidirectional) communication between the client and the server. Unlike HTTP,
    the WebSocket connection always remains open for real-time data transfer. So,
    in WebSocket apps, the server can send data to the client without having the client
    initiate the request.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就像HTTP一样，WebSocket是一种通信协议，但它提供了客户端和服务器之间的全双工（双向）通信。与HTTP不同，WebSocket连接始终保持开放状态，用于实时数据传输。因此，在WebSocket应用程序中，服务器可以在没有客户端发起请求的情况下向客户端发送数据。
- en: 'Also, unlike the HTTP schema that starts with HTTP or HTTPS for Hypertext Transfer
    Protocol Secure, the WebSocket protocol schema starts with `ws` or `wss` for WebSocket
    Secure; for example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，与以HTTP或HTTPS开头的HTTP模式不同，WebSocket协议模式以`ws`或`wss`开头，例如：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Socket.IO is a JavaScript library that uses the WebSocket protocol and polling
    as the fallback option for creating real-time web apps. It supports any platform,
    browser, or device and handles all the degradation for the server and client to
    get the full-duplex communication in real time. Most browsers support the WebSocket
    protocol these days anyway, including Google Chrome, Microsoft Edge, Firefox,
    Safari, and Opera. But when using Socket.IO, we must use its client-side and server-side
    libraries together. The client-side library runs inside the browser, while the
    server-side library runs on your server-side Node.js app. So, let's get these
    two libraries working in our apps.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO是一个使用WebSocket协议和轮询作为创建实时Web应用的备用选项的JavaScript库。它支持任何平台、浏览器或设备，并处理服务器和客户端的所有降级，以实现实时的全双工通信。大多数浏览器现在都支持WebSocket协议，包括Google
    Chrome、Microsoft Edge、Firefox、Safari和Opera。但是在使用Socket.IO时，我们必须同时使用其客户端和服务器端库。客户端库在浏览器内运行，而服务器端库在服务器端的Node.js应用程序上运行。因此，让我们在我们的应用程序中让这两个库一起工作。
- en: If you want to find out more about Socket.IO, please visit [https://socket.io/](https://socket.io/).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Socket.IO的信息，请访问[https://socket.io/](https://socket.io/)。
- en: Adding and using Socket.IO server and client
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和使用Socket.IO服务器和客户端
- en: 'We will add the Socket.IO server to the API that we have been building in the
    last few sections, and then add the Socket.IO client to the Nuxt app eventually.
    But before adding it to the Nuxt app, we will add it to a simple HTML page so
    that we have a bird''s-eye view of how the Socket.IO server and Socket.IO client
    work together. Let''s learn how to do so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把Socket.IO服务器添加到我们在最近几节中构建的API中，然后最终将Socket.IO客户端添加到Nuxt应用程序中。但在将其添加到Nuxt应用程序之前，我们将其添加到一个简单的HTML页面中，以便我们可以全面了解Socket.IO服务器和Socket.IO客户端是如何一起工作的。让我们学习如何做到这一点：
- en: 'Install the Socket.IO server via npm:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm安装Socket.IO服务器：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create an `index.js` file in the `/configs/` directory to store the server
    setting if you haven''t done so yet:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，可以在`/configs/`目录中创建一个`index.js`文件来存储服务器设置：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: From this simple setting, we will be serving our API at port 4000.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个简单的设置中，我们将在端口4000上提供我们的API。
- en: 'Import `socket.io` and bind it to the Node.js HTTP object with the new instance
    of Koa to create a new instance of Socket.IO, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`socket.io`并将其绑定到Node.js HTTP对象，使用Koa的新实例创建一个新的Socket.IO实例，如下所示：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After creating the new instance of Socket.IO, we can start listening to the
    Socket.IO `connection` event for the incoming socket from the `socket` callback.
    We log the incoming socket to the console with its ID. We also log the incoming
    socket''s `disconnect` event when it is disconnected. Lastly, notice that we start
    and serve the app on `localhost:4000` by using the native Node.js HTTP, as opposed
    to using the HTTP inside Koa, which we used to do:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Socket.IO的新实例后，我们可以开始监听Socket.IO的`connection`事件，以接收来自`socket`回调的传入socket。我们将传入的socket记录到控制台并附带其ID。当socket断开连接时，我们还会记录传入socket的`disconnect`事件。最后，请注意，我们使用原生Node.js
    HTTP来启动和提供应用程序在`localhost:4000`上，而不是使用我们以前使用的Koa内部的HTTP：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a `socket-client.html` page and import the Socket.IO client via CDN.
    Create a new instance of it by passing `localhost:4000` as the specific URL, as
    follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`socket-client.html`页面，并通过CDN导入Socket.IO客户端。通过将`localhost:4000`作为特定URL传递来创建一个新的实例，如下所示：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, if you browse this HTML page on your browser, or when you refresh the
    page, you should see the console printing the log with the socket ID, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在浏览器上浏览这个HTML页面，或者当你刷新页面时，你应该看到控制台打印出带有socket ID的日志，如下所示：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should also see the console printing the log with the socket ID when you
    close the HTML page, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你关闭HTML页面时，你也应该看到控制台打印出带有socket ID的日志，如下所示：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That's all you need to do in order to connect the server and client sides of
    Socket.IO. This is extremely simple and easy, isn't it? But all we're doing here
    is connecting and disconnecting the server and client. We need more from them
    – we want to transmit data simultaneously. To do that, we just need to emit and
    receive events from and to each other, which we'll do in the upcoming steps.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是连接Socket.IO服务器和客户端的全部操作。这非常简单易懂，不是吗？但我们在这里所做的只是连接和断开服务器和客户端。我们需要更多的功能——我们希望能够同时传输数据。为了做到这一点，我们只需要相互发射和接收事件，这将在接下来的步骤中完成。
- en: If you want to use the local version of the Socket.IO client, you can point
    the script tag's URL source to `/node_modules/socket.io-client/dist/socket.io.js`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用Socket.IO客户端的本地版本，你可以将脚本标签的URL源指向`/node_modules/socket.io-client/dist/socket.io.js`。
- en: 'Create an emit event from the server by using the `emit` method from the Socket.IO
    server, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用Socket.IO服务器的`emit`方法，从服务器创建一个发射事件，如下所示：
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, you can see that we emit the event with a simple message through the
    custom event called `emit.onserver` and log the activity to the console. Notice
    that we can only emit the event when the connection is established. Then, we can
    listen to this custom event on the client-side and log the message coming from
    the server, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们通过名为`emit.onserver`的自定义事件发射了一个简单的消息，并将活动记录到控制台中。请注意，我们只能在连接建立时发射事件。然后，我们可以在客户端监听这个自定义事件，并记录来自服务器的消息，如下所示：
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'So, now, if you refresh the page again on your browser, you should see the
    console printing the log with the socket ID, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，现在，如果你再次在浏览器上刷新页面，你应该看到控制台打印出带有socket ID的日志，如下所示：
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create an emit event from the client by using the `emit` method from the Socket.IO
    client, as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用Socket.IO客户端的`emit`方法，从客户端创建一个发射事件，如下所示：
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, you can see that, first, we install jQuery via CDN and create a `<button>`
    with the jQuery `click` event. Secondly, we emit the Socket.IO custom event called
    `emit.onclient` with a simple message when the button is clicked. Lastly, we log
    the activity to the console.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到，首先，我们通过CDN安装jQuery，并创建一个带有jQuery `click`事件的`<button>`。其次，当按钮被点击时，我们发射名为`emit.onclient`的Socket.IO自定义事件，并附带一个简单的消息。最后，我们将活动记录到控制台中。
- en: 'After that, we can listen to the Socket.IO custom event on the server-side
    and log the message coming from the client, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以在服务器端监听Socket.IO自定义事件，并记录来自客户端的消息，如下所示：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you refresh the page again on your browser, you should see the console printing
    the log, along with the socket ID, as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你再次在浏览器上刷新页面，你应该看到控制台打印出日志，以及socket ID，如下所示：
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You now know how to transmit data back and forth in real time with Socket.IO
    – just by emitting custom events and listening to them. The next thing you should
    know about is how to integrate Socket.IO with the changefeeds in RethinkDB in
    order to transmit the real-time data from the database to the client. So, keep
    reading!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何通过Socket.IO实时传输数据——只需发射自定义事件并监听它们。你接下来应该了解的是如何将Socket.IO与RethinkDB的changefeeds集成，以便将实时数据从数据库传输到客户端。所以，请继续阅读！
- en: Integrating Socket.IO server and RethinkDB changefeeds
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成Socket.IO服务器和RethinkDB changefeeds
- en: 'Remember that you fiddled with the RethinkDB changefeeds previously, using
    the Data Explorer from the Administration UI again at `localhost:8080/#dataexplorer`.
    To subscribe to a changefeed, you just have to chain the ReQL `changes` command
    to the query, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您之前曾在`localhost:8080/#dataexplorer`的管理UI中再次使用Data Explorer调整RethinkDB changefeeds。要订阅changefeed，您只需将ReQL的`changes`命令链接到查询，如下所示：
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The RethinkDB changefeeds contain real-time data that''s emitted from the RethinkDB
    database to our API, which means we need to catch these feeds on the server-side
    with the Socket.IO server and emit them to the client. So, let''s learn how to
    catch them by refactoring the API we have been developing throughout this chapter:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: RethinkDB changefeeds包含从RethinkDB数据库发出的实时数据，这意味着我们需要在服务器端使用Socket.IO服务器捕获这些feed，并将它们发出到客户端。因此，让我们学习如何通过重构我们在本章中一直在开发的API来捕获它们：
- en: 'Install the Socket.IO server via npm into your API:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm将Socket.IO服务器安装到您的API中：
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create an asynchronous anonymous arrow function in a `changefeeds.js` file
    in the `/core/` directory with the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/core/`目录中的`changefeeds.js`文件中创建一个异步匿名箭头函数，代码如下：
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In this function, we import `rethinkdb` as `rdb` and our RethinkDB database
    connection as `rdbConnection`, and then use the following items as the parameters
    of this function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们将`rethinkdb`导入为`rdb`，将我们的RethinkDB数据库连接导入为`rdbConnection`，然后将以下项目用作此函数的参数：
- en: The instance of the Socket.IO server
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Socket.IO服务器的实例
- en: The Socket.IO emit custom event name that you will want to use
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将要使用的Socket.IO发出的自定义事件名称
- en: The RethinkDB table name that you want to subscribe to its changefeed
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您要订阅其changefeed的RethinkDB表名
- en: The changefeed will return the documents in a cursor object as a callback, so
    we iterate through the cursor object and emit each row of the document with the
    custom event name.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: changefeed将以回调的形式将文档返回为游标对象，因此我们通过游标对象进行迭代，并使用自定义事件名称发出每个文档的行。
- en: 'Import the `changefeeds` function as `rdbChangeFeeds` in the app root in the
    `/public/` directory and integrate it with the rest of the existing code in the
    `index.js` file, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序根目录的`/public/`目录中将`changefeeds`函数导入为`rdbChangeFeeds`，并将其与`index.js`文件中的其余现有代码集成，如下所示：
- en: '[PRE65]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding code, the table name we want to subscribe to is `user` and
    the emit event name we want to call is `user.changefeeds`. So, we pass them into
    the `rdbChangeFeeds` function with the `socket.io` instance. That's all you need
    to do to integrate Socket.IO and RethinkDB once only and globally.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们要订阅的表名是`user`，我们要调用的发出事件名称是`user.changefeeds`。因此，我们将它们传递给`rdbChangeFeeds`函数，并使用`socket.io`实例。这就是您一次性全局集成Socket.IO和RethinkDB所需做的一切。
- en: Well done! You have managed to integrate Koa, RethinkDB, and Socket.IO on the
    server-side and created a real time API. But what about the client side, and how
    do we listen to the event being emitted from the API? We'll find out in the next
    section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您已成功在服务器端集成了Koa、RethinkDB和Socket.IO，并创建了一个实时API。但是客户端怎么样，我们如何监听从API发出的事件？我们将在下一节中找出答案。
- en: Integrating Socket.IO with Nuxt
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Socket.IO与Nuxt集成
- en: 'The Nuxt app we are going to build is very similar to the one we had in the
    previous chapter, where we had a `/users/` directory that contains the following
    CRUD pages in the `/pages/` directory for adding, updating, listing, and deleting
    users:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的Nuxt应用程序与上一章中的应用程序非常相似，在那里我们有一个包含以下CRUD页面的`/users/`目录，该目录位于`/pages/`目录中，用于添加、更新、列出和删除用户：
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can copy these files from the previous chapter. The only major change and
    difference in this app is the `<script>` block, where we will list users in real
    time by listening to the emit event from the Socket.IO server. To do that, we
    will need to use the Socket.IO client, which you learned in the *Adding and using
    Socket.IO server and client* section with the simple HTML page. So, let''s find
    out how to implement what we already know into the Nuxt app:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从上一章复制这些文件。这个应用程序中唯一的主要变化和不同之处在于`<script>`块，我们将通过监听来自Socket.IO服务器的emit事件实时列出用户。为此，我们需要使用Socket.IO客户端，这是您在*添加和使用Socket.IO服务器和客户端*部分学到的，该部分使用简单的HTML页面。因此，让我们看看如何将我们已经知道的内容实现到Nuxt应用中：
- en: 'Install the Socket.IO client via npm into your Nuxt project:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm将Socket.IO客户端安装到您的Nuxt项目中：
- en: '[PRE67]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create the following variables for the app''s protocol, hostname, and the cross-domain
    ports in the Nuxt config file so that we can reuse them later:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件中创建以下变量，以便稍后重用应用的协议、主机名和跨域端口：
- en: '[PRE68]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'These variables are made for the following situations:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量适用于以下情况：
- en: The `host` variable is used to take the value of `a-cool-domain-name.com` when
    the Nuxt app is in production; that is, when you run the app with `npm run start`.
    Otherwise, it just takes `localhost` as the default value.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`变量用于在Nuxt应用处于生产环境时获取`a-cool-domain-name.com`的值；也就是说，当您使用`npm run start`运行应用时。否则，它只会将`localhost`作为默认值。'
- en: The `local` key in the `ports` variable is used to set a server port for the
    Nuxt app and it is set to `8000`. Remember that the default port that Nuxt serves
    the app is `3000`.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`变量中的`local`键用于为Nuxt应用设置服务器端口，设置为`8000`。请记住，Nuxt提供应用的默认端口是`3000`。'
- en: The `remote` key in the `ports` variable is used to tell the Nuxt app what server
    port the API is on, which is `4000`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`变量中的`remote`键用于告诉Nuxt应用API所在的服务器端口，即`4000`。'
- en: The `remoteUrl` variable is used to concatenate the API with the preceding variables.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remoteUrl`变量用于将API与前面的变量连接起来。'
- en: 'Apply the preceding variables to the `env` and `server` options in the Nuxt
    config file, as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前述变量应用于Nuxt配置文件中的`env`和`server`选项，如下所示：
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'So, with this configuration, we can access the `remoteUrl` variable again when
    serving the app via the following methods:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过这种配置，我们可以通过以下方法再次访问`remoteUrl`变量：
- en: '`process.env.remoteUrl`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process.env.remoteUrl`'
- en: '`context.env.remoteUrl`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.env.remoteUrl`'
- en: Also, in this configuration, we have changed the Nuxt app's default server port
    to `8000` in the `server` option. The default port is `3000`, while the default
    host is `localhost`. But you may want to use a different port for some reason.
    That's why we looked at how to change them here.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这个配置中，我们已将Nuxt应用的默认服务器端口更改为`8000`，在`server`选项中。默认端口是`3000`，默认主机是`localhost`。但是您可能出于某种原因想要使用不同的端口。这就是为什么我们在这里看如何更改它们。
- en: If you want to find out more about the `server` configuration and other options
    such as `timing` and `https`, please visit [https://nuxtjs.org/api/configuration-server](https://nuxtjs.org/api/configuration-server).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于`server`配置和其他选项（如`timing`和`https`）的信息，请访问[https://nuxtjs.org/api/configuration-server](https://nuxtjs.org/api/configuration-server)。
- en: If you want to find out more about the `env` configuration, please visit [https://nuxtjs.org/api/configuration-envthe-env-property](https://nuxtjs.org/api/configuration-env#the-env-property).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于`env`配置的信息，请访问[https://nuxtjs.org/api/configuration-envthe-env-property](https://nuxtjs.org/api/configuration-env#the-env-property)。
- en: 'Install the Nuxt Axios and Proxy modules and configure them in the Nuxt config
    file, as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Nuxt Axios和Proxy模块，并在Nuxt配置文件中进行配置，如下所示：
- en: '[PRE70]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Notice that we have reused the `remoteUrl` variable in the `proxy` option. So,
    every API request we make that starts with `/api/` will be converted into `http://localhost:4000/api/`.
    But since we don't have `/api/` in the routes in the API, we remove this `/api/`
    section from the request URL with the `pathRewrite` option before sending it off
    to the API.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在`proxy`选项中重用了`remoteUrl`变量。因此，我们发出的每个以`/api/`开头的API请求都将转换为`http://localhost:4000/api/`。但由于我们在API的路由中没有`/api/`，在将其发送到API之前，我们使用`pathRewrite`选项从请求URL中删除这个`/api/`部分。
- en: 'Create a plugin in the `/plugin/` directory for abstracting the instance of
    the Socket.IO client so that we can reuse it anywhere:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/plugin/`目录中创建一个插件，用于抽象Socket.IO客户端的实例，以便我们可以在任何地方重用它：
- en: '[PRE71]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice that we have reused the `remoteUrl` variable via `process.env.remoteUrl`
    in the Socket.IO client instance. This means the Socket.IO client will call the
    Socket.IO server at `localhost:4000`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过`process.env.remoteUrl`重用了`remoteUrl`变量在Socket.IO客户端实例中。这意味着Socket.IO客户端将在`localhost:4000`调用Socket.IO服务器。
- en: 'Import the `socket.io` client plugin into the `<script>` block and fetch the
    list of users with the `@nuxtjs/axios` module in the `index` file. This index
    file is kept in the `/users/` directory, under `pages`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`socket.io`客户端插件导入到`<script>`块中，并使用`@nuxtjs/axios`模块在`index`文件中获取用户列表。此索引文件位于`/users/`目录下的`pages`中：
- en: '[PRE72]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'After fetching and setting the users with the `asyncData` method, use the Socket.IO
    plugin to listen to the `user.changefeeds` event in the `mounted` method for any
    new real-time feeds from the server, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`asyncData`方法获取并设置用户后，使用Socket.IO插件在`mounted`方法中监听`user.changefeeds`事件，以获取来自服务器的任何新的实时反馈，如下所示：
- en: '[PRE73]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here, you can see that we always check the `data` callback to make sure that
    `new_val` and `old_val` are defined in the incoming feed. In other words, we want
    to ensure these two keys are always present in the feed before proceeding to the
    following lines.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们始终检查`data`回调，以确保传入的反馈中`new_val`和`old_val`被定义。换句话说，在继续下一行之前，我们希望确保这两个键始终出现在反馈中。
- en: 'After checking this, if we receive data in the `new_val` key but the `old_val`
    key is empty, this means a new user has been added to the server. If we get a
    new feed from the server side, we will prepend the new user data to the top of
    the `user` array by using the JavaScript `unshift` function, as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查后，如果我们在`new_val`键中收到数据，但`old_val`键为空，这意味着新用户已添加到服务器。如果我们从服务器端获取新的反馈，我们将使用JavaScript的`unshift`函数将新用户数据添加到`user`数组的顶部，如下所示：
- en: '[PRE74]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, if we receive data in the `old_val` key but the `new_val` key is empty,
    this means an existing user has been deleted from the server. So, to pop off an
    existing user from the array by its index (its position/location in the array),
    we can use the JavaScript `splice` function. But first, we must find the index
    of the user by its ID using the JavaScript `map` function, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们在`old_val`键中收到数据，但`new_val`键为空，这意味着现有用户已从服务器中删除。因此，要从数组中弹出现有用户，我们可以使用JavaScript的`splice`函数，通过其索引（在数组中的位置/位置）来删除。但首先，我们必须使用JavaScript的`map`函数按其ID找到用户的索引，如下所示：
- en: '[PRE75]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Lastly, if we receive data in both the `new_val` and `old_val` keys, this means
    a current user has been updated. So, if a user has been updated, we must find
    the user''s index in the array first and then replace it with the JavaScript `splice`
    function., as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们在`new_val`和`old_val`键中都收到数据，这意味着当前用户已更新。因此，如果用户已更新，我们必须首先找到数组中用户的索引，然后使用JavaScript的`splice`函数替换它，如下所示：
- en: '[PRE76]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that we use the JavaScript `findIndex` function instead as another alternative
    to the `map` function.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用JavaScript的`findIndex`函数作为`map`函数的另一种替代方法。
- en: 'If you want to find out more information about the JavaScript standard built-in
    functions we have used here for manipulating the JavaScript arrays, please visit
    the following links:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于我们在这里使用的用于操作JavaScript数组的JavaScript标准内置函数的信息，请访问以下链接：
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift) for
    the `unshift` function'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift) 用于`unshift` 函数'
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) for
    the `splice` function'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) 用于`splice` 函数'
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) for
    the `map` function'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) 用于`map` 函数'
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) for
    the `findIndex` function'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) 用于`findIndex` 函数'
- en: 'Add the following template to the `<template>` block to display the users,
    as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下模板添加到`<template>`块中以显示用户，如下所示：
- en: '[PRE77]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this template, you can see that we simply loop the user data we get from
    the `asyncData` method with `v-for` and bind the user `uuid` to each looped element.
    After that, any real-time feed that occurs in the `mounted` method will update
    the user data and the template reactively.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模板中，您可以看到我们只是简单地使用`v-for`从`asyncData`方法获取的用户数据，并将用户`uuid`绑定到每个循环的元素上。之后，发生在`mounted`方法中的任何实时反馈都将以响应式方式更新用户数据和模板。
- en: 'Run the Nuxt app with `npm run dev`. You should the following information on
    your terminal:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm run dev`运行Nuxt应用程序。您应该在终端上看到以下信息：
- en: '[PRE78]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Open two tabs on your browser side by side, or two different browsers side by
    side, and point them to `localhost:8000/users`. Add a new user from one of the
    tabs (or browsers) at `localhost:8000/users/add`. You should see that the newly
    added user is shown on all the tabs (or browsers) instantly and concurrently,
    in real time, without you needing to refresh them.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开两个标签并排，或者在两个不同的浏览器中并排，并将它们指向`localhost:8000/users`。从其中一个标签（或浏览器）在`localhost:8000/users/add`添加一个新用户。您应该看到新添加的用户立即并同时显示在所有标签（或浏览器）上，而无需刷新它们。
- en: You can find all the code and apps in this chapter in `/chapter-17/frontend/`
    and `/chapter-17/backend/` in this book's GitHub repository.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-17/frontend/`和`/chapter-17/backend/`中找到本章中的所有代码和应用程序。
- en: Well done – you have made it! We hope you found this application fun and easy
    and that it inspires you to venture further with what you've learned so far. Let's
    summarize what we have learned in this chapter.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好 - 您成功了！我们希望您觉得这个应用程序有趣且易于操作，并且它能激励您进一步探索您迄今为止所学到的知识。让我们总结一下本章学到的内容。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you managed to install and use RethinkDB and Socket.IO to turn
    the ordinary backend API and frontend Nuxt app into real-time apps. You learned
    how to manipulate the JSON data by creating, reading, updating, and deleting them
    on the server side with RethinkDB through the RethinkDB Administration UI, and
    then used the RethinkDB client driver with Koa. Most importantly, you learned
    how to manipulate the real time feeds in RethinkDB, known as changefeeds, through
    the RethinkDB Administration UI as well, and then integrated them with the Socket.IO
    server and Koa on the server side. Furthermore, you used the Socket.IO server
    to emit data with custom events and the Socket.IO client to listen to the event
    and catch the data in real-time on the client side with the Nuxt app. Wasn't it
    a fun ride?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您成功安装并使用RethinkDB和Socket.IO，将普通的后端API和前端Nuxt应用程序转变为实时应用程序。您学会了如何通过RethinkDB管理UI在服务器端创建、读取、更新和删除JSON数据，然后使用Koa与RethinkDB客户端驱动程序。最重要的是，您学会了如何通过RethinkDB管理UI操作RethinkDB中的实时订阅，称为changefeeds，然后在服务器端将其与Socket.IO服务器和Koa集成。此外，您使用Socket.IO服务器发出自定义事件的数据，并使用Socket.IO客户端在Nuxt应用程序的客户端端实时监听事件并捕获数据。这难道不是一次有趣的旅程吗？
- en: In the next chapter, we will take Nuxt further with third-party APIs, **content
    management systems** (**CMS**), and GraphQL. You will be introduced to WordPress
    API, Keystone, and GraphQL. You will then learn how to create custom content types
    and custom routes to extend the WordPress API so that you can integrate it with
    Nuxt and stream remote images from the WordPress project. You will be developing
    custom CMS using Keystone, installing and securing PostgreSQL for Keystone app
    development, as well as securing MongoDB, which you learned how to install in
    [Chapter 9](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml), *Adding a Server-Side
    Database*. Most importantly and excitingly, you will learn the differences between
    the REST API and the GraphQL API; build a GraphQL API with GraphQL.js, Express,
    and Apollo Server; understand the GraphQL schema and its resolvers; use the Keystone
    GraphQL API; and then integrate them with Nuxt. It will definitely be another
    fun ride, so buckle up and get ready!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过第三方API、内容管理系统（CMS）和GraphQL进一步了解Nuxt。您将了解WordPress API、Keystone和GraphQL。然后，您将学习如何创建自定义内容类型和自定义路由，以扩展WordPress
    API，以便将其与Nuxt集成，并从WordPress项目中流式传输远程图像。您将使用Keystone开发自定义CMS，安装和保护用于Keystone应用程序开发的PostgreSQL，以及保护MongoDB，您将学习如何在第9章中安装的内容，即*添加服务器端数据库*。最重要且令人兴奋的是，您将学习REST
    API和GraphQL API之间的区别；使用GraphQL.js、Express和Apollo Server构建GraphQL API；了解GraphQL模式及其解析器；使用Keystone
    GraphQL API；然后将它们与Nuxt集成。这绝对会是另一次有趣的旅程，所以系好安全带，准备好！
