- en: Adding Vue Components
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 添加Vue组件
- en: As we stated in the previous chapter, Vue components are an **optional part**
    of the Nuxt view. You've already learned about various constituents of the Nuxt
    view: app template, HTML head, layout, and page.However, we haven't covered the
    smallest unit in Nuxt -** the Vue component**. So, in this chapter, you will learn
    how it works and how to make use of `/components/` for creating custom components. You
    will then learn how to create global and local components, as well as basic and
    global mixins, and get to know some of the naming conventions for developing Vue
    or Nuxt apps. Most excitingly, you will discover how to pass data down from a parent
    component to a child component, as well as emit data up to the parent from the
    child.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中所述，Vue组件是Nuxt视图的**可选部分**。您已经了解了Nuxt视图的各种组成部分：应用程序模板、HTML头部、布局和页面。但是，我们还没有涵盖Nuxt中最小的单位-**Vue组件**。因此，在本章中，您将学习它的工作原理以及如何利用`/components/`创建自定义组件。然后，您将学习如何创建全局和本地组件，以及基本和全局mixin，并了解一些用于开发Vue或Nuxt应用程序的命名约定。最令人兴奋的是，您将发现如何将数据从父组件传递到子组件，以及如何从子组件向父组件发出数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding Vue components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Vue组件
- en: Creating single-file Vue components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单文件Vue组件
- en: Registering global and local components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册全局和本地组件
- en: Writing basic and global mixins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写基本和全局mixin
- en: Defining component names and using naming conventions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义组件名称并使用命名约定
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Understanding Vue components
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Vue组件
- en: 'We covered the `/components/` directory briefly in [Chapter 2](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml),
    *Getting Started with Nuxt,* but we haven''t got hands-on with it yet. All we
    know so far is there is a `Logo.vue` component in this directory if you install
    your Nuxt project with the Nuxt scaffolding tool. All the components in this directory
    are **Vue components**, just like the page components in the `/pages/` directory.
    The main difference is that there is no `asyncData` method supported in these
    components in the `/components/` directory. Let''s take the `copyright.vue` component
    in `/chapter-4/nuxt-universal/sample-website/` as an example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml)中简要介绍了`/components/`目录，*开始使用Nuxt*，但我们还没有亲自动手。到目前为止，我们知道如果使用Nuxt脚手架工具安装Nuxt项目，则该目录中有一个`Logo.vue`组件。该目录中的所有组件都是**Vue组件**，就像`/pages/`目录中的页面组件一样。主要区别在于`/components/`目录中的这些组件不支持`asyncData`方法。让我们以`/chapter-4/nuxt-universal/sample-website/`中的`copyright.vue`组件为例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s try replacing the `data` function in the preceding code with the `asyncData`
    function, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用`asyncData`函数替换前面代码中的`data`函数，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will get a warning error stating Property or method "copyright" is not
    defined... on your browser''s console. So, how can we get the data for copyright
    purposes dynamically? We can request data using the `fetch` method in the component
    directly with an HTTP client (for example, `axios`), as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到警告错误，浏览器控制台上会显示“属性或方法“copyright”未定义...”。那么，我们如何动态获取版权目的的数据呢？我们可以使用`fetch`方法直接在组件中使用HTTP客户端（例如`axios`）请求数据，如下所示：
- en: 'Install the `axios` package via npm in the project directory:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录中通过npm安装`axios`包：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Import `axios` and request the data in the `fetch` method, as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`axios`并在`fetch`方法中请求数据，如下所示：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This method works fine, but it is not ideal to use an HTTP request to get a
    small piece of data from a payload, which is better off being requested once and
    then passing the pieces of data from a parent scope into its child components,
    like so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以正常工作，但是最好不要使用HTTP请求从有效负载中获取少量数据，最好是请求一次，然后将数据从父作用域传递到其子组件中，如下所示：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding snippet, the child component is the `copyright.vue` file in
    the `/components/` directory. The magic in this solution is just using the `props`
    property in the component. It's simpler and neater, thus making it an elegant
    solution! But if we are going to understand how it works and how we can use it,
    we need to understand Vue's component system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，子组件是“/components/”目录中的“copyright.vue”文件。这个解决方案的奥妙就在于在组件中使用“props”属性。这样更简单、更整洁，因此是一个优雅的解决方案！但是，如果我们要理解它是如何工作的，以及如何使用它，我们需要了解Vue的组件系统。
- en: What is a component?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是组件？
- en: 'Components are single, self-contained, and reusable **Vue instances** with
    a custom name. We define components by using the Vue `component` method. For example,
    if we want to define a component called `post-item`, we would do this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是单一的、自包含的、可重用的Vue实例，具有自定义名称。我们使用Vue的“component”方法来定义组件。例如，如果我们想定义一个名为“post-item”的组件，我们会这样做：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After doing this, we can use this component as `<post-item>` inside the HTML
    document when the root Vue instance is created with the `new` statement, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这些之后，当使用“new”语句创建根Vue实例时，我们可以在HTML文档中将此组件用作“<post-item>”，如下所示：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All components are essentially Vue instances. This means they possess the same
    options (`data`, `computed`, `watch`, `methods`, and so on) as `new Vue`, except
    a few root-specific options such as `el`. Also, components can be nested inside
    other components and become tree-like components eventually. However, when this
    happens, passing data around them becomes tricky. So, fetching the data directly
    in the specific component using the `fetch` method might be more suitable for
    this situation. Alternatively, you can use Vuex store, which you will discover
    in [Chapter 10](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml), *Adding a Vuex Store*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件本质上都是Vue实例。这意味着它们具有与“new Vue”相同的选项（“data”、“computed”、“watch”、“methods”等），只是少了一些根特定的选项，比如“el”。此外，组件可以嵌套在其他组件中，并最终成为类似树状的组件。然而，当这种情况发生时，传递数据变得棘手。因此，在特定组件中直接使用“fetch”方法获取数据可能更适合这种情况。或者，您可以使用Vuex存储，您将在[第10章](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml)中发现它，“添加Vuex存储”。
- en: However, we will put aside deeply nested components for a moment and focus on
    simple parent-child components in this chapter and learn how to pass data around
    them. Data can be passed either from the parent components to their children or
    from their children to the parents. But how can we do this? First, let's find
    out how we can pass data to the child components from their parents.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将暂时搁置深度嵌套的组件，专注于本章中简单的父子组件，并学习如何在它们之间传递数据。数据可以从父组件传递到它们的子组件，也可以从子组件传递到父组件。但是我们如何做到这一点呢？首先，让我们找出如何从父组件向子组件传递数据。
- en: Passing data to child components with props
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用props将数据传递给子组件
- en: 'Let''s create a small Vue app by starting with a child component called `user-item`,
    as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个名为“user-item”的子组件来创建一个小型的Vue应用，如下所示：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see that it is just a static component and doesn''t do much; you can''t
    abstract or reuse it at all. It only becomes reusable if we can pass data into
    the template dynamically, inside the `template` property. This can be done with
    a `props` property. Let''s refactor the component, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它只是一个静态组件，没有太多功能；你根本无法抽象或重用它。只有在我们可以动态地将数据传递到模板内部的“template”属性中时，它才变得可重用。这可以通过“props”属性来实现。让我们对组件进行重构，如下所示：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In a sense, `props` behave like variables and we set the data for them with
    the `v-bind` directive, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，“props”的行为类似于变量，我们可以使用“v-bind”指令为它们设置数据，如下所示：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this refactored component, we use a `v-bind` directive to bind `item.name`
    to `name`, as in `v-bind:name`. The props inside the component must accept `name`
    as the property for this component. However, in a more complex app, it is likely
    we will need to pass more data, and writing multiple props for every piece of
    data can be counter-productive. So, let''s refactor the `<user-item>` component
    so that it accepts a single prop called `user` instead:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构的组件中，我们使用`v-bind`指令将`item.name`绑定到`name`，如`v-bind:name`。组件内的props必须接受`name`作为该组件的属性。然而，在一个更复杂的应用程序中，我们可能需要传递更多的数据，为每个数据写多个props可能会适得其反。因此，让我们重构`<user-item>`组件，使其接受一个名为`user`的单个prop：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we should refactor the component code once more, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次重构组件代码，如下所示：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s put what we''ve done here into a single page HTML so that you can see
    the bigger picture:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们在这里所做的事情放到一个单页HTML中，这样您就可以看到更大的图片：
- en: 'Include the following CDN link in the `<head>` block:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<head>`块中包含以下CDN链接：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the following markups in the `<body>` block:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<body>`块中创建以下标记：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code to the `<script>` block:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`<script>`块中：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, we have broken down the app into smaller units: a child and
    a parent. However, they are bound through the `props` property. Now, we can further
    refine them without the fear of them interfering with each other.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将应用程序分解成了更小的单元：一个子组件和一个父组件。然而，它们通过`props`属性进行绑定。现在，我们可以进一步完善它们，而不用担心它们相互干扰。
- en: You can find this example code in `/chapter-5/vue/component/basic.html` in this
    book's GitHub repository.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-5/vue/component/basic.html`中找到这个示例代码。
- en: However, in a real and complex app, we should divide this app into separate
    files (single-file components) that are more manageable. We will show you how
    to create them in the *Creating single-file Vue components* section. But for now,
    let's discover how we can pass the data up to the parent from the child component.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一个真实而复杂的应用程序中，我们应该将这个应用程序分成更可管理的单独文件（单文件组件）。我们将在*创建单文件Vue组件*部分向您展示如何创建它们。但现在，让我们发现如何从子组件将数据传递给父组件。
- en: Listening to child component events
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听子组件事件
- en: 'So far, you''ve learned how to pass data down to child components from the
    parent using the `props` property. But what about passing data up to the parent
    from the child component? We can achieve this by using the `$emit` method with
    a custom event, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学会了如何使用`props`属性将数据传递给子组件。但是如何从子组件将数据传递给父组件呢？我们可以通过使用`$emit`方法和自定义事件来实现这一点，如下所示：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can choose any name for the custom event in the child component to be broadcasted.
    Then, the parent component can listen to this broadcasted event using the `v-on`
    directive and decide what to do next in this format:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择任何名称作为要在子组件中广播的自定义事件的名称。然后，父组件可以使用`v-on`指令来监听这个广播事件，并决定接下来要做什么。
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, if you are emitting a custom event called `done`, then the parent will
    be listing to this `done` event with the `v-on` directive as `v-on:done`, followed
    by an event handler. This event handler can be a plain JavaScript function, such
    as `v-on:done=handleDone`. Let''s create a simple app to demonstrate this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您正在发出一个名为`done`的自定义事件，那么父组件将使用`v-on:done`指令来监听这个`done`事件，然后是一个事件处理程序。这个事件处理程序可以是一个简单的JavaScript函数，比如`v-on:done=handleDone`。让我们创建一个简单的应用程序来演示这一点：
- en: 'Create the app''s markups, as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序的标记，如下所示：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a child component, as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个子组件，如下所示：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a Vue root instance as the parent:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Vue根实例作为父级：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the child component will emit a `completed` event when the
    `clicked` method in it is triggered. Here, the parent receives the event via `v-on`
    and then triggers the `handleCompleted` method on its side.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`clicked`方法在子组件中触发时，子组件将发出一个`completed`事件。在这里，父组件通过`v-on`接收事件，然后在其端触发`handleCompleted`方法。
- en: You can find this example in `/chapter-5/vue/component/emit/emit-basic.html` in
    this book's GitHub repository.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-5/vue/component/emit/emit-basic.html`中找到这个例子。
- en: Emitting a value with an event
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过事件发出值
- en: 'However, emitting just an event is not enough sometimes. In some cases, it''s
    more useful to emit the event with a value. We can do that by using the second
    parameter in the `$emit` method, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时仅仅发出一个事件是不够的。在某些情况下，使用带有值的事件更有用。我们可以通过在`$emit`方法中使用第二个参数来实现这一点，如下所示：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, when the parent is listening to the event, it can access the emitted
    event''s value with `$event` in this format:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当父组件监听事件时，可以以以下格式使用`$event`访问发出的事件的值：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the event handler is a method, then the value will be the first parameter
    for that method in this format:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件处理程序是一个方法，那么该值将是该方法的第一个参数，格式如下：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, now, we can simply modify the previous app, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，我们可以简单地修改前面的应用程序，如下所示：
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, you can see that it is fun and easy to pass the data down or up between
    the parent and child components. But if you have an `<input>` element in your
    child component, how can you pass the value in the input field up to the parent
    in a two-way data binding? This isn't as hard as it seems if we understand what
    is going on "under" the two-way data binding in Vue. We'll learn about this in
    the next section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到在父组件和子组件之间传递数据是有趣且容易的。但是，如果您的子组件中有一个`<input>`元素，如何将输入字段中的值传递给父组件进行双向数据绑定呢？如果我们了解Vue中双向数据绑定的“底层”发生了什么，这并不难。我们将在下一节中学习这个知识点。
- en: You can find a simple example of this in `/chapter-5/vue/component/emit/value.html` and
    a more complex example in `/chapter-5/vue/component/emit/emit-value-with-props.html`,
    both of which can be found in this book's GitHub repository.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-5/vue/component/emit/value.html`中找到这个简单的例子，以及在`/chapter-5/vue/component/emit/emit-value-with-props.html`中找到更复杂的例子。
- en: Creating custom input components with v-model
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用v-model创建自定义输入组件
- en: 'We also can use a component to create custom two-way binding inputs that work
    the same as a `v-model` directive for emitting events to the parent. Let''s create
    a basic custom input component:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用组件创建自定义的双向绑定输入，其工作方式与`v-model`指令相同，用于向父组件发出事件。让我们创建一个基本的自定义输入组件：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'How does it work? To understand this, we need to understand how `v-model` works
    under the hood. Let''s use a simple `v-model` input:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？要理解这一点，我们需要了解`v-model`在幕后是如何工作的。让我们使用一个简单的`v-model`输入：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding `<input>` element is shorthand for the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`<input>`元素是以下内容的简写：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, writing `v-model="newTodoText"` in our custom input is shorthand for the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的自定义输入中编写`v-model="newTodoText"`是以下内容的简写：
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This means the component underneath this shorthand must have the `value` attribute
    in the `props` property to let the data be passed down from the top. It must emit
    an `input` event with `$event.target.value` in order to pass the data up to the
    top.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个简写下面的组件必须在`props`属性中具有`value`属性，以便让数据从顶部传递下来。它必须发出一个带有`$event.target.value`的`input`事件，以便将数据传递到顶部。
- en: 'So, in this example, we emit the value when the user types in the `custom-input`
    child component, while the parent listens to the change via `v-model="newTodoText"`
    and updates the value of `newTodoText` in the `data` object:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，当用户在`custom-input`子组件中输入时，我们发出值，而父组件通过`v-model="newTodoText"`监听更改，并更新`data`对象中`newTodoText`的值：
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This makes perfect sense when you know the mechanism underneath the two-way
    data binding in Vue – the `v-model` directive – doesn't it? But what about the
    checkbox input and radio button elements, if you don't want to use their default
    values? In this situation, you'd want to send the custom ones to the parent component
    instead. We'll learn how to do this in the next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你了解Vue中双向数据绑定的机制——`v-model`指令时，这就变得很合理了，不是吗？但是，如果你不想使用复选框输入和单选按钮元素的默认值呢？在这种情况下，你会想要将自定义的值发送到父组件中。我们将在下一节中学习如何做到这一点。
- en: You can find this simple example in `/chapter-5/vue/component/custom-inputs/basic.html`
    and a more complex example in `/chapter-5/vue/component/custom-inputs/props.html`,
    both of which can be found in this book's GitHub repository.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`/chapter-5/vue/component/custom-inputs/basic.html`找到这个简单的例子，在`/chapter-5/vue/component/custom-inputs/props.html`中找到一个更复杂的例子，这两个例子都可以在这本书的GitHub存储库中找到。
- en: Customizing the model in custom input components
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义输入组件中的模型定制
- en: 'By default, the model in a custom input component uses the `value` property
    as the prop and `input` as the event. Using the `custom-input` component from
    our previous example, this can be written as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，自定义输入组件中的模型使用`value`属性作为prop，`input`作为事件。使用我们之前例子中的`custom-input`组件，可以写成如下形式：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we don't need to specify the `prop` and `event` properties
    since they are the default behavior in this component's model. But this becomes
    useful when we don't want to use these defaults for some input types, such as
    checkboxes and radio buttons.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不需要指定`prop`和`event`属性，因为它们是该组件模型的默认行为。但是当我们不想对某些输入类型使用这些默认值时，这将变得很有用，比如复选框和单选按钮。
- en: 'We may want to use the `value` attribute in these inputs for a different purpose,
    such as sending a specific value along with the checkbox''s `name` to the server
    in the submitted data, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望在这些输入中使用`value`属性来实现不同的目的，比如在提交的数据中与复选框的`name`一起发送特定的值，如下所示：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, we want to send these two pieces of data to the server:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们想要将这两个数据发送到服务器：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also do this in JSON format after performing serialization with `JSON.stringify`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在使用`JSON.stringify`进行序列化后以JSON格式进行：
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So, let''s say we don''t set the following custom model in this component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，假设我们在这个组件中没有设置以下自定义模型：
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this case, we can only send the following default data to the server:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只能将以下默认数据发送到服务器：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can find this example in `/chapter-5/vue/component/custom-inputs/checkbox.html` in
    this book's GitHub repository.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这本书的GitHub存储库中的`/chapter-5/vue/component/custom-inputs/checkbox.html`中找到这个例子。
- en: Again, it makes sense when you know what is underneath a Vue component as it
    can be customized with a bit of effort. The Vue components in the `/components/` directory
    work the same as the components you have just learned about. But before diving
    into writing the components for a Nuxt app, you should understand why the `key` attribute
    is important when using the `v-for` directive. Let's find out.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道Vue组件底层是什么，并且可以通过一点努力进行定制时，这就变得合理了。`/components/`目录中的Vue组件与你刚刚学习的组件的工作方式相同。但在深入编写Nuxt应用程序的组件之前，你应该了解在使用`v-for`指令时为什么`key`属性很重要。让我们找出来。
- en: Understanding the key attribute in v-for loops
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`v-for`循环中的`key`属性
- en: 'In many of this book''s previous examples and exercises, you probably noticed
    a `key` attribute in all our `v-for` loops, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的许多先前的例子和练习中，你可能注意到了所有`v-for`循环中的`key`属性，如下所示：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You may be wondering what it is and what it is for. The `key` attribute is
    a unique identity of each DOM node so that Vue can track their changes, and thus
    reuse and reorder existing elements. Tracking by the index is the default behavior
    of Vue to track nodes with `v-for`, so using `index` for the key attribute like
    so is redundant:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道它是什么，它是用来做什么的。`key`属性是每个DOM节点的唯一标识，以便Vue可以跟踪它们的变化，从而重用和重新排序现有元素。使用`index`作为key属性的跟踪是Vue默认的行为，因此像这样使用`index`作为key属性是多余的：
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Hence, if we want Vue to track each item''s identity accurately, we must bind
    each key attribute with a unique value by using the `v-bind` directive, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们希望Vue准确地跟踪每个项目的标识，我们必须通过使用`v-bind`指令将每个key属性绑定到一个唯一的值，如下所示：
- en: '[PRE37]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can use a shorthand `:key` to bind the unique value, as shown in the previous
    example. Also, bear in mind that `key` is a reserved attribute. This means it
    cannot be used as a component prop:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用缩写`:key`来绑定唯一的值，就像前面的例子中所示的那样。还要记住，`key`是一个保留属性。这意味着它不能作为组件prop使用：
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Using `key` in the `props` property will result in the following error in the
    browser''s console:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`props`属性中使用`key`将导致浏览器控制台中出现以下错误：
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `key` attribute is always required when using `v-for` with a component.
    Thus, it is good practice to use `key` explicitly with `v-for` whenever possible,
    whether you're using it with a component or not.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`v-for`与组件时，`key`属性是必需的。因此，最好在可能的情况下明确地使用`key`与`v-for`，无论您是否将其与组件一起使用。
- en: 'To demonstrate this issue, let''s create a Vue app where we''ll be using an `index` as
    our `key`, along with a little help from jQuery:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个问题，让我们创建一个Vue应用程序，我们将在其中使用`index`作为我们的`key`，并借助一点jQuery的帮助：
- en: 'Include the required CDN links in the `<head>` block, along with some CSS styles:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<head>`块中包含所需的CDN链接，以及一些CSS样式：
- en: '[PRE40]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create the required app HTML markup in the `<body>` block:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<body>`块中创建所需的应用程序HTML标记：
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create the required component in the `<script>` block:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<script>`块中创建所需的组件：
- en: '[PRE42]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create the required list of todo tasks, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需的待办任务列表，如下所示：
- en: '[PRE43]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, we added a new todo task to the top of the list as a result
    of an `unshift` occurring on our `todos` array. We remove a todo task by adding
    a `removed` class name to the `li` element. Then, we use CSS to add a strike-through to
    the removed todo task and hide the Remove button.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过在我们的`todos`数组上发生`unshift`来将一个新的待办任务添加到列表的顶部。我们通过向`li`元素添加`removed`类名来删除一个待办任务。然后，我们使用CSS为已删除的待办任务添加删除线，并隐藏删除按钮。
- en: 'Let''s remove `Do the dishes`. You will see the following:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们移除`洗碗`。你会看到以下内容：
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, add a new task called `Feed the cat`. You will see the following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个名为`喂猫`的新任务。你会看到以下内容：
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is because `Feed the cat` has now taken over the index of `Do the dishes`,
    which is 0\. Vue is just reusing the element instead of rendering a new one. In
    other words, whenever any changes are made to the items, Vue will just update
    the DOM elements according to their indexes in the array. This means we get an
    unintended outcome.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`喂猫`现在已经占据了`洗碗`的索引，即0。Vue只是重用元素而不是渲染新元素。换句话说，无论对项目进行了何种更改，Vue都将根据数组中的索引更新DOM元素。这意味着我们得到了一个意外的结果。
- en: You can find this example in `/chapter-5/vue/component/key/using-index.html` in
    this book's GitHub repository. Run it on your browser to see the issue for yourself.
    Then, compare it with the one using `id` as a key in `/chapter-5/vue/component/key/using-id.html`.
    You will see that you get the correct behavior.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这本书的GitHub存储库中的`/chapter-5/vue/component/key/using-index.html`中找到这个例子。在浏览器上运行它，看看问题出在哪里。然后，将其与在`/chapter-5/vue/component/key/using-id.html`中使用`id`作为键的情况进行比较。你会发现你得到了正确的行为。
- en: 'The issue of using an index as a key can also be explained by the following
    pseudo-code, in which a list of numbers is being generated with `index` set as
    the key for each of them:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引作为key的问题也可以通过以下伪代码来解释，其中正在生成一组数字，并为每个数字设置索引作为key：
- en: '[PRE46]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This looks great and works fine at first glance. But if you add number 4, the
    index information becomes useless. This is because each number now gets a new
    index:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很棒，乍一看工作正常。但是如果你添加数字4，索引信息就变得无用了。这是因为现在每个数字都得到了一个新的索引：
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see 1, 2, and 3 have lost their states and have to be rerendered.
    This is why using a unique key is required for cases like this. It is important
    for each item to keep its index number and not be reassigned on every change:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，1、2和3失去了它们的状态，必须重新渲染。这就是为什么对于这种情况，使用唯一的key是必需的。对于每个项目来说，保持其索引号并且不在每次更改时重新分配是很重要的：
- en: '[PRE48]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As a rule of thumb, whenever you manipulate a list in a way that results in
    a change of indexes, use a key so that Vue can update the DOM correctly afterward.
    These manipulations include the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，每当你以一种导致索引变化的方式操纵列表时，使用key，这样Vue可以在之后正确地更新DOM。这些操纵包括以下内容：
- en: Adding an item to an array, in any position other than the end of the array
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数组中的任何位置添加一个项目
- en: Removing an item from an array, from any position other than the end of the
    array
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数组中删除一个项目，从除数组末尾以外的任何位置
- en: Reordering the array in any way
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以任何方式重新排序数组
- en: If your list is never changed during the lifetime of your component, or you
    only append items with a push function instead of the `unshift` function, as in
    the previous example, it is fine to use indexes as keys. But if you try and keep
    track of where you need one and where you don't, you will eventually end up with
    "bugs" as you may misinterpret what Vue does.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的列表在组件的生命周期内从未改变过，或者你只是使用push函数而不是`unshift`函数添加项目，就像前面的例子一样，那么使用索引作为key是可以的。但是如果你试图追踪你何时需要使用索引和何时不需要使用索引，最终你会遇到“bug”，因为你可能会误解Vue的行为。
- en: If you are unsure whether to use indexes as keys or not, then it probably better
    to use the `key` attribute with an immutable ID in the `v-for` loop. Using the `key` attribute
    with a unique value is not only important with the `v-for` directive but also
    in the `<input>` elements in an HTML form. We'll look at this in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定是否要使用索引作为key，那么最好在`v-for`循环中使用带有不可变ID的`key`属性。使用具有唯一值的`key`属性不仅对`v-for`指令很重要，而且对HTML表单中的`<input>`元素也很重要。我们将在下一节中讨论这个问题。
- en: Controlling reusable elements with key attributes
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用key属性控制可重用的元素
- en: 'For the sake of providing better performance, we have discovered that Vue always reuses DOM
    nodes instead of rendering anew, and this can have some undesirable results, as
    demonstrated in the previous section. Here is another example without `v-for` to
    demonstrate why having the key attribute is rather important:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更好的性能，我们发现Vue总是重用DOM节点而不是重新渲染，这可能会产生一些不良结果，正如前一节所示。这里有另一个没有使用`v-for`的示例，以演示为什么拥有key属性是相当重要的：
- en: '[PRE49]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this example, if you type in the name of a fruit and switch the type, you
    will still see the name you just entered in the `vegetables` input field. This
    is because Vue is trying to reuse the same `<input>` element as best as it can
    to get the fastest result. But this isn''t always desirable. You can tell Vue not to
    reuse the same `<input>` element by adding the `key` attribute to each `<input>` element,
    along with a unique value, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果你在输入水果的名字并切换类型，你仍然会在`vegetables`输入框中看到你刚刚输入的名字。这是因为Vue试图尽可能地重用相同的`<input>`元素以获得最快的结果。但这并不总是理想的。你可以通过为每个`<input>`元素添加`key`属性以及一个唯一值来告诉Vue不要重用相同的`<input>`元素，如下所示：
- en: '[PRE50]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: So, if you refresh the page and test it again, the input fields should now work
    as expected, without "reusing" each other when you toggle them. This doesn't count
    for the `<label>` elements because there is no `key` attribute in them. However,
    visually, this is not a problem.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您刷新页面并再次测试，输入字段现在应该按预期工作，而不会在切换它们时“重用”彼此。这不适用于`<label>`元素，因为它们没有`key`属性。但是，从视觉上来看，这不是问题。
- en: You can find this example code in the `toggle-with-key.html` and `toggle-without-key.html` files
    inside the `/chapter-5/vue/component/key/` directory of this book's GitHub repository.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库的`/chapter-5/vue/component/key/`目录中的`toggle-with-key.html`和`toggle-without-key.html`文件中找到此示例代码。
- en: That's all you need to know about the basic nature of the Vue component. So,
    by now, you should have enough essential knowledge to get started with the next
    level of creating Vue components by using single-file components. Let's get going!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要了解的关于Vue组件基本性质的全部内容。因此，到目前为止，您应该已经掌握了足够的基本知识，可以开始使用单文件组件创建Vue组件的下一个级别。让我们开始吧！
- en: If you want to find out more about Vue components and more in-depth parts of
    Vue components, such as slots, please visit [https://vuejs.org/v2/guide/components.html](https://vuejs.org/v2/guide/components.html).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Vue组件以及Vue组件更深入的部分，例如插槽，请访问[https://vuejs.org/v2/guide/components.html](https://vuejs.org/v2/guide/components.html)。
- en: Creating single-file Vue components
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单文件Vue组件
- en: 'We have been writing Vue apps using single HTML pages for quickness and getting
    the outcomes we wanted to see. But in a real development project in Vue or Nuxt,
    we wouldn''t want to write something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用单个HTML页面编写Vue应用程序，以便快速获得我们想要看到的结果。但是在Vue或Nuxt的实际开发项目中，我们不希望编写这样的东西：
- en: '[PRE51]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code, we have created two Vue components using JavaScript
    objects in one place (for example, in a single HTML page), but it is better to
    separate them and create each component in a separate `.js` file, like so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在一个地方（例如在单个HTML页面中）使用JavaScript对象创建了两个Vue组件，但最好将它们分开，并在单独的`.js`文件中创建每个组件，如下所示：
- en: '[PRE52]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This can work very well for a simple component, where the HTML layout is simple.
    However, in more complex layouts that involve more complicated HTML markups, we
    would want to avoid coding our HTML inside a JavaScript file. This issue can be
    solved by single-file components with a `.vue` extension, as shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于简单的组件可以很好地工作，其中HTML布局很简单。但是，在涉及更复杂的HTML标记的更复杂布局中，我们希望避免在JavaScript文件中编写HTML。这个问题可以通过具有`.vue`扩展名的单文件组件来解决，如下所示：
- en: '[PRE53]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: However, we can't just run that file on the browser without compiling it with
    build tools such as webpack or rollup. In this book, we're using webpack. This
    means that, from now on, we will no longer be using CDN or single HTML pages to
    create complex Vue apps. Instead, we will be using `.vue` and `.js` files with
    only one `.html` file to create our Vue apps. We will guide you through how to
    use webpack to help us to do that in the following section. Let's dive in.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能只是在浏览器上运行该文件，而不使用构建工具（如webpack或rollup）进行编译。在本书中，我们使用webpack。这意味着，从现在开始，我们将不再使用CDN或单个HTML页面来创建复杂的Vue应用程序。相反，我们将使用`.vue`和`.js`文件，只有一个`.html`文件来创建我们的Vue应用程序。我们将在接下来的部分指导您如何使用webpack来帮助我们做到这一点。让我们开始吧。
- en: Compiling single-file components with webpack
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用webpack编译单文件组件
- en: 'To compile `.vue` components, we need to install `vue-loader` and `vue-template-compiler` into
    the webpack build process. But before that, we must create a `package.json` file in
    our project directory that lists the Node.js packages our project relies on. You
    can check the details of the `package.json` fields at [https://docs.npmjs.com/creating-a-package-json-file](https://docs.npmjs.com/creating-a-package-json-file).
    The most basic and required are the `name` and `version` fields. Let''s get started:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译`.vue`组件，我们需要将`vue-loader`和`vue-template-compiler`安装到webpack构建过程中。但在此之前，我们必须在项目目录中创建一个`package.json`文件，列出我们项目依赖的Node.js包。您可以在[https://docs.npmjs.com/creating-a-package-json-file](https://docs.npmjs.com/creating-a-package-json-file)上查看`package.json`字段的详细信息。最基本和必需的是`name`和`version`字段。让我们开始吧：
- en: 'Create a `package.json` file in your project directory with the following required
    fields and values:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录中创建一个`package.json`文件，其中包含以下必填字段和值：
- en: '[PRE54]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Open a terminal, change the directory to your project, and install `vue-loader` and `vue-template-compiler`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端，将目录更改为您的项目，并安装`vue-loader`和`vue-template-compiler`：
- en: '[PRE55]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You should see a warning on your terminal since the Node.js packages you installed
    here require other Node.js packages, the most notable of which is the webpack
    package. In this book, we have set up a basic build process with webpack in `/chapter-5/vue/component-webpack/basic/`
    in this book''s GitHub repository. We will be using this setup for most of our
    upcoming Vue apps. We have separated the webpack configuration file into three
    smaller config files:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端上看到一个警告，因为您在此处安装的Node.js包需要其他Node.js包，其中最显着的是webpack包。在本书中，我们在本书的GitHub存储库中的`/chapter-5/vue/component-webpack/basic/`中设置了一个基本的webpack构建过程。我们将在大多数即将推出的Vue应用程序中使用此设置。我们已将webpack配置文件分成了三个较小的配置文件：
- en: '`webpack.common.js` contains common webpack plugins and configurations that
    are shared in the development and production process.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpack.common.js`包含在开发和生产过程中共享的常见webpack插件和配置。'
- en: '`webpack.dev.js` contains plugins and configurations for the development process
    only.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpack.dev.js`仅包含开发过程的插件和配置。'
- en: '`webpack.prod.js` contains plugins and configurations for the production process
    only.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpack.prod.js`仅包含生产过程的插件和配置。'
- en: 'The following code shows how we use these files in `script` commands, respectively:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们如何在`script`命令中使用这些文件：
- en: '[PRE56]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that in this book, we are assuming that you already know how to use webpack
    to compile JavaScript modules in general. If you are new to webpack, please visit [https://webpack.js.org/](https://webpack.js.org/) for
    more information.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本书中，我们假设您已经知道如何使用webpack来编译JavaScript模块。如果您对webpack还不熟悉，请访问[https://webpack.js.org/](https://webpack.js.org/)获取更多信息。
- en: 'So, after installing `vue-loader` and `vue-template-compiler`, we will need
    to configure `module.rules` in `webpack.common.js` (or `webpack.config.js`, if
    you are using a single config file), as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在安装了`vue-loader`和`vue-template-compiler`之后，我们需要在`webpack.common.js`（或`webpack.config.js`，如果您使用单个配置文件）中配置`module.rules`，如下所示：
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can then use the following commands we set in `package.json` to see our
    app in action:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用在`package.json`中设置的以下命令来查看我们的应用程序运行情况：
- en: '`$ npm run start` for live reloading and development at `localhost:8080`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ npm run start`用于在`localhost:8080`进行实时重新加载和开发'
- en: '`$ npm run watch` for development at `/path/to/your/project/dist/`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ npm run watch`用于在`/path/to/your/project/dist/`进行开发'
- en: '`$ npm run build` for compiling our code at `/path/to/your/project/dist/`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ npm run build`用于在`/path/to/your/project/dist/`编译我们的代码'
- en: That's it. You now have a basic build process to develop Vue apps with webpack.
    So, from now on, in more complex apps, we will be writing single-file components and
    using this method to compile them. We'll create a simple Vue app in the following
    section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在你有了一个基本的构建流程来开发Vue应用程序与webpack。所以，从现在开始，在更复杂的应用程序中，我们将编写单文件组件，并使用这种方法来编译它们。我们将在下一节中创建一个简单的Vue应用程序。
- en: Passing data and listening to events in single-file components
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单文件组件中传递数据和监听事件
- en: 'So far, we have been using a single HTML page for our "todo" demonstrations.
    This time, we''ll use single-file components with a simple "todo" grocery list.
    Let''s begin:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用单个HTML页面进行我们的“todo”演示。这一次，我们将使用单文件组件来创建一个简单的“todo”购物清单。让我们开始：
- en: 'Create an `index.html` file with a `"todos"` ID in the `<div>` element for
    Vue to run the Vue instance:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<div>`元素中创建一个带有`"todos"`ID的`index.html`文件，以便Vue运行Vue实例：
- en: '[PRE58]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a `/src/` directory in your project root and an `entry.js` file in it
    as the file entry point to indicate which modules webpack should use to start
    building out our app internal dependency graph. webpack will also use this file
    to figure out what other modules and libraries the entry point depends on (directly
    and indirectly):'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录中创建一个`/src/`目录，并在其中创建一个`entry.js`文件作为文件入口点，以指示webpack应该使用哪些模块来开始构建我们的应用程序内部依赖图。webpack还将使用此文件来找出入口点依赖的其他模块和库（直接和间接）。
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a parent component that provides dummy data with a list of items in
    the `<script>` block:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<script>`块中创建一个提供虚拟数据的父组件，其中包含项目列表：
- en: '[PRE60]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding code, we simply `import` the child component as a `TodoItem`
    and generate a list of them from the data in `groceryList` with `v-for`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们简单地将子组件作为`TodoItem`导入，并使用`v-for`从`groceryList`中生成它们的列表。
- en: 'Add the following methods to the `methods` object in order to add and delete
    items. Then, add a method to the `computed` object that sums up the total cost
    of the items in the shopping cart:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`methods`对象中添加以下方法以添加和删除项目。然后，在`computed`对象中添加一个方法，计算购物车中项目的总成本：
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a child component that displays the item being passed down from the
    parent via `props`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个子组件，通过`props`显示从父级传递下来的项目：
- en: '[PRE62]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this component, we also have a `checkbox` button. This is used to emit the
    `delete-item` or `add-item` event and pass the item data up to the parent. Now,
    if you run the app with `$ npm run start`, you should see it load at `localhost:8080`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，我们还有一个`checkbox`按钮。这用于发出`delete-item`或`add-item`事件，并将项目数据传递给父级。现在，如果你用`$
    npm run start`运行应用程序，你应该看到它在`localhost:8080`加载。
- en: Well done! You have managed to build a Vue app with single-file components using
    webpack, which is what Nuxt uses behind the scene to compile and build your Nuxt
    app. It is always useful to know what is running beneath an established system.
    When you know how to use webpack, you can use the webpack build setup that you
    just learned about for various JavaScript and CSS related projects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你已经成功构建了一个使用webpack的Vue应用程序，这就是Nuxt在幕后使用的编译和构建你的Nuxt应用程序。了解已建立系统下方运行的内容总是有用的。当你知道如何使用webpack时，你可以使用刚学到的webpack构建设置来进行各种JavaScript和CSS相关的项目。
- en: You can find this example in `/chapter-5/vue/component-webpack/todo/` in this
    book's GitHub repository.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub存储库中的`/chapter-5/vue/component-webpack/todo/`中找到这个示例。
- en: In the next section, we'll apply what we learned in the previous sections to
    the sample website in `/chapter-5/nuxt-universal/local-components/sample-website/`,
    which can be found in this book's GitHub repository.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把前面几节学到的内容应用到`/chapter-5/nuxt-universal/local-components/sample-website/`中的`sample
    website`示例网站中，这个示例可以在本书的GitHub存储库中找到。
- en: Adding Vue components in Nuxt
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Nuxt中添加Vue组件
- en: 'There are only two `.vue` files in the sample website that we can improve with
    Vue components: `/layouts/default.vue` and `/pages/work/index.vue`. First, we
    should improve `/layouts/default.vue`. There are only three things we need to
    improve in this file: the navigation, the social media links, and the copyright.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例网站中，我们只有两个`.vue`文件可以使用Vue组件进行改进：`/layouts/default.vue`和`/pages/work/index.vue`。首先，我们应该改进`/layouts/default.vue`。在这个文件中，我们只需要改进三件事：导航、社交媒体链接和版权。
- en: Refactoring n**avigation** and **social links**
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构**导航**和**社交链接**
- en: 'We will begin by refactoring the navigation and social media links:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从重构导航和社交媒体链接开始：
- en: 'Create a navigation component in the `/components/` directory, as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/components/`目录中创建一个导航组件，如下所示：
- en: '[PRE63]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a social links component in the `/components/` directory as well, as
    follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/components/`目录中也创建一个社交链接组件，如下所示：
- en: '[PRE64]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Import them into the `<script>` block in the layout, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们导入到布局的`<script>`块中，如下所示：
- en: '[PRE65]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that you can skip this step if you have the `components` option set to
    `true` in your Nuxt config file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在Nuxt配置文件中将`components`选项设置为`true`，则可以跳过此步骤。
- en: 'Remove the existing navigation and social links blocks from the `<template>`
    block:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`<template>`块中删除现有的导航和社交链接块：
- en: '[PRE66]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Replace them with the imported `Nav` and `Social` components, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用导入的`Nav`和`Social`组件替换它们，如下所示：
- en: '[PRE67]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: And with that, you're done!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你就完成了！
- en: Refactoring the **copyright component**
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构**版权组件**
- en: 'We will now refactor the copyright component that we already have in the `/components/` directory.
    Let''s get started:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重构已经存在于`/components/`目录中的版权组件。让我们开始吧：
- en: 'Remove the `data` function from the `<script>` block in the `/components/base-copyright.vue`
    file:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`/components/base-copyright.vue`文件的`<script>`块中删除`data`函数：
- en: '[PRE68]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Replace the preceding `data` function with the `props` property, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`props`属性替换前面的`data`函数，如下所示：
- en: '[PRE69]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add the copyright data in the `<script>` block to `/layouts/default.vue` instead:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将版权数据添加到`<script>`块中，而不是`/layouts/default.vue`中：
- en: '[PRE70]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Remove the existing `<Copyright />` component in the `<template>` block:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`<template>`块中删除现有的`<Copyright />`组件：
- en: '[PRE71]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Add a new `<Copyright />` component with the copyright data bound to it:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`<Copyright />`组件，并将版权数据绑定到它：
- en: '[PRE72]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With that, you should have managed to pass the data down to the components
    (the children) from the default page (the parent) where you kept your data. Well
    done! That''s it for `/layouts/default.vue`. We can also improve the work pages,
    which we have already done for you in `/chapter-5/nuxt-universal/local-components/sample-website/`,
    which can be found in this book''s GitHub repository. If you install this sample
    website and run it on your local machine, you will see that we have finally applied
    our components beautifully. With this, you can see how easy it is to abstract
    the elements in layouts so that they become components once you have understood
    how Vue component system works. But what about passing the data up to the parent
    components? For this, we have created an example app with child components emitting
    events to the parent components in `/chapter-5/nuxt-universal/local-components/emit-events/`,
    which can be found in this book''s GitHub repository. We have also added custom
    input and checkbox components to the app, so please check it out. The following
    is an example snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，您应该已经成功将数据从默认页面（父级）传递给组件（子级），在默认页面中保留了您的数据。干得好！这就是`/layouts/default.vue`的全部内容。我们还可以改进工作页面，我们已经为您在`/chapter-5/nuxt-universal/local-components/sample-website/`中完成了这项工作，这可以在本书的GitHub存储库中找到。如果您在本地安装此示例网站并在本地机器上运行它，您将看到我们已经很好地应用了我们的组件。通过这个例子，您可以看到在理解了Vue组件系统的工作原理后，将布局中的元素抽象化为组件是多么容易。但是，如何将数据传递给父组件呢？为此，我们创建了一个示例应用程序，其中子组件向父组件发出事件，位于`/chapter-5/nuxt-universal/local-components/emit-events/`，这可以在本书的GitHub存储库中找到。我们还向应用程序添加了自定义输入和复选框组件，请查看一下。以下是一个示例片段：
- en: '[PRE73]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here, you can see that the component code we used in the Nuxt app is the same
    as what we wrote in the Vue app. These kinds of components are nested components.
    The `props` property and the `$emit` method are used to pass the data up and down
    between the parent and the child components. These nested components also are
    local because they are only available in the scope of the component (parent) that
    imports them. So, from another perspective, Vue components can be categorized
    into local components and global components. You''ve been learning about global
    components ever since the *What is a component?* section. However, you''ve only
    learned how to use them in a Vue app. In the next section, we will look at how
    to register global components for Nuxt apps. But before jumping into that, let''s
    revisit Vue components from a holistic view: global components and local components.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们在Nuxt应用程序中使用的组件代码与我们在Vue应用程序中编写的代码相同。这些类型的组件是嵌套组件。`props`属性和`$emit`方法用于在父组件和子组件之间传递数据。这些嵌套组件也是本地的，因为它们只在导入它们的组件（父级）的范围内可用。因此，从另一个角度来看，Vue组件可以被归类为本地组件和全局组件。自从*什么是组件？*部分以来，您一直在学习全局组件。但是，您只学会了如何在Vue应用程序中使用它们。在接下来的部分中，我们将看看如何为Nuxt应用程序注册全局组件。但在跳入其中之前，让我们从整体的角度重新审视Vue组件：全局组件和本地组件。
- en: Registering global and local components
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册全局和本地组件
- en: We have created many components either using `Vue.component()`, plain JavaScript
    objects, or single-file components engines. Some of the components we've created
    have been global components, while some of them have been local components. For
    example, all the refactored components you just created in the `/components/`
    directory in the previous section are local ones, while the components you created
    in the *What is a component? *section are global ones. Whether they are local
    or global components, they have to be registered if you want to use them. Some
    of them are registered at the time of their creation, while some of them are registered
    manually. In the following sections, you will learn how to register them globally
    and locally. You will also learn about the two types of registration that will
    affect your app. We will be looking at registering Vue components, instead of
    passing around them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了许多组件，无论是使用`Vue.component()`、纯JavaScript对象还是单文件组件引擎。我们创建的一些组件是全局组件，而另一些是本地组件。例如，在上一节中刚刚创建的`/components/`目录中的所有重构组件都是本地组件，而在*什么是组件？*部分中创建的组件都是全局组件。无论它们是本地组件还是全局组件，如果您想使用它们，都必须进行注册。其中一些在创建时注册，而另一些则需要手动注册。在接下来的部分中，您将学习如何全局和本地注册它们。您还将了解两种类型的注册将如何影响您的应用程序。我们将学习如何注册Vue组件，而不是传递它们。
- en: Registering global components in Vue
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Vue中注册全局组件
- en: 'Global components, just as their name suggests, are available globally throughout
    your application. They are globally registered when you create them using `Vue.component()`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 全局组件，正如它们的名称所示，可以在整个应用程序中全局使用。当您使用`Vue.component()`创建它们时，它们会被全局注册：
- en: '[PRE74]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Global components must be registered before the instantiation of the root Vue
    instance. After they''ve been registered, they can be used in the template of
    the root Vue instance, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 全局组件必须在根Vue实例实例化之前注册。注册后，它们可以在根Vue实例的模板中使用，如下所示：
- en: '[PRE75]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, you can see that it is very easy to register global components – you might
    not even realize the registration process while creating them. We will look into
    this type of registration for Nuxt shortly in the *Registering global components
    in Nuxt *section. But now, we'll learn how to register local components.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到注册全局组件非常容易 - 在创建它们时，您甚至可能意识不到注册过程。我们将很快在*Nuxt中注册全局组件*部分中研究这种类型的注册。但现在，我们将学习如何注册本地组件。
- en: Registering local components in Vue/Nuxt
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Vue/Nuxt中注册本地组件
- en: 'We have seen and used local components in the Vue and Nuxt apps in this chapter.
    These components are created by using plain JavaScript objects, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到并使用了Vue和Nuxt应用中的本地组件。这些组件是通过使用纯JavaScript对象创建的，如下所示：
- en: '[PRE76]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, they can be registered through the `components` option, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它们可以通过`components`选项进行注册，如下所示：
- en: '[PRE77]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Remember the Vue app we created at the beginning of the *Passing data to child
    components with props* section, in the `/chapter-5/vue/component/basic.html` file
    in this book''s GitHub repository? The `user-item` component in that app is a
    global component. Now, let''s refactor it and turn it into a local component:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在本书的GitHub存储库中的`/chapter-5/vue/component/basic.html`文件中创建的Vue应用吗？该应用中的`user-item`组件是一个全局组件。现在，让我们对其进行重构并将其变成一个本地组件：
- en: 'Remove the following global component:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除以下全局组件：
- en: '[PRE78]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Replace it with a local component, as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方式替换为本地组件：
- en: '[PRE79]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Register the local component using the `components` options:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`components`选项注册本地组件：
- en: '[PRE80]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The app will work the same way as it did previously. The only difference is
    that `user-item` is no longer available globally. This means it is not available
    in any other sub-components. For instance, if you want to make `ComponentX` available
    in `ComponentZ`, then you have to "attach" it manually:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将与以前的方式相同工作。唯一的区别是`user-item`不再全局可用。这意味着它在任何其他子组件中都不可用。例如，如果您想要在`ComponentZ`中使`ComponentX`可用，那么您必须手动"附加"它：
- en: '[PRE81]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you are writing ES2015 modules using babel and webpack, you can make `ComponentX` a
    single-file component and then import it, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用babel和webpack编写ES2015模块，您可以将`ComponentX`作为单文件组件，然后导入它，如下所示：
- en: '[PRE82]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You also can omit `component-x` from the `components` option and use the `ComponentX`
    variable directly inside it, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从`components`选项中省略`component-x`，并直接在其中使用`ComponentX`变量，如下所示：
- en: '[PRE83]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Using variables such as `ComponentX` in a JavaScript object in ES2015+ is short
    form for `ComponentX: ComponentX`. Since `component-x` is never registered, so
    instead of using the component as `<component-x>`, you will need to use `<ComponentX>`
    in the template instead:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '在ES2015+中使用诸如`ComponentX`之类的变量作为JavaScript对象的简写形式为`ComponentX: ComponentX`。由于`component-x`从未注册过，所以您需要在模板中使用`<ComponentX>`而不是`<component-x>`。'
- en: '[PRE84]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Writing ES2015 in the preceding single-file component is the same as how we
    write `.vue` files in Nuxt. So by now, you should have realized that we have been
    writing local components in our Nuxt apps, such as `/components/copyright.vue`
    and `/components/nav.vue`. But how do we write global components in Nuxt apps?
    That's where the `/plugins/` directory comes in. In the next section, you'll learn
    how to do this in Nuxt.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的单文件组件中编写ES2015与我们在Nuxt中编写`.vue`文件的方式相同。因此，到目前为止，您应该已经意识到我们一直在Nuxt应用程序中编写本地组件，例如`/components/copyright.vue`和`/components/nav.vue`。但是在Nuxt应用程序中如何编写全局组件呢？这就是`/plugins/`目录发挥作用的地方。在下一节中，您将学习如何在Nuxt中进行此操作。
- en: You can find the preceding app in `/chapter-5/vue/component/registering-local-components.html`,
    in this book's GitHub repository.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-5/vue/component/registering-local-components.html`中找到前面的应用程序。
- en: Registering global components in Nuxt
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Nuxt中注册全局组件
- en: We learned about the directory structure in [Chapter 2](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml),
    *Getting Started with Nuxt*, and that the `/plugins/` directory is where we can
    create JavaScript files that we want to run before instantiating the root Vue
    app. Hence, this is the best place to register our global components.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml)中学习了目录结构，*开始使用Nuxt*，`/plugins/`目录是我们可以创建JavaScript文件并在实例化根Vue应用程序之前运行的最佳位置。因此，这是注册我们的全局组件的最佳位置。
- en: 'Let''s create our first global component:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个全局组件：
- en: 'Create a simple Vue component in the `/plugins/` directory, as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/plugins/`目录中创建一个简单的Vue组件，如下所示：
- en: '[PRE85]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Create a `.js` file in the `/plugins/` directory and import the preceding component,
    as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/plugins/`目录中创建一个`.js`文件，并导入前面的组件，如下所示：
- en: '[PRE86]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can also create a second global component directly in `/plugins/global-components.js`,
    like this:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以直接在`/plugins/global-components.js`中创建第二个全局组件，如下所示：
- en: '[PRE87]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Tell Nuxt to run them first before instantiating the root app in the Nuxt config
    file, as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉Nuxt在Nuxt配置文件中在实例化根应用程序之前先运行它们，如下所示：
- en: '[PRE88]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Note that this component will be available on both the client and server sides
    of your Nuxt app. If you want to run this component on a specific side only, such
    as only on the client-side, then you can register it, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此组件将在Nuxt应用程序的客户端和服务器端都可用。如果您只想在特定端上运行此组件，例如仅在客户端上运行，则可以注册它，如下所示：
- en: '[PRE89]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now, this component will only be available on the client-side. But if you just
    want to run it on the server side, simply use `server` in the preceding `mode`
    option.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个组件只能在客户端使用。但是，如果你只想在服务器端运行它，只需在前面的`mode`选项中使用`server`。
- en: 'We can use these global components anywhere we like without having to import
    them again manually, as shown in the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在任何地方使用这些全局组件，而无需手动再次导入它们，如下面的代码所示：
- en: '[PRE90]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Run the app on your browser. You should get the following output:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器上运行应用程序。你应该得到以下输出：
- en: '[PRE91]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: That's it! This is how you can register global components in Nuxt by involving
    various files. The bottom line of global registration is using `Vue.component`,
    just like we do in the Vue app. However, global registration is not often ideal,
    just like its "cousin", global mixins, which we will cover in the next section.
    For instance, globally registering components but not needing them in most cases
    can be unnecessary for both server and client sides. Now, let's move on and take
    a look at what mixins are and how to write them.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！这就是你可以通过涉及各种文件在Nuxt中注册全局组件的方法。全局注册的底线是使用`Vue.component`，就像我们在Vue应用程序中所做的那样。然而，全局注册通常不是理想的，就像它的“表兄弟”全局混入一样，我们将在下一节中介绍。例如，全局注册组件但在大多数情况下不需要它们对于服务器和客户端来说都是不必要的。现在，让我们继续看看混入是什么，以及如何编写它们。
- en: You can find this example in `/chapter-5/nuxt-universal/global-components/` in
    this book's GitHub repository.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub存储库中的`/chapter-5/nuxt-universal/global-components/`中找到这个例子。
- en: Writing basic and global mixins
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基本和全局混入
- en: A mixin is just a JavaScript object that can be used to contain any component
    option, such as `created`, `methods`, `mounted`, and so on. They can be used to
    make these options reusable. We can do this by importing them into a component
    and "mixing" them with the other options in that component.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 混入只是一个JavaScript对象，可以用来包含任何组件选项，比如`created`，`methods`，`mounted`等等。它们可以用来使这些选项可重用。我们可以通过将它们导入到组件中，并将它们与该组件中的其他选项“混合”来实现这一点。
- en: 'Using mixins can be useful in some situations, such as in [Chapter 2](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml),
    *Getting Started with Nuxt*. We know that when Vue Loader compiles the `<template>`
    blocks in single-file components, it converts any encountered asset URLs into
    webpack module requests, like so:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用混入可能是有用的，比如在[第2章](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml)中，*开始使用Nuxt*。我们知道，当Vue
    Loader编译单文件组件中的`<template>`块时，它会将遇到的任何资源URL转换为webpack模块请求，如下所示：
- en: '[PRE92]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The preceding image will be converted into the following JavaScript code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像将被转换为以下JavaScript代码：
- en: '[PRE93]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This isn''t difficult if you insert the image manually. But in most cases,
    we''ll want to insert images dynamically, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您手动插入图像，这并不难。但在大多数情况下，我们希望动态插入图像，如下所示：
- en: '[PRE94]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In this example, you will get a 404 error for the image on your console because
    Vue Loader never compiles it when it is used with a `:src` directive, and so webpack
    never compiles the image in the build process. To resolve this problem, we need
    to insert the module request into the `:sr` directive manually:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当您在控制台上使用`:src`指令时，图像将会得到404错误，因为Vue Loader在构建过程中从未编译它。为了解决这个问题，我们需要手动将模块请求插入到`:src`指令中。
- en: '[PRE95]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'However, this is no good either because a dynamic image solution is preferred.
    So, the solution here is as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也不好，因为更倾向于动态图像解决方案。因此，这里的解决方案如下：
- en: '[PRE96]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In this solution, we write a reusable `loadAssetImage` function so that it can
    be called in any Vue component where it is needed. Hence, mixins are what we need
    in this situation. There are a few ways of using mixins. We'll have a look at
    some common ways in the following sections.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，我们编写了一个可重用的`loadAssetImage`函数，以便在任何需要的Vue组件中调用它。因此，在这种情况下，我们需要混合。有几种使用混合的方法。我们将在接下来的几节中看一些常见的用法。
- en: Creating basic mixins/non-global mixins
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本混合/非全局混合
- en: 'In a non-single-file component Vue app, we can we define a mixin object like
    so:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在非单文件组件Vue应用程序中，我们可以这样定义一个混合对象：
- en: '[PRE97]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Then, we can "attach" it to a component using `Vue.extend()`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`Vue.extend()`将其“附加”到一个组件中：
- en: '[PRE98]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In this example, we only attached this mixin to `Foo`, so you will only see
    that `console.log` message when this component is called.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只将这个混合附加到`Foo`，所以当调用这个组件时，你只会看到`console.log`消息。
- en: You can find this example in `/chapter-5/vue/mixins/basic.html` in this book's
    GitHub repository.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这本书的GitHub存储库的`/chapter-5/vue/mixins/basic.html`中找到这个例子。
- en: 'For Nuxt apps, we create and keep the mixin object in the `/plugins/` directory,
    in a `.js` file. Let''s demonstrate this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Nuxt应用程序，我们在`/plugins/`目录中创建并保存混合对象，保存在`.js`文件中。让我们来演示一下：
- en: 'Create a `mixin-basic.js` file in the `/plugins/` directory with a function
    that prints a message on the browser console when the Vue instance is created:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/plugins/`目录中创建一个`mixin-basic.js`文件，其中包含一个在浏览器控制台上打印消息的函数，当Vue实例被创建时：
- en: '[PRE99]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Import it whenever and wherever we need it, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要的地方随时导入它，如下所示：
- en: '[PRE100]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In this example, you will only get the `console.log` message when you are on
    the `/about` route. This is how we create and use a non-global mixin. But in some
    cases, we need global mixins for all the components in our app. Let's take a look
    at how we can do that.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，只有当你在`/about`路由上时，你才会得到`console.log`消息。这就是我们创建和使用非全局混合的方法。但在某些情况下，我们需要全局混合适用于应用程序中的所有组件。让我们看看我们如何做到这一点。
- en: You can find this example in `/chapter-5/nuxt-universal/mixins/basic/` in this
    book's GitHub repository.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这本书的GitHub存储库的`/chapter-5/nuxt-universal/mixins/basic/`中找到这个例子。
- en: Creating global mixins
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建全局混合
- en: 'We can create and apply a mixin globally by using `Vue.mixin()`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`Vue.mixin()`来创建和应用全局混合：
- en: '[PRE101]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Global mixins must be defined before you instantiate the Vue instance:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 全局混合必须在实例化Vue实例之前定义：
- en: '[PRE102]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, every component you create will be affected and show that message. You
    can find this example in `/chapter-5/vue/mixins/global.html` in this book''s GitHub
    repository. If you run it on your browser, you will see the `console.log` message
    appear on every route as it spreads across all the route components. In this way,
    we can see the potential harm that could be done if it''s misused. In Nuxt, we
    create global mixins in the same way; that is, by using `Vue.mixin()`. Let''s
    take a look:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你创建的每个组件都将受到影响并显示该消息。你可以在这本书的GitHub存储库的`/chapter-5/vue/mixins/global.html`中找到这个例子。如果你在浏览器上运行它，你会看到`console.log`消息出现在每个路由上，因为它在所有路由组件中传播。通过这种方式，我们可以看到如果被滥用可能造成的潜在危害。在Nuxt中，我们以相同的方式创建全局混合；也就是使用`Vue.mixin()`。让我们来看一下：
- en: 'Create a `mixin-utils.js` file in the `/plugins/` directory, along with the
    function for loading images from the `/assets/` directory:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/plugins/`目录中创建一个`mixin-utils.js`文件，以及用于从`/assets/`目录加载图像的函数：
- en: '[PRE103]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Include the preceding global mixin path in the Nuxt config file:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件中包含前面的全局混合路径：
- en: '[PRE104]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now, you can use the `loadAssetImage` function anywhere you like in your component,
    as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在你的组件中随意使用`loadAssetImage`函数，如下所示：
- en: '[PRE105]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note that we don't need to import global mixins like we import basic mixins
    because we already injected them globally through `nuxt.config.js`. But again,
    use them sparsely and carefully.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要像导入基本混入那样导入全局混入，因为我们已经通过`nuxt.config.js`全局注入了它们。但同样，要谨慎而谨慎地使用它们。
- en: You can find this mixin example in `/chapter-5/nuxt-universal/mixins/global/` in
    this book's GitHub repository.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-5/nuxt-universal/mixins/global/`中找到这个混入的示例。
- en: Mixins are useful. Global mixins such as global Vue components are hard to manage
    when there are too many of them, thus making your app hard to predict and debug.
    So, use them wisely and sparsely. We hope that you now know how Vue components
    work and how to write them. However, knowing how they work and how to write them
    is not enough – we should know about the standard rules we need to comply with
    when writing them for readability and future manageability. Therefore, before
    we end this chapter, we will look at some of these rules.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 混入非常有用。全局混入如全局Vue组件在数量过多时很难管理，因此会使您的应用难以预测和调试。因此，明智而谨慎地使用它们。我们希望您现在知道Vue组件是如何工作的以及如何编写它们。然而，仅仅知道它们是如何工作和如何编写它们是不够的
    - 我们应该了解编写可读性和未来可管理性时需要遵守的标准规则。因此，在结束本章之前，我们将看一些这些规则。
- en: Defining component names and using naming conventions
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义组件名称和使用命名约定
- en: We have seen and created many components in this and the previous chapters.
    The more components we make, the more we need to follow naming conventions for
    our components. Otherwise, we will inevitably get confused and come across errors,
    bikeshedding, and anti-patterns. Our components will inevitably conflict with
    each other – even with the HTML elements. Luckily, there is an official Vue style
    guide that we can comply with to improve our app's readability. In this section,
    we'll go through a few that are specific to this book.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和前几章中，我们已经看到并创建了许多组件。我们创建的组件越多，我们就越需要遵循组件的命名约定。否则，我们将不可避免地会遇到混淆和错误，以及反模式。我们的组件将不可避免地会相互冲突
    - 甚至与HTML元素相冲突。幸运的是，有一个官方的Vue风格指南，我们可以遵循以提高我们应用的可读性。在本节中，我们将介绍一些特定于本书的规则。
- en: Multi-word component names
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多词组件名称
- en: 'Our existing and future HTML elements are single words (for example, `article`,
    `main`, `body`, and so on), so to prevent conflicts from occurring, we should
    use multi-words when naming our components (except for the root app components).
    For example, the following is considered bad practice:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现有和未来的HTML元素都是单词（例如`article`，`main`，`body`等），因此为了防止冲突发生，我们在命名组件时应该使用多个单词（除了根应用组件）。例如，以下做法被认为是不好的：
- en: '[PRE106]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The component''s name should be written as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的名称应该按照以下方式书写：
- en: '[PRE107]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Component data
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件数据
- en: 'We should always use the `data` function instead of the `data` property for
    our component data, except in the root Vue instance. For example, this is considered
    bad practice:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终使用`data`函数而不是`data`属性来处理组件的数据，除了在根Vue实例中。例如，以下做法被认为是不好的：
- en: '[PRE108]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The data in the preceding components should be written as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 上述组件中的数据应该按照以下方式书写：
- en: '[PRE109]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: But why? This is because when Vue initiates data, it creates a reference of
    `data` from `vm.$options.data`. So, if the data is an object and when there are
    many instances of a component, they will all use the same `data`. Changing the
    data in an instance will affect the other instances. This is not what we want.
    So, if `data` is a function, Vue will use a `getData` method to return a new object
    that only belongs to the current instance that you are initializing. Hence, the
    data in the root instance is shared across all the other components' instances,
    which contain their own data. You can access the root data from any component's
    instance by using `this.$root.$data`. You can check out some examples in `/chapter-5/vue/component-webpack/data/` and
    `/chapter-5/vue/data/basic.html`, both of which can be found in this book's GitHub
    repository.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么呢？这是因为当Vue初始化数据时，它会从`vm.$options.data`创建一个对`data`的引用。因此，如果数据是一个对象，并且一个组件有多个实例，它们都将使用相同的`data`。更改一个实例中的数据将影响其他实例。这不是我们想要的。因此，如果`data`是一个函数，Vue将使用`getData`方法返回一个只属于当前初始化实例的新对象。因此，根实例中的数据在所有其他组件实例中共享，这些实例包含它们自己的数据。你可以通过`this.$root.$data`从任何组件实例中访问根数据。你可以在本书的GitHub存储库中的`/chapter-5/vue/component-webpack/data/`和`/chapter-5/vue/data/basic.html`中查看一些示例。
- en: You can check out the Vue source code on how data is initiated at [https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L112](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L112).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L112](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L112)上查看Vue源代码，了解数据是如何初始化的。
- en: Prop definitions
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性定义
- en: 'We should define properties in the `props` property so that they''re as detailed
    as possible by specifying their types (at a minimum). It is only okay to not have
    detailed definitions when you''re prototyping. For example, this is considered
    bad practice:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在`props`属性中定义属性，以便尽可能详细地指定它们的类型（至少）。只有在原型设计时才可以不进行详细定义。例如，以下做法被认为是不好的：
- en: '[PRE110]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This should be written as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该这样写：
- en: '[PRE111]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Or, even better, it should be written as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更好的做法是这样写：
- en: '[PRE112]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Component files
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件文件
- en: 'We should always comply with the one file one component "policy"; that is,
    writing only one component in one file. This means that you should not have more
    than one component in a file. For example, this is considered bad practice:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终遵守“一个文件一个组件”的政策；也就是说，一个文件中只写一个组件。这意味着你不应该在一个文件中有多个组件。例如，以下做法被认为是不好的：
- en: '[PRE113]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'They should be split into multiple files, as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 它们应该拆分成多个文件，如下所示：
- en: '[PRE114]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This should be done as follows if you are writing the components in `.vue`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`.vue`中编写组件，应该这样做：
- en: '[PRE115]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Single-file component filename casing
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单文件组件文件名大小写
- en: 'We should only use PascalCase or kebab-case for the filenames for single-file
    components. For example, these are considered bad practice:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该只为单文件组件的文件名使用PascalCase或kebab-case。例如，以下做法被认为是不好的：
- en: '[PRE116]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'They should be written as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 它们应该这样写：
- en: '[PRE117]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Self-closing components
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自闭合组件
- en: 'We should use the self-closing format when there''s no content in our single-file
    components, unless they are used in a DOM template. For example, these are considered
    bad practice:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的单文件组件中没有内容时，应该使用自闭合格式，除非它们在DOM模板中使用。例如，以下做法被认为是不好的：
- en: '[PRE118]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'They should be written as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 它们应该这样写：
- en: '[PRE119]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: These are only a few essential rules. There are more, such as rules for writing multi-attribute
    elements, directive shorthands, quoted attribute values, and so on. But the selected
    rules that we've highlighted here should be enough for you to complete this book.
    You can find the other rules and the full style guide at [https://vuejs.org/v2/style-guide/](https://vuejs.org/v2/style-guide/).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些基本的规则。还有更多规则，比如编写多属性元素的规则，指令简写，带引号的属性值等等。但是我们在这里突出显示的选定规则应该足够让你完成本书。你可以在[https://vuejs.org/v2/style-guide/](https://vuejs.org/v2/style-guide/)找到其他规则和完整的样式指南。
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Well done! In this chapter, you learned about the differences between global
    and local Vue components, how to register global components in Nuxt apps, and
    how to create local and global mixins. You also learned how to pass data to child
    components from the parent component using the `props` property, how to emit data
    to the parent from the child component using the `$emit` method, and how to create
    custom input components. You then learned the importance of using the `key` attribute
    for components. After that, you learned how to write single-file components with
    webpack. Last but not least, you were introduced to some rules that should be
    followed in Nuxt and Vue app development.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！在本章中，你学会了全局和局部Vue组件之间的区别，如何在Nuxt应用程序中注册全局组件，以及如何创建局部和全局mixin。你还学会了如何通过`props`属性将数据传递给子组件，如何使用`$emit`方法从子组件向父组件发出数据，以及如何创建自定义输入组件。然后，你学会了为组件使用`key`属性的重要性。之后，你学会了如何使用webpack编写单文件组件。最后但同样重要的是，你了解了在Nuxt和Vue应用程序开发中应该遵循的一些规则。
- en: In the next chapter, we are going to explore the use of the `/plugins/` directory
    further for extending a Nuxt app by writing custom plugins in Vue and importing
    them. We'll also look at importing external Vue plugins from the Vue community,
    creating global functions by injecting them into Nuxt's `$root` and `context` components,
    writing basic/async modules and module snippets, and using external Nuxt modules
    from the Nuxt community. We will guide you through these thoroughly, so stay tuned!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨`/plugins/`目录的使用，通过编写Vue中的自定义插件并导入它们来扩展Nuxt应用程序。我们还将研究如何从Vue社区导入外部Vue插件，通过将它们注入到Nuxt的`$root`和`context`组件中创建全局函数，编写基本/异步模块和模块片段，并使用Nuxt社区的外部Nuxt模块。我们将会对这些进行详细的指导，敬请关注！
