- en: Introducing Nuxt
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍Nuxt
- en: Welcome to your journey of *Hands-on Nuxt.js Web Development*. In this chapter,
    we will peer inside Nuxt to see what constitutes this framework. We will walk
    you through Nuxt's features and you will get to know the pros and cons of the
    different types of applications that Nuxt falls in line with. Last but not least,
    you will discover the great potential of using Nuxt as a universal SSR app, a
    static site generator, and a single-page app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到您的*Nuxt.js Web开发实践*之旅。在本章中，我们将深入了解Nuxt，看看构成这个框架的是什么。我们将带您了解Nuxt的特性，您将了解Nuxt所属的不同类型应用程序的优缺点。最后但同样重要的是，您将发现使用Nuxt作为通用SSR应用程序、静态站点生成器和单页面应用程序的巨大潜力。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: From Vue to Nuxt
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Vue到Nuxt
- en: Why Use Nuxt?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用Nuxt？
- en: Types of applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序类型
- en: Nuxt as a universal SSR app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt作为通用SSR应用程序
- en: Nuxt as a static site generator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt作为静态站点生成器
- en: Nuxt as a single-page app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt作为单页面应用程序
- en: Let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: From Vue to Nuxt
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Vue到Nuxt
- en: 'Nuxt is a higher-level Node.js web development framework for creating Vue apps
    that can be developed and deployed in two different modes: universal (SSR) or
    **single-page application** (**SPA**). Furthermore, you can deploy SSR and SPA
    in Nuxt as static-generated apps. Even though you can choose the SPA mode, the
    full power of Nuxt lies in its universal mode or **server-side rendering** (**SSR**)
    for building universal apps. A universal app is used to describe JavaScript code
    that can execute both on the client and the server-side. But if you wish to develop
    a classic (or standard/traditional) SPA, which executes on the client-side only,
    you may want to consider using vanilla Vue.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt是一个更高级的Node.js Web开发框架，用于创建可以以两种不同模式开发和部署的Vue应用程序：通用（SSR）或单页面应用程序（SPA）。此外，您可以在Nuxt中部署SSR和SPA作为静态生成的应用程序。尽管您可以选择SPA模式，但Nuxt的全部潜力在于其通用模式或用于构建通用应用程序的服务器端渲染（SSR）。通用应用程序用于描述可以在客户端和服务器端都执行的JavaScript代码。但是，如果您希望开发经典（或标准/传统）的SPA，仅在客户端执行的SPA，您可能希望考虑使用纯Vue。
- en: Note that an SPA mode Nuxt app is slightly different from a classic SPA. You
    will find out more about it later in this book and briefly in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SPA模式的Nuxt应用程序与经典SPA略有不同。您将在本书的后面和本章中简要了解更多信息。
- en: Nuxt is created on top of Vue, supercharged with some extra features such as
    asynchronous data, middleware, layouts, modules, and plugins that execute your
    app on the server-side first, and then on the client-side. This means the app
    generally renders quicker than the traditional server-side (or multiple-page)
    apps.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt是建立在Vue之上的，具有一些额外功能，如异步数据、中间件、布局、模块和插件，可以先在服务器端执行您的应用程序，然后再在客户端执行。这意味着应用程序通常比传统的服务器端（或多页面）应用程序渲染更快。
- en: 'Nuxt is pre-installed with the following packages so that you don''t have to
    install them, which you would do in a standard Vue app:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt预装了以下软件包，因此您无需像在标准Vue应用程序中那样安装它们：
- en: Vue ([https://vuejs.org/](https://vuejs.org/))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue（[https://vuejs.org/](https://vuejs.org/)）
- en: Vue Router ([https://router.vuejs.org/](https://router.vuejs.org/))
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue路由器（[https://router.vuejs.org/](https://router.vuejs.org/)）
- en: Vuex ([https://vuex.vuejs.org/](https://vuex.vuejs.org/))
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vuex（[https://vuex.vuejs.org/](https://vuex.vuejs.org/)）
- en: Vue Server Renderer ([https://ssr.vuejs.org/](https://ssr.vuejs.org/))
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue服务器渲染器（[https://ssr.vuejs.org/](https://ssr.vuejs.org/)）
- en: Vue Meta ([https://vue-meta.nuxtjs.org/](https://vue-meta.nuxtjs.org/))
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue元（[https://vue-meta.nuxtjs.org/](https://vue-meta.nuxtjs.org/)）
- en: 'On top of that, Nuxt uses webpack and Babel to compile and bundle your code
    with the following webpack loaders:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Nuxt使用webpack和Babel来编译和捆绑您的代码，使用以下webpack加载器：
- en: Vue Loader ([https://vue-loader.vuejs.org/](https://vue-loader.vuejs.org/))
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue加载器（[https://vue-loader.vuejs.org/](https://vue-loader.vuejs.org/)）
- en: Babel Loader ([https://webpack.js.org/loaders/babel-loader/](https://webpack.js.org/loaders/babel-loader/))
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel Loader ([https://webpack.js.org/loaders/babel-loader/](https://webpack.js.org/loaders/babel-loader/))
- en: In a nutshell, webpack is a module bundler that bundles all the scripts, styles,
    assets, and images in your JavaScript app, while Babel is a JavaScript compiler
    that compiles or transpiles the next-generation JavaScript (ES2015+) to browser-compatible
    JavaScript (ES5) so that you can run your code on current browsers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，webpack是一个模块打包工具，它将JavaScript应用程序中的所有脚本、样式、资产和图像捆绑在一起，而Babel是一个JavaScript编译器，它将下一代JavaScript（ES2015+）编译或转译为浏览器兼容的JavaScript（ES5），以便您可以在当前浏览器上运行您的代码。
- en: For more information about webpack and Babel, please visit [https://webpack.js.org/](https://webpack.js.org/) and [https://babeljs.io/](https://babeljs.io/),
    respectively.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有关webpack和Babel的更多信息，请分别访问[https://webpack.js.org/](https://webpack.js.org/)和[https://babeljs.io/](https://babeljs.io/)。
- en: webpack uses what they call loaders to preprocess your files when you import
    them via the JavaScript `import` statement or `require` method. You can write
    your loaders but you don't have to do so when compiling your code in Vue files
    since they have been created for you by the Babel community and Vue team. We'll
    discover the great features that come with Nuxt and those contributed by these
    loaders in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: webpack使用他们称之为加载器的东西来预处理您通过JavaScript `import`语句或`require`方法导入的文件。您可以编写自己的加载器，但在编译Vue文件时，您无需这样做，因为它们已经由Babel社区和Vue团队为您创建。我们将在下一节中发现Nuxt带来的伟大功能以及这些加载器贡献的功能。
- en: Why use Nuxt?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用Nuxt？
- en: Frameworks such as Nuxt exist because of the shortcomings of the traditional SPA
    and the server-side rendering of **multi-page applications** (**MPAs**). We can
    regard Nuxt as a hybrid of server-side rendering MPA and traditional SPA. Hence,
    it is dubbed "universal" or "isomorphic". So, being able to do server-side rendering
    is the defining feature of Nuxt. In this section, we will walk you through other
    prominent features of Nuxt that will make your app development easy and fun. The
    first feature we'll look at allows you to write single-file Vue components by
    using a `.vue` extension in your files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传统SPA和**多页面应用**（**MPA**）的缺点，存在诸如Nuxt之类的框架。我们可以将Nuxt视为服务器端渲染MPA和传统SPA的混合体。因此，它被称为“通用”或“同构”。因此，能够进行服务器端渲染是Nuxt的定义特性。在本节中，我们将为您介绍Nuxt的其他突出特性，这将使您的应用开发变得简单而有趣。我们将首先介绍的功能允许您通过在文件中使用`.vue`扩展名来编写单文件Vue组件。
- en: Writing single-file components
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单文件组件
- en: 'There are a few methods we can use to create a Vue component. A global Vue
    component is created by using `Vue.component`, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用几种方法来创建Vue组件。全局Vue组件是通过使用`Vue.component`创建的，如下所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On the other hand, a local Vue component can be created using a plain JavaScript
    object, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可以使用普通JavaScript对象创建本地Vue组件，如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These two methods are manageable and maintainable if you're using Vue for a
    small project, but it becomes difficult to manage for a big project when you have
    tons of components with different templates, styles, and JavaScript methods all
    at once.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在小型项目中使用Vue是可管理和可维护的，但是当你一次拥有大量具有不同模板、样式和JavaScript方法的组件时，对于大型项目来说，管理变得困难。
- en: 'Hence, single-file components come to the rescue, in which we only use one
    `.vue` file for each Vue component. If you need more than one component in your
    app, then just separate them into multiple `.vue` files. In each of them, you
    can write the template, script, and style that relate to that particular component
    only, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，单文件组件来拯救，我们只使用一个`.vue`文件来创建每个Vue组件。如果您的应用程序需要多个组件，只需将它们分开成多个`.vue`文件。在每个文件中，您可以只编写与该特定组件相关的模板、脚本和样式，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, you can see how we have an HTML template that prints the message from
    the JavaScript script and the CSS style that describes the presentation of the
    template, all in one single `.vue` file. This makes your code more structured,
    readable, and organizable. Sweet, isn't it? This is only made possible by `vue-loader`
    and webpack. In Nuxt, we only write components in `.vue` files, regardless of
    whether they are components in the `/components/`, `/pages/`, or `/layouts/` directory.
    We will explore this in more detail in [Chapter 2](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml),
    *Getting Started with Nuxt*. Now, we'll look at the Nuxt feature that allows you
    to write ES6 JavaScript out of the box.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们有一个HTML模板，它从JavaScript脚本中打印消息，并且描述模板的CSS样式，全部在一个`.vue`文件中。这使得您的代码更加结构化、可读和可组织。很棒，不是吗？这只能通过`vue-loader`和webpack实现。在Nuxt中，我们只在`.vue`文件中编写组件，无论它们是`/components/`、`/pages/`还是`/layouts/`目录中的组件。我们将在[第2章](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml)中更详细地探讨这一点，*开始使用Nuxt*。现在，我们将看一下Nuxt功能，它允许您直接编写ES6
    JavaScript。
- en: Writing ES2015+
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写ES2015+
- en: 'Nuxt compiles your ES6+ code out of the box without you having to worry about
    configuring and installing Babel in webpack. This means you can write ES6+ code
    straight away and your code will be compiled into JavaScript that can be run on
    older browsers. For example, you will see the following destructuring assignment
    syntax often when using an `asyncData` method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt在不需要您担心配置和安装Babel在webpack的情况下，即可编译您的ES6+代码。这意味着您可以立即编写ES6+代码，并且您的代码将被编译为可以在旧版浏览器上运行的JavaScript。例如，当使用`asyncData`方法时，您经常会看到以下解构赋值语法：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The destructuring assignment syntax is used in the preceding code to unpack
    the properties from the Nuxt context into distinct variables that we can use for
    the logic inside the `asyncData` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用解构赋值语法将Nuxt上下文中的属性解包到不同的变量中，以便我们可以在`asyncData`方法中使用这些变量进行逻辑处理。
- en: For more information about the Nuxt context and ECMAScript 2015 features, please
    visit [https://nuxtjs.org/api/context](https://nuxtjs.org/api/context) and [https://babeljs.io/docs/en/learn/](https://babeljs.io/docs/en/learn/),
    respectively.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Nuxt上下文和ECMAScript 2015功能的更多信息，请分别访问[https://nuxtjs.org/api/context](https://nuxtjs.org/api/context)和[https://babeljs.io/docs/en/learn/](https://babeljs.io/docs/en/learn)。
- en: Writing ES6 in Nuxt is only made possible by `babel-loader` and webpack. There's
    more than just the destructuring assignment syntax that you can write in Nuxt,
    including the `async` function, the `await` operator, the `arrow` function, the
    `import` statement, and many more. What about the CSS preprocessor? If you write
    CSS styles with a popular CSS preprocessor such as Sass, Less, or Stylus, but if
    you are a Sass person and not a Less person, nor a Stylus person, can Nuxt support
    any of them? The short answer is yes. We'll find out the long answer to this question
    in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nuxt中编写ES6只能通过`babel-loader`和webpack实现。在Nuxt中，您可以编写更多内容，包括`async`函数、`await`运算符、`箭头`函数、`import`语句等。那么CSS预处理器呢？如果您使用Sass、Less或Stylus等流行的CSS预处理器编写CSS样式，但如果您是Sass用户而不是Less用户或Stylus用户，Nuxt是否支持它们中的任何一个？简短的答案是是。我们将在下一节中找出这个问题的长答案。
- en: Writing CSS with a preprocessor
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预处理器编写CSS
- en: 'In Nuxt, you can choose your favorite CSS preprocessor to write the styles
    for your app, whether it is Sass, Less, or Stylus. They are already pre-configured
    for you in Nuxt. You can check out their configurations at [https://github.com/nuxt/nuxt.js/blob/dev/packages/webpack/src/config/base.js](https://github.com/nuxt/nuxt.js/blob/dev/packages/webpack/src/config/base.js).
    So, you just need to install the preprocessor and its webpack loader in your Nuxt
    project. For example, if you want to use Less as your CSS preprocessor, just install
    the following dependencies in your Nuxt project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nuxt中，您可以选择喜欢的CSS预处理器来编写应用程序的样式，无论是Sass、Less还是Stylus。它们已经在Nuxt中为您预配置。您可以在[https://github.com/nuxt/nuxt.js/blob/dev/packages/webpack/src/config/base.js](https://github.com/nuxt/nuxt.js/blob/dev/packages/webpack/src/config/base.js)查看它们的配置。因此，您只需要在Nuxt项目中安装预处理器及其webpack加载程序。例如，如果您想将Less作为CSS预处理器，只需在Nuxt项目中安装以下依赖项：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, you can start writing your Less code by setting the `lang` attribute
    to "less" in the `<style>` block, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过在`<style>`块中将`lang`属性设置为"less"来开始编写您的Less代码，如下所示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From this example, you can see that writing modern CSS styles is as easy as
    writing modern JavaScript in Nuxt. All you are required to do is install your
    favorite CSS preprocessor and its webpack loader. We will use Less in this book
    in the upcoming chapters, but for now, let's find out what other features Nuxt
    offers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，您可以看到在Nuxt中编写现代CSS样式就像在Nuxt中编写现代JavaScript一样容易。您只需要安装您喜欢的CSS预处理器及其webpack加载程序。在本书的后续章节中，我们将使用Less，但现在让我们找出Nuxt提供了哪些其他功能。
- en: 'For more information about these preprocessors and their webpack loaders, please
    visit the following links:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些预处理器及其webpack加载程序的更多信息，请访问以下链接：
- en: '[http://lesscss.org/](http://lesscss.org) for Less'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://lesscss.org/](http://lesscss.org) 用于Less'
- en: '[https://webpack.js.org/loaders/less-loader/](https://webpack.js.org/loaders/less-loader/) for less-loader'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://webpack.js.org/loaders/less-loader/](https://webpack.js.org/loaders/less-loader/) 用于less-loader'
- en: '[https://sass-lang.com/](https://sass-lang.com/) for Sass'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://sass-lang.com/](https://sass-lang.com/) 用于Sass'
- en: '[https://webpack.js.org/loaders/sass-loader/](https://webpack.js.org/loaders/sass-loader/) for sass-loader'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://webpack.js.org/loaders/sass-loader/](https://webpack.js.org/loaders/sass-loader/) 用于sass-loader'
- en: '[http://stylus-lang.com/](https://stylus-lang.com/) for Stylus'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://stylus-lang.com/](https://stylus-lang.com/) 用于Stylus'
- en: '[https://github.com/shama/stylus-loader](https://github.com/shama/stylus-loader) for stylus-loader'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/shama/stylus-loader](https://github.com/shama/stylus-loader) 用于stylus-loader'
- en: Even though PostCSS is not a preprocessor, if you want to use it in a Nuxt project,
    please visit the guide provided at [https://nuxtjs.org/faq/postcss-plugins](https://nuxtjs.org/faq/postcss-plugins).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PostCSS不是预处理器，但如果您想在Nuxt项目中使用它，请访问提供的指南[https://nuxtjs.org/faq/postcss-plugins](https://nuxtjs.org/faq/postcss-plugins)。
- en: Extending Nuxt with modules and plugins
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模块和插件扩展Nuxt
- en: 'Nuxt was created on top of a modular architecture. This means you can extend it
    with endless modules and plugins for your app or Nuxt community. This also means you
    can choose tons of modules and plugins from the Nuxt and Vue communities so that
    you don''t have to reinvent them for your app. The links to these are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt是建立在模块化架构之上的。这意味着您可以使用无数的模块和插件来扩展它，适用于您的应用程序或Nuxt社区。这也意味着您可以从Nuxt和Vue社区中选择大量的模块和插件，这样您就不必为您的应用程序重新发明它们。这些链接如下：
- en: Awesome Nuxt.js at [https://github.com/nuxt-community/awesome-nuxt#official](https://github.com/nuxt-community/awesome-nuxt#official) for
    Nuxt modules
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt.js的精彩模块[https://github.com/nuxt-community/awesome-nuxt#official](https://github.com/nuxt-community/awesome-nuxt#official)
- en: Awesome Vue.js at [https://github.com/vuejs/awesome-vue#components--libraries](https://github.com/vuejs/awesome-vue#components--libraries)[ ](https://github.com/vuejs/awesome-vue#components--libraries)for
    Vue components, libraries, and plugins
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/vuejs/awesome-vue#components--libraries](https://github.com/vuejs/awesome-vue#components--libraries)上查看令人敬畏的Vue.js，用于Vue组件、库和插件
- en: Modules and plugins are simply JavaScript functions. Don't worry about the distinction
    between them for now; we will get to this in [Chapter 6](2102475f-1a6b-42c0-abaa-ec018f8fa25a.xhtml),
    *Writing Plugins and Modules*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和插件只是JavaScript函数。现在不用担心它们之间的区别；我们将在[第6章](2102475f-1a6b-42c0-abaa-ec018f8fa25a.xhtml)中讨论这个问题，*编写插件和模块*。
- en: Adding transitions between routes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在路由之间添加过渡
- en: 'Unlike traditional Vue apps, in Nuxt, you don''t have to use the wrapper `<transition>`
    element to handle JavaScript animations, CSS animations, and CSS transitions on
    your elements or components. For example, if you want to apply a `fade` transition
    to the specific page when navigating to it, you can just add the transition name (for
    example, `fade`) to the `transition` property of that page:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的Vue应用程序不同，在Nuxt中，您不必使用包装器`<transition>`元素来处理元素或组件上的JavaScript动画、CSS动画和CSS过渡。例如，如果您想在导航到特定页面时应用`fade`过渡，您只需将过渡名称（例如`fade`）添加到该页面的`transition`属性中：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you can just create the transition style in a `.css` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在`.css`文件中创建过渡样式：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The "fade" transition will apply to the `about` page automatically when navigating
    to the `/about` route. Cool, isn't it? Don't worry if the code or the class names
    look a bit overwhelming to you at this point; we will look at this transition
    feature and explore it in more detail in [Chapter 4](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml),
    *Adding Views, Routes, and Transitions*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当导航到`/about`路由时，“fade”过渡将自动应用于`about`页面。很酷，不是吗？如果此时代码或类名看起来有点令人不知所措，不要担心；我们将在[第4章](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml)中更详细地了解和探索这个过渡特性。
- en: Managing the <head> element
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理`<head>`元素
- en: 'Also, unlike traditional Vue apps, you can manage the `<head>` block of your
    app out of the box without installing the additional Vue package that handles
    it – `vue-meta`. You just add the data you need for `<title>`, `<meta>`, and `<link>`
    via the `head` property to any page. For example, you can manage the global `<head>`
    element via the Nuxt config file of your app:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与传统的Vue应用程序不同，您可以直接管理应用程序的`<head>`块，而无需安装额外处理它的Vue包`vue-meta`。您只需通过`head`属性向任何页面添加所需的`<title>`、`<meta>`和`<link>`数据。例如，您可以通过应用程序的Nuxt配置文件管理全局`<head>`元素：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Nuxt will convert this data into the HTML tags for you. Again, we will learn
    about this feature and explore it in more detail in [Chapter 4](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml),
    *Adding Views, Routes, and Transitions*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt将为您将此数据转换为HTML标记。同样，我们将在[第4章](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml)中更详细地了解和探索此功能，*添加视图、路由和过渡*。
- en: Bundling and splitting code with webpack
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用webpack捆绑和拆分代码
- en: 'Nuxt uses webpack to bundle, minify, and split your code into chunks that can
    speed up the load time of your app. For example, in a simple Nuxt app with two
    pages, index/home and about, you will get similar chunks for the client-side:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt使用webpack将您的代码捆绑、缩小并拆分为可以加快应用程序加载时间的块。例如，在一个简单的Nuxt应用程序中有两个页面，index/home和about，您将为客户端获得类似的块：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The chunks that you would get for the server-side will look as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您将为服务器端获取的块如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These chunks and the build information are generated when you use Nuxt `npm
    run build` command to build your app for deployment. We will look at this in more
    detail in [Chapter 14](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml), *Using Linters,
    Formatters, and Deployment Commands*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块和构建信息是在使用 Nuxt `npm run build` 命令构建应用以进行部署时生成的。我们将在[第14章](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml)中更详细地了解这一点，*使用
    Linters、Formatters 和部署命令*。
- en: 'This aside, there are other great features and plugins from webpack that are
    used by Nuxt, such as static files and asset serving (asset management), hot module
    replacement, CSS extraction (`extract-css-chunks-webpack-plugin`), a progress
    bar while you''re building and watching (webpackbar), and so on. For more information,
    please visit the following links:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Nuxt 还使用了 webpack 的其他出色功能和插件，比如静态文件和资源服务（资源管理），热模块替换，CSS 提取（`extract-css-chunks-webpack-plugin`），构建和监视时的进度条（webpackbar）等等。更多信息，请访问以下链接：
- en: '[https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/)
    for code splitting'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/)
    用于代码拆分'
- en: '[https://webpack.js.org/concepts/manifest/](https://webpack.js.org/concepts/manifest/)
    for the manifest'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://webpack.js.org/concepts/manifest/](https://webpack.js.org/concepts/manifest/)
    用于清单'
- en: '[https://webpack.js.org/guides/asset-management/](https://webpack.js.org/guides/asset-management/)
    for asset management'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://webpack.js.org/guides/asset-management/](https://webpack.js.org/guides/asset-management/)
    用于资源管理'
- en: '[https://webpack.js.org/concepts/hot-module-replacement/](https://webpack.js.org/concepts/hot-module-replacement/)
    for hot module replacement'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://webpack.js.org/concepts/hot-module-replacement/](https://webpack.js.org/concepts/hot-module-replacement/)
    用于热模块替换'
- en: '[https://webpack.js.org/plugins/mini-css-extract-plugin/](https://webpack.js.org/plugins/mini-css-extract-plugin/)
    for CSS extraction'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://webpack.js.org/plugins/mini-css-extract-plugin/](https://webpack.js.org/plugins/mini-css-extract-plugin/)
    用于 CSS 提取'
- en: '[https://github.com/nuxt/webpackbar](https://github.com/nuxt/webpackbar) for `webpackbar`
    (a plugin developed by Nuxt core team)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/nuxt/webpackbar](https://github.com/nuxt/webpackbar) 用于
    `webpackbar`（Nuxt 核心团队开发的插件）'
- en: These great features from webpack, Babel, and Nuxt itself will make your modern
    project development fun and easy. Now, let's take a look at the various application
    types to see why you should or shouldn't use Nuxt when you're building your next
    web app.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 webpack、Babel 和 Nuxt 本身的这些出色功能将使您的现代项目开发变得有趣且轻松。现在，让我们看看各种应用类型，看看在构建下一个 web
    应用时，为什么应该或不应该使用 Nuxt。
- en: Types of applications
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用类型
- en: 'The web applications of today are very different from the ones from decades
    ago. We had fewer options and solutions in those days. Today, they are blooming.
    Whether we call them "applications" or "apps", they are the same. We will call
    them "apps" in this book. So, we can categorize our current web apps as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的 web 应用与几十年前的应用非常不同。在那些日子里，我们的选择和解决方案更少。今天，它们正在蓬勃发展。无论我们称它们为“应用”还是“应用程序”，它们都是一样的。在本书中，我们将称它们为“应用”。因此，我们可以将我们当前的
    web 应用分类如下：
- en: Traditional server-side rendered app
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的服务器端渲染应用
- en: Traditional SPA
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的单页应用
- en: Universal SSR app
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用 SSR 应用
- en: Static-generated app
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态生成的应用
- en: Let's go through each of them and understand the pros and cons. We will first
    look at the oldest type of app – the traditional server-side rendered app.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个了解它们，并了解其利弊。我们首先来看最古老的应用类型 - 传统的服务器端渲染应用。
- en: Traditional server-side rendered app
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统的服务器端渲染应用
- en: Server-side rendering is the most common approach for delivering the data and
    HTML to the client side on the browser on your screen. It was the only way to
    do things when the web industry just started. In traditional server-rendered apps
    or dynamic websites, every request requires a new page re-rendered from the server
    to the browser. This means you will reload all the scripts, styles, and template(s)
    once more with every request you send to the server. The idea of reloading and
    re-rendering does not sound compelling and elegant at all. Even though some of
    the reloading and re-rendering burdens can be lifted by using AJAX these days,
    this adds more complexity to the app.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端呈现是向浏览器客户端传递数据和HTML的最常见方法。在网络行业刚刚开始时，这是唯一的做事方式。在传统的服务器呈现的应用程序或动态网站中，每个请求都需要从服务器重新呈现新页面到浏览器。这意味着您将在每次发送请求到服务器时重新加载所有脚本、样式和模板。重新加载和重新呈现的想法一点也不吸引人。尽管如今可以通过使用AJAX来减轻一些重新加载和重新呈现的负担，但这会给应用程序增加更多复杂性。
- en: Let's go through the advantages and disadvantages of these types of apps.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些类型应用程序的优缺点。
- en: '**Advantages**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**优势**：'
- en: '**Better SEO performance:** Because the client (browser) gets the finished
    page with all the data and HTML tags, especially the meta tags that belong to
    the page, search engines can crawl the page and index it.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的SEO性能：**因为客户端（浏览器）得到了包含所有数据和HTML标记的完成页面，特别是属于页面的元标记，搜索引擎可以爬取页面并对其进行索引。'
- en: '**Faster initial load time:** Because the pages and content are rendered on
    the server side by a server-side scripting language such as PHP before sending
    it to the client browser, we get the rendered page fast on the client side. Also,
    there is no need to compile the web pages and content in JavaScript files like
    we do in traditional SPAs, so the app is loaded quicker on the browser.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的初始加载时间：**因为页面和内容是由服务器端脚本语言（如PHP）在发送到客户端浏览器之前在服务器端呈现的，所以我们在客户端很快就能得到呈现的页面。此外，无需像传统的单页应用程序那样在JavaScript文件中编译网页和内容，因此应用程序在浏览器上加载更快。'
- en: '**Disadvantages**:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: '**Poorer user experience:** Because every page has to be re-rendered and this
    process takes time on the server, the user has to wait until everything is reloaded
    on the browser and that may affect the user experience. Most of the time, we want
    the new data only when provided with the new request; we don''t need the HTML
    base to be regenerated, for example, the navigation bar and the footer, but still,
    we get these base elements re-rendered, regardless. We can make use of AJAX to
    render just a particular component, but this makes development more difficult
    and complex.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户体验较差：**因为每个页面都必须重新呈现，这个过程在服务器上需要时间，用户必须等待直到在浏览器上重新加载所有内容，这可能会影响用户体验。大多数情况下，我们只希望在提供新请求时获得新数据；我们不需要重新生成HTML基础，例如导航栏和页脚，但仍然会重新呈现这些基本元素。我们可以利用AJAX来仅呈现特定组件，但这会使开发变得更加困难和复杂。'
- en: '**Tight coupling of the backend and frontend logic:** The view and data are
    usually handled together within the same app. For example, in a typical PHP framework
    app such as Laravel, you may render the view ([https://laravel.com/docs/7.x/views](https://laravel.com/docs/7.x/views))
    with a template engine such as Laravel Pug ([https://github.com/BKWLD/laravel-pug](https://github.com/BKWLD/laravel-pug))
    in a route. Or, if you are using Express for a traditional server-side rendered
    app, you may use a template engine such as Pug ([https://pugjs.org/api/getting-started.html](https://pugjs.org/api/getting-started.html))
    or vuexpress ([https://github.com/vuexpress/vuexpress](https://github.com/vuexpress/vuexpress))
    for rending the view ([https://expressjs.com/en/guide/using-template-engines.html](https://expressjs.com/en/guide/using-template-engines.html)).
    In these two frameworks for a typical, traditional server-side rendered app, the
    view is coupled with the backend logic, even though we can extract the view layer
    with a template engine. The backend developer has to know what view (for example,
    `home.pug`) to use for each specific route or controller. On the other hand, the
    frontend developer has to work on the view within the same framework as the backend
    developer. This adds more complexity to the project.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端和前端逻辑的紧密耦合：视图和数据通常在同一个应用程序中处理。例如，在典型的PHP框架应用程序中，如Laravel，您可以在路由中使用模板引擎（如Laravel
    Pug）渲染视图。或者，如果您正在为传统的服务器端渲染应用程序使用Express，您可以使用模板引擎（如Pug或vuexpress）来渲染视图。在这两个框架中，视图与后端逻辑耦合在一起，即使我们可以使用模板引擎提取视图层。后端开发人员必须知道每个特定路由或控制器要使用的视图（例如`home.pug`）。另一方面，前端开发人员必须在与后端开发人员相同的框架中处理视图。这给项目增加了更多复杂性。
- en: Traditional single-page app (SPA)
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统的单页面应用程序（SPA）
- en: 'As opposed to server-side rendered apps, SPAs are client-side rendered (CSR)
    apps that render content in the browser using JavaScript without requiring new
    pages to be reloaded during use. So, instead of getting the content rendered to
    the HTML document, you get barebones HTML from the server, and the content will
    be loaded using JavaScript in the browser, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器端渲染应用程序相反，SPA是客户端渲染（CSR）应用程序，它使用JavaScript在浏览器中渲染内容，而不需要在使用过程中重新加载新页面。因此，您不会将内容呈现到HTML文档中，而是从服务器获取基本的HTML，然后在浏览器中使用JavaScript加载内容。
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a very simple Vue app in which you have a container, `<div>`, with
    `app` as its ID only and nothing else inside it, followed by two `<script>` elements.
    The first `<script>` element will load the Vue.js library, while the second one
    will load the Vue instance that renders the content of your app, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的Vue应用程序，其中您有一个容器`<div>`，只有`app`作为其ID，里面没有其他内容，然后是两个`<script>`元素。第一个`<script>`元素将加载Vue.js库，而第二个将加载渲染应用程序内容的Vue实例。
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's go through the advantages and disadvantages of this type of app.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这种类型应用程序的优缺点。
- en: '**Advantages:**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**Better user experience:** SPA is fast when rendering content after the initial
    load. Most resources, such as CSS styles, JavaScript code, and HTML templates,
    are only loaded once throughout the lifespan of the app. Only data is sent back
    and forth afterward; the base HTML and layout stay unchanged, thus offering a
    smooth and better user experience.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的用户体验：SPA在初始加载后渲染内容时非常快速。大多数资源，如CSS样式、JavaScript代码和HTML模板，在应用程序的整个生命周期中只加载一次。之后只是来回发送数据；基本的HTML和布局保持不变，从而提供了流畅和更好的用户体验。
- en: '**Easier development and deployment:** SPA development is comparatively easier
    to get started without the need for a server and a server-side scripting language.
    You can simply kick off the development from your local machine with `file://URI`.
    It is easier to deploy as well because it consists of HTML, JavaScript, and CSS
    files; you can just drop them to the remote server and go live right away.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发和部署更容易：** 单页应用程序的开发相对容易，无需服务器和服务器端脚本语言。您可以从本地机器上简单地启动开发，使用`file://URI`。部署也更容易，因为它由HTML、JavaScript和CSS文件组成；您只需将它们放到远程服务器上，立即上线。'
- en: '**Disadvantages:**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点：**'
- en: '**Poor performance on the search engine:** SPAs are bare-bone single HTML pages,
    mostly with no headings and paragraph tags for search engine crawlers to crawl.
    The SPA content is loaded via JavaScript that the crawlers mostly cannot execute,
    so SPAs usually perform poorly in SEO.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索引擎性能差：** 单页应用程序通常是裸骨的单个HTML页面，大多数情况下没有标题和段落标签供搜索引擎爬虫爬取。SPA内容是通过JavaScript加载的，而爬虫通常无法执行JavaScript，因此SPA在搜索引擎优化方面通常表现不佳。'
- en: '**Slow initial load time:** Most resources such as CSS styles, JavaScript code,
    and HTML templates are only loaded once throughout the lifespan of the app, so
    we need to load tons of these resource files all at once at the beginning. By
    doing this, the app usually slows down regarding its initial loading time, especially
    in a large SPA.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始加载时间慢：** 大多数资源，如CSS样式、JavaScript代码和HTML模板，在应用程序的整个生命周期中只加载一次，因此我们需要在开始时一次性加载大量这些资源文件。通过这样做，应用程序通常在初始加载时间方面变慢，特别是在大型单页应用程序中。'
- en: Universal server-side rendered app (SSR)
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用服务器端渲染应用（SSR）
- en: 'As we learned in the previous section, there are advantages and disadvantages
    to both traditional server-side rendered apps and SPAs. There are benefits in
    writing SPAs, but there are things that you lose: the ability for web crawlers
    to traverse your app and slower performance while the app is initially loaded.
    This is the opposite of writing traditional server-side rendered apps, also there
    are things you do not have, such as better user experience and the fun of client-side
    development in SPAs. Ideally, client-side and server-side rendering can be balanced
    for user experience and performance. Here is where universal server-side rendering
    (SSR) comes to bridge the gap.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中所学到的，传统的服务器端渲染应用程序和单页应用程序都有优点和缺点。编写单页应用程序有好处，但也有一些你会失去的东西：网络爬虫遍历您的应用程序的能力以及应用程序初始加载时的性能较慢。这与编写传统的服务器端渲染应用程序相反，还有一些你没有的东西，比如更好的用户体验和单页应用程序中客户端开发的乐趣。理想情况下，客户端和服务器端渲染可以平衡用户体验和性能。这就是通用服务器端渲染（SSR）的用武之地。
- en: JavaScript has become an isomorphic language since the release of Node.js in
    2009\. By isomorphic, we mean that codes can run both on the client side and the
    server side. Isomorphic (universal) JavaScript can be defined as a hybrid of client-side
    and server-side applications. It is a new approach for web apps to compensate
    for the shortcomings of both traditional SSR apps and traditional SPAs. This is
    the category that Nuxt falls into.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2009年Node.js发布以来，JavaScript已经成为一种等同的语言。通过等同，我们指的是代码可以在客户端和服务器端都运行。等同（通用）JavaScript可以被定义为客户端和服务器端应用程序的混合体。这是网页应用程序的一种新方法，以弥补传统SSR应用程序和传统SPA的缺点。这就是Nuxt所属的类别。
- en: In universal SSR, your app will first pre-load on the server side, pre-render
    the pages, and send the rendered HTML to the browser before switching to the client-side
    operation for the rest of its lifespan. Building universal SSR apps from scratch
    can be tedious as it requires lots of configuration before the actual development
    process begins. This is what Nuxt aims to achieve by presetting all the configuration
    needed for you to create SSR Vue apps easily.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用SSR中，您的应用程序将首先在服务器端预加载，预渲染页面，并在切换到客户端操作其余寿命之前将呈现的HTML发送到浏览器。从头开始构建通用SSR应用程序可能会很繁琐，因为在实际开发过程开始之前需要大量的配置。这就是Nuxt的目标，它通过为您预设创建SSR
    Vue应用程序所需的所有配置来轻松实现。
- en: Even though universal SSR apps are a great solution in our modern web development,
    there are still advantages and disadvantages to these types of apps. Let's go
    through them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通用SSR应用程序在我们现代的Web开发中是一个很好的解决方案，但这些类型的应用程序仍然有优点和缺点。让我们来看看它们。
- en: '**Advantages**:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: '**Faster initial load time: **In universal SSR, JavaScript and CSS are split
    into chunks, assets are optimized, and pages are rendered on the server-side before
    being served to the client browser. All of these options help make the initial
    loading time faster.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的初始加载时间：**在通用SSR中，JavaScript和CSS被分割成块，资源被优化，并且页面在服务器端呈现后再提供给客户端浏览器。所有这些选项都有助于加快初始加载时间。'
- en: '**Better SEO support:** Since all pages are rendered on the server side with
    the appropriate meta content, headings, and paragraphs before being served on
    the client side, the search engine crawlers can traverse the page to increase
    the SEO performance of your app.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的SEO支持：**由于所有页面在服务器端呈现时都带有适当的元内容、标题和段落，然后再提供给客户端，搜索引擎爬虫可以遍历页面，以提高应用程序的SEO性能。'
- en: '**Better user experience:** Universal SSR apps work like traditional SPAs after
    the initial load in that the transition between pages and routes is seamless.
    Only data is transmitted back and forth without re-rendering the HTML content
    holders. All these features have helped to provide a better user experience overall.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的用户体验：**通用SSR应用程序在初始加载后的工作方式类似于传统的SPA，因为页面和路由之间的转换是无缝的。只有数据来回传输，而不重新渲染HTML内容持有者。所有这些功能都有助于提供更好的用户体验。'
- en: '**Disadvantages**:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: '**Node.js server required: **Running JavaScript on the server side requires
    a Node.js server, so the server must be set up before you can use Nuxt and write
    your app.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要Node.js服务器：**在服务器端运行JavaScript需要一个Node.js服务器，因此在使用Nuxt和编写应用程序之前必须设置服务器。'
- en: '**Complex development:** Running JavaScript code in universal SSR apps can
    be confusing because some JavaScript plugins and libraries are meant to run on
    the client side only, such as Bootstrap and Zurb Foundation for styling and DOM
    manipulation.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的开发：**在通用SSR应用程序中运行JavaScript代码可能会令人困惑，因为一些JavaScript插件和库只能在客户端运行，比如用于样式和DOM操作的Bootstrap和Zurb
    Foundation。'
- en: Static-generated app
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态生成的应用程序
- en: 'Static-generated apps are pre-generated with the help of a static site generator
    and stored as static HTML pages on the hosting server. Nuxt comes with a `nuxt
    generate` command that generates **static pages** out of the box for you from
    the universal SSR or SPA app that you''ve developed in Nuxt. It pre-renders HTML
    pages for each of your routes into a generated `/dist/` folder during the build
    step, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 静态生成的应用程序是通过静态站点生成器预先生成的，并存储为静态HTML页面在托管服务器上。Nuxt带有一个`nuxt generate`命令，可以为您从您在Nuxt中开发的通用SSR或SPA应用程序生成**静态页面**。它在构建过程中为每个路由预渲染HTML页面到生成的`/dist/`文件夹中，如下所示：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can deploy these static files to a static hosting server without the need
    for Node.js or any server-side support. So, when the app is initially loaded on
    the browser – no matter what route you are requesting – you will always get the
    full content (if it's been exported from the universal SSR app) immediately, and
    the app will perform like a traditional SPA afterward.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些静态文件部署到静态托管服务器，而无需Node.js或任何服务器端支持。因此，当应用程序最初在浏览器上加载时 - 无论您请求的是哪个路由 -
    您都将立即获得完整的内容（如果它是从通用SSR应用程序中导出的），之后应用程序将像传统的单页面应用程序一样运行。
- en: Let's go through the advantages and disadvantages of these types of apps.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些类型应用程序的优势和劣势。
- en: '**Advantages**:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**优势：**'
- en: '**Fast initial load time:** Since each route is pre-generated as a static HTML
    page that has its own content, it is fast to load on the browser.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速的初始加载时间：** 由于每个路由都被预先生成为具有自己内容的静态HTML页面，因此在浏览器上加载速度很快。'
- en: '**Good for SEO:** Static-generated web apps allow your JavaScript app to be
    crawled perfectly by search engines, just like traditional server-side rendered
    apps.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有利于SEO：** 静态生成的Web应用程序允许您的JavaScript应用程序被搜索引擎完美地抓取，就像传统的服务器端渲染应用程序一样。'
- en: '**Easier deployment:** Because static-generated web apps are just static files,
    this makes them easy to deploy to static hosting servers such as GitHub Pages.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署更容易：** 因为静态生成的Web应用程序只是静态文件，这使它们易于部署到静态托管服务器，如GitHub Pages。'
- en: '**Disadvantages**:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**劣势：**'
- en: '**No server-side support:** Because static-generated web apps are just static
    HTML pages and run on the client side only, this means there''s no runtime support
    for Nuxt''s `nuxtServerInit` action method and Node.js HTTP request and response objects,
    which are only available on the server side. All data will be pre-rendered during
    the build step.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有服务器端支持：** 因为静态生成的Web应用程序只是静态HTML页面，并且仅在客户端上运行，这意味着没有运行时支持Nuxt的`nuxtServerInit`动作方法和Node.js
    HTTP请求和响应对象，这些仅在服务器端可用。所有数据将在构建步骤中预先呈现。'
- en: '**No real-time rendering: **Static-generated web apps are suitable for apps
    that only serve **static pages** that are pre-rendered at **build time**. If you
    are developing a complex app that requires real-time rendering from the server,
    then you should probably use universal SSR instead to utilize the full power of
    Nuxt.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有实时渲染：** 静态生成的Web应用程序适用于只提供**静态页面**的应用程序，这些页面在**构建时**预先呈现。如果您正在开发一个需要从服务器实时渲染的复杂应用程序，那么您应该使用通用SSR来充分利用Nuxt的全部功能。'
- en: From these categories, you have probably figured out that Nuxt falls in line
    with universal SSR apps and static-generated apps. Apart from this, it also falls
    in line with single-page apps, but not the same as traditional SPAs, which you
    will find out more about in [Chapter 15](450e252f-a94b-4f7f-9762-533a150f5d19.xhtml), *Creating
    an SPA with Nuxt*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些类别中，你可能已经发现Nuxt符合通用SSR应用程序和静态生成的应用程序。除此之外，它也符合单页面应用程序，但与传统的单页面应用程序不同，你将在第15章“使用Nuxt创建单页面应用程序”中了解更多信息。
- en: Now, let's take a better look at Nuxt regarding the types of applications that
    you will be creating in this book. We'll start with Nuxt as a universal SSR app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更好地了解Nuxt在本书中将要创建的应用程序类型。我们将从Nuxt作为通用SSR应用程序开始。
- en: Nuxt as a universal SSR app
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nuxt作为通用SSR应用程序
- en: Many years ago, we had server-side scripting languages such as ASP, Java, server-side
    JavaScript, PHP, and Python to create traditional server-side apps with template
    engines to render the view of our apps. This resulted in the tight coupling disadvantage
    that we went through in the previous section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 许多年前，我们有服务器端脚本语言，如ASP、Java、服务器端JavaScript、PHP和Python来创建具有模板引擎的传统服务器端应用程序来渲染我们应用程序的视图。这导致了我们在前一节中经历的紧耦合的缺点。
- en: 'So, with the rise of universal SSR frameworks such as Nuxt, Next ([https://nextjs.org/](https://nextjs.org/)),
    and Angular Universal ([https://angular.io/guide/universal](https://angular.io/guide/universal)),
    we can utilize their full power to decouple the view from the server-side scripting
    app for good by replacing the template engine, such as Pug ([https://pugjs.org/](https://pugjs.org/)),
    Handlebars ([https://handlebarsjs.com/](https://handlebarsjs.com/)), Twig ([https://twig.symfony.com/](https://twig.symfony.com/)),
    and many more that we have been deeply replying on. If we consider Nuxt a **frontend
    server-side** app and Express (or others) a **backend server-side** app, we can
    see how they complement each other perfectly. For example, we can use Express
    to create a backend server-side app for serving data in JSON format on an API
    route (for example, `/`) at `localhost:4000`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着Nuxt、Next（[https://nextjs.org/](https://nextjs.org/)）和Angular Universal（[https://angular.io/guide/universal](https://angular.io/guide/universal)）等通用SSR框架的兴起，我们可以充分利用它们的力量，通过替换模板引擎（如Pug（[https://pugjs.org/](https://pugjs.org/)）、Handlebars（[https://handlebarsjs.com/](https://handlebarsjs.com/)）、Twig（[https://twig.symfony.com/](https://twig.symfony.com/)）等）来彻底解耦视图和服务器端脚本应用。如果我们将Nuxt视为**前端服务器端**应用程序，Express（或其他）视为**后端服务器端**应用程序，我们可以看到它们如何完美地互补。例如，我们可以使用Express在API路由（例如`/`）上创建一个**后端服务器端**应用程序，以JSON格式提供数据，位于`localhost:4000`上。
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, on the frontend server side, we can use Nuxt as a universal SSR app running
    on `localhost:3000` to consume the aforementioned data by sending an HTTP request
    from a page in our Nuxt app, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在前端服务器端，我们可以使用Nuxt作为一个通用的SSR应用程序，在`localhost:3000`上运行，通过从Nuxt应用程序中的页面发送HTTP请求来消耗上述数据，如下所示：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we have Nuxt as both a server and a client that handles our app's view
    and templates, while Express just handles our server-side logic. We no longer
    need a template engine to present our content. So, for once, perhaps we don't
    need to learn so many template engines and we don't need to worry about the battle
    between them because we now have the universal one – Nuxt.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将Nuxt作为服务器和客户端来处理我们应用的视图和模板，而Express只处理我们的服务器端逻辑。我们不再需要模板引擎来呈现我们的内容。因此，也许我们不需要学习那么多模板引擎，也不需要担心它们之间的竞争，因为现在我们有了通用的Nuxt。
- en: We will show you how to create cross-domain apps with Nuxt and Koa (another
    Node.js server-side framework similar to Express) in [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml),
    *Creating User Logins and API Authentication*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示如何使用Nuxt和Koa（另一个类似于Express的Node.js服务器端框架）创建跨域应用程序，详见[第12章](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml)，*创建用户登录和API身份验证*。
- en: Note that in the preceding code, we used the Nuxt HTTP module to make the HTTP
    request. However, we will mostly use vanilla Axios or theNuxt Axios modulethroughout
    this book for HTTP requests. For more information about the Nuxt HTTP module,
    please visit [https://http.nuxtjs.org/](https://http.nuxtjs.org/).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码中，我们使用了Nuxt HTTP模块来发出HTTP请求。然而，在本书中，我们将主要使用原始的Axios或Nuxt Axios模块来进行HTTP请求。有关Nuxt
    HTTP模块的更多信息，请访问[https://http.nuxtjs.org/](https://http.nuxtjs.org/)。
- en: You also can use the Nuxt Content module to act as headless CMS so that you
    can serve your app content from Markdown, JSON, YAML, XML, and CSV files that
    can be stored "locally" in your Nuxt project. However, in this book, we will be
    using and creating external APIs to serve our content in order to avoid the tightly
    coupled issue that we found in the traditional server-side apps in the first place.
    For more information about the Nuxt Content module, please visit [https://content.nuxtjs.org/](https://content.nuxtjs.org/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Nuxt Content模块作为无头CMS，以便从Markdown、JSON、YAML、XML和CSV文件中提供应用程序内容，这些文件可以“本地”存储在您的Nuxt项目中。但是，在本书中，我们将使用和创建外部API来提供我们的内容，以避免我们在传统服务器端应用程序中发现的紧密耦合问题。有关Nuxt
    Content模块的更多信息，请访问[https://content.nuxtjs.org/](https://content.nuxtjs.org/)。
- en: Nuxt as a static site generator
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nuxt作为静态站点生成器
- en: Even though server-side rendering is the main feature of Nuxt, it is also a
    static site generator that pre-renders your Nuxt app in a static site, as shown
    in the example provided for the static-generated app category. It is perhaps the
    best of both worlds between a traditional single-page application and a server-side-rendered
    app. While benefiting from the static HTML content for a better SEO, you no longer
    need the runtime support from Node.js and Nuxt. However, your app will still behave
    like an SPA.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管服务器端渲染是Nuxt的主要特性，但它也是一个静态站点生成器，可以在静态站点中预渲染您的Nuxt应用程序，就像静态生成的应用程序类别中提供的示例一样。它可能是传统单页面应用程序和服务器端渲染应用程序之间最好的结合。通过静态HTML内容获益，以获得更好的SEO，您不再需要来自Node.js和Nuxt的运行时支持。但是，您的应用程序仍将像SPA一样运行。
- en: What's more is that during static generation, Nuxt has a crawler that crawls
    the links in your app to generate dynamic routes and save their data from the
    remote API as `payload.js` files in a `/static/` folder inside the `/dist/` folder.
    These payloads are then used to serve the data that was originally requested from
    the API. This means you are not calling the API anymore. This can secure your
    API from the public, and possibly from attackers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，在静态生成期间，Nuxt具有一个爬虫，用于爬取应用程序中的链接以生成动态路由，并将它们的数据从远程API保存为`payload.js`文件，存储在`/dist/`文件夹内的`/static/`文件夹中。然后使用这些负载来提供最初从API请求的数据。这意味着您不再调用API。这可以保护您的API免受公众和可能的攻击者的侵害。
- en: You'll learn how to generate static sites from Nuxt with a remote API in [Chapter
    14](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml), *Using Linters, Formatters, and
    Deployment Commands*, and in the final chapter of this book, [Chapter 18](a2720301-9e1c-4c28-8af8-39bd5c093fb9.xhtml), *Creating
    a Nuxt App with CMS and GraphQL*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何在[第14章](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml)中使用远程API从Nuxt生成静态站点，以及在本书的最后一章[第18章](a2720301-9e1c-4c28-8af8-39bd5c093fb9.xhtml)中创建具有CMS和GraphQL的Nuxt应用程序。
- en: Nuxt as a single-page app
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nuxt作为单页面应用程序
- en: Nuxt is well-suited for developing single-page apps if you have any reason that
    prevents you from using Nuxt as a server-side rendering app. As we mentioned at
    the beginning of this chapter, Nuxt comes with two modes for developing your app: 
    `universal` and `spa`.  This means you just have to specify `spa` in the `mode`
    property in your project configuration, which we'll explore in more detail in
    the next chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有任何原因不希望将Nuxt用作服务器端渲染应用程序，那么Nuxt非常适合开发单页面应用程序。正如我们在本章开头提到的，Nuxt有两种开发应用程序的模式：`universal`和`spa`。这意味着您只需在项目配置的`mode`属性中指定`spa`，我们将在下一章中更详细地探讨这一点。
- en: 'So, you might be thinking that if we can use Nuxt for developing a SPA, then
    why bother with Vue anymore? In fact, the SPA you can develop from Nuxt is slightly
    different from the SPA from Vue. The SPA you build from Vue is a traditional SPA,
    while the SPA from Nuxt is a "static" SPA (let''s refer to it as Nuxt SPA) – your
    app pages are pre-rendered at build time. This means deploying a Nuxt SPA is technically
    the same as statically generating a Nuxt universal SSR app – both require the
    same Nuxt command: `nuxt generate`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能会想，如果我们可以使用Nuxt开发SPA，那为什么还要费心使用Vue呢？事实上，你从Nuxt开发的SPA与从Vue开发的SPA略有不同。你从Vue构建的SPA是传统的SPA，而从Nuxt构建的SPA是“静态”SPA（让我们称之为Nuxt
    SPA）——你的应用页面在构建时进行了预渲染。这意味着部署Nuxt SPA在技术上与静态生成Nuxt通用SSR应用是相同的——两者都需要相同的Nuxt命令：`nuxt
    generate`。
- en: This can be confusing and you may want to ask what is the difference between
    the static-generated SSR app and the static-generated SPA? The difference is very
    obvious – the static-generated SPA has no page content compared to the static-generated
    SSR app. The static-generated SPA is pre-rendered with your app pages and "empty"
    HTML, just like the traditional SPA – devoid of page content. This is confusing,
    but rest assured, we will figure all this out in the upcoming chapters of this
    book. In particular, you learn about the trade-offs of developing SPAs in Nuxt
    and how to overcome them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让人感到困惑，你可能想问静态生成的SSR应用和静态生成的SPA之间有什么区别？区别非常明显——与静态生成的SSR应用相比，静态生成的SPA没有页面内容。静态生成的SPA是使用你的应用页面和“空”HTML预渲染的，就像传统的SPA一样——没有页面内容。这很令人困惑，但请放心，我们将在本书的后续章节中弄清楚这一切。特别是，你将了解在Nuxt中开发SPA的权衡以及如何克服它们。
- en: You'll learn how to develop a Nuxt SPA and generate a static Nuxt SPA with a
    remote API in [Chapter 15](450e252f-a94b-4f7f-9762-533a150f5d19.xhtml), *Creating
    an SPA with Nuxt*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何开发Nuxt SPA，并在[第15章](450e252f-a94b-4f7f-9762-533a150f5d19.xhtml)中使用远程API生成静态Nuxt
    SPA，*使用Nuxt创建SPA*。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Well done! You have made it through the first chapter of your journey into Nuxt.
    In this chapter, you learned what makes up the Nuxt framework; that is, Vue (the
    origin of Nuxt), webpack, and Babel. You learned about the various features Nuxt
    provides, such as the ability for you to write Vue single-file components (`.vue` files),
    ES2015+ JavaScript (ES6), CSS with a preprocessor (Sass, Less, Stylus). You are
    also able to extend your app with modules and plugins, to add transitions between
    the routes of your app, to manage the `<head>` element and the meta content of
    each route or page in your app.  Apart from this you also covered tons of great
    features that are imported from webpack and Babel, such as bundling, minifying,
    and splitting code. You also learned that you can access tons of plugins and modules
    from the Nuxt community for your Nuxt projects.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你已经完成了进入Nuxt的旅程的第一章。在本章中，你了解了Nuxt框架的组成部分；即Vue（Nuxt的起源）、webpack和Babel。你了解了Nuxt提供的各种功能，比如你可以编写Vue单文件组件（`.vue`文件）、ES2015+
    JavaScript（ES6）、使用预处理器的CSS（Sass、Less、Stylus）。你还可以通过模块和插件扩展你的应用，为应用的路由添加过渡效果，管理`<head>`元素和应用中每个路由或页面的元内容。除此之外，你还涵盖了从webpack和Babel导入的大量出色功能，比如打包、压缩和代码分割。你还了解到，你可以从Nuxt社区获取大量插件和模块用于你的Nuxt项目。
- en: 'Apart from these great features, you learned about the pros and cons of each
    type of available application: traditional server-side rendered apps, traditional
    single-page apps (SPAs), universal server-side rendered apps (SSRs), and static-generated
    apps. You also learned that Nuxt apps actually fall in line with the categories
    of universal SSR apps and static-generated apps. And then, you learned that Nuxt
    also falls in line with single-page apps, but not the same as traditional SPAs.
    Lastly, you looked into using Nuxt for universal SSR apps, static-generated apps,
    and single-page apps, all of which you''ll learn more about throughout this book.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些强大的功能之外，您还了解了每种可用应用类型的优缺点：传统的服务器端渲染应用程序、传统的单页面应用（SPA）、通用服务器端渲染应用程序（SSR）和静态生成应用程序。您还了解到Nuxt应用实际上符合通用SSR应用程序和静态生成应用程序的类别。然后，您了解到Nuxt也符合单页面应用的类别，但与传统的SPA不同。最后，您还了解了如何在本书中更多地了解如何使用Nuxt来进行通用SSR应用程序、静态生成应用程序和单页面应用。
- en: In the next chapter, you will learn how to install Nuxt and create a simple
    Nuxt app and understand the default directory structure that comes with the Nuxt
    scaffolding tool. You will also learn how to customize your Nuxt app and understand
    the assets that are served in Nuxt. So, stay tuned!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何安装Nuxt并创建一个简单的Nuxt应用程序，并了解Nuxt脚手架工具提供的默认目录结构。您还将学习如何自定义您的Nuxt应用程序，并了解Nuxt中提供的资源。所以，请继续关注！
