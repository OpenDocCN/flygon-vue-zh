["```js\n  \"devDependencies\": { \n    <...> \n    \"**chai**\": \"^3.5.0\", \n    <...> \n    \"**karma**\": \"^0.13.15\", \n    \"karma-chrome-launcher\": \"^2.0.0\", \n    \"karma-coverage\": \"^0.5.5\", \n    \"karma-mocha\": \"^0.2.2\", \n    \"karma-phantomjs-launcher\": \"^1.0.0\", \n    \"**karma-sinon-chai**\": \"^1.2.0\", \n    \"**mocha**\": \"^2.4.5\", \n    <...> \n  } \n\n```", "```js\nfunction sum(a, b) { \n  return a + b \n} \n\n```", "```js\nit('should follow commutative law', () => { \n  let a = 2; \n  let b = 3; \n\n  expect(sum(a, b)).to.equal(5); \n  expect(sum(b, a)).to.equal(5); \n}) \n\n```", "```js\n**import** MyComponent from <path to my component> \nvar vm = **new Vue**(MyComponent).**$mount()** \n\n```", "```js\nimport store from <path to store> \nimport **MyComponent** from <path to my component> \n// load the component with a vue instance \nvar vm = new Vue({ \n  template: '<div><test :items=\"items\" :id=\"id\" ref=testcomponent></test></div>', \n  components: { \n    'test': **MyComponent** \n  }, \n  data() { \n    return { \n      items: [], \n      id: 'myId' \n    } \n  }, \n  store \n}).$mount(); \n\nvar myComponent = **vm.$refs.testcomponent**; \n\n```", "```js\n**// myBeautifulThing.js** \nexport myBeautifulMethod1() { \n  return 'hello beauty' \n} \n\nexport myBeautifulMethod2() { \n  return 'hello again' \n} \n\n**// myBeautifulThing.spec.js** \nimport myBeautifulThing from <path to myBeautifulThing> \n\ndescribe('myBeautifulThing', () => { \n  //define needed variables \n\n  describe('myBeautifulMethod1', () => { \n    it('should return hello beauty', () { \n      expect(myBeautifulThing.myBeautifulMethod1()).to.equal('hello  \n        beauty') \n    }) \n  }) \n}) \n\n```", "```js\n//actions.js  \ncreateShoppingList: (store, shoppinglist) => { \n  api.addNewShoppingList(shoppinglist).then(() => { \n    store.dispatch('populateShoppingLists') \n  }, () => { \n    **store.commit(ADD_SHOPPING_LIST, shoppinglist)** \n  }) \n}, \ndeleteShoppingList: (store, id) => { \n  api.deleteShoppingList(id).then(() => { \n    store.dispatch('populateShoppingLists') \n  }, () => { \n    **store.commit(DELETE_SHOPPING_LIST, id)** \n  }) \n} \n\n```", "```js\n// mutations.spec.js \nimport mutations from 'src/vuex/mutations' \nimport { ADD_SHOPPING_LIST, DELETE_SHOPPING_LIST, POPULATE_SHOPPING_LISTS, CHANGE_TITLE } from 'src/vuex/mutation_types' \n\ndescribe('mutations.js', () => { \n  var state \n\n  beforeEach(() => { \n    state = { \n      shoppinglists: [] \n    } \n  }) \n}) \n\n```", "```js\n[types.ADD_SHOPPING_LIST] (state, newList) { \n  state.shoppinglists.push(newList) \n}, \n\n```", "```js\ndescribe(**'ADD_SHOPPING_LIST'**, () => { \n}) \n\n```", "```js\n  it('should add item to the shopping list array and increase its \n    length', () => { \n  //call the add_shopping_list mutations \n  **mutations[ADD_SHOPPING_LIST](state, {id: '1'})** \n  //check that the array now equals array with new object \n  **expect(state.shoppinglists).to.eql([{id: '1'}])** \n  //check that array's length had increased \n  **expect(state.shoppinglists).to.have.length(1)** \n}) \n\n```", "```js\n// mutations.spec.js \nimport mutations from 'src/vuex/mutations' \nimport { ADD_SHOPPING_LIST, DELETE_SHOPPING_LIST, POPULATE_SHOPPING_LISTS, CHANGE_TITLE } from 'src/vuex/mutation_types' \n\ndescribe('mutations.js', () => { \n  var state \n\n  beforeEach(() => { \n    state = { \n      shoppinglists: [] \n    } \n  }) \n\n  describe('ADD_SHOPPING_LIST', () => { \n    it('should add item to the shopping list array and increase its \n      length', () => { \n      mutations[ADD_SHOPPING_LIST](state, {id: '1'}) \n      expect(state.shoppinglists).to.eql([{id: '1'}]) \n      expect(state.shoppinglists).to.have.length(1) \n    }) \n  }) \n}) \n\n```", "```js\n**npm run unit** \n\n```", "```js\nit('should not add the item if item is empty', () => { \n  mutations[ADD_SHOPPING_LIST](state) \n  **expect(state.shoppinglists).to.have.length(0)** \n}) \n\n```", "```js\nexpected [ undefined ] to have a length of 0 but got 1 \n\n```", "```js\n//mutations.js \n[types.ADD_SHOPPING_LIST](state, newList) { \n  if (**_.isObject(newList)**) { \n    state.shoppinglists.push(newList) \n  } \n} \n\n```", "```js\n[types.ADD_SHOPPING_LIST](state, newList) { \n  if (_.isObject(newList)) { \n    **newList.title = 'New Shopping List'**     \n    state.shoppinglists.push(newList) \n  } \n} \n\n```", "```js\nit.**skip**('should not add the item if item is empty', () => { \n  mutations[ADD_SHOPPING_LIST](state) \n  expect(state.shoppinglists).to.have.length(0) \n}) \n\n```", "```js\n//actions.js \npopulateShoppingLists: ({ commit }) => { \n  api.fetchShoppingLists().then(response => { \n    commit(POPULATE_SHOPPING_LISTS, response.data) \n  }) \n} \n\n```", "```js\n//actions.js \npopulateShoppingLists: ({ commit }) => { \n  **return** api.fetchShoppingLists().then(response => { \n    commit(POPULATE_SHOPPING_LISTS, response.data) \n  }) \n} \n\n```", "```js\nit('should test that commit is called with correct parameters', () => { \n  actions.populateShoppingLists({ commit }).then(() => { \n    expect(commit).to.have.been.calledWith(<...>) \n  }) \n}) \n\n```", "```js\nit('should test that commit is called with correct parameters', \n(**done**) => { \n  actions.populateShoppingLists({ commit }).then(() => { \n   expect(commit).to.have.been.calledWith(<...>) \n   **done()** \n  }) \n}) \n\n```", "```js\n// actions.spec.js \nimport actions from 'src/vuex/actions' \nimport { CHANGE_TITLE, POPULATE_SHOPPING_LISTS } from 'src/vuex/mutation_types' \n\ndescribe('actions.js', () => { \n  describe('populateShoppingLists', () => { \n    //here we will add our test case \n  }) \n}) \n\n```", "```js\n//actions.spec.js \ndescribe('actions.js', () => { \n  **var lists** \n\n  beforeEach(() => { \n    **// mock shopping lists \n    lists = [{ \n      id: '1', \n      title: 'Groceries' \n    }, { \n      id: '2', \n      title: 'Clothes' \n    }]** \n  }) \n\n  describe('populateShoppingLists', () => { \n  }) \n}) \n\n```", "```js\n// actions.spec.js \ndescribe('actions.js', () => { \n  var lists, **store** \n\n  beforeEach(() => { \n    <...> \n    //mock store commit method \n    **store = { \n      commit: (method, data) => {}, \n      state: { \n        shoppinglists: lists \n      } \n    }** \n  }) \n  <...> \n}) \n\n```", "```js\nsinon.stub(store, 'commit')  \n\n```", "```js\nbeforeEach(() => { \n    <...> \n    // mock store commit method \n    store = { \n      commit: (method, data) => {}, \n      state: { \n        shoppinglists: lists \n      } \n    } \n\n    sinon.stub(store, 'commit') \n}) \n\n```", "```js\nafterEach(function () { \n  //restore stub \n  store.commit.restore() \n}) \n\n```", "```js\ndescribe('actions.js', () => { \n  var lists, store, server \n\n  beforeEach(() => { \n    <...> \n    //mock server \n    **server = sinon.fakeServer.create() \n    server.respondWith('GET', /shoppinglists/, xhr => { \n      xhr.respond(200, {'Content-Type': 'application/json'}, \n      JSON.stringify(lists)) \n    })** \n  }) \n  <...> \n}) \n\n```", "```js\nserver.autoRespond = true \n\n```", "```js\nbeforeEach(() => { \n    <...> \n    //mock server \n    server = sinon.fakeServer.create() \n    server.respondWith('GET', /shoppinglists/, xhr => { \n      xhr.respond(200, {'Content-Type': 'application/json'}, \n      JSON.stringify(lists) \n    }) \n    **server.autoRespond = true**   \n}) \n\n```", "```js\nafterEach(() => { \n  //restore stubs and server mock \n  store.commit.restore() \n  **server.restore()** \n}) \n\n```", "```js\nit('should call commit method with POPULATE_SHOPPING_LIST and with mocked lists', done => { \n  actions.populateShoppingLists(store).then(() => { \n    **expect(store.commit).to.have.been.calledWith(POPULATE_SHOPPING_LISTS,\n    lists) \n    done()** \n  }).catch(done) \n}) \n\n```", "```js\n  var server, store, lists, successPut, successPost, successDelete \n\n  **successDelete = {'delete': true} \n  successPost = {'post': true} \n  successPut = {'put': true}** \n\n```", "```js\n    server.respondWith(**'POST'**, /shoppinglists/, xhr => { \n      xhr.respond(200, {'Content-Type': 'application/json'}, \n        JSON.stringify(**successPost**)) \n    }) \n    server.respondWith(**'PUT'**, /shoppinglists/, xhr => { \n      xhr.respond(200, {'Content-Type': 'application/json'}, \n        JSON.stringify(**successPut**)) \n    }) \n    server.respondWith(**'DELETE'**, /shoppinglists/, xhr => { \n      xhr.respond(200, {'Content-Type': 'application/json'}, \n        JSON.stringify(**successDelete**)) \n    }) \n\n```", "```js\ndescribe(**'changeTitle'**, () => { \n  it('should call commit method with CHANGE_TITLE string', (done) => { \n    let title = 'new title' \n\n    actions.changeTitle(store, {title: title, id: '1'}).then(() => { \n      **expect(store.commit).to.have.been.calledWith(CHANGE_TITLE, \n      {title: title, id: '1'})** \n      done() \n    }).catch(done) \n  }) \n}) \n\n```", "```js\n// mock store commit and dispatch methods \nstore = { \n  commit: (method, data) => {}, \n  **dispatch: () => { \n    return Promise.resolve() \n  },** \n  state: { \n    shoppinglists: lists \n  } \n} \n\n```", "```js\n//AddItemComponent.spec.js \nimport Vue from 'vue' \nimport AddItemComponent from 'src/components/AddItemComponent' \n\ndescribe('AddItemComponent.vue', () => { \n\n}) \n\n```", "```js\ndescribe('initialization', () => { \n  it('should initialize the component with empty string newItem', () => { \n    **expect(AddItemComponent.data()).to.eql({ \n      newItem: '' \n    })** \n  }) \n}) \n\n```", "```js\n//AddItemComponent.vue \naddItem () { \n  var text \n\n  text = this.newItem.trim() \n  if (text) { \n    this.$emit('add', this.newItem) \n    this.newItem = '' \n    this.$store.dispatch('updateList', this.id) \n  } \n} \n\n```", "```js\nvar vm, addItemComponent; \n\nvm = new Vue({ \n  template: '<add-item-component :items=\"items\" :id=\"id\" \n  **ref=\"additemcomponent\"**>' + \n  '</add-item-component>', \n  components: { \n    AddItemComponent \n  }, \n  data() { \n    return { \n      items: [], \n      id: 'niceId' \n    } \n  }, \n  store \n}).$mount(); \n\n**addItemComponent = vm.$refs.additemcomponent** \n\n```", "```js\ndescribe(**'addItem'**, () => { \n\n}) \n\n```", "```js\n//AddItemComponent.spec.js \nit('should call $emit method', () => { \n  let newItem = 'Learning Vue JS' \n  // stub $emit method \n  sinon.stub(component, '$emit') \n  // stub store's dispatch method \n  sinon.stub(store, 'dispatch') \n  // set a new item \n  **component.newItem = newItem** \n  component.addItem() \n  // newItem should be reset \n  **expect(component.newItem).to.eql('')** \n  // $emit should be called with custom event 'add' and a newItem value \n  **expect(component.$emit).to.have.been.calledWith('add', newItem)** \n  // dispatch should be called with updateList and the id of the list \n  **expect(store.dispatch).to.have.been.calledWith('updateList', \n  'niceId')** \n  store.dispatch.restore() \n  component.$emit.restore() \n}) \n\n```", "```js\n// mutations.spec.js \nimport Vue from 'vue' \nimport mutations from 'src/vuex/mutations' \nimport * as types from 'src/vuex/mutation_types' \n\ndescribe('mutations', () => { \n  var state \n\n  beforeEach(() => { \n    state = {} \n    // let's mock Vue noise plugin \n    //to be able to listen on its methods \n    **Vue.noise = { \n      start: () => {}, \n      stop: () => {}, \n      pause: () => {} \n    }** \n    sinon.spy(Vue.noise, 'start') \n    sinon.spy(Vue.noise, 'pause') \n    sinon.spy(Vue.noise, 'stop') \n  }) \n\n  afterEach(() => { \n    **Vue.noise.start.restore() \n    Vue.noise.pause.restore() \n    Vue.noise.stop.restore()** \n  }) \n\n  describe(**'START'**, () => { \n  }) \n}) \n\n```", "```js\n[types.START] (state) { \n  state.started = true \n  state.paused = false \n  state.stopped = false \n  state.interval = setInterval(() => tick(state), 1000) \n  if (state.isWorking && state.soundEnabled) { \n    Vue.noise.start() \n  } \n}, \n\n```", "```js\nit('should set all the state properties correctly after start', () => { \n  // ensure that all the properties are undefined \n  // before calling the start method \n  expect(state.started).to.be.undefined \n  expect(state.stopped).to.be.undefined \n  expect(state.paused).to.be.undefined \n  expect(state.interval).to.be.undefined \n  // call the start method \n  mutations[types.START](state) \n  // check that all the properties were correctly set \n  expect(state.started).to.be.true \n  expect(state.paused).to.be.false \n  expect(state.stopped).to.be.false \n  expect(state.interval).not.to.be.undefined \n}) \n\n```", "```js\nit('should call Vue.noise.start method if both state.isWorking and state.soundEnabled are true', () => { \n  state.**isWorking** = true \n  state.**soundEnabled** = true \n  mutations[types.START](state) \n  expect(Vue.noise.start).**to.have.been.called** \n}) \n\n```", "```js\nit('should not call Vue.noise.start method if state.isWorking is not true', () => { \n  **state.isWorking = false** \n  state.soundEnabled = true \n  mutations[types.START](state) \n  expect(Vue.noise.start).**to.not.have.been.called** \n}) \n\nit('should not call Vue.noise.start method if state.soundEnabled is not true', () => { \n  state.isWorking = true \n  **state.soundEnabled = false** \n  mutations[types.START](state) \n  expect(Vue.noise.start).**to.not.have.been.called** \n}) \n\n```", "```js\nmodule.exports = { \n  'e2e test': function (browser) { \n    browser \n    .**url**('http://localhost:8080') \n      .**waitForElementVisible**('#app', 5000) \n      .assert.**elementPresent**('.logo') \n      .assert.**containsText**('h1', 'Hello World!') \n      .assert.**elementCount**('p', 3) \n      .end() \n  } \n} \n\n```", "```js\nmodule.exports = { \n  'default e2e tests': (browser) => { \n    // open the browser and check that #app is on the page \n    browser.url('http://localhost:8080') \n      .waitForElementVisible('#app', 5000); \n    // check that toggle-volume icon is not visible \n    browser.expect.element('.toggle-volume') \n      .to.not.be.visible \n    // check that pause button is disabled \n    browser.expect.element('[title=pause]') \n      .to.have.attribute('disabled') \n    // check that stop button is disabled \n    browser.expect.element('[title=stop]') \n      .to.have.attribute('disabled') \n    // check that start button is not disabled            \n    browser.expect.element('[title=start]') \n      .to.not.have.attribute('disabled') \n    // click on start button, check that toggle volume \n    // button is visible \n    browser.click('[title=start]') \n      .waitForElementVisible('.toggle-volume', 5000) \n    // check that pause button is not disabled \n    browser.expect.element('[title=pause]') \n      .to.not.have.attribute('disabled') \n    // check that stop button is not disabled \n    browser.expect.element('[title=stop]') \n      .to.not.have.attribute('disabled') \n    // check that stop button is disabled \n    browser.expect.element('[title=start]') \n      .to.have.attribute('disabled') \n    browser.end() \n  } \n} \n\n```", "```js\n//config.js \nexport const WORKING_TIME = 0.1 * 60 \n\n```", "```js\n'wait for kitten test': (browser) => { \n  browser.url('http://localhost:8080') \n    .waitForElementVisible('#app', 5000) \n  // initially the kitten element is not visible \n  browser.expect.element('.well.kittens') \n    .to.not.be.visible \n  // click on the start button and wait for 7s for \n  //kitten element to appear \n  browser.click('[title=start]') \n    .waitForElementVisible('.well.kittens', 7000) \n  // check that the image contains the src element \n  //that matches thecatapi string \n  browser.expect.element('.well.kittens img') \n    .to.have.attribute('src') \n    .which.matches(/thecatapi/); \n  browser.end() \n} \n\n```", "```js\n**npm run e2e** \n\n```", "```js\n**npm test** \n\n```"]