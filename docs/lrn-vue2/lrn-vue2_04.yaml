- en: Chapter 4. Reactivity – Binding Data to Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。反应性-将数据绑定到您的应用程序
- en: In the previous chapter, you learned one of the most important concepts of Vue.js: components.
    You saw how to create components, how to register, how to invoke, and how to use
    and reuse them. You also learned the concept of single-file components and even
    used them in the shopping list and Pomodoro applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了Vue.js中最重要的概念之一：组件。您看到了如何创建组件，如何注册，如何调用以及如何使用和重用它们。您还学习了单文件组件的概念，甚至在购物清单和番茄钟应用程序中使用了它们。
- en: In this chapter, we will go deeper into the concept of data binding. We have
    already talked about it earlier, so you are already familiar with it. We will
    bind data in all possible ways in our components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨数据绑定的概念。我们之前已经谈论过它，所以你已经很熟悉了。我们将以所有可能的方式在我们的组件中绑定数据。
- en: 'Summing it up, in this chapter, we are going to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在本章中，我们将：
- en: Revisit the data binding syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视数据绑定语法
- en: Apply data binding in our applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中应用数据绑定
- en: Iterate over the array of elements and render each element using the same template
    with different data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历元素数组，并使用相同的模板渲染每个元素
- en: Revisit and apply the shorthands of data and events binding in our applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视并应用数据和事件绑定的速记方式在我们的应用程序中
- en: Revisiting data binding
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视数据绑定
- en: We have been talking about data binding and reactivity starting from the very
    first chapter. So, you already know that data binding is a mechanism of propagating
    changes from the data to the visible layer and vice versa. In this chapter, we
    will carefully revisit all the different ways of data binding and apply them in
    our applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第一章开始就一直在谈论数据绑定和反应性。所以，你已经知道数据绑定是一种从数据到可见层以及反之的变化传播机制。在本章中，我们将仔细审视所有不同的数据绑定方式，并在我们的应用程序中应用它们。
- en: Interpolating data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入数据
- en: 'Let''s imagine the following piece of HTML code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下以下的HTML代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also, imagine the following JavaScript object:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还想象以下JavaScript对象：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How can we render the values of data entries on the page? How can we access
    them so that we can use them inside our HTML? Actually, we have been doing this
    a lot with Vue.js during the last two chapters. There is no problem in understanding
    and doing it again and again.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在页面上呈现数据条目的值？我们如何访问它们，以便我们可以在HTML中使用它们？实际上，在过去的两章中，我们已经在Vue.js中大量做了这个。理解并一遍又一遍地做这件事并没有问题。
- en: '*"Repetitio est mater studiorum"*'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “重复是学习之母”
- en: If you are already a professional of data interpolation, just skip this section
    and proceed to the expressions and filters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经是数据插值的专业人士，只需跳过本节，然后继续表达式和过滤器。
- en: 'So, what should we do to populate the `<div>` with the value of `msg`? If we
    go the old-fashioned jQuery way, we would probably do something like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该怎么做才能用`msg`的值填充`<div>`？如果我们按照老式的jQuery方式，我们可能会做类似以下的事情：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But then, during runtime, if you change the value of `msg` and if you want this
    change to be propagated to the DOM, you must do it manually. By simply changing
    the `data.msg` value, nothing will happen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在运行时，如果您更改`msg`的值，并且希望这种更改传播到DOM，您必须手动执行。仅仅改变`data.msg`的值，什么也不会发生。
- en: 'For example, let''s write the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们编写以下代码：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then the text that will appear in the `<div>` will, of course, be `Hello`. Check
    this JSFiddle at   [https://jsfiddle.net/chudaol/uevnd0e4/](https://jsfiddle.net/chudaol/uevnd0e4/).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后出现在`<div>`中的文本将是`Hello`。在[https://jsfiddle.net/chudaol/uevnd0e4/](https://jsfiddle.net/chudaol/uevnd0e4/)上检查这个JSFiddle。
- en: 'With Vue, the simplest interpolation is done with `{{ }}` (handlebars annotation).
    In our example, we would write the following HTML code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue，最简单的插值是用`{{ }}`（句柄注释）完成的。在我们的示例中，我们将编写以下HTML代码：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The content of the `<div>` thus becomes bound to the `msg` data. Each time `msg`
    changes, the content of the `div` changes automatically following its content.
    Have a look at the jsfiddle example at [https://jsfiddle.net/chudaol/xuvqotmq/1/](https://jsfiddle.net/chudaol/xuvqotmq/1/)
    . `data.msg` is also changed after the Vue instantiation. The value that appears
    on the screen is the new one!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`<div>`的内容将与`msg`数据绑定。每次`msg`更改时，`div`的内容都会自动更改其内容。请查看[https://jsfiddle.net/chudaol/xuvqotmq/1/](https://jsfiddle.net/chudaol/xuvqotmq/1/)上的jsfiddle示例。Vue实例化后，`data.msg`也会更改。屏幕上显示的值是新的值！
- en: It is still one-way binding interpolation. If we change the value in the DOM,
    nothing will happen to data. Still, if we only need the values of the data to
    appear in the DOM and to be changed accordingly, it is a perfect and valid approach.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是单向绑定的插值。如果我们在DOM中更改值，数据将不会发生任何变化。但是，如果我们只需要数据的值出现在DOM中，并相应地更改，这是一种完美有效的方法。
- en: At this moment, it should be really clear that if we want to use the values
    of the `data` object inside the template, we should surround them with `{{}}`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，应该非常清楚，如果我们想在模板中使用`data`对象的值，我们应该用`{{}}`将它们括起来。
- en: 'Let''s add the missing interpolations to our Pomodoro application. Please check
    the current situation in the [chapter4/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro)
    folder. If you run `npm run dev` and have a look at the opened page, you will
    see that the page looks like the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的番茄钟应用程序添加缺失的插值。请在[chapter4/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro)文件夹中检查当前情况。如果您运行`npm
    run dev`并查看打开的页面，您将看到页面如下所示：
- en: '![Interpolating data](../Images/image00273.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![插入数据](../Images/image00273.jpeg)'
- en: Missing interpolations in our Pomodoro application
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们番茄钟应用程序中缺少的插值
- en: From the very first glance at the page, we are able to identify what is missing
    there.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从对页面的第一眼扫视中，我们能够确定那里缺少什么。
- en: The page is missing the timer, the kittens, the title of the Pomodoro state
    (the one that displays **`Work!`** or **`Rest!`**), and the logic that shows or
    hides the kittens' placeholder according to the Pomodoro state. Let's start by
    adding the title of the Pomodoro state and the minutes and seconds of the Pomodoro
    timer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 页面缺少计时器、小猫、番茄钟状态的标题（显示**`工作！`**或**`休息！`**）、以及根据番茄钟状态显示或隐藏小猫占位符的逻辑。让我们首先添加番茄钟状态的标题和番茄钟计时器的分钟和秒。
- en: Adding title of the Pomodoro state
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加番茄钟状态的标题
- en: 'First of all, we should decide what component this element should belong to.
    Have a look at our four components. It is more than obvious that it should belong
    to `StateTitleComponent`. If you look at the following code, you will see that
    it actually already interpolates the title in its template:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该决定这个元素应该属于哪个组件。看看我们的四个组件。很明显，它应该属于`StateTitleComponent`。如果您查看以下代码，您将看到它实际上已经在其模板中插值了标题：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Good! In the previous chapter, we''ve already done most of the work. Now we
    just have to add the data that must be interpolated. In the `<script>` tag of
    this component, let''s add the `data` object with the `title` attribute inside.
    For now, let''s hardcode it to one of the possible values and then decide how
    to change it. What do you prefer? **`Work!`** or **`Rest!`**? I think I know the
    answer, so let''s add the following code to our `script` tag:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好！在上一章中，我们已经完成了大部分工作。现在我们只需要添加必须被插值的数据。在这个组件的`<script>`标签中，让我们添加带有`title`属性的`data`对象。现在，让我们将其硬编码为可能的值之一，然后决定如何更改它。你更喜欢什么？**`工作！`**
    还是 **`休息！`**？我想我知道答案，所以让我们将以下代码添加到我们的`script`标签中：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's leave it like this for now. We will come back to this later in the methods
    and event handling section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就让它保持这样。我们将在以后的方法和事件处理部分回到这个问题。
- en: Exercise
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: In the same way in which we added the title of the Pomodoro state, please add
    the minutes and seconds timer counters to the `CountDownComponent`. They can be
    hardcoded for now.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以与我们添加Pomodoro状态标题相同的方式，请将分钟和秒计时器计数器添加到`CountDownComponent`中。它们现在可以是硬编码的。
- en: Using expressions and filters
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表达式和过滤器
- en: In the previous example, we have used simple property keys inside the `{{}}`
    interpolations. Actually, Vue supports a lot more inside these nice curly brackets.
    Let's see what it is possible to do there.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在`{{}}`插值中使用了简单的属性键。实际上，Vue在这些花括号中支持更多的内容。让我们看看在那里可能做些什么。
- en: Expressions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式
- en: It might sound unexpected, but Vue supports full JavaScript expressions inside
    the data binding brackets! Let's go to any of the Pomodoro application components
    and add any JavaScript expression to the template. You can do some experiments
    in the [chapter4/pomodoro2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro2)
    folder.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来出乎意料，但Vue支持在数据绑定括号内使用完整的JavaScript表达式！让我们去Pomodoro应用程序的任何一个组件，并在模板中添加任何JavaScript表达式。你可以在[chapter4/pomodoro2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro2)文件夹中进行一些实验。
- en: 'Try, for example, to open the `StateTitleComponent.vue` file. Let''s add some
    JavaScript expression interpolation to its template, for example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试打开`StateTitleComponent.vue`文件。让我们在其模板中添加一些JavaScript表达式插值，例如：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Actually, you just need to uncomment the following lines:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你只需要取消注释以下行：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will see number **`25`** on the page. Nice, isn''t it? Let''s replace some
    of our data bindings in the Pomodoro application with a JavaScript expression.
    For example, in the `CountdownComponent` component''s template, two directives,
    each for `min` and `sec`, can be replaced by one expression. Currently it looks
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在页面上看到数字**`25`**。很好，不是吗？让我们用JavaScript表达式替换Pomodoro应用程序中的一些数据绑定。例如，在`CountdownComponent`组件的模板中，每个用于`min`和`sec`的指令可以被一个表达式替换。目前它看起来是这样的：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can replace it with the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码替换它：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Where else can we add some expressions? Let''s have a look at `StateTitleComponent`.
    At this moment, we use the hardcoded title. We know, however, that somehow it
    should depend on the Pomodoro state. If it is in the *working* state, it should
    display **`Work!`**, otherwise it should display **`Rest!`**. Let''s create this
    attribute and call it `isworking`, and let''s assign it to the main `App.vue`
    component because it seems to belong to the global application state. Then we
    will reuse it inside the `StateTitleComponent` component''s `props` attribute.
    Thus, open `App.vue`, and add the Boolean property `isworking` and set it to `true`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有哪些地方可以添加一些表达式呢？让我们看看`StateTitleComponent`。此刻，我们使用的是硬编码的标题。然而，我们知道它应该以某种方式依赖于番茄钟的状态。如果它处于“工作”状态，它应该显示**`Work!`**，否则应该显示**`Rest!`**。让我们创建这个属性并将其命名为`isworking`，然后将其分配给主`App.vue`组件，因为它似乎属于全局应用状态。然后我们将在`StateTitleComponent`组件的`props`属性中重用它。因此，打开`App.vue`，添加布尔属性`isworking`并将其设置为`true`：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s now reuse this property in `StateTitleComponent`, add two string properties
    for each of the possible titles, and, finally, add the expression in the template
    that will conditionally render one title or another accordingly to the current
    state. Thus, the script of the component will look like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`StateTitleComponent`中重用这个属性，在每个可能的标题中添加两个字符串属性，并最后在模板中添加表达式，根据当前状态有条件地渲染一个标题或另一个标题。因此，组件的脚本将如下所示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can conditionally render one title or another based on the `isworking`
    property. Thus, the template of `StateTitleComponent` will look like the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据`isworking`属性有条件地渲染一个标题或另一个标题。因此，`StateTitleComponent`的模板将如下所示：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Look at the refreshed page. Strangely, it shows **`Rest!`** as the title. How
    did this happen if the `isworking` property is set to `true` in `App.vue`? We
    simply forgot to bind this property on the component invocation in the `App.vue`
    template! Open the `App.vue` component and add the following code on the `state-title-component`
    invocation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下刷新后的页面。奇怪的是，它显示**`Rest!`**作为标题。如果`App.vue`中的`isworking`属性设置为`true`，那么这是怎么发生的？我们只是忘记在`App.vue`模板中的组件调用上绑定这个属性！打开`App.vue`组件，并在`state-title-component`调用上添加以下代码：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, if you look at the page, the correct title appears as **`Work!`** If you
    open the devtools console and type `data.isworking = false`, you will see the
    title changing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看页面，正确的标题会显示为**`Work!`**。如果你打开开发工具控制台并输入`data.isworking = false`，你会看到标题改变。
- en: 'If the `isworking` attribute is `false`, the title is **`Rest!`**, as shown
    in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isworking`属性为`false`，标题为**`Rest!`**，如下截图所示：
- en: '![Expressions](../Images/image00274.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Expressions](../Images/image00274.jpeg)'
- en: 'If the `isworking` attribute is `true`, the title is **`Work!`**, as shown
    in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isworking`属性为`true`，标题为**`Work!`**，如下截图所示：
- en: '![Expressions](../Images/image00275.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Expressions](../Images/image00275.jpeg)'
- en: Filters
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器
- en: 'Besides expressions inside the curly interpolation brackets, it is also possible
    to use filters that are applied to the result of the expression. Filters are just
    functions. They are created by us and applied by using the pipe symbol:  `|`.
    If you create a filter that makes letters uppercase and call it uppercase, in
    order to apply it, just use it after the pipe symbol inside the mustache interpolation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了花括号内的表达式之外，还可以使用应用于表达式结果的过滤器。过滤器只是函数。它们是由我们创建的，并且通过使用管道符号`|`应用。如果你创建一个将字母转换为大写的过滤器并将其命名为`uppercase`，那么要应用它，只需在双大括号内的管道符号后面使用它：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can chain as many filters as you want, for example, if you have filter
    `A`, `B`, `C`, you can do something like `{{ key | A | B | C }}`. Filters are
    created using `Vue.filter` syntax. Let''s create our `lowercase` filter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以链接尽可能多的过滤器，例如，如果你有过滤器`A`，`B`，`C`，你可以做类似`{{ key | A | B | C }}`的事情。过滤器是使用`Vue.filter`语法创建的。让我们创建我们的`lowercase`过滤器：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s apply it to the Pomodoro title in the main `App.vue` component. In order
    to be able to use the filter, we should pass the `''Pomodoro''` string inside
    the handlebars interpolation notation. We should pass it as a JavaScript string
    expression and apply a filter using the pipe symbol:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其应用到主`App.vue`组件中的Pomodoro标题。为了能够使用过滤器，我们应该将`'Pomodoro'`字符串传递到句柄插值符号内。我们应该将它作为JavaScript字符串表达式传递，并使用管道符号应用过滤器：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Check the page; the **`Pomodoro`** title will actually appear written in the
    lowercase syntax.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 检查页面；**`Pomodoro`**标题实际上将以小写语法显示。
- en: Let's revisit our `CountdownTimer` component and have a look at the timer. For
    now, there are only hardcoded values, right? But when the application is fully
    functional, the values will come from some computation. The range of values will
    be from 0 to 60\. It is okay if the timer shows **`20:40`**, but it is not okay
    for fewer than ten values. For example, when it is only 1 minute and 5 seconds,
    it will be **`1:5`**, which is not good. We are expecting to see something like
    **`01:05`**. So, we need the `leftpad` filter! Let's create it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视我们的`CountdownTimer`组件并查看计时器。目前，只有硬编码的值，对吧？但是当应用程序完全功能时，值将来自某些计算。值的范围将从0到60。计时器显示**`20:40`**是可以的，但少于十的值是不可以的。例如，当只有1分钟和5秒时，它将是**`1:5`**，这是不好的。我们希望看到类似**`01:05`**的东西。所以，我们需要`leftpad`过滤器！让我们创建它。
- en: 'Go to the `main.js` file and add a `leftpad` filter after the uppercase filter
    definition:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`main.js`文件，并在大写过滤器定义之后添加一个`leftpad`过滤器：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open the `CountdownComponent` component and let''s again split `min` and `sec`
    to the different interpolation brackets and add filters to each of them:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`CountdownComponent`组件，让我们再次将`min`和`sec`拆分到不同的插值括号中，并为每个添加过滤器：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Replace `min` and `sec` in data with 1 and 5, respectively, and have a look.
    The numbers appear with a preceding "0"!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 用1和5替换数据中的`min`和`sec`，然后查看。数字出现了前面的"0"！
- en: Exercise
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Create two filters, `uppercase` and `addspace`, and apply them to the title
    **`Pomodoro:`**
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个过滤器，`大写`和`addspace`，并将它们应用到标题**`Pomodoro:`**
- en: The `uppercase` filter must do exactly what it says it does
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`大写`过滤器必须做到它所说的那样'
- en: The `addspace` filter must add a space on the right of the given string value
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addspace`过滤器必须在给定的字符串值右侧添加一个空格'
- en: 'Do not forget that **`Pomodoro`** is not a key, so inside the interpolation
    brackets, it should be treated as a string! The title before and after this exercise
    would look something like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记**`Pomodoro`**不是一个关键字，所以在插值括号内，它应该被视为一个字符串！在这个练习之前和之后的标题看起来应该是这样的：
- en: '![Exercise](../Images/image00276.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![练习](../Images/image00276.jpeg)'
- en: The title of the Pomodoro application before and after applying filters uppercase
    and addspace
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用过滤器大写和添加空格之前和之后的Pomodoro应用程序的标题
- en: 'Check yourself: have a look at the [chapter4/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro3)
    folder.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 自己检查：查看[chapter4/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro3)文件夹。
- en: Revisiting and applying directives
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视和应用指令
- en: 'In the previous section, we saw how to interpolate the application''s data
    and how to bind it to the visual layer. Though the syntax is pretty powerful and
    offers a high possibility of data modification (using filters and expressions),
    it has some limitations. Try, for example, to implement the following using `{{}}`
    notation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何插值应用程序的数据以及如何将其绑定到可视层。尽管语法非常强大，并且提供了高可能性的数据修改（使用过滤器和表达式），但它也有一些限制。例如，尝试使用
    `{{}}` 符号来实现以下内容：
- en: Use the interpolated data in the user input and apply the changes to the corresponding
    data when the user types in the input
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户输入中使用插值数据，并在用户在输入中键入时将更改应用到相应的数据
- en: Bind a specific element's attribute (for example, `src`) to the data
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将特定元素的属性（例如 `src`）绑定到数据
- en: Render some element conditionally
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有条件地渲染一些元素
- en: Iterate through an array and render some component with the elements of the
    array
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历数组并渲染一些组件与数组的元素
- en: Create event listeners on the elements
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在元素上创建事件监听器
- en: 'Let''s try at least the first one. Open, for example, the shopping list application
    (it''s in the [chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)
    folder). Create an `input` element in the `App.vue` template and set its value
    to `{{ title }}`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们至少尝试第一个。例如，打开购物清单应用程序（在 [chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)
    文件夹中）。在 `App.vue` 模板中创建一个 `input` 元素，并将其值设置为 `{{ title }}`：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Oh no! Errors, errors everywhere. **`Interpolation inside attributes has been
    removed,`** it says. Does it mean that prior to Vue 2.0 you could easily use the
    interpolation inside attributes? Yes, and no. You would not get an error if you'd
    use interpolations inside attributes, but changing the title inside the input
    would result in nothing. In Vue 2.0, as well as in the prior versions, to achieve
    this kind of behavior, we must use directives.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不！到处都是错误。**`已删除属性内的插值`**，它说。这是否意味着在Vue 2.0之前，您可以轻松地在属性内使用插值？是的，也不是。如果您在属性内使用插值，您将不会收到错误，但在输入框内更改标题将不会产生任何结果。在Vue
    2.0中，以及在之前的版本中，为了实现这种行为，我们必须使用指令。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Directives** are special attributes of the elements that have a `v-` prefix.
    Why `v-`? Because Vue! Directives provide a tiny syntax that provides a richer
    set of possibilities than simple text interpolation. They have the power to reactively
    apply some special behavior to the visual layer on each data change.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令**是具有 `v-` 前缀的元素的特殊属性。为什么是 `v-`？因为Vue！指令提供了一种微小的语法，比简单的文本插值提供了更丰富的可能性。它们有能力在每次数据更改时对可视层应用一些特殊行为。'
- en: Two-way binding using the v-model directive
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `v-model` 指令进行双向绑定
- en: Two-way binding is a type of binding where not only data changes are propagated
    to the DOM layer, but also the changes that occur to the bound data in the DOM
    are propagated to the data. To bind the data in such a way to the DOM, we can
    use the `v-model` directive.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 双向绑定是一种绑定类型，不仅数据更改会传播到DOM层，而且DOM中绑定数据发生的更改也会传播到数据中。要以这种方式将数据绑定到DOM，我们可以使用 `v-model`
    指令。
- en: 'I am sure you still remember from the first chapter that the `v-model` directive
    is used as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您仍然记得第一章中使用 `v-model` 指令的方式：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this way, the value of the title will appear in the input, and if you type
    something in this input, the corresponding change will be immediately applied
    to the data and reflected in all interpolated values on the page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，标题的值将出现在输入框中，如果您在此输入框中输入内容，相应的更改将立即应用到数据，并反映在页面上所有插值的值中。
- en: Just replace the handlebars notation with `v-model` and open the page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 只需用 `v-model` 替换花括号符号，并打开页面。
- en: Try to type something in the input. You will see how the title is immediately
    changed!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在输入框中输入一些内容。您将看到标题立即更改！
- en: 'Just remember, this directive can only be used with the following elements:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 只记住，这个指令只能用于以下元素：
- en: '`<input>`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<input>`'
- en: '`<select>`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<select>`'
- en: '`<textarea>`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<textarea>`'
- en: Try all of them and then delete this code. Our main purpose is to be able to
    change the title using the change title component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试所有这些然后删除这段代码。我们的主要目的是能够使用更改标题组件来更改标题。
- en: Two-way binding between components
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件之间的双向绑定
- en: Remember from the previous chapter that two-way binding between components cannot
    be easily achieved using the `v-model` directive. Due to architectural reasons,
    Vue just prevents children from easily changing the parents' scope.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章中记得，使用`v-model`指令不能轻松实现组件之间的双向绑定。由于架构原因，Vue只是阻止子组件轻松地改变父级作用域。
- en: That's why we used the events system in the previous chapter to be able to change
    the title of the shopping list from the child component.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们在上一章中使用事件系统来能够从子组件更改购物清单的标题。
- en: We will do it again in this chapter. Just wait couple of paragraphs until we
    reach the section on `v-on` directives.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中再次进行。等到我们到达`v-on`指令的部分之前再等几段时间。
- en: Binding attributes using the v-bind directive
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`v-bind`指令绑定属性
- en: 'The `v-bind` directive allows us to bind an element''s `attribute` or a `component`
    property to an expression. In order to apply it to the specific attribute, we
    use a colon delimiter:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-bind`指令允许我们将元素的`属性`或`组件`属性绑定到一个表达式。为了将其应用于特定属性，我们使用冒号分隔符：'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '`v-bind:src="src"`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-bind:src="src"`'
- en: '`v-bind:class="className"`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-bind:class="className"`'
- en: Any expression can be written inside the `""`. The data properties can be used
    as well, just like in the previous examples. Let's add the kitten image to `KittenComponent`
    in our Pomodoro application using `thecatapi` as the source. Open our Pomodoro
    application from the [chapter4/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro3)
    folder.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 任何表达式都可以写在`""`内。数据属性也可以像之前的例子一样使用。让我们在我们的Pomodoro应用程序中的`KittenComponent`中使用`thecatapi`作为来源添加小猫图片。从[chapter4/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro3)文件夹打开我们的Pomodoro应用程序。
- en: 'Open `KittenComponent`, add `catimgsrc` to the component''s data, and bind
    it to the image template using `v-bind` syntax with the `src` attribute:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`KittenComponent`，将`catimgsrc`添加到组件的数据中，并使用`v-bind`语法将其绑定到图像模板的`src`属性：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Open the page. Enjoy the kitten!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面。享受小猫！
- en: '![Binding attributes using the v-bind directive](../Images/image00277.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![使用v-bind指令绑定属性](../Images/image00277.jpeg)'
- en: Pomodoro KittenComponent with applied source attribute
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 应用了源属性的Pomodoro KittenComponent
- en: Conditional rendering using v-if and v-show directives
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用v-if和v-show指令进行条件渲染
- en: If you have paid enough attention in the earlier sections, and if I ask you
    to conditionally render something, you might be actually able to do it using JavaScript
    expressions inside the interpolation brackets `{{ }}`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在前面的部分中已经付出了足够的注意，并且如果我要求您有条件地渲染某些内容，您实际上可以使用插值括号`{{ }}`内的JavaScript表达式来实现。
- en: However, try to conditionally render some element or the whole component. It
    might not be as simple as applying an expression inside the brackets.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，尝试有条件地渲染某个元素或整个组件。这可能并不像在括号内应用表达式那么简单。
- en: 'The `v-if` directive allows to conditionally render the whole element, which
    might also be a component element depending on some condition. The condition can
    be any expression and it can use the data properties as well. For example, we
    can do the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-if`指令允许有条件地渲染整个元素，这个元素也可能是一个组件元素，取决于某些条件。条件可以是任何表达式，也可以使用数据属性。例如，我们可以这样做：'
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or even:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Or using the component''s data:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用组件的数据：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `v-show` attribute does the same job. The only difference is that `v-if`
    will or will not render the element to the condition accordingly, whereas the
    `v-show` attribute will always render the element, just applying `display:none`
    CSS property when the result of the condition is `false`. Let's see the difference.
    Open the `beer-time` project in the [chapter4/beer-time](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/beer-time)
    folder. Run `npm install` and `npm run dev`. Open the `App.vue` component and
    play with `true`/`false` values, and try to replace `v-if` with `v-show`. Open
    devtools and check the **`elements`** tab.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-show`属性做的是同样的工作。唯一的区别是，`v-if`根据条件渲染或不渲染元素，而`v-show`属性总是渲染元素，只是在条件结果为`false`时应用`display:none`
    CSS属性。让我们来看看区别。在[chapter4/beer-time](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/beer-time)文件夹中打开`beer-time`项目。运行`npm
    install`和`npm run dev`。打开`App.vue`组件，尝试使用`true`/`false`值，并尝试用`v-show`替换`v-if`。打开devtools并检查**`elements`**标签页。'
- en: Let's first check how it looks when we switch between `true` and `false` in
    the `isadmin` property value using `v-if`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先检查在`isadmin`属性值中使用`v-if`切换`true`和`false`时的外观。
- en: 'When the condition is met, everything appears as expected; the element is rendered
    and appears on the page:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件满足时，一切都如预期般出现；元素被渲染并出现在页面上：
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00278.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![使用v-if和v-show指令进行条件渲染](../Images/image00278.jpeg)'
- en: Conditional rendering using the v-if directive. Condition is met.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`v-if`指令进行条件渲染。条件满足。
- en: 'When the condition is not met, the element is not rendered:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件不满足时，元素不会被渲染：
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00279.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用v-if和v-show指令进行条件渲染](../Images/image00279.jpeg)'
- en: Conditional rendering using the v-if directive. Condition is not met.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`v-if`指令进行条件渲染。条件不满足。
- en: Note that when the condition is not fulfilled, the corresponding element is
    not rendered at all!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当条件不满足时，相应的元素根本不会被渲染！
- en: 'Let''s play with the condition result value using the `v-show` directive. When
    the condition is met, it appears in exactly the same way as it was in the previous
    case using `v-if`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`v-show`指令来玩弄条件结果值。当条件满足时，它的外观与使用`v-if`的前一种情况完全相同：
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00280.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![使用v-if和v-show指令进行条件渲染](../Images/image00280.jpeg)'
- en: Conditional rendering using the v-show directive. Condition is met.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`v-show`指令进行条件渲染。条件满足。
- en: 'Now let''s check what will happen with the element using the `v-show` directive
    when the right condition is not met:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看当条件不满足时，使用`v-show`指令的元素会发生什么：
- en: '![Conditional rendering using v-if and v-show directives](../Images/image00281.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![使用v-if和v-show指令进行条件渲染](../Images/image00281.jpeg)'
- en: Conditional rendering using the v-show directive. Condition is not met.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`v-show`指令进行条件渲染。条件不满足。
- en: In this case, everything is the same when the condition is met, but when the
    condition is not fulfilled, the element is rendered as well with the `display:none`
    CSS property.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当条件满足时，一切都是一样的，但当条件不满足时，元素也会被渲染，使用`display:none` CSS属性。
- en: How do you decide which one is better to use? On the first render, if the condition
    is not met, the `v-if` directive will not render the element at all, hence reducing
    the computation costs on the initial rendering. But, if the property changes frequently
    during runtime, the cost of rendering/removing an element is higher than just
    to apply the `display:none` property. Thus, use `v-show` with frequently changing
    properties and `v-if` if the condition will not change too much during runtime.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何决定使用哪一个更好？在第一次渲染时，如果条件不满足，`v-if`指令将根本不渲染元素，从而减少初始渲染时的计算成本。但是，如果属性在运行时频繁更改，渲染/移除元素的成本高于仅应用`display:none`属性。因此，对于频繁更改的属性，请使用`v-show`，对于在运行时不会太多更改的条件，请使用`v-if`。
- en: Let's come back to our Pomodoro application. `KittensComponent` should be conditionally
    rendered when Pomodoro is not in its working state. So, open your Pomodoro application
    code in the [chapter4/pomodoro4](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro4)
    folder.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的番茄钟应用程序。当番茄钟不处于工作状态时，应该有条件地呈现`KittensComponent`。因此，打开[chapter4/pomodoro4](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/pomodoro4)文件夹中的Pomodoro应用程序代码。
- en: 'What do you think should be used? `v-if` or `v-show`? Let''s analyze. Independently
    from what we use, should this element be visible on the initial render? The answer
    is no, because on the initial render, the user starts her working day and starts
    the Pomodoro timer. It might be better to use `v-if` to not have the cost of initial
    rendering when there is no need. But, let''s analyze another factor—the frequency
    of toggling the state that will make the kittens component visible/invisible.
    This will happen at each Pomodoro interval, right? After 15-20 minutes of work
    and then after 5 minutes of rest interval, which is, actually, not so frequent
    and will not affect the cost of rendering that much. In this case, in my opinion,
    it doesn''t matter which one you use. Let''s use `v-show`. Open the `App.vue`
    file and apply the `v-show` directive to the `kittens-component` invocation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为应该使用什么？`v-if`还是`v-show`？让我们分析一下。无论我们使用什么，这个元素在初始渲染时都应该可见吗？答案是否定的，因为在初始渲染时，用户开始工作并启动番茄钟计时器。也许最好使用`v-if`，以免在没有必要时产生初始渲染的成本。但是，让我们分析另一个因素——使小猫组件可见/不可见的状态切换的频率。这将在每个番茄钟间隔发生，对吧？在工作15-20分钟后，然后在5分钟的休息间隔后，实际上并不那么频繁，不会对渲染造成太大影响。在这种情况下，在我看来，无论你使用哪种，都无所谓。让我们使用`v-show`。打开`App.vue`文件，并将`v-show`指令应用于`kittens-component`的调用：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Open the page and try to toggle the value of `data.isworking` in the devtools
    console. You will see how the **kittens** container appears and disappears.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面，尝试在devtools控制台中切换`data.isworking`的值。您将看到**小猫**容器的出现和消失。
- en: Array iteration using the v-for directive
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用v-for指令进行数组迭代
- en: 'You probably remember that array iteration is done using the `v-for` directive
    with the following syntax:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，数组迭代是使用`v-for`指令完成的，具体语法如下：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or with components:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用组件：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For each item in the array, this will render a component and bind the component's `item`
    property to the value of the item. Of course, you remember that inside the `""`
    of the binding syntax you can use whatever JavaScript expression you want. So,
    just be creative!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组中的每个项目，这将呈现一个组件，并将组件的`item`属性绑定到项目的值。当然，你记得在绑定语法的`""`内部，你可以使用任何JavaScript表达式。所以，要有创意！
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not forget that the property we use in the binding syntax (`componentitem`)
    should be present in the component's data!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，在绑定语法（`componentitem`）中使用的属性应该存在于组件的数据中！
- en: 'Have a look, for example, at our shopping list application (The [chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)
    folder). It already uses the `v-for` syntax in `ItemsComponent` to render the
    list of items:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看我们的购物清单应用程序（[chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)文件夹）。它已经在`ItemsComponent`中使用了`v-for`语法来渲染物品列表：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`ItemComponent`, in turn, has the `item` property declared using `props`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemComponent`，反过来，使用`props`声明了`item`属性：'
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, let's do something interesting with our shopping list application. Until
    now we were dealing only with one shopping list. Imagine that you want to have
    a different shopping list for different kind of shopping. For example, you might
    have a regular shopping list for the normal groceries shopping day. You might
    have a different shopping list for the holidays. You might also want to have a
    different shopping list when you buy a new house. Let's use the power of the reusability
    of the Vue components and transform our shopping list application into the list
    of shopping lists! We will display them using Bootstrap's tab panel; for more
    information, refer to [http://getbootstrap.com/javascript/#tabs](http://getbootstrap.com/javascript/#tabs)
    .
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用我们的购物清单应用程序做一些有趣的事情。到目前为止，我们只处理了一个购物清单。想象一下，你想为不同类型的购物准备不同的购物清单。例如，你可能有一个常规的购物清单，用于正常的杂货购物日。你可能有一个不同的购物清单用于假期。当你买新房子时，你可能也想有一个不同的购物清单。让我们利用Vue组件的可重用性，将我们的购物清单应用程序转换为购物清单列表！我们将使用Bootstrap的选项卡面板来显示它们；有关更多信息，请参考[http://getbootstrap.com/javascript/#tabs](http://getbootstrap.com/javascript/#tabs)。
- en: Open your shopping list application in the IDE (the [chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)
    folder).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDE中打开您的购物清单应用程序（[chapter4/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list)文件夹）。
- en: 'First of all, we should add Bootstrap''s JavaScript file and jQuery, because
    bootstrap relies on it for doing its amazing magic. Go on and just add them manually
    to the `index.html` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该添加Bootstrap的JavaScript文件和jQuery，因为Bootstrap依赖它来进行其惊人的魔术。继续手动将它们添加到`index.html`文件中：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s establish a step-by-step overview of what we should do in order
    to transform our application into the list of shopping lists:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐步概述一下，我们应该做些什么，以便将我们的应用程序转换为购物清单列表：
- en: First of all, we must create a new component. Let's call it `ShoppingListComponent`
    and move the content of our current `App.vue` to there.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个新组件。让我们称之为`ShoppingListComponent`，并将我们当前的`App.vue`内容移动到那里。
- en: Our new `ShoppingListComponent` should contain the `props` attribute with `title`
    and `items` that it will receive from `App.vue`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新`ShoppingListComponent`应该包含`props`属性，其中包括它将从`App.vue`接收的`title`和`items`。
- en: '`ItemsComponent` should receive `items` from the `props` attribute rather than
    having it hardcoded.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ItemsComponent`应该从`props`属性接收`items`，而不是硬编码它。'
- en: In `App` component's `data`, let's declare and hardcode (for now) an array of
    `shoppinglists`, each of the items should have a title, an array of items, and
    an ID.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`组件的`data`中，让我们声明并硬编码（暂时）一个`shoppinglists`数组，每个项目应该有一个标题，一个物品数组和一个ID。
- en: '`App.vue` should import `ShoppingListComponent`, and in the template, iterate
    over the `shoppinglists` array, and for each of them, build the `html/jade` structure
    of the tabs panel for each of the shopping lists.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App.vue`应该导入`ShoppingListComponent`，并在模板中遍历`shoppinglists`数组，并为每个构建`html/jade`结构的选项卡面板。'
- en: Okay, then, let's start!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么，让我们开始吧！
- en: Creating ShoppingListComponent and modifying ItemsComponent
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建ShoppingListComponent并修改ItemsComponent
- en: 'Inside the `components` folder, create a new `ShoppingListComponent.vue`. Copy
    and paste the `App.vue` file''s content into this new file. Do not forget to declare
    `props` that will contain `title` and `items` and bind `items` to the `items-component`
    invocation inside the template. Your final code for this component should look
    something like the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`文件夹内，创建一个新的`ShoppingListComponent.vue`。将`App.vue`文件的内容复制粘贴到这个新文件中。不要忘记声明将包含`title`和`items`的`props`，并将`items`绑定到模板内的`items-component`调用。此组件的最终代码应该类似于以下内容：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that we removed the styling for the container and the container's `class`
    from the parent `div`. This part of the code should stay in `App.vue` because
    it defines the global application's container styling. Do not forget about the
    `props` attribute and binding `props` to `items-component`!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们删除了父`div`的容器样式和容器的`class`的部分。这部分代码应该留在`App.vue`中，因为它定义了全局应用程序的容器样式。不要忘记`props`属性和将`props`绑定到`items-component`！
- en: 'Open `ItemsComponent.vue` and ensure that it contains the `props` attribute
    with `items`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`ItemsComponent.vue`，确保它包含带有`items`的`props`属性：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Modifying App.vue
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改App.vue
- en: 'Now go to `App.vue`. Remove all the code inside the `<script>` and `<template>`
    tags. In the `script` tag, import `ShoppingListComponent` and invoke it inside
    the `components` property:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到`App.vue`。删除`<script>`和`<template>`标签内的所有代码。在`script`标签中，导入`ShoppingListComponent`并在`components`属性内调用它：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add a `data` attribute and create a `shoppinglists` array there. Add arbitrary
    data for this array. Each of the objects of the array should have `id`, `title`,
    and `items` attributes. `items`, as you remember, must contain the `checked` and
    `text` properties. For example, your `data` property might look like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`data`属性并在那里创建一个`shoppinglists`数组。为该数组添加任意数据。该数组的每个对象应该具有`id`、`title`和`items`属性。正如你记得的那样，`items`必须包含`checked`和`text`属性。例如，你的`data`属性可能如下所示：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Be more creative than me: add more lists, more items, something nice and interesting!'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 比我更有创意：添加更多的清单，更多的项目，一些漂亮有趣的东西！
- en: 'Let''s now create a structure for composing the bootstrap tab panel based on
    iteration over the shopping list! Let''s start by defining a basic structure needed
    for tabs to work. Let''s add all the necessary classes and jade structure pretending
    that we have only one element. Let''s also write in Caps Lock all the unknowns
    that will be reused from our shopping list array:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为基于购物清单的迭代创建组合bootstrap标签面板的结构！让我们首先定义标签工作所需的基本结构。让我们添加所有必要的类和jade结构，假装我们只有一个元素。让我们还用大写锁定写出所有将从我们的购物清单数组中重复使用的未知部分：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are two elements where we need to iterate over the shopping lists array—the
    `<li>` tag that contains an `<a>` attribute and the `tab-pane` div. In the first
    case, we must bind the ID of each shopping list to the `href` and `aria-controls`
    attribute and interpolate the title. In the second case, we need to bind the `id`
    attribute to the `id` property and render the shopping list item and bind the
    `items` array and `title` to it. Easy! Let''s go. Start by adding the `v-for`
    directive to each of the elements (to the `<li>` and to the `tab-pane div` element):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个元素需要在购物清单数组上进行迭代——包含`<a>`属性的`<li>`标签和`tab-pane` div。在第一种情况下，我们必须将每个购物清单的ID绑定到`href`和`aria-controls`属性，并插入标题。在第二种情况下，我们需要将`id`属性绑定到`id`属性，并呈现购物清单项目并将`items`数组和`title`绑定到它。简单！让我们开始。首先向每个元素添加`v-for`指令（对`<li>`和`tab-pane
    div`元素）：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now replace the parts in Caps Lock with the proper bindings. Remember that to
    the `bind` attribute, we use the `v-bind:<corresponding_attribute>="expression"`
    syntax.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用正确的绑定替换大写锁定部分。记住，对于`bind`属性，我们使用`v-bind:<corresponding_attribute>="expression"`语法。
- en: 'For the `href` attribute of the anchor element, we have to define an expression
    that appends the ID selector `#` to `id: v-bind:href="''#'' + list.id"`. The `aria-controls`
    attribute should be bound to the value of the ID. `title` can be bound using the
    simple `{{ }}` notation interpolation.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '对于锚元素的`href`属性，我们必须定义一个表达式，将ID选择器`#`附加到`id: v-bind:href="''#'' + list.id"`。`aria-controls`属性应该绑定到ID的值。`title`可以使用简单的`{{
    }}`符号插值进行绑定。'
- en: For `shopping-list-component`, we must bind `title` and `items` to the corresponding
    values of the list item. Do you remember that we defined the `title` and `items`
    properties inside the `props` of the `ShoppingListComponent`? The bindings, thus,
    should look like `v-bind:title=list.title` and `v-bind:items=list.items`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`shopping-list-component`，我们必须将`title`和`items`绑定到列表项的相应值。你还记得我们在`ShoppingListComponent`的`props`中定义了`title`和`items`属性吗？因此，绑定应该看起来像`v-bind:title=list.title`和`v-bind:items=list.items`。
- en: 'So after the proper binding attribution, the template will look like the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在适当的绑定属性之后，模板将如下所示：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''re almost done! If you open the page now, you will see both of the titles
    of the tabs appearing on the page:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成了！如果你现在打开页面，你会看到标签的标题都出现在页面上：
- en: '![Modifying App.vue](../Images/image00282.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![修改App.vue](../Images/image00282.jpeg)'
- en: Tab titles as seen on the screen after the modification
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后屏幕上看到的标签标题
- en: If you start clicking on the tabs titles, the corresponding tab panes will open.
    But this is not what we were expecting to see, right? What we were expecting is
    for the first tab to be visible (active) by default. For this to happen, we should
    add the `active` class  to the first `li` and to the first `tab-pane div`. But
    how can we do it if the code is the same for all the tabs as long as we are iterating
    through the array?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始点击标签标题，相应的标签窗格将打开。但这不是我们期望看到的，对吧？我们期望的是第一个标签默认可见（活动状态）。为了实现这一点，我们应该将`active`类添加到第一个`li`和第一个`tab-pane
    div`中。但是，如果代码对所有标签都是相同的，因为我们正在遍历数组，我们该怎么做呢？
- en: 'Fortunately, for us, Vue allows us to provide not only the *iteration item*
    inside the `v-for` loop, but also `index`, and then reuse this `index` variable
    inside the expressions used in the templates. Thus, we can use it to conditionally
    render the `active` class if the index is "0". Using the `index` variable inside
    the `v-for` loop is as easy as the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Vue允许我们在`v-for`循环内不仅提供*迭代项*，还提供`index`，然后在模板中的表达式中重用这个`index`变量。因此，我们可以使用它来有条件地渲染`active`类，如果索引是"0"的话。在`v-for`循环内使用`index`变量就像下面这样简单：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The syntax for class binding is the same as for everything else (`class` is
    also an attribute):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 类绑定的语法与其他所有内容的语法相同（`class`也是一个属性）：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Do you remember that we can write any JavaScript expression inside the quotes?
    In this case, we want to write a condition that evaluates the value of `index`,
    and in case it is "0", the value of class is `active`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们可以在引号内写任何JavaScript表达式吗？在这种情况下，我们想要编写一个条件，评估`index`的值，如果是"0"，则类的值是`active`：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the `index` variable to the `v-for` modifiers and the `class` bindings
    to the `li` and to the `tab-pane` element, so that the final template code looks
    like following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将`index`变量添加到`v-for`修饰符和`li`和`tab-pane`元素的`class`绑定中，使得最终的模板代码看起来像下面这样：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Look at the page. Now you should see nice tabs that display the content by
    default:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这页。现在你应该看到漂亮的标签，它们默认显示内容：
- en: '![Modifying App.vue](../Images/image00283.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![修改App.vue](../Images/image00283.jpeg)'
- en: The look and feel of  the shopping list application after the correct class
    binding
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的类绑定后的购物清单应用程序的外观和感觉
- en: The final shopping list application code after these modifications can be found
    in the [chapter4/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list2)
    folder.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些修改后，最终的购物清单应用程序代码可以在[chapter4/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list2)文件夹中找到。
- en: Event listeners using the v-on directive
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用v-on指令的事件监听器
- en: 'It is very easy to listen to the events and call callbacks using Vue.js. Event
    listening is also done using a special directive with specific modifiers for each
    of the event types. The directive is `v-on`. The modifiers are applied after the
    colon:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue.js监听事件并调用回调非常容易。事件监听也是使用特定修饰符的特殊指令完成的。该指令是`v-on`。修饰符在冒号之后应用：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Ok, you say, and where do I declare this method? You will probably not believe
    me, but all the component''s methods are declared inside the `methods` property!
    So, to declare the method called `myMethod`, you should do the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你说，我在哪里声明这个方法？你可能不会相信，但所有组件的方法都是在`methods`属性内声明的！因此，要声明名为`myMethod`的方法，你应该这样做：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: All the `data` and `props` attributes are accessible inside the methods using
    the `this` keyword.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`data`和`props`属性都可以使用`this`关键字在方法内部访问。
- en: Let's add a method to add a new item to the `items` array. We have actually
    done it already in the previous chapter, when we learned how to pass data between
    parent and children components using the events emitting system. We will just
    recap this part here.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个方法来向`items`数组中添加新项目。实际上，在上一章中，当我们学习如何在父子组件之间传递数据时，我们已经做过了。我们只是在这里回顾一下这部分。
- en: 'In order to be able to add new items within `AddItemComponent` to the shopping
    list that belongs to `ShoppingListComponent`, we should do the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在属于`ShoppingListComponent`的购物清单中向`AddItemComponent`内添加新项目，我们应该这样做：
- en: Ensure that `AddItemComponent` has a `data` property called `newItem`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保`AddItemComponent`有一个名为`newItem`的`data`属性。
- en: Create an `addItem` method inside the `AddItemComponent` that pushes the `newItem`
    and emits the event `add`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AddItemComponent`内创建一个名为`addItem`的方法，该方法推送`newItem`并触发`add`事件。
- en: Apply an event listener to the **`Add!`** button using the `v-on:click` directive.
    This event listener should call the defined `addItem` method.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`v-on:click`指令为**`Add!`**按钮应用一个事件监听器。此事件监听器应调用已定义的`addItem`方法。
- en: Create an `addItem` method inside the `ShoppingListComponent` that will receive
    the `text` as a parameter and push it to the `items` array.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ShoppingListComponent`内创建一个名为`addItem`的方法，该方法将接收`text`作为参数，并将其推送到`items`数组中。
- en: Bind the `v-on` directive with a custom `add` modifier to the `add-item-component`
    invocation inside the `ShoppingListComponent`. This listener will call the `addItem`
    method defined in this component.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`v-on`指令与自定义的`add`修饰符绑定到`ShoppingListComponent`内的`add-item-component`的调用上。此监听器将调用此组件中定义的`addItem`方法。
- en: Let's go then! Use the shopping list application from the [chapter4/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list2)
    folder and play with it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！使用[chapter4/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list2)文件夹中的购物清单应用程序并进行操作。
- en: 'Start by opening `AddItemComponent` and add the missing `v-on` directive to
    the **`Add!`** button and the `addItem` method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开`AddItemComponent`，并为**`Add!`**按钮和`addItem`方法添加缺失的`v-on`指令：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Switch to `ShoppingListComponent` and bind the `v-on:add` directive to the
    invocation of `add-item-component` inside the `template` tag:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到`ShoppingListComponent`，并将`v-on:add`指令绑定到`template`标签内的`add-item-component`的调用上：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now create the `addItem` method inside the `ShoppingListComponent`. It should
    receive the text and just push it into the `this.items` array:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`ShoppingListComponent`内创建`addItem`方法。它应该接收文本，并将其推入`this.items`数组中：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Open the page and try to add the items to the list by typing in the input box
    and clicking the button afterward. It works!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面，尝试通过在输入框中输入并点击按钮来将项目添加到列表中。它有效！
- en: Now, I would like to ask you to switch your role from the application's developer
    to its user. Type the new item in the input box. What is the obvious user action
    after the item has been introduced? Aren't you trying to hit the *Enter* button?
    I bet you are! When nothing is happening, it is a little bit frustrating, isn't
    it? Don't worry, my friend, we just have to add one more event listener to the
    input box and call the same method as we did with the **`Add!`** button.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想请你将角色从应用程序的开发人员切换到其用户。在输入框中输入新项目。项目介绍后，用户显而易见的动作是什么？难道你不是想按*Enter*按钮吗？我敢打赌你是！当什么都没有发生时，这有点令人沮丧，不是吗？别担心，我的朋友，我们只需要向输入框添加一个事件侦听器，并调用与**`Add!`**按钮相同的方法。
- en: 'Sounds easy, right? What event is fired when we''re hitting the *Enter* button?
    Right, it is the keyup event. So, we just have to use the `v-on` directive with
    the `keyup` method after the delimiter colon: `v-on:keyup`. The problem is that
    this event is fired when any keyboard button is hit, which means that while we''re
    typing the new shopping list item, each time the new letter is being introduced,
    the method will be called. This is not what we want. Of course, we could add a
    condition inside our `addItem` method that would check for the `event.code` attribute
    and, only in case it''s `13` (which corresponds to the *Enter* key), we would
    call the rest of the method. Fortunately, for us, Vue provides a mechanism to
    provide keystroke modifiers to this method that allows us to only call a method
    if a certain key code was hit. It should be implemented using the dot (`.`) modifier.
    In our case, it is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很容易，对吧？我们按*Enter*按钮时触发了什么事件？对，就是keyup事件。因此，我们只需要在冒号分隔符后使用`v-on`指令和`keyup`方法。问题是，当我们按下新的购物清单项目时，每次引入新字母时，该方法都会被调用。这不是我们想要的。当然，我们可以在`addItem`方法内添加一个条件，检查`event.code`属性，并且只有在它是`13`（对应*Enter*键）时，我们才会调用方法的其余部分。幸运的是，对于我们来说，Vue提供了一种机制，可以为此方法提供按键修饰符，这样我们只能在按下特定按键时调用方法。它应该使用点（`.`）修饰符实现。在我们的情况下，如下所示：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s add it to our input box. Go to `AddItemComponent` and add the `v-on:keyup.enter` directive
    to the input as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到我们的输入框中。转到`AddItemComponent`，并将`v-on:keyup.enter`指令添加到输入中，如下所示：
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Open the page and try to add the item to the shopping list using the *Enter*
    button. It works!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面，尝试使用*Enter*按钮将项目添加到购物清单中。它有效！
- en: 'Let''s do the same for title changing. The only difference is that the adding
    items, we used a custom `add` event and here we will use the native input event.
    We have already done it. We just have to perform the following steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对标题更改做同样的事情。唯一的区别是，在添加项目时，我们使用了自定义的`add`事件，而在这里我们将使用原生的输入事件。我们已经做到了。我们只需要执行以下步骤：
- en: Bind the model title using the `v-model` directive to `change-title-component`
    in the template of the `ShoppingListComponent`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShoppingListComponent`的模板中，使用`v-model`指令将模型标题绑定到`change-title-component`。
- en: Export `value` in the `props` attribute of the `ChangeTitleComponent`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ChangeTitleComponent`的`props`属性中导出`value`。
- en: Create an `onInput` method inside the `ChangeTitleComponent` that will emit
    the native `input` method with the value of the event target.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ChangeTitleComponent`内创建一个`onInput`方法，该方法将使用事件目标的值发出原生的`input`方法。
- en: Bind `value` to `input` inside the `ChangeTitleComponent` component's template
    and the `v-on` directive with the `onInput` modifier.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `value` 绑定到 `ChangeTitleComponent` 组件模板中的 `input`，并使用带有 `onInput` 修饰符的 `v-on`
    指令。
- en: 'Thus, the `change-title-component` invocation inside the `ShoppingListComponent`
    template will look like the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `ShoppingListComponent` 模板中的 `change-title-component` 调用将如下所示：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`ChangeTitleComponent` will look like the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChangeTitleComponent` 将如下所示：'
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The final code for this part can be found in the [chapter4/shopping-list3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list3)
    folder.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分的最终代码可以在 [chapter4/shopping-list3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list3)
    文件夹中找到。
- en: Shorthands
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简写
- en: 'Of course, it is not time consuming to write the `v-bind` or `v-on` directive
    in the code each time. Developers tend to think that each time we decrease the
    amount of code, we win. Vue.js allows us to win! Just remember that the shorthand
    for the `v-bind` directive is a colon (`:`) and the shorthand for the `v-on` directive
    is the `@` symbol. This means that the following code does the same thing:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每次在代码中写 `v-bind` 或 `v-on` 指令并不费时。开发人员倾向于认为每次减少代码量，我们就赢了。Vue.js 允许我们赢！只需记住
    `v-bind` 指令的简写是冒号（`:`），`v-on` 指令的简写是 `@` 符号。这意味着以下代码做了同样的事情：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Exercise
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Rewrite all the `v-bind` and `v-on` directives in the shopping list application
    using the shortcuts we just learned.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们刚学到的快捷方式重写购物清单应用程序中的所有 `v-bind` 和 `v-on` 指令。
- en: Check yourself by looking at the [chapter4/shopping-list4](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list4)
    folder.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 [chapter4/shopping-list4](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter4/shopping-list4)
    文件夹来检查自己。
- en: Kittens
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小猫
- en: 'In this chapter, we haven''t touched a lot on our Pomodoro application with
    its nice kittens. I promise you that we''ll do a lot of it in the next chapter.
    In the meantime, I hope that this kitten will make you happy:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们并没有涉及到我们的番茄钟应用程序及其可爱的小猫。我向您保证，我们将在下一章中大量涉及它。与此同时，我希望这只小猫会让您开心：
- en: '![Kittens](../Images/image00284.jpeg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![小猫](../Images/image00284.jpeg)'
- en: Kitten asking "What's next?"
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 小猫问：“接下来做什么？”
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we had an extensive overview of all the possible ways of binding
    data to our presentation layer. You learned how to simply interpolate data using
    handlebars brackets (`{{ }}`). You also learned how to use JavaScript expressions
    and filters in such an interpolation. You learned and applied directives such
    as `v-bind`, `v-model`, `v-for`, `v-if`, and `v-show`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对将数据绑定到我们的表示层的所有可能方式进行了广泛的概述。您学会了如何简单地使用句柄括号（`{{ }}`）插值数据。您还学会了如何在这样的插值中使用
    JavaScript 表达式和过滤器。您学习并应用了诸如 `v-bind`、`v-model`、`v-for`、`v-if` 和 `v-show` 等指令。
- en: We modified our applications so that they use richer and more efficient data-binding
    syntax.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了我们的应用程序，使它们使用更丰富和更高效的数据绑定语法。
- en: In the next chapter, we will talk about Vuex**,** the state management architecture
    inspired by Flux and Redux but with simplified concepts.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 Vuex，这是受 Flux 和 Redux 启发的状态管理架构，但具有简化的概念。
- en: We will create global application state management stores for both of our applications
    and explore their potential by working with it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的两个应用程序创建全局应用程序状态管理存储，并通过使用它来探索它们的潜力。
