- en: Chapter 8. Deploying – Time to Go Live!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。部署-时间上线！
- en: In the previous chapter, you learned how to test your Vue applications. We tested
    them applying different testing techniques. In the beginning, we have performed
    classic unit testing on Vue components and on Vuex-related modules, such as actions,
    mutations, and getters. After that, we learned how to apply end-to-end testing
    techniques using Nightwatch.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学会了如何测试您的Vue应用程序。我们应用了不同的测试技术进行测试。一开始，我们对Vue组件和与Vuex相关的模块（如actions、mutations和getters）进行了经典的单元测试。之后，我们学会了如何使用Nightwatch应用端到端测试技术。
- en: In this chapter, we will make our applications go live by deploying them to
    a server and making them available to the world. We will also guarantee continuous
    integration and continuous deployment of our applications. This means that every
    time we commit changes performed on the applications, they will automatically
    be tested and deployed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过将应用程序部署到服务器并使其对世界可用来使我们的应用程序上线。我们还将保证我们的应用程序进行持续集成和持续部署。这意味着每当我们提交对应用程序所做的更改时，它们将自动进行测试和部署。
- en: 'With this in mind, in this chapter, we are going to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，在本章中，我们将做以下事情：
- en: Set up a continuous integration process using Travis
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Travis设置持续集成流程
- en: Set up a continuous deployment using Heroku
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Heroku设置持续部署
- en: Software deployment
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件部署
- en: 'Before starting to deploy our applications, let''s first try to define what
    it actually means:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始部署我们的应用程序之前，让我们首先尝试定义它实际上意味着什么：
- en: '*"Software deployment is all of the activities that make a software system
    available for use."                                         – Wikipedia: https://en.wikipedia.org/wiki/Software_deployment*'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“软件部署是使软件系统可供使用的所有活动。” - 维基百科：https://en.wikipedia.org/wiki/Software_deployment*'
- en: 'This definition means that after we perform all the necessary activities, our
    software will be accessible to the public. In our case, as we are deploying web
    applications, it means that there will be a public URL, and any person will be
    able to type this URL on their browser and access the application. How can this
    be achieved? The simplest way is to provide your own IP address to your friends
    and run the application. Thus, people inside your private network will be able
    to access the application on their browser. So, run, for example, the Pomodoro
    application:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义意味着在我们执行所有必要的活动之后，我们的软件将对公众可用。在我们的情况下，由于我们正在部署Web应用程序，这意味着将有一个公共URL，任何人都可以在其浏览器中输入此URL并访问该应用程序。如何实现这一点？最简单的方法是向您的朋友提供您自己的IP地址并运行该应用程序。因此，在您的私人网络内的人将能够在其浏览器上访问该应用程序。因此，例如，运行番茄钟应用程序：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And then check your IP:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后检查你的IP：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Software deployment](../Images/image00315.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![软件部署](../Images/image00315.jpeg)'
- en: Checking the IP address with the ifconfig command
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ifconfig命令检查IP地址
- en: And then share the address with your friends on the same private network. In
    my case, it would be `http://192.168.1.6:8080`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后与在同一私人网络上的朋友分享地址。在我的情况下，它将是`http://192.168.1.6:8080`。
- en: However, only your friends who are inside your network will be able to access
    the application, and there's obviously not that much fun in it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有在你的网络内的朋友才能访问该应用程序，显然这样并不那么有趣。
- en: 'You can use some software that will create a publicly accessible address and
    thus transform your computer into a hosting provider, for example, **ngrok** (
    [https://ngrok.com/](https://ngrok.com/) ). Run the application and then run the
    following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一些软件来创建一个公共可访问的地址，从而将您的计算机转变为一个托管提供者，例如**ngrok**（[https://ngrok.com/](https://ngrok.com/)）。运行该应用程序，然后运行以下命令：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will create an address that will be accessible from anywhere, just like
    a regular website:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个地址，可以从任何地方访问，就像一个常规网站：
- en: '![Software deployment](../Images/image00316.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![软件部署](../Images/image00316.jpeg)'
- en: Using ngrok to provide a tunnel to your localhost
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ngrok为本地主机提供隧道
- en: In my case, it would be `http://5dcb8d46.ngrok.io` . I can share this address
    on my social networks and everybody will be able to access it and try the Pomodoro
    application! But stop ... I can leave my laptop on for the whole night, but I
    can't leave it on forever. Once I switch it off, the network connection is lost
    and there is no access to my application anymore. Also, even if I could leave
    it on forever, I don't like this website address. It's a bunch of letters and
    numbers, and I want it to be something meaningful.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，它将是`http://5dcb8d46.ngrok.io`。我可以在我的社交网络上分享这个地址，每个人都可以访问并尝试Pomodoro应用程序！但是停下…我可以让我的笔记本电脑整夜开着，但我不能永远让它开着。一旦我关闭它，网络连接就会丢失，我的应用程序就无法访问了。而且，即使我可以让它永远开着，我也不喜欢这个网站地址。这是一堆字母和数字，我希望它有意义。
- en: There are more robust ways. I can buy, for example, a virtual instance on **AWS**
    (**Amazon Web Services**), copy my application to this instance, buy a domain
    at a domain provider such as GoDaddy, associate this domain to the bought instance's
    IP, and run the application there and it will be accessible, maintained, backed
    up, and taken care of by the Amaz(on)ing service. Amazing, but ... expensive as
    hell. Let's think of this solution when our applications reach the corresponding
    size and payback level.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更强大的方法。例如，我可以在**AWS**（**亚马逊网络服务**）上购买一个虚拟实例，将我的应用程序复制到这个实例上，在GoDaddy等域名提供商购买一个域名，将该域名与购买的实例IP关联，并在那里运行应用程序，它将是可访问的，维护、备份和由亚马逊服务照料。令人惊讶，但…贵得要命。让我们在我们的应用程序达到相应规模和回报水平时考虑这个解决方案。
- en: 'For now, for this chapter, we want our deployment solution to be cheap (where
    cheap means free), robust, and simple. That is why we will deploy our application
    to Heroku, a cloud-application platform. In order to do that, we will first host
    our application on GitHub. Do you remember that deployment is something that makes
    our applications ready to use? I consider an application to be ready to use when
    it''s tested and when tests are not failing. That is why we will also use Travis
    to guarantee the quality of our applications before their actual deployment. So,
    our necessary activities to deploy the application will be the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，在这一章中，我们希望我们的部署解决方案是便宜的（便宜意味着免费）、强大和简单。这就是为什么我们将部署我们的应用程序到Heroku，一个云应用平台。为了做到这一点，我们将首先将我们的应用程序托管在GitHub上。你还记得部署是使我们的应用程序准备好使用的东西吗？我认为一个应用程序在经过测试并且测试没有失败时才能使用。这就是为什么在实际部署之前，我们还将使用Travis来保证我们应用程序的质量。因此，我们部署应用程序的必要活动将是以下内容：
- en: Create GitHub repositories for the applications and move the applications into
    the repositories.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用程序创建GitHub存储库，并将应用程序移入存储库。
- en: Set up continuous integration with Travis.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Travis进行持续集成。
- en: Connect applications to Heroku, and set up and configure them in order for Heroku
    to run them and to expose them to the world.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序连接到Heroku，并设置和配置它们，以便Heroku运行它们并向世界公开它们。
- en: In the next three subsections, I will give a small introduction to GitHub, Travis,
    and Heroku.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三个小节中，我将简要介绍GitHub、Travis和Heroku。
- en: What is GitHub?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub是什么？
- en: GitHub is a hosting provider for Git-based projects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub是基于Git的项目的托管提供商。
- en: It can be used at a small, personal scale for individual private and public
    projects. It can also be used for big corporate projects and all development-related
    activities, such as code reviews, continuous integration, and so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在小型个人规模上用于个人私人和公共项目。它也可以用于大型企业项目和所有与开发相关的活动，如代码审查，持续集成等等。
- en: Everyone who lives in the world of open source software knows GitHub. If you
    are reading this book about Vue, which is hosted on GitHub ( [https://github.com/vuejs/](https://github.com/vuejs/)
    ), I am sure that you are skipping this subsection, so probably I can write some
    stupid jokes about you here and you will never notice them! Just kidding!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 生活在开源软件世界的每个人都知道GitHub。如果你正在阅读这本关于Vue的书，它托管在GitHub上（[https://github.com/vuejs/](https://github.com/vuejs/)），我相信你会跳过这一小节，所以我可能会在这里写一些愚蠢的笑话，而你永远不会注意到它们！开玩笑！
- en: What is Travis?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Travis是什么？
- en: Travis is a tool for GitHub that allows us to connect GitHub projects to it
    and ensure their quality. It runs tests in your projects and tells you that build
    has passed, or warns you that build has failed. Check more about Travis and how
    to use it at  [https://travis-ci.org/](https://travis-ci.org/) .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Travis是GitHub的一个工具，它允许我们将GitHub项目连接到它，并确保它们的质量。它在您的项目中运行测试，并告诉您构建是否通过，或者警告您构建失败了。在[https://travis-ci.org/](https://travis-ci.org/)上了解更多关于Travis以及如何使用它。
- en: What is Heroku?
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Heroku是什么？
- en: Heroku is a cloud platform for deploying your apps. It is extremely easy to
    use. You just create an application, give it a nice meaningful name, connect it
    to your GitHub project, and voilà! Each time you push to a given branch (for example,
    to the `master` branch), Heroku will just run a script provided by you as an entry
    point script of your app and redeploy it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是一个用于部署应用程序的云平台。它非常容易使用。您只需创建一个应用程序，给它一个好的有意义的名称，将其连接到您的GitHub项目，然后就完成了！每次您推送到特定分支（例如`master`分支），Heroku将运行您提供的脚本作为应用程序的入口点脚本，并重新部署它。
- en: It is highly configurable and also provides a command-line interface so that
    you can access all your applications from your local command line without having
    to check your Heroku dashboard website. Let's then start and learn everything
    by doing it ourselves.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它是高度可配置的，还提供了命令行界面，这样您就可以从本地命令行访问所有应用程序，而无需检查Heroku仪表板网站。让我们开始学习并亲自做一切。
- en: Moving the application to the GitHub repository
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序移动到GitHub存储库
- en: Let's start by creating the GitHub repositories for our applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为我们的应用程序创建GitHub存储库开始。
- en: Please use the code from the [chapter8/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter8/pomodoro)
    and [chapter8/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter8/shopping-list)
    directories.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用[chapter8/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter8/pomodoro)和[chapter8/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter8/shopping-list)目录中的代码。
- en: 'If you still don''t have an account at GitHub, create it. Now log in to your
    GitHub account and create two repositories, `Pomodoro` and `ShoppingList`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有GitHub帐户，请创建一个。现在登录到您的GitHub帐户并创建两个存储库，`Pomodoro`和`ShoppingList`：
- en: '![Moving the application to the GitHub repository](../Images/image00317.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![将应用程序移动到GitHub存储库](../Images/image00317.jpeg)'
- en: Create a repository at GitHub
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上创建存储库
- en: 'Once you hit the **`Create repository`** button, a page with different instructions
    appears. We are particularly interested in the second paragraph, which says **`...or
    create a new repository on the command line`**. Copy it, paste it to the command
    line while in the Pomodoro application directory, remove the first line (because
    we already have the README file) and modify the third line to add everything inside
    the directory, and hit the *Enter* button:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击**`创建存储库`**按钮，会出现一个包含不同指令的页面。我们特别关注第二段，它说**`...或在命令行上创建一个新的存储库`**。复制它，粘贴到Pomodoro应用程序目录中的命令行中，删除第一行（因为我们已经有了README文件），并修改第三行以添加目录中的所有内容，然后点击*Enter*按钮：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Refresh your GitHub project page, and you will see that all the code is there!
    In my case, it is at [https://github.com/chudaol/Pomodoro](https://github.com/chudaol/Pomodoro)
    .
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新你的GitHub项目页面，你会看到所有的代码都在那里！在我的情况下，它在[https://github.com/chudaol/Pomodoro](https://github.com/chudaol/Pomodoro)。
- en: 'Do the same for the shopping list application. I just did it and here I am:
    [https://github.com/chudaol/ShoppingList](https://github.com/chudaol/ShoppingList)
    .'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于购物清单应用程序也是一样。我刚刚做了，现在在这里：[https://github.com/chudaol/ShoppingList](https://github.com/chudaol/ShoppingList)。
- en: If you don't want to create your own repositories, you can just fork mine. Open
    source is open!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想创建自己的存储库，你可以直接fork我的。开源就是开放的！
- en: Setting continuous integration with Travis
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Travis设置持续集成
- en: 'In order to be able to set up continuous integration with Travis, first of
    all you have to connect your Travis account with your GitHub account. Open [https://travis-ci.org/](https://travis-ci.org/)
    and click on the **`Sign in with GitHub`** button:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用Travis设置持续集成，首先你必须将你的Travis账户与你的GitHub账户连接起来。打开[https://travis-ci.org/](https://travis-ci.org/)，点击**`使用GitHub登录`**按钮：
- en: '![Setting continuous integration with Travis](../Images/image00318.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![使用Travis设置持续集成](../Images/image00318.jpeg)'
- en: Click on the Sign in with GitHub button
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 点击使用GitHub登录按钮
- en: 'Now you can add repositories that will be tracked with Travis. Click on the
    plus sign (**`+`**):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以添加要由Travis跟踪的存储库。点击加号（**`+`**）：
- en: '![Setting continuous integration with Travis](../Images/image00319.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![使用Travis设置持续集成](../Images/image00319.jpeg)'
- en: Click on the plus sign to add your GitHub project
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 点击加号添加你的GitHub项目
- en: 'After you click on the plus button, the whole list of your GitHub project appears.
    Choose the projects you want to track:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 点击加号按钮后，你的GitHub项目的整个列表会出现。选择你想要跟踪的项目：
- en: '![Setting continuous integration with Travis](../Images/image00320.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![使用Travis设置持续集成](../Images/image00320.jpeg)'
- en: Choose the projects you want to track with Travis
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你想要用Travis跟踪的项目
- en: 'Now that we have our projects connected to the Travis build system that listens
    to every commit and push to the `master` branch, we need to tell it somehow what
    it has to do once it detects changes. All the configuration for Travis should
    be stored in the `.travis.yml` file. Add the `.travis.yml` file to both the projects.
    We have at least to tell which node version should be used. Check the Node version
    of your system (this is the one that you are completely sure that works with our
    projects). Just run the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目已经连接到Travis构建系统，它会监听对`master`分支的每次提交和推送，我们需要告诉它一些东西，一旦它检测到变化。所有Travis的配置都应该存储在`.travis.yml`文件中。将`.travis.yml`文件添加到这两个项目中。至少我们要告诉它应该使用哪个节点版本。检查你系统的Node版本（这是你完全确定可以与我们的项目一起工作的版本）。只需运行以下命令：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In my case, it is `v5.11.0`. So I will add it to the `.travis.yml` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，它是`v5.11.0`。所以我会把它添加到`.travis.yml`文件中：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you commit and push now, you will see that Travis automatically starts running
    tests. By default, it calls the `npm test` command on the project. Wait for a
    few minutes and observe the result. Unfortunately, it will fail while performing
    end-to-end (Selenium) tests. Why does this happen?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在提交并推送，你会发现Travis会自动开始运行测试。默认情况下，它会在项目上调用`npm test`命令。等待几分钟，观察结果。不幸的是，在执行端到端（Selenium）测试时会失败。为什么会发生这种情况呢？
- en: 'By default, virtual images of the Travis building and testing environment do
    not have the Chrome browser installed. And our Selenium tests are trying to run
    on the Chrome browser. But fortunately for us, Travis provides a mechanism of
    performing some commands before building. It should be done in the `before_script`
    section of the YML file. Let''s invoke the necessary commands to install Chrome
    and export the `CHROME_BIN` variable. Add the following to your `.travis.yml`
    files:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Travis构建和测试环境的虚拟镜像没有安装Chrome浏览器。而我们的Selenium测试正试图在Chrome浏览器上运行。但幸运的是，Travis提供了在构建之前执行一些命令的机制。这应该在YML文件的`before_script`部分中完成。让我们调用必要的命令来安装Chrome并导出`CHROME_BIN`变量。将以下内容添加到你的`.travis.yml`文件中：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, in order to perform the installation and system update, we
    must invoke commands with `sudo`. By default, Travis does not let you execute
    `sudo` commands in order to prevent accidental damage by non-trustworthy scripts.
    But you can tell Travis explicitly that your script uses `sudo`, which means that
    you are aware of what are you doing. Just add the following lines to your `.travis.yml`
    files:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，为了执行安装和系统更新，我们必须使用`sudo`来调用命令。默认情况下，Travis不允许你执行`sudo`命令，以防止不可信任的脚本造成意外损害。但你可以明确告诉Travis你的脚本使用了`sudo`，这意味着你知道自己在做什么。只需将以下行添加到你的`.travis.yml`文件中：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now your whole `.travis.yml` file should look like the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的整个`.travis.yml`文件应该如下所示：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Try to commit it and check your Travis dashboard.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试提交并检查你的Travis仪表板。
- en: 'Oh no! It fails again. This time, it seems to be timeout issue:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，不！它又失败了。这次，似乎是超时问题：
- en: '![Setting continuous integration with Travis](../Images/image00321.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![使用Travis进行持续集成设置](../Images/image00321.jpeg)'
- en: Even after installing Chrome, tests silently fail due to the timeout
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 即使安装了Chrome，测试仍然会由于超时而悄悄失败
- en: Why did it happen? Let's recall what actually happens when we run our end-to-end
    tests. Each test opens the browser and then performs clicks, inputs, and other
    things to test our UI. The keyword of the last sentence is *UI*. If we need to
    test a UI, we need a **graphical user interface** (**GUI**). Travis virtual images
    do not have graphical displays. Thus, there is no way that they can open the browser
    and display our UIs in it. Fortunately for us, there is a nice thing called *Xvfb
    - X virtual framebuffer*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？让我们回想一下当我们运行端到端测试时实际发生了什么。每个测试都会打开浏览器，然后执行点击、输入和其他操作来测试我们的用户界面。最后一句话的关键词是*用户界面*。如果我们需要测试用户界面，我们需要一个**图形用户界面**（**GUI**）。Travis虚拟镜像没有图形显示。因此，它们无法打开浏览器并在其中显示我们的用户界面。幸运的是，有一种叫做*Xvfb
    - X虚拟帧缓冲*的好东西。
- en: 'Xvfb is a display server that implements the protocol used by the physical
    displays. All needed graphical operations are performed in memory; thus, there
    is no need of having physical displays. Therefore, we can run an Xvfb server that
    will provide a virtual graphical environment to our tests. And if you carefully
    read the Travis documentation, you will find that this is exactly what it suggests
    as a way of running tests that require GUI: [https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI](https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI)
    . So open the `.travis.yml` files and add the following to the `before_script`
    section:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Xvfb是一个显示服务器，实现了物理显示使用的协议。所有需要的图形操作都在内存中执行；因此，不需要物理显示。因此，我们可以运行一个Xvfb服务器，为我们的测试提供虚拟图形环境。如果您仔细阅读Travis文档，您会发现这正是它建议的运行需要GUI的测试的方法：[https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI](https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI)。因此，打开`.travis.yml`文件，并将以下内容添加到`before_script`部分：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The whole YML file now looks like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 整个YML文件现在看起来像下面这样：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Commit it and check your Travis dashboard. The Pomodoro application was built
    successfully!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 提交并检查您的Travis仪表板。Pomodoro应用程序已成功构建！
- en: '![Setting continuous integration with Travis](../Images/image00322.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![使用Travis设置持续集成](../Images/image00322.jpeg)'
- en: The Pomodoro application built with success!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Pomodoro应用程序构建成功！
- en: 'However, the shopping list application''s build has failed. Note that Travis
    even changes the tab''s title color for each of the build states:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，购物清单应用程序的构建失败了。请注意，Travis甚至会为每个构建状态更改选项卡的标题颜色：
- en: '![Setting continuous integration with Travis](../Images/image00323.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![使用Travis设置持续集成](../Images/image00323.jpeg)'
- en: Travis changes the icon on the tab's title according to the build state
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Travis根据构建状态更改选项卡标题上的图标
- en: 'So what is happening with the shopping list application build? There''s a step
    in the end-to-end test that checks for the **`Groceries`** title being present
    on the page. The thing is that this title comes from our backend server that should
    be run with the `npm run server` command. Do you remember we implemented it in
    [Chapter 6](part0061.xhtml#aid-1Q5IA1 "Chapter 6. Plugins – Building Your House
    with Your Own Bricks"), *Plugins – Building Your House with Your Own Bricks*,
    using the `vue-resource` plugin? This means that before building the application,
    we need to tell Travis to run our small server. Just add the following line to
    the `.travis.yml` file of the shopping list application:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 购物清单应用程序的构建发生了什么？在端到端测试中有一步检查页面上是否存在**`Groceries`**标题。问题是，这个标题来自我们的后端服务器，应该使用`npm
    run server`命令运行。你还记得我们在[第6章](part0061.xhtml#aid-1Q5IA1 "第6章。插件-用自己的砖头建造你的房子")中实现它的吗，*插件-用自己的砖头建造你的房子*，使用了`vue-resource`插件？这意味着在构建应用程序之前，我们需要告诉Travis运行我们的小服务器。只需将以下行添加到购物清单应用程序的`.travis.yml`文件中：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Commit your changes and check Travis dashboard. The build passed! Everything
    is green and we are happy (at least I am, and I hope that successful build makes
    you happy as well). Now it would be nice if we could tell the world that our builds
    are passing. We can do it by adding the Travis button to our `README.md` files.
    This will allow us to immediately see the build status on the project's GitHub
    page.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 提交您的更改并检查Travis仪表板。构建通过了！一切都是绿色的，我们很高兴（至少我是，我希望成功的构建也能让你开心）。现在，如果我们能告诉世界我们的构建是通过的，那就太好了。我们可以通过将Travis按钮添加到我们的`README.md`文件中来实现这一点。这将使我们能够立即在项目的GitHub页面上看到构建状态。
- en: 'Click on the **`build passing`** button on the Travis page of your application,
    check the **`Markdown`** option from the second drop-down list, and copy the generated
    text to the `README.md` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的Travis页面上点击**`构建通过`**按钮，从第二个下拉列表中选择**`Markdown`**选项，并将生成的文本复制到`README.md`文件中：
- en: '![Setting continuous integration with Travis](../Images/image00324.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![使用Travis设置持续集成](../Images/image00324.jpeg)'
- en: Click on the build passing button, select option Markdown from the second drop-down,
    and copy the text to the README.md file
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 点击通过构建按钮，从第二个下拉菜单中选择Markdown选项，并将文本复制到README.md文件中
- en: 'Look how nice it looks in the README file on the GitHub page of our project:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看看它在我们项目的GitHub页面的README文件中是多么漂亮：
- en: '![Setting continuous integration with Travis](../Images/image00325.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![使用Travis设置持续集成](../Images/image00325.jpeg)'
- en: The Travis button looks really fancy in the README file of the project on its
    GitHub page
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Travis按钮在GitHub页面上的项目的README文件中看起来真的很漂亮
- en: Now that our applications are being checked on each commit and therefore we
    have for sure guaranteed their quality, we can finally deploy them to the publicly
    accessible place.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在每次提交时都会被检查，因此我们可以确保它们的质量，最终将它们部署到公共可访问的地方。
- en: Before starting the process of deployment, please create an account at Heroku
    ( [https://signup.heroku.com/dc](https://signup.heroku.com/dc) ) and install Heroku
    Toolbelt ( [https://devcenter.heroku.com/articles/getting-started-with-nodejs#set-up](https://devcenter.heroku.com/articles/getting-started-with-nodejs#set-up)
    ).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始部署过程之前，请在Heroku（[https://signup.heroku.com/dc](https://signup.heroku.com/dc)）创建一个帐户并安装Heroku
    Toolbelt（[https://devcenter.heroku.com/articles/getting-started-with-nodejs#set-up](https://devcenter.heroku.com/articles/getting-started-with-nodejs#set-up)）。
- en: Now we are ready to deploy our projects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备部署我们的项目。
- en: Deploying the Pomodoro application
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署番茄应用程序
- en: Let's start by adding new application to our Heroku account. Click on the **`Create
    New App`** button on the Heroku dashboard. You can create your own name or leave
    the name input field blank, and Heroku will create a name for you. I will call
    my application *catodoro* because it is Pomodoro that has cats!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在Heroku账户中添加新应用开始。在Heroku仪表板上点击**`创建新应用`**按钮。你可以创建自己的名称，也可以将名称输入字段留空，Heroku会为你创建一个名称。我会将我的应用称为*catodoro*，因为它是有猫的番茄！
- en: '![Deploying the Pomodoro application](../Images/image00326.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![部署番茄应用程序](../Images/image00326.jpeg)'
- en: Creating a new app with Heroku
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Heroku创建一个新应用
- en: 'Click on the **`Create App`** button and you will proceed to the page, choosing
    a deployment pipeline for your application. Choose the GitHub method, and then
    from the proposed drop-down of your GitHub projects, choose the project that we
    want to deploy:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**`创建应用`**按钮，然后选择一个部署流水线来部署你的应用。选择GitHub方法，然后从建议的GitHub项目下拉菜单中选择我们想要部署的项目：
- en: '![Deploying the Pomodoro application](../Images/image00327.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![部署番茄应用程序](../Images/image00327.jpeg)'
- en: Choose the GitHub method of deployment and select the corresponding project
    from your GitHub projects
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 选择GitHub部署方法，并从GitHub项目中选择相应的项目
- en: 'After clicking on the **`Connect`** button, two things that you might probably
    want to check are the **`Automatic deploys from master are enabled`** and **`Wait
    for CI to pass before deploy`** options:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**`连接`**按钮后，你可能想要检查的两件事是 **`从主分支启用自动部署`** 和 **`等待CI通过后再部署`** 选项：
- en: '![Deploying the Pomodoro application](../Images/image00328.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![部署番茄应用程序](../Images/image00328.jpeg)'
- en: Check the Wait for CI to pass before deploy checkbox and click on the Enable
    Automatic Deploys button
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 勾选等待CI通过后再部署复选框，然后点击启用自动部署按钮
- en: Everything is ready to perform a first deployment and you can even click on
    the **`Deploy Branch`** button, and Heroku will try to perform a build, but then,
    if you try to open the application in the browser, it will not work. If you wonder
    why, you should always look at the running log while performing such operations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都准备好进行第一次部署，甚至可以单击**`Deploy Branch`**按钮，Heroku将尝试执行构建，但是，如果您尝试在浏览器中打开应用程序，它将无法工作。如果您想知道原因，您应该始终查看执行此类操作时的运行日志。
- en: Checking logs
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查日志
- en: 'I hope you have successfully installed the Heroku CLI (or Heroku toolbelt),
    so now you can run `heroku` commands in your command line. Let''s check the logs.
    Run the `heroku logs` command in your shell:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您已经成功安装了Heroku CLI（或Heroku工具包），现在您可以在命令行中运行`heroku`命令。让我们检查日志。在您的shell中运行`heroku
    logs`命令：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will see a continuously running log while Heroku tries to perform a build.
    And the error is `npm ERR! missing script: start`. We don''t have a `start` script
    in our `package.json` file.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '当Heroku尝试执行构建时，您将看到一个持续运行的日志。错误是`npm ERR! missing script: start`。我们在`package.json`文件中没有`start`脚本。'
- en: 'This is entirely true. In order to create a start script, let''s first try
    to understand how to build and run a Vue application for production. The README
    file tells us that we need to run the `npm run build` command. Let''s run it locally
    and check what happens:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全正确的。为了创建一个启动脚本，让我们首先尝试了解如何为生产构建和运行Vue应用程序。README文件告诉我们需要运行`npm run build`命令。让我们在本地运行它并检查发生了什么：
- en: '![Checking logs](../Images/image00329.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![检查日志](../Images/image00329.jpeg)'
- en: The output of the npm run build command
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: npm run build命令的输出
- en: So we know that the result of the build command goes to the `dist` folder. And
    we also know that we have to serve the `index.html` file from this folder using
    an HTTP server. We also know that we have to create a `start` script in the `scripts`
    section of the `package.json` file, so Heroku knows how to run our application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道构建命令的结果会进入`dist`文件夹。我们还知道我们必须使用HTTP服务器从此文件夹中提供`index.html`文件。我们还知道我们必须在`package.json`文件的`scripts`部分中创建一个`start`脚本，以便Heroku知道如何运行我们的应用程序。
- en: Preparing the application to run on Heroku
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备在Heroku上运行应用程序
- en: We were able to gather a lot of information by checking the log file. Let's
    also summarize here Heroku's pipeline for running the application before proceeding
    to the steps for deploying the application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查日志文件，我们能够收集了大量信息。在继续部署应用程序的步骤之前，让我们在这里总结一下Heroku在运行应用程序之前的流程。
- en: 'So, Heroku does the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Heroku执行以下操作：
- en: Runs the `npm install` script to install all the needed dependencies (it checks
    the dependencies in the `dependencies` section of the `package.json` file)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`npm install`脚本以安装所有所需的依赖项（它检查`package.json`文件的`dependencies`部分中的依赖项）
- en: Runs the `npm start` script from the `package.json` and serves the result of
    it on the known web address
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`package.json`运行`npm start`脚本，并在已知的web地址上提供其结果
- en: 'So, given this information and the information we gathered from the logs and
    running the `npm build` script, we need to do the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据这些信息和我们从日志和运行`npm build`脚本中收集到的信息，我们需要执行以下操作：
- en: Tell Heroku to install all the needed dependencies; for that, we need to move
    project dependencies from the `devDependencies` section to the `dependencies`
    section in the `package.json` file so that Heroku installs them all
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉Heroku安装所有所需的依赖项；为此，我们需要将项目依赖项从`package.json`文件的`devDependencies`部分移动到`dependencies`部分，以便Heroku安装它们
- en: Tell Heroku to run a build script after performing `npm install`; for that,
    we need to create a `postinstall` script in the `package.json` file where we will
    call the `npm run build` command.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉Heroku在执行`npm install`后运行构建脚本；为此，我们需要在`package.json`文件中创建一个`postinstall`脚本，其中我们将调用`npm
    run build`命令。
- en: Create a `server.js` file that serves the `index.html` file from the `dist`
    folder
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`server.js`文件，从`dist`文件夹中提供`index.html`文件
- en: Provide a way for Heroku to run the `server.js` script; for this, we need to
    create a `start` script in the `package.json` file that runs the `server.js` script
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供Heroku运行`server.js`脚本的方法；为此，我们需要在`package.json`文件中创建一个`start`脚本来运行`server.js`脚本
- en: 'Start by moving all the dependencies, except the ones that have to do with
    testing, from the `devDependencies` section to the `dependencies` section of our
    `package.json` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`package.json`文件的`devDependencies`部分中除了与测试有关的依赖之外的所有依赖移动到`dependencies`部分中：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let''s create a `postinstall` script in which we will tell Heroku to run
    the `npm run build` script. In the `scripts` section, add the `postinstall` script:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个`postinstall`脚本，在其中我们将告诉Heroku运行`npm run build`脚本。在`scripts`部分中，添加`postinstall`脚本：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now let''s create a `server.js` file in which we will serve the `index.html`
    file from the `dist` directory. Create a `server.js file` in the project''s folder
    and add the following content:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个`server.js`文件，在其中我们将从`dist`目录中提供`index.html`文件。在项目文件夹中创建一个`server.js`文件，并添加以下内容：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Okay, now we just need to create a `start` script in the `scripts` section
    of our `package.json` file and we are done! Our `start` script should just run
    `node server.js`, so let''s do it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们只需要在`package.json`文件的`scripts`部分创建一个`start`脚本，然后我们就完成了！我们的`start`脚本应该只运行`node
    server.js`，所以让我们来做吧：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Commit your changes, go to the Heroku dashboard, and click on the **`Deploy
    Branch`** button. Do not forget to check running logs!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 提交您的更改，转到Heroku仪表板，然后点击**`Deploy Branch`**按钮。不要忘记检查运行日志！
- en: And yippee! The build was successful! After a successful build, you are invited
    to click the **`View`** button; don't be shy, click on it and you will see your
    application in action!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！构建成功了！成功构建后，您被邀请点击**`View`**按钮；别害羞，点击它，您将看到您的应用程序在运行！
- en: '![Preparing the application to run on Heroku](../Images/image00330.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![准备在Heroku上运行应用程序](../Images/image00330.jpeg)'
- en: The Pomodoro application is successfully deployed to Heroku
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 番茄钟应用程序已成功部署到Heroku
- en: Now you can use your Pomodoro application everywhere. Now you can ask your friends
    to use it as well by simply providing them the Heroku link.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在任何地方使用您的番茄钟应用程序。现在您也可以邀请您的朋友使用它，只需提供Heroku链接即可。
- en: Well, congratulations! You've just deployed your Vue application, and it can
    be used by everyone. How nice is it?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚部署了您的Vue应用程序，每个人都可以使用它。多么美好啊！
- en: Deploying the shopping list application
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署购物清单应用程序
- en: In order to deploy our shopping list application, we need to perform exactly
    the same steps as we have done with the Pomodoro application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署我们的购物清单应用程序，我们需要执行与番茄钟应用程序完全相同的步骤。
- en: Create a new application on your Heroku dashboard and connect it to your GitHub
    shopping list project. After that, copy the `server.js` file from the Pomodoro
    application, deal with the dependencies in the `package.json` file, and create
    `postinstall` and `start` scripts.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Heroku仪表板上创建一个新应用程序，并将其连接到您的GitHub购物清单项目。之后，从番茄钟应用程序中复制`server.js`文件，处理`package.json`文件中的依赖关系，并创建`postinstall`和`start`脚本。
- en: However, we still have one step left. Do not forget about our backend server
    that serves the REST API for the shopping lists. We need to run it as well.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还有一步要做。不要忘记我们的后端服务器，为购物清单提供REST API。我们也需要运行它。
- en: 'Or even better, why do we need to run two servers if we can have just one server
    that does everything? We can integrate our JSON server with our express server
    by providing it the routing path to serve the shopping list endpoint, let''s say
    `api`. Open the `server.js` file, import the `jsonServer` dependency there, and
    tell the express app to use it. So, your `server.js` file will look like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更好的是，如果我们可以只运行一个服务器来完成所有工作，为什么我们需要运行两个服务器呢？我们可以通过为其提供路由路径来将我们的JSON服务器与我们的express服务器集成以提供购物清单端点，比如`api`。打开`server.js`文件，在那里导入`jsonServer`依赖项，并告诉express应用程序使用它。因此，你的`server.js`文件将如下所示：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the preceding line, we tell our express app to use `jsonServer` and serve
    the `db.json` file over the `/api/` endpoint.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前一行，我们告诉我们的express应用程序使用`jsonServer`并在`/api/`端点上提供`db.json`文件。
- en: 'We should also change the endpoint''s address in our `Vue` resource. Open `index.js` in
    the API folder and replace `localhost:3000` with an `api` prefix:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该更改`Vue`资源中的端点地址。打开API文件夹中的`index.js`，并用`api`前缀替换`localhost:3000`：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We should also add JSON server support to `dev-server.js`; otherwise, we will
    not be able to run the application in development mode. So, open the `build/dev-server.js`
    file, import `jsonServer`, and tell the express app to use it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该在`dev-server.js`中添加JSON服务器支持；否则，我们将无法以开发模式运行应用程序。因此，打开`build/dev-server.js`文件，导入`jsonServer`，并告诉express应用程序使用它：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Try to run the application in dev mode (`npm run dev`). Everything works fine.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以开发模式运行应用程序（`npm run dev`）。一切正常。
- en: You can now also remove the server running command (`- nohup npm run server
    &`) from the `travis.yml` file. You can also remove the server script from `package.json`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你也可以从`travis.yml`文件中删除运行服务器的命令（`- nohup npm run server &`）。你也可以从`package.json`中删除服务器脚本。
- en: Run tests locally and check that they are not failing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行测试并检查它们是否失败。
- en: We are almost done. Let's try our application locally.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。让我们在本地尝试我们的应用程序。
- en: Trying Heroku locally
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试在本地使用Heroku
- en: 'Sometimes it gets a lot of try-fail iterations to get things work. We try something,
    commit, push, try to deploy, see whether it works. We realize that we have forgotten
    about something, commit, push, try to deploy, see the error log. Do it again and
    again. It might be really time-consuming because things over the network take
    time! Fortunately for us, the Heroku CLI provides a way to run the application
    locally as it was already deployed to the Heroku server. You just need to run
    the `heroku local web` command right after building the application:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候要让事情运行起来需要很多次尝试和失败的迭代。我们尝试一些东西，提交，推送，尝试部署，看看是否起作用。我们意识到我们忘记了一些东西，提交，推送，尝试部署，看错误日志。一遍又一遍地做。这可能会非常耗时，因为网络上的事情需要时间！幸运的是，Heroku
    CLI提供了一种在本地运行应用程序的方法，就像它已经部署到Heroku服务器上一样。你只需要在构建应用程序后立即运行`heroku local web`命令：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Try it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 试一下。
- en: Open `http://localhost:5000` in your browser. Yes, it works!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:5000`。是的，它起作用了！
- en: '![Trying Heroku locally](../Images/image00331.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![尝试在本地使用Heroku](../Images/image00331.jpeg)'
- en: Running the application locally with the Heroku local web command. It works!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Heroku本地web命令在本地运行应用程序。它起作用了！
- en: Let's now commit and push the changes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们提交并推送更改。
- en: 'Now you can wait for the successful Travis build and automatic deploy by Heroku
    after that, or you can just open your Heroku dashboard and click on the **`Deploy
    Branch`** button. Wait a bit. And ... it works! Here is the result of two deployments
    we performed today:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以等待Travis成功构建并Heroku自动部署，或者你可以打开你的Heroku仪表板，点击**`Deploy Branch`**按钮。等一会儿。然后...
    它起作用了！这是我们今天执行的两次部署的结果：
- en: '**Pomodoro application**: [https://catodoro.herokuapp.com/](https://catodoro.herokuapp.com/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**番茄钟应用程序**：[https://catodoro.herokuapp.com/](https://catodoro.herokuapp.com/)'
- en: '**Shopping list application**:  [https://shopping-list-vue.herokuapp.com/](https://shopping-list-vue.herokuapp.com/)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**购物清单应用程序**：[https://shopping-list-vue.herokuapp.com/](https://shopping-list-vue.herokuapp.com/)'
- en: The respective GitHub repositories can be found at  [https://github.com/chudaol/Pomodoro](https://github.com/chudaol/Pomodoro)
     and  [https://github.com/chudaol/ShoppingList](https://github.com/chudaol/ShoppingList)
    .
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 各自的GitHub存储库可以在[https://github.com/chudaol/Pomodoro](https://github.com/chudaol/Pomodoro)和[https://github.com/chudaol/ShoppingList](https://github.com/chudaol/ShoppingList)找到。
- en: Fork, play, test, deploy. At this moment, you have all the instruments needed
    to enhance, improve, and show these applications to the whole world. Thank you
    for being with me through this exciting journey!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 分叉，玩耍，测试，部署。此刻，您拥有增强，改进并向全世界展示这些应用程序所需的所有工具。感谢您与我一起经历这激动人心的旅程！
