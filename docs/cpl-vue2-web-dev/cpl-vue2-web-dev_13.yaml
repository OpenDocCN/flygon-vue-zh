- en: Transitions and Animations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过渡和动画
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Integrating with third-party CSS animation libraries such as animate.css
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与animate.css等第三方CSS动画库集成
- en: Adding your own transition classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义的过渡类
- en: Animating with JavaScript instead of CSS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript而不是CSS进行动画处理
- en: Transitioning on the initial render
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始渲染上进行过渡
- en: Transitioning between elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素之间的过渡
- en: Letting an element leave before the enter phase in a transition
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过渡中，在进入阶段之前让元素离开
- en: Adding entering and leaving transitions for elements of a list
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为列表中的元素添加进入和离开过渡
- en: Transitioning elements that move in a list
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中移动的元素进行过渡
- en: Animating the state of your components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对组件的状态进行动画处理
- en: Packaging reusable transitions into components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可重用的过渡打包到组件中
- en: Dynamic transitions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态过渡
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'This chapter contains recipes related to transitions and animations. Vue has
    its own tags for dealing with transitions intended for when an element enters
    or leaves the scene: `<transition>` and `<transition-group>`. You will learn all
    about them and how to use them to give your customers a better user experience.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含与过渡和动画相关的示例。Vue具有用于处理元素进入或离开场景的过渡的标签：<transition>和<transition-group>。您将学习如何使用它们，以便为您的客户提供更好的用户体验。
- en: Vue transitions are pretty powerful in that they are completely customizable and
    can easily combine JavaScript and CSS styling while having very intuitive defaults
    that will let you write less code in case you don't want all the frills.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Vue过渡非常强大，因为它们是完全可定制的，并且可以轻松地结合JavaScript和CSS样式，同时具有非常直观的默认值，这样您就可以在不需要所有花哨效果的情况下编写更少的代码。
- en: You can animate a great deal of what happens in your components even without
    transition tags since all you have to do is bind your state variables to some
    visible property.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有过渡标签，您也可以对组件中发生的大部分内容进行动画处理，因为您只需要将状态变量绑定到某些可见属性即可。
- en: Finally, once you have mastered everything that there is to know about Vue transitions
    and animations, you can easily package these in layered components and reuse them
    throughout your application. This is what makes them not only powerful, but also
    easy to use and maintain.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦您掌握了关于Vue过渡和动画的所有知识，您可以轻松地将它们打包到分层组件中，并在整个应用程序中重复使用它们。这不仅使它们功能强大，而且易于使用和维护。
- en: Integrating with third-party CSS animation libraries such as animate.css
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与animate.css等第三方CSS动画库集成
- en: Graphical interfaces not only need to be usable and easy to understand; they
    should also provide affordability and be pleasant to use. Having transitions can
    help a great deal by giving cues of how a website works in a fun way. In this
    recipe, we will examine how to use a CSS library with our application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图形界面不仅需要可用性和易于理解，还应提供可负担性和愉悦性。通过提供过渡效果，可以以有趣的方式提供网站的工作方式的线索，这对于帮助很大。在这个示例中，我们将介绍如何在应用程序中使用CSS库。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before starting, you can take a look at [https://daneden.github.io/animate.css/](https://daneden.github.io/animate.css/),
    as shown, just to get an idea of the available animations, but you don''t really
    need any special knowledge to proceed:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，您可以查看[https://daneden.github.io/animate.css/](https://daneden.github.io/animate.css/)，如图所示，以了解可用的动画效果，但您实际上不需要任何特殊的知识来继续：
- en: '![](assets/f9ba4864-e66a-485c-a49f-10a17ecd5ecc.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/f9ba4864-e66a-485c-a49f-10a17ecd5ecc.png)
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Imagine that you are creating an app to book taxis. The interface we will create
    will be simple and fun.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您正在创建一个预订出租车的应用程序。我们将创建的界面将简单而有趣。
- en: First of all, add the `animate.css` library to the list of dependencies (refer
    to the *Choosing a development environment* recipe to learn how to do it).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`animate.css`库添加到依赖列表中（参考*选择开发环境*教程来了解如何做）。
- en: 'To proceed, we need our usual wrapper:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续，我们需要我们通常的包装器：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside, we will put a button to call for a taxi:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们将放置一个按钮来叫出租车：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can already tell that we will use the `taxiCalled` variable to keep track
    of whether the button has been pressed or not
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经可以看出我们将使用`taxiCalled`变量来跟踪按钮是否已被按下
- en: 'Let''s add an emoji that will confirm to the user when the taxi is called:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个表情符号，以向用户确认出租车已被叫到：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, we can add some JavaScript:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以添加一些JavaScript代码：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the application and you will see the taxi appear instantly when you press
    the button. We are a cool taxi company, so let''s make the taxi drive to us with
    a transition:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，当您按下按钮时，您将立即看到出租车出现。我们是一家很酷的出租车公司，所以让我们让出租车通过过渡来到我们这里：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now run your application; if you call the taxi, it will get to you by sliding
    from the right:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行您的应用程序；如果您叫出租车，它将从右侧滑动到您这里：
- en: '![](assets/888029b7-74d1-4c9a-8bff-f82c8f721b3c.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/888029b7-74d1-4c9a-8bff-f82c8f721b3c.png)'
- en: 'The taxi will slide from right to left, as shown:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 出租车将从右向左滑动，如图所示：
- en: '![](assets/d0e494f6-2f43-401d-a551-cea5cfa6aebc.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d0e494f6-2f43-401d-a551-cea5cfa6aebc.png)'
- en: How does it work...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Every transition applies four classes. Two are applied when the element enters
    the *scene* and the other two are applied when it leaves:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个过渡应用四个类。两个类应用于元素进入*场景*时，另外两个类应用于元素离开时：
- en: '| **Name** | **Applied when** | **Removed when** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **应用于** | **移除于** |'
- en: '| `v-enter` | Before the element is inserted | After one frame |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `v-enter` | 元素插入之前 | 一帧后 |'
- en: '| `v-enter-active` | Before the element is inserted | When transition ends
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `v-enter-active` | 元素插入之前 | 过渡结束时 |'
- en: '| `v-enter-to` | After one frame | When transition ends |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `v-enter-to` | 一帧后 | 过渡结束时 |'
- en: '| `v-leave` | Transition starts | After one frame |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `v-leave` | 过渡开始 | 一帧后 |'
- en: '| `v-leave-active` | Transition starts | When transition ends |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `v-leave-active` | 过渡开始 | 过渡结束时 |'
- en: '| `v-leave-to` | After one frame | When transition ends |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `v-leave-to` | 一帧后 | 过渡结束时 |'
- en: Here, the initial *v* stands for the name of your transition. If you don't specify
    a name, *v* will be used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，初始的*v*代表您的过渡名称。如果您没有指定名称，将使用*v*。
- en: While the beginning of the transition is a well-defined instant, the end of
    the transition is a bit of work for the browser to figure out. For example, if
    a CSS animation loops, the duration of the animation will only be one iteration.
    Also, this may change in future releases, so keep this in mind.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然过渡的开始是一个明确定义的瞬间，但过渡的结束对于浏览器来说需要一些工作。例如，如果CSS动画循环，动画的持续时间只有一个迭代。此外，这可能会在将来的版本中发生变化，所以请记住这一点。
- en: In our case, we wanted to provide a third-party `v-enter-active` instead of
    writing our own. The problem is that our library already has a different name
    for the class of the animation we want to use (`slideInRight`). Since we can't
    change the name of the class, we tell Vue to use `slideInRight` instead of looking
    for a `v-enter-active` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们希望提供一个第三方的`v-enter-active`，而不是编写我们自己的。问题是，我们的库已经为我们想要使用的动画类（`slideInRight`）命名为不同的名称。由于我们无法更改类的名称，我们告诉Vue使用`slideInRight`而不是寻找`v-enter-active`类。
- en: 'To do this, we used the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们使用了以下代码：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This means that our `v-enter-active` is called animated `slideInRight` now.
    Vue will append those two classes before the element is inserted and drop them
    when the transition ends. Just note that animated is a kind of helper class that
    comes with `animate.css`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的`v-enter-active`现在被称为`animated slideInRight`。Vue将在元素插入之前附加这两个类，并在过渡结束时删除它们。只需注意，animated是一种带有`animate.css`的辅助类。
- en: Adding your own transition classes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自己的过渡类
- en: If your application is rich in animations and you would like to reuse your CSS classes
    in other projects by mixing and matching them, this is the recipe for you. You
    will also understand an important technique for performant animations, called
    **FLIP** (**First Last Invert Play**). While the latter technique is normally
    triggered automatically by Vue, we will implement it manually to get a better
    understanding of how it works.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序富含动画，并且希望通过混合和匹配在其他项目中重用您的CSS类，那么这就是适合您的示例。您还将了解一种重要的性能动画技术，称为FLIP（First
    Last Invert Play）。虽然后一种技术通常由Vue自动触发，但我们将手动实现它，以更好地理解其工作原理。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you should understand how CSS animations and transitions
    work. This is out of the scope of this book, but you can find a good primer at [http://css3.bradshawenterprises.com/](https://daneden.github.io/animate.css/).
    This website is also great because it will explain when you can use animations
    and transitions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此示例，您应该了解CSS动画和过渡的工作原理。这超出了本书的范围，但您可以在[http://css3.bradshawenterprises.com/](https://daneden.github.io/animate.css/)上找到一个很好的入门指南。这个网站也很棒，因为它会解释何时可以使用动画和过渡。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will build an interface for a taxi company (similar to the preceding recipe)
    that will enable users to call a taxi at the click of a button and will provide
    a nice animated feedback when the taxi is called.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为出租车公司构建一个界面（类似于前面的示例），用户可以通过点击按钮来叫出租车，并在叫出租车时提供一个漂亮的动画反馈。
- en: 'To code the button, write the following HTML:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写按钮，请编写以下HTML代码：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you initialize the `taxiCalled` variable to `false`, as shown in the
    following JavaScript:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在JavaScript中将`taxiCalled`变量初始化为`false`，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At this point, we will create our own custom transition in CSS:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们将在CSS中创建自定义过渡：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Wrap your car emoji in a Vue transition:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的汽车表情包装在Vue过渡中：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you run your code and hit the Call a cab button, you will see a taxi stopping
    by.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行代码并点击“叫出租车”按钮时，您将看到一辆出租车停在旁边。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When we click on the button, the `taxiCalled` variable turns `true` and Vue
    inserts the taxi into your page. Before actually doing this, it reads the classes
    you specified in `enter-class` (in this case, only `slideInRight`) and applies
    it to the wrapped element (the `<p>` element with the taxi emoji). It also applies
    the classes specified in `enter-class-active` (in this case, only go).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击按钮时，`taxiCalled`变量变为`true`，Vue会将出租车插入到您的页面中。在实际执行此操作之前，它会读取您在`enter-class`中指定的类（在本例中仅为`slideInRight`），并将其应用于包装元素（带有出租车表情的`<p>`元素）。它还会应用在`enter-class-active`中指定的类（在本例中仅为go）。
- en: The classes in `enter-class` are removed after the first frame, and the classes
    in `enter-class-active` are also removed when the animation ends.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`enter-class`中的类在第一帧后被移除，`enter-class-active`中的类在动画结束时也被移除。'
- en: 'The animation created here follows the FLIP technique that is composed of four
    points:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此处创建的动画遵循FLIP技术，由四个要点组成：
- en: '**First (F)**: You take the property as it is in the first frame of your animation;
    in our case, we want the taxi to start somewhere from the right of the screen.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**First (F)**：您将属性保持在动画的第一帧中；在我们的例子中，我们希望出租车从屏幕右侧的某个位置开始。'
- en: '**Last (L)**: You take the property as it is in the last frame of your animation,
    which is the taxi at the left of the screen in our case.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Last (L)**：你将属性保持在动画的最后一帧中，对于我们的情况来说，就是屏幕左侧的出租车。'
- en: '**Invert (I)**: You invert the property change you registered between the first
    and last frame. Since our taxi moved to the left, at the final frame it will be
    at say -200 pixel offset. We invert that and set the `slideInRight` class to have
    transform as `translateX(200px)` so that the taxi will be at +200 pixel offset
    when it appears.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Invert (I)**：你反转在第一帧和最后一帧之间注册的属性变化。由于我们的出租车向左移动，在最后一帧中它将位于-200像素的偏移位置。我们反转这个并设置`slideInRight`类，使得transform为`translateX(200px)`，这样出租车出现时将位于+200像素的偏移位置。'
- en: '**Play (P)**: We create a transition for every property we have touched. In
    the taxi example, we use the transform property and so, we use `writetransition:
    all 2s ease-out` to tween the taxi smoothly.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Play (P)**：我们为每个已触摸的属性创建一个过渡效果。在出租车的例子中，我们使用了transform属性，因此我们使用`writetransition:
    all 2s ease-out`来使出租车平滑过渡。'
- en: This technique is used automatically by Vue under the cover to make transitions
    work inside the `<transition-group>` tag. More on that in the *Adding entering
    and leaving transition for elements of a list* recipe.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Vue在内部自动使用这种技术来使得在`<transition-group>`标签内的过渡效果正常工作。关于这一点，我们将在*为列表中的元素添加进入和离开过渡效果*的食谱中详细介绍。
- en: Animating with JavaScript instead of CSS
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript而不是CSS进行动画
- en: 'It''s a common misconception that animating with JavaScript is slower and that
    animations should be done in CSS. The reality is that if used correctly, animation
    in JavaScript can have similar or superior performance. In this recipe, we will
    create an animation with the help of the simple but powerful Velocity.js ([http://velocityjs.org/](http://velocityjs.org/)) library:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个普遍的误解，即使用JavaScript进行动画会更慢，而动画应该在CSS中完成。事实是，如果使用正确，JavaScript中的动画可以具有相似或更好的性能。在这个食谱中，我们将使用简单但强大的Velocity.js（[http://velocityjs.org/](http://velocityjs.org/)）库创建一个动画：
- en: '![](assets/ba4a4bef-77a9-4d77-9b99-92d7dcc8a914.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ba4a4bef-77a9-4d77-9b99-92d7dcc8a914.png)'
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe, while it presupposes no knowledge of the Velocity library, assumes
    that you are quite familiar with animations either in CSS or with JavaScript libraries,
    such as jQuery. If you've never seen a CSS animation and you want a speedy introduction,
    just complete the two preceding recipes and you should be able to follow along.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱假设你对Velocity库没有任何了解，但假设你对CSS或JavaScript库（如jQuery）中的动画非常熟悉。如果你从未见过CSS动画并且想要快速入门，只需完成前两个食谱，你就能跟上。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We're still looking for the perfect transition for a taxi company (the same
    as in the preceding recipe) that will entertain our clients while waiting for
    a taxi. We have a button to call a cab and a little taxi emoji that will appear
    when we make a reservation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍在寻找一个完美的过渡效果，用于等待出租车时娱乐我们的客户（与前一个食谱中相同）。我们有一个按钮来呼叫出租车，当我们预订时会出现一个小的出租车表情符号。
- en: Before anything else, add the Velocity library as a dependency to your project--[https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js](http://velocityjs.org/).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他操作之前，将Velocity库作为项目的依赖项添加进来--[https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js](http://velocityjs.org/)。
- en: 'Here is the HTML to create the skeleton of our interface:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建界面框架的HTML代码：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our Vue model is very simple and consists only of the `taxiCalled` variable:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Vue模型非常简单，只包含一个`taxiCalled`变量：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the animation by wrapping the little taxi in a Vue transition:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将小出租车包装在Vue过渡中来创建动画：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The enter method will be called as soon as the taxi emoji is inserted at the
    press of a button.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下按钮插入出租车表情符号时，将调用enter方法。
- en: 'The enter method, which you have to add to your Vue instance, looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: enter方法，您需要将其添加到Vue实例中，如下所示：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run your code and press the button to book your taxi!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码并按下按钮预订您的出租车！
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As you may have noted, there is no CSS in your code. The animation is purely
    driven by JavaScript. Let''s dissect our Vue transition a little:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，你的代码中没有CSS。动画完全由JavaScript驱动。让我们稍微解析一下我们的Vue过渡：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Although this is still a transition that could use CSS, we want to tell Vue
    to shut down the CSS and save precious CPU cycles by setting `:css="false"`. This
    will make Vue skip all the code related to CSS animation and will prevent CSS
    from interfering with our pure JavaScript animation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这仍然是一个可以使用CSS的过渡，但我们想告诉Vue关闭CSS并节省宝贵的CPU周期，通过设置`:css="false"`。这将使Vue跳过与CSS动画相关的所有代码，并防止CSS干扰我们纯粹的JavaScript动画。
- en: 'The juicy part is in the `@enter="enter"` bit. We are binding the hook that
    triggers when the element is inserted in to the `enter` method. The method itself
    is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 多汁的部分在`@enter="enter"`这一部分。我们将触发元素插入时的钩子绑定到`enter`方法上。方法本身如下：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are calling the Velocity library. The `el` parameter is passed for
    free by Vue, and it refers to the element that was inserted (in our case, the
    `<p>` element containing the emoji of the car).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了Velocity库。`el`参数由Vue免费传递，并且它指的是被插入的元素（在我们的例子中，是包含汽车表情的`<p>`元素）。
- en: 'The syntax of the Velocity function is as illustrated:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Velocity函数的语法如下所示：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Other syntaxes are possible, but we will stick to this one.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他语法可能，但我们将坚持使用这种语法。
- en: In our call to this function, we passed our paragraph element as the first argument;
    we then said that the opacity should change from 0 to 1 and, at the same time,
    the element should move from a starting position of 200 pixels on the x axis toward
    its origin. As options, we specified that the animation should last for two seconds
    and that we want to ease the animation near the end.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用此函数时，我们将段落元素作为第一个参数传递；然后我们说不透明度应该从0变为1，并且同时，元素应该从x轴上的起始位置200像素移动到其原点。作为选项，我们指定动画持续时间为两秒，并且我们希望在接近结束时缓和动画。
- en: I think everything is pretty clear maybe except how we are passing the `opacity`
    and `translateX` parameters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为一切都很清楚，除了我们如何传递`opacity`和`translateX`参数。
- en: This is what Velocity calls **forcefeeding**--we are telling Velocity that the
    opacity should start from 0 and go to 1\. Likewise, we are telling Velocity that
    the `translateX` property should start at 200 pixels, ending at 0 pixels.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Velocity所谓的**强制喂食**--我们告诉Velocity不透明度应该从0开始到1结束。同样，我们告诉Velocity`translateX`属性应该从200像素开始，结束于0像素。
- en: In general, we can avoid passing arrays to specify the initial value for the
    properties; Velocity will calculate how to transition.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们可以避免传递数组来指定属性的初始值；Velocity会计算如何过渡。
- en: 'For example, we could have had the following CSS class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以有以下CSS类：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we rewrite the Velocity call as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将Velocity调用重写如下：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The car will slowly appear. Velocity queried the DOM for the initial value of
    the element and then transitioned it to 1\. The problem with this approach is
    that since a query to the DOM is involved, some animations could be slower, especially
    when you have a lot of concurrent animations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车将慢慢出现。Velocity查询了元素的初始值，然后将其过渡到1。这种方法的问题是，由于涉及对DOM的查询，某些动画可能会变慢，特别是当您有很多并发动画时。
- en: 'Another way we can obtain the same effect as force-feeding is by using the
    begin option, like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用begin选项来获得与强制喂食相同的效果，如下所示：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will set the opacity to zero just before the animation begins (and hence,
    before the element is inserted). This will help in slower browsers in which forcefeeding
    will still display a flash of the car before bringing it all the way to the right
    and starting the animation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在动画开始之前（因此在元素插入之前）将不透明度设置为零。这将有助于在较慢的浏览器中，强制显示仍然会在将其完全移到右侧并开始动画之前显示一闪而过的汽车。
- en: 'The possible hooks for JavaScript animations are summarized in this table:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript动画的可能钩子在下表中总结：
- en: '| **Attribute** | **Description** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `@before-enter` | This function is called before the element is inserted.
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `@before-enter` | 在元素插入之前调用此函数。 |'
- en: '| `@enter` | This function is called when the element is inserted. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `@enter` | 当元素插入时调用此函数。 |'
- en: '| `@after-enter` | This function is called when the element is inserted and
    the animation is finished. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `@after-enter` | 当元素插入并且动画完成时调用此函数。 |'
- en: '| `@enter-cancelled` | This function is called when the animation is still
    in progress, but the element has to leave. If you use Velocity you can do something
    like `Velocity(el, "stop")`. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `@enter-cancelled` | 当动画仍在进行中但元素必须离开时调用此函数。如果使用Velocity，可以执行类似于`Velocity(el,
    "stop")`的操作。 |'
- en: '| `@before-leave` | This function is called before the leave function is triggered.
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `@before-leave` | 在触发离开函数之前调用此函数。 |'
- en: '| `@leave` | This function is called when the element leaves. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `@leave` | 当元素离开时调用此函数。 |'
- en: '| `@after-leave` | This function is called when the element leaves the page.
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `@after-leave` | 当元素离开页面时调用此函数。 |'
- en: '| `@leave-cancelled` | This is called in case the element has to be inserted
    before the leave call is finished. It works only with v-show. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `@leave-cancelled` | 在离开调用完成之前，如果必须插入元素，则调用此函数。仅适用于v-show。 |'
- en: Just be reminded that these hooks are valid for any library, not just Velocity.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些钩子对于任何库都有效，不仅仅适用于Velocity。
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can try another take with this interface by implementing a cancel button.
    If the user booked a cab by mistake, hitting cancel will delete the reservation,
    and it will be apparent by the fact that the little taxi emoji disappears.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用这个界面来实现一个取消按钮。如果用户错误地预订了出租车，点击取消按钮将删除预订，并且通过小的出租车表情消失来表明。
- en: 'First, let''s add a cancel button:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个取消按钮：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That was easy enough; now we add our leave transition:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易；现在我们添加离开过渡效果：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That brings us to our leave method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引导我们到离开方法：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What we are doing is making the emoji disappear while scaling it down.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做的是使表情符号消失并缩小。
- en: If you try to run your code, you will encounter some problems.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试运行代码，您将遇到一些问题。
- en: When you click on the cancel button, what should happen is the leave animation
    should start and the taxi should become smaller and eventually disappear. Instead,
    nothing happens and the taxi disappears abruptly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击取消按钮时，应该发生的是离开动画应该开始，出租车应该变小并最终消失。相反，什么都不会发生，出租车会突然消失。
- en: The reason the cancel animation doesn't play as planned is because since the
    animation is written in JavaScript instead of CSS, Vue has no way to tell when
    the animation is finished. In particular, what happens is that Vue thinks that
    the leave animation is finished before it even starts. That is what makes our
    car disappear.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 取消动画无法按计划播放的原因是因为动画是用JavaScript编写的，而不是CSS，Vue无法判断动画何时完成。特别是，发生的情况是Vue认为离开动画在开始之前就已经完成了。这就是我们的汽车消失的原因。
- en: The trick lies in the second argument. Every hook calls a function with two
    arguments. We have already seen the first, `el`, which is the subject of the animation.
    The second is a callback that when called, tells Vue that the animation is finished.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于第二个参数。每个钩子都调用一个带有两个参数的函数。我们已经看到了第一个参数`el`，它是动画的主体。第二个参数是一个回调函数，当调用时，告诉Vue动画已经完成。
- en: We will leverage the fact that Velocity has an option called `complete`, which
    expects a function to call when the animation (from the Velocity perspective)
    is complete.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用Velocity有一个名为`complete`的选项，它期望在动画（从Velocity的角度）完成时调用一个函数。
- en: 'Let''s rewrite our code with this new information:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些新信息重写我们的代码：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Adding the done arguments to our function lets Vue know that we want a callback
    to call when the animation is finished. We don''t need to explicitly use the callback
    as Vue will figure it out by itself, but since it''s always a bad idea to rely
    on default behaviors (they can change if they are not documented), let''s call
    the done function when the animation is finished:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的函数添加`done`参数，让Vue知道我们希望在动画完成时调用回调函数。我们不需要显式使用回调函数，因为Vue会自动找到它，但是由于依赖默认行为总是一个坏主意（如果它们没有记录，它们可能会改变），让我们在动画完成时调用`done`函数：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run your code and press the Cancel button to cancel your taxi!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码并按下取消按钮来取消您的出租车！
- en: Transitioning on the initial render
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在初始渲染上进行过渡
- en: With the `appear` keyword, we are able to package transition for elements when
    they are first loaded. This helps the user experience in that it gives the impression
    that the page is more responsive and faster to load when you apply it to many
    elements.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`appear`关键字，我们可以在元素首次加载时为其添加过渡效果。这有助于提高用户体验，因为它给人一种页面更具响应性和加载速度更快的印象，尤其是当应用于多个元素时。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe doesn't assume any particular knowledge, but if you have completed
    at least the *Adding some fun to your app with CSS transitions* recipe, it will
    be a piece of cake.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例不假设任何特定的知识，但如果您至少完成了*使用CSS过渡为您的应用程序增添一些乐趣*示例，那么这将是小菜一碟。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: We will build a page about the American actor Fill Murray; no, not Bill Murray.
    You can find more information about him at [http://www.fillmurray.com](https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js).
    We will use images from this site to fill our page about him.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将建立一个关于美国演员Fill Murray的页面；不，不是Bill Murray。您可以在[http://www.fillmurray.com](https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js)找到关于他的更多信息。我们将使用这个网站的图片来填充我们关于他的页面。
- en: 'In our HTML, let''s write a header as the title of our page:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML中，让我们写一个标题作为页面的标题：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After the title, we will place our Vue application:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题之后，我们将放置我们的Vue应用程序：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Which when rendered in a browser would appear like the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中呈现时，将显示如下：
- en: '![](assets/6132613a-c762-478c-9751-3dd4d3e38999.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6132613a-c762-478c-9751-3dd4d3e38999.png)'
- en: 'Our page is very plain right now. We want the Fill Murray picture to fade in.
    We have to wrap it inside a transition:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面现在非常简单。我们希望Fill Murray的图片淡入。我们必须将其包装在一个过渡中：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following are the CSS classes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是CSS类：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running our page now will make the image appear slowly, but it will also move
    the text. To fix it, we have to specify the image size in advance:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行我们的页面将使图片慢慢出现，但也会移动文本。为了修复这个问题，我们必须提前指定图片的大小：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This way, our browser will set aside some space for the image that will appear
    slowly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的浏览器将为即将出现的图片预留一些空间。
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `appear` directive in the `transition` tag will make the components appear
    for the first time with an associated transition (if it is found).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`transition`标签中的`appear`指令将使组件在首次出现时带有关联的过渡效果（如果找到）。'
- en: There are many possible ways to specify a transition on the first rendering
    of the component. In all cases, the `appear` directive must be specified.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的第一次渲染中，有很多可能的方法来指定一个过渡。在所有情况下，必须指定`appear`指令。
- en: 'The first things Vue will look for when this directive is present are JavaScript
    hooks or CSS classes specified in the tag:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个指令存在时，Vue将首先寻找JavaScript钩子或在标签中指定的CSS类：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After that, if a name is specified, Vue will look for an entrance transition
    for that element:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，如果指定了一个名称，Vue将会寻找该元素的入场过渡：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code will look for classes named as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将寻找以下命名的类：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Vue will look for the default CSS classes for the element insertion (`v-enter`
    and `v-enter-active`) if everything else fails. Incidentally, this is what we
    have done in our recipe.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他方法都失败了，Vue将会寻找元素插入的默认CSS类（`v-enter`和`v-enter-active`）。顺便说一句，这就是我们在这个示例中所做的。
- en: Relying on these defaults is not a good practice; here, we have done it just
    as a demonstration. You should always give names to your transitions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖这些默认值并不是一个好的实践；在这里，我们只是作为演示而这样做。你应该总是给你的过渡命名。
- en: Maybe it's worth mentioning why we had to add the width and height to our image.
    The reason is that when we specify an image URL in our HTML, the browser doesn't
    know the size of the image in advance, so it doesn't reserve any space for it
    by default. Only by specifying the size of the image in advance, the browser is
    able to correctly compose the page even before an image is loaded.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 也许值得一提的是，为什么我们必须为图像添加宽度和高度。原因是当我们在HTML中指定一个图像URL时，浏览器不知道图像的大小，所以默认情况下不会为其保留任何空间。只有通过提前指定图像的大小，浏览器才能在图像加载之前正确地组合页面。
- en: Transitioning between elements
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元素之间的过渡
- en: Everything on a web page is an element. You can easily make them appear and
    disappear, thanks to Vue `v-if` and `v-show` directives. With transitions, you
    can easily control how they appear and even add magic effects. This recipe explains
    how to do it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 网页上的每个东西都是一个元素。通过Vue的`v-if`和`v-show`指令，你可以轻松地使它们出现和消失。通过过渡，你甚至可以轻松地控制它们的出现，并添加魔法效果。本示例将解释如何做到这一点。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should have some familiarity with Vue transitions and how
    CSS works.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你应该对Vue过渡和CSS的工作原理有一些了解。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Since we talked about magic, we will turn a frog into a princess. The transformation
    itself will be a transition.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们谈到了魔法，我们将把一只青蛙变成一位公主。变化本身将是一个过渡。
- en: 'We will instantiate a button that, when pressed, will represent a kiss to the
    frog:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实例化一个按钮，当按下时，它将代表对青蛙的一个吻：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Every time the button is pressed, the variable kisses increases. The variable
    will be initialized to zero, as the following code shows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每次按下按钮时，变量kisses都会增加。变量将被初始化为零，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we need the frog and the princess that we will add immediately after
    the button:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要青蛙和公主，我们将在按钮之后立即添加它们：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The fade transition is the following CSS:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 淡入淡出过渡的CSS代码如下：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To make it work properly, we need a last CSS selector to add:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其正常工作，我们需要添加一个最后的CSS选择器：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you run the application and click enough times the kiss button, you should
    see your frog turn into a princess:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序并点击足够多次的吻按钮，你应该会看到你的青蛙变成一位公主：
- en: '![](assets/3a709d1d-79ed-4bb9-86a8-aeaeeadcaf9a.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3a709d1d-79ed-4bb9-86a8-aeaeeadcaf9a.png)'
- en: 'This transition will have a fade effect:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过渡将有一个淡入淡出的效果：
- en: '![](assets/d17f58dc-50cd-4e11-b234-c4633095a802.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d17f58dc-50cd-4e11-b234-c4633095a802.png)'
- en: 'The frog emoji will turn into a princess emoji:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 青蛙表情符号将变成公主表情符号：
- en: '![](assets/297edc0a-d809-41d8-9490-b59770387e70.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/297edc0a-d809-41d8-9490-b59770387e70.png)'
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we wrote the two elements, we used the `key` attribute specifying who is
    the frog and who is the princess. This is because, Vue optimization system will
    kick in otherwise. It will see that the content of the two elements can be swapped
    without swapping the elements themselves and no transition will ensue since the
    element was the same and only the content changed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写下这两个元素时，我们使用了`key`属性来指定谁是青蛙，谁是公主。这是因为，否则Vue优化系统将会启动。它会看到两个元素的内容可以互换，而不必交换元素本身，并且由于元素是相同的，只有内容发生了变化，所以不会发生过渡。
- en: 'If we remove the `key` attribute, we can see for ourselves that the frog and
    the princess will change, but without any transition:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除`key`属性，我们可以亲眼看到青蛙和公主会发生变化，但没有任何过渡效果：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Consider that we use two different elements, as shown:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们使用了两个不同的元素，如下所示：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Also, we modify our CSS selector for `<p>` accordingly:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们相应地修改了`<p>`的CSS选择器：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now if we launch our application again, everything works without using any `key`
    attribute.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次启动应用程序，一切都可以正常工作，而不需要使用任何`key`属性。
- en: Using keys is generally recommended even when not necessary, like in the preceding
    case. This is especially true when items have a different semantic meaning. There
    are a couple of reasons for this. The main reason is that when multiple people
    work on the same line of code, modifying the `key` attribute will not break the
    application as easily as switching a `span` element back into a `p` element, which
    will ruin the transition as we just saw.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在不必要的情况下，使用key通常也是推荐的，就像前面的情况一样。这尤其适用于项目具有不同的语义含义的情况。这样做的原因有几个。主要原因是，当多个人在同一行代码上工作时，修改`key`属性不会像将`span`元素切换回`p`元素那样容易破坏应用程序，这会破坏我们刚刚看到的过渡效果。
- en: There's more...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here, we cover two subcases of the preceding recipe: switching between more
    than two elements and binding the `key` attribute.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们涵盖了前面示例的两个子情况：在多个元素之间切换和绑定`key`属性。
- en: Transitioning between more than two elements
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个元素之间进行过渡
- en: We can expand on the recipe we just completed in a straightforward manner.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照简单的方式扩展我们刚刚完成的示例。
- en: Let's suppose that if we kiss the princess too many times, she will turn into
    Santa Claus, which may or may not be appealing, depending on your age I guess.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设如果我们亲吻公主太多次，她会变成圣诞老人，这可能会或可能不会吸引人，这取决于你的年龄。
- en: 'First, we add the third element:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加第三个元素：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can launch the application immediately and when we kiss the princess/frog
    more than five times, Santa will appear with the same fading transition:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即启动应用程序，当我们亲吻公主/青蛙超过五次时，圣诞老人将以相同的淡入淡出过渡效果出现：
- en: '![](assets/ee62f5c3-adb1-4d2e-819b-cfe0888084b8.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ee62f5c3-adb1-4d2e-819b-cfe0888084b8.png)'
- en: Using this setup, we are limited in using the same transition we used between
    the first two elements.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，我们在使用第一个和第二个元素之间使用相同的过渡时受到限制。
- en: There is a workaround for this explained in the *Dynamic transitions* recipe.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在*动态过渡*的示例中，有一个解决方法。
- en: Setting the key attribute dynamically
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态设置key属性
- en: 'We don''t have to write the key for all our elements if we already have some
    data available. Another way we could write the same app, but without repeating
    the element is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经有一些可用的数据，我们不必为所有元素编写key。我们可以以以下方式编写相同的应用程序，但不重复元素：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This, of course, means that we have to provide a sensible value for the `transformation`
    and `emoji` variables, depending on the number of kisses.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着我们必须根据亲吻的次数为`transformation`和`emoji`变量提供一个合理的值。
- en: 'To do this, we will tie them to computed properties:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将把它们与计算属性绑定起来：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We traded off some complexity in the template for some more logic in our Vue
    instance. This can be good in the long run if we expect more complex logic in
    the future or if the number of transformation rises.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模板中牺牲了一些复杂性，换取了Vue实例中更多的逻辑。如果我们预计将来会有更复杂的逻辑或者转换数量增加，这可能是有益的。
- en: Letting an element leave before the enter phase in a transition
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在过渡中让元素在进入阶段之前离开
- en: In the *Transitioning between elements* recipe, we explored how to make the
    transition between two elements. The default behavior of Vue is to start the transition
    of the element that is entering at the same time that the first element is leaving;
    this is not always desirable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在*元素之间过渡*的示例中，我们探讨了如何在两个元素之间进行过渡。Vue的默认行为是在第一个元素离开的同时开始进入元素的过渡；这并不总是理想的。
- en: You will learn about this important corner case and how to work around it in
    this recipe.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本示例中了解到这个重要的特殊情况以及如何解决它。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds on top of the transitioning between two elements and solves
    a specific problem. If you don't know what we are talking about, go back one recipe
    and you'll be on track in no time.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是在两个元素之间的过渡的基础上构建的，解决了一个特定的问题。如果您不知道我们在谈论什么，返回上一个示例，您将很快跟上。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, you will see the problem if you have not encountered it yet. Next, we'll
    see what Vue offers us to solve it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果您还没有遇到这个问题，您将看到问题。接下来，我们将看到Vue为我们提供的解决方案。
- en: The two elements problem
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个元素的问题
- en: Let's create a carousel effect on our website. The user will view one product at
    a time and then he will swipe to the next product. To swipe to the next product
    the user will need to click a button.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的网站上创建一个轮播效果。用户一次只能查看一个产品，然后他将滑动到下一个产品。要滑动到下一个产品，用户需要点击一个按钮。
- en: 'First, we need our list of products in the Vue instance:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在Vue实例中有我们的产品列表：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In our HTML, we will only need a button and the view of an element:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML中，我们只需要一个按钮和一个元素的视图：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The modulo 4 (product % 4) is only because we want to start all over again when
    the list of products finishes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 模4（product % 4）只是因为我们希望在产品列表结束时重新开始。
- en: 'To set up our sliding transition, we will need the following rules:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置我们的滑动过渡，我们需要以下规则：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, to make everything look good, we finish up with the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使一切看起来好看，我们最后完成了以下内容：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you run the code now, you will see a nice carousel:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行代码，您将看到一个漂亮的轮播图：
- en: '![](assets/27675ea7-0d13-48b1-83d1-91270017df29.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/27675ea7-0d13-48b1-83d1-91270017df29.png)'
- en: 'Now, let''s try to remove the `position: absolute` from the last rule:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们尝试从最后一个规则中删除`position: absolute`：'
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you try your code now, you will see a weird jumping from the products:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试您的代码，您将看到产品之间的奇怪跳动：
- en: '![](assets/90d782ed-fe42-4226-885d-4d370ff4d49c.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/90d782ed-fe42-4226-885d-4d370ff4d49c.png)'
- en: This is the problem we are trying to solve. The second transition starts before
    the first product has left. If the positioning is not absolute, we will see some
    weird effects.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们试图解决的问题。第二个过渡在第一个产品离开之前就开始了。如果定位不是绝对的，我们会看到一些奇怪的效果。
- en: Transition modes
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过渡模式
- en: 'To fix this problem, we will change the transition mode. Let''s modify the
    `<transition>` code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将改变过渡模式。让我们修改`<transition>`的代码：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now run your program and you will see the products taking a little more time
    before sliding inside the screen. They are waiting for the previous item to go
    away before entering.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行您的程序，您将看到产品在滑入屏幕之前需要更长的时间。它们在进入之前等待上一个项目离开。
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To recapitulate, you have two different ways to manage transitions between
    components in Vue. The default way is to start the *in* transition at the same
    time with the *out* transition. We can make that explicit with the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，您有两种不同的方法来管理Vue组件之间的过渡。默认方式是同时开始“in”过渡和“out”过渡。我们可以通过以下方式明确表示：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can change this default behavior by waiting for the *out* part to be finished
    before starting the *in* animation. We achieved it with the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过等待“out”部分完成后再开始“in”动画来改变这种默认行为。我们通过以下方式实现了这一点：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: While the former is useful when elements have the absolute style position, the
    latter is more relevant when we really need to wait to have a clear way before
    putting more stuff on the page.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 前者在元素具有绝对样式位置时很有用，而后者在我们真正需要等待在页面上放置更多内容之前有一个清晰的方法时更相关。
- en: Absolute positioning won't care about having elements on top of each other because
    they don't follow the flow of the page. On the other hand, static positioning
    will append the second element after the first, making the transition awkward
    if both the elements are shown at the same time.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对定位不会在意元素之间的重叠，因为它们不遵循页面的流动。另一方面，静态定位将在第一个元素之后追加第二个元素，如果两个元素同时显示，则过渡会变得尴尬。
- en: Adding entering and leaving transitions for elements of a list
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为列表中的元素添加进入和离开过渡
- en: Here, we will try to add a visual way to suggest that an element is added or
    removed from the list. This can add a lot to UX since you have an opportunity
    to suggest to the user why an element was added or removed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将尝试添加一种视觉方式来暗示列表中的元素是添加还是删除。这可以为用户体验增添很多，因为您有机会向用户建议为什么添加或删除元素。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some familiarity with CSS and transition will help. If you feel like this is
    needed, just browse the other recipes in this chapter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对CSS和过渡有一些了解会有所帮助。如果您觉得有必要，只需浏览本章中的其他示例。
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll build a syllabus to study programming. When we are done with a topic,
    we'll feel relieved and we want to incorporate that feeling in our app by making
    the topic float away from the syllabus as we learn it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将建立一个学习编程的教学大纲。当我们完成一个主题时，我们会感到宽慰，并希望通过让主题从教学大纲中飘走来将这种感觉融入我们的应用程序中。
- en: 'The data of the list will be in our Vue instance:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的数据将在我们的Vue实例中：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The list will be printed in our HTML with the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表将在我们的HTML中打印出以下代码：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When we press a button, we want the topic to disappear from the list. For this
    to happen, we need to modify the code we have written.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下按钮时，我们希望主题从列表中消失。为了实现这一点，我们需要修改我们已经编写的代码。
- en: 'First, let''s add a Done button before each topic:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在每个主题之前添加一个“完成”按钮：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, the completed method will look like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，completed方法将如下所示：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Running the code now will reveal a simple application for checking off the topics
    we already studied. What we want though is an animation that will make us feel
    relieved.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行代码将显示一个简单的应用程序，用于勾选我们已经学习过的主题。不过，我们想要的是一种让我们感到宽慰的动画。
- en: 'For that, we need to edit the container of our list. We remove the `<ul>` tag
    and, instead, tell the `<transition-group>` to compile to a `<ul>` tag:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要编辑我们列表的容器。我们删除`<ul>`标签，并告诉`<transition-group>`编译为`<ul>`标签：
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Note that we also added a key to each list element according to the topic.
    The last thing we need is adding the transition rules to our CSS:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还根据主题为每个列表元素添加了一个键。我们需要做的最后一件事是将过渡规则添加到我们的CSS中：
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, the subjects will disappear with the transition on clicking the Done button,
    as shown:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，主题将在点击“完成”按钮时以过渡方式消失，如下所示：
- en: '![](assets/1dc697d3-26c5-4957-86c6-2ed79cc3966b.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/1dc697d3-26c5-4957-86c6-2ed79cc3966b.png)
- en: How it works...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `<transition-group>` tag represents a container for a group of elements
    that will be displayed at the same time. By default, it represents the `<span>`
    tag, but by setting the tag attribute to `ul`, we made it represent an unordered
    list.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`<transition-group>`标签表示一组元素的容器，这些元素将同时显示。默认情况下，它表示`<span>`标签，但通过将标签属性设置为`ul`，我们使其表示无序列表。'
- en: Every element in the list must have a unique key or the transitions won't work.
    Vue will take care of applying a transition to every element that enters or leaves.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个元素必须具有唯一的键，否则转换将无法工作。Vue将负责对每个进入或离开的元素应用转换。
- en: Transitioning elements that move in a list
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在列表中移动的过渡元素
- en: In this recipe, you will build a list of elements that move according to how
    the list changes. This particular animation is useful when you want to tell your
    user that something has changed and the list is now updated accordingly. It will
    also help the user identify the point in which the element was inserted.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将构建一个元素列表，根据列表的变化而移动。当您想告诉用户某些内容已经改变并且列表已相应更新时，这种特定的动画是有用的。它还将帮助用户识别插入元素的位置。
- en: Getting ready
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is a little advanced; I would suggest you complete some of the recipes
    in this chapter if you are not very familiar with transitions in Vue. If you can
    complete the *Adding entering and leaving transitions for elements of a lists*
    recipe without much difficulty, you are good to go.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程有点高级；如果您对Vue中的过渡不是很熟悉，我建议您先完成本章中的一些教程。如果您可以轻松完成*为列表元素添加进入和离开过渡*教程，那就可以继续了。
- en: How to do it...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: You will build a little game--a bus station simulator!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您将构建一个小游戏--一个公交车站模拟器！
- en: 'Whenever a bus--represented by its emoji--leaves the station, all the other
    buses will drive a little ahead to take its place. Every bus is identified by
    a number, as you can see from the Vue instance data:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一辆公交车--由其表情符号表示--离开车站时，所有其他公交车都会稍微前进以占据它的位置。每辆公交车都由一个数字标识，您可以从Vue实例数据中看到：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Whenever a new bus arrives, it will have a progressive number assigned. We
    want a new bus to leave or go every two seconds. We can achieve this by hooking
    a timer when our component is mounted on screen. Immediately after data, write
    the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 每当新的公交车到达时，它将被分配一个递增的编号。我们希望每两秒钟有一辆新的公交车离开或到达。我们可以通过在组件挂载到屏幕时挂接一个计时器来实现这一点。在数据之后，立即编写以下内容：
- en: '[PRE59]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The HTML of our app will look like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的HTML将如下所示：
- en: '[PRE60]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To make the buses move around, we need to specify some CSS rules under the
    prefix station:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让公交车四处移动，我们需要在前缀站下指定一些CSS规则：
- en: '[PRE61]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Launching the app now will result in an orderly queue of buses in which one
    leaves or arrives every two seconds:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动应用将导致一个有序的公交车队列，每两秒钟有一辆公交车离开或到达：
- en: '![](assets/c4f025b1-b825-45e3-8ab4-9f362737ccd2.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c4f025b1-b825-45e3-8ab4-9f362737ccd2.png)'
- en: How it works...
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The core of our app is the `<transition-group>` tag. It manages all the buses
    identified by their key:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的核心是`<transition-group>`标签。它管理所有通过它们的键标识的公交车：
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Whenever a bus enters or leaves the scenes, a FLIP animation (see the *Adding
    your own transition classes* recipe) will be automatically triggered by Vue.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一辆公交车进入或离开场景时，Vue将自动触发FLIP动画（参见*添加自己的过渡类*教程）。
- en: 'To fix ideas, let''s say we have buses [1, 2, 3] and bus 1 leaves the scene.
    What happens next is that the properties of the first bus''s `<span>` element
    will be memorized before the animation actually starts. So we may retrieve the
    following object describing the properties:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，假设我们有公交车[1, 2, 3]，公交车1离开了。接下来发生的是，在动画实际开始之前，将记住第一辆公交车的`<span>`元素的属性。因此，我们可以检索到描述属性的以下对象：
- en: '[PRE63]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Vue does this for all the elements keyed inside the `<transition-group>` tag.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Vue对`<transition-group>`标签内的所有元素都这样做。
- en: 'After this, the `station-leave-active` class will be applied to the first bus.
    Let''s briefly review what the rules are:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`station-leave-active`类将应用于第一辆公交车。让我们简要回顾一下规则是什么：
- en: '[PRE64]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We note that the position becomes absolute. This means that the element is
    removed from the normal flow of the page. This in turn means that all the buses
    behind him will suddenly move to fill the space left blank. Vue records all the
    properties of the buses at this stage also and this is considered the final frame
    of the animation. This frame is not actually a real displayed frame; it is just
    used as an abstraction to calculate the final position of the elements:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到位置变为绝对定位。这意味着元素从页面的正常流程中移除。这又意味着所有在它后面的公交车将突然移动填补留下的空间。Vue在这个阶段记录所有公交车的属性，这被认为是动画的最终帧。这个帧实际上并不是一个真正显示的帧；它只是用来计算元素的最终位置的抽象：
- en: '![](assets/43cd7f74-3133-418b-bd7b-48893eb924a4.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/43cd7f74-3133-418b-bd7b-48893eb924a4.png)'
- en: 'Vue will calculate the difference between the final frame and the starting
    frame and will apply styles to make the buses appear in the initial frame even
    if they are not. The styles will be removed after one frame. The reason the buses
    slowly crawl to their final frame position instead of immediately moving in their
    new position is that they are `span` elements and we specified that any transform
    style (the one used by Vue to fake their position for one frame) must be transitioned
    for two seconds:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Vue将计算最终帧和起始帧之间的差异，并将应用样式，使公交车出现在初始帧，即使它们实际上并不在那里。这些样式将在一帧后被移除。公交车缓慢爬向它们的最终位置，而不是立即移动到它们的新位置，原因是它们是`span`元素，我们指定了任何变换样式（Vue用来伪造它们位置一帧的样式）必须过渡两秒：
- en: '[PRE65]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In other words, at frame -1, the three buses are all in place and their position
    is recorded.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在第-1帧，三辆公交车都在原位，并记录了它们的位置。
- en: At frame 0, the first bus is removed from the flow of the page and the other
    buses are instantaneously moved behind it. In the very same frame, Vue records
    their new position and applies a transform that will move the buses back to where
    they were at frame -1 giving the appearance that nobody moved.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在第0帧，第一辆公交车从页面流中移除，其他公交车立即移动到它的后面。在同一帧中，Vue记录它们的新位置，并应用一个变换，将公交车移回到它们在第-1帧的位置，从视觉上看就好像没有人移动过。
- en: At frame 1, the transform is removed, but since we have a transition, the buses
    will slowly move to their final position.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1帧，变换被移除，但由于我们有一个过渡，公交车将缓慢移动到它们的最终位置。
- en: Animating the state of your components
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画化组件的状态
- en: In computers, everything is a number. In Vue, everything that is a number can
    be animated in one way or other. In this recipe, you will control a bouncy ball
    that will smoothly position itself with a tween animation.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机中，一切都是数字。在Vue中，一切都是数字的东西都可以以某种方式进行动画。在这个配方中，您将控制一个弹跳球，它将通过缓动动画平稳地定位自己。
- en: Getting ready
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you will need at least some familiarity with JavaScript.
    The technicalities of JavaScript are out of the scope of this book, but I will
    break the code down for you in the *How it works...* section, so don't worry too
    much about it.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个配方，您至少需要对JavaScript有一定的了解。JavaScript的技术细节超出了本书的范围，但我会在*它是如何工作的...*部分为您解释代码，所以不要太担心。
- en: How to do it...
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In our HTML, we will add only two elements: an input box in which we will enter
    the desired position of our bouncy ball and the ball itself:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML中，我们只会添加两个元素：一个输入框，我们将在其中输入我们的弹跳球的期望位置，以及球本身：
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To properly render the ball, write this CSS rule and it will appear on the
    screen:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确渲染小球，写下这个CSS规则，它将出现在屏幕上：
- en: '[PRE67]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We want to control the bar *Y* position. To do that, we will bind the `top`
    property of the ball:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要控制球的*Y*位置。为此，我们将绑定球的`top`属性：
- en: '[PRE68]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Height will be part of our Vue instance model:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 高度将成为我们Vue实例模型的一部分：
- en: '[PRE69]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, since we want the ball to animate in the new position whenever the `enteredHeight`
    changes, one idea would be to bind the `@change` event of the input element:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们希望每当`enteredHeight`更改时，球在新位置上进行动画，一个想法是绑定输入元素的`@change`事件：
- en: '[PRE70]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The move method will be the one responsible for taking the current height of
    the ball and slowly transitioning it to the specified value.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: move方法将负责将球的当前高度缓慢过渡到指定值。
- en: Before doing this, you will add the **Tween.js** library as a dependency. The
    official repository is at [https://github.com/tweenjs/tween.js](https://github.com/tweenjs/tween.js).
    You can add the CDN link specified in the README.md page if you are using JSFiddle.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作之前，您将将**Tween.js**库添加为依赖项。官方存储库位于[https://github.com/tweenjs/tween.js](https://github.com/tweenjs/tween.js)。如果您在使用JSFiddle，可以添加README.md页面中指定的CDN链接。
- en: 'Add the move method after adding the library, like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加库之后添加move方法，就像这样：
- en: '[PRE71]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Try to launch the app and see the ball bounce while you edit its height:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试启动应用程序，看到球在您编辑其高度时弹跳：
- en: '![](assets/1f7dd650-3963-4f71-9d27-2c6ebdc95ef9.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1f7dd650-3963-4f71-9d27-2c6ebdc95ef9.png)'
- en: 'When we change the height, the position of the ball also changes:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们改变高度时，球的位置也会改变：
- en: '![](assets/069a6b5b-0417-4316-b6b7-d755712488be.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/069a6b5b-0417-4316-b6b7-d755712488be.png)'
- en: How it works...
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The general principle here is that you have a state for an element or component.
    When the state is numeric in nature, you can "tween" (from between) from one value
    to the other following a specific curve or acceleration.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一般原则是，您有一个元素或组件的状态。当状态是数字性质时，您可以根据特定的曲线或加速度从一个值“tween”（在之间）到另一个值。
- en: Let's break down the code, shall we?
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解代码，好吗？
- en: 'The first thing we do is to take the specified new height for the ball and
    save it to the `newHeight` variable:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是将指定的新高度保存到`newHeight`变量中：
- en: '[PRE72]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the next line, we are also saving our Vue instance in a `_this` helper variable:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们还将Vue实例保存在`_this`辅助变量中：
- en: '[PRE73]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The reason we do so will be clear in a minute:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做的原因一分钟后就会清楚：
- en: '[PRE74]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the preceding code, we are wrapping all of our animation in a function.
    This is idiomatic to the Tween.js library and identifies the main loop we will
    use to animate. If we have other tweens, this is the place to trigger them:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将所有的动画包装在一个函数中。这是Tween.js库的惯用法，并且确定了我们将用于动画的主循环。如果我们有其他Tween，这就是触发它们的地方：
- en: '[PRE75]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is the API call to our library. First, we are creating an object that
    will hold a copy of the height value in lieu of our component. Normally, here
    you put the object that represents the state itself. Due to Vue limitations (or
    Tween.js limitations), we are using a different strategy; we are animating a copy
    of the state and we are syncing the true state for every frame:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对我们库的API调用。首先，我们创建一个对象，它将保存状态值的副本，而不是我们组件的状态。通常，在这里，您放置代表状态本身的对象。由于Vue的限制（或Tween.js的限制），我们使用了一种不同的策略；我们正在动画化状态的副本，并且我们正在为每一帧同步真实状态：
- en: '[PRE76]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The first line initializes this copy to be equal to the current actual height
    of the ball:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将此副本初始化为球的当前实际高度：
- en: '[PRE77]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We choose the easing to resemble a bouncy ball:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择缓动效果来模拟弹跳球：
- en: '[PRE78]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This line sets the target height and the number of milliseconds the animation
    should last for:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这行设置了目标高度和动画应持续的毫秒数：
- en: '[PRE79]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, we are copying the height of the animation back to the real thing. As
    this function binds this to the copied state, we are forced to use ES5 syntax
    to have access to it. This is why we had a variable ready to reference the Vue
    instance. Had we used the ES6 syntax, we would not have any way to get the value
    of `H` directly.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将动画的高度复制回真实的事物。由于此函数将this绑定到复制的状态，我们被迫使用ES5语法来访问它。这就是为什么我们有一个变量准备好引用Vue实例的原因。如果我们使用了ES6语法，我们将无法直接获取`H`的值。
- en: Packaging reusable transitions into components
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将可重用的过渡效果打包到组件中
- en: We may have a significant transition in our website that we want to reuse throughout
    the user funnel. Packaging transition into components can be a good strategy if
    you are trying to keep your code organized. In this recipe, you will build a simple
    transition component.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能在网站中有一个重要的过渡效果，我们希望在用户漏斗中重复使用。如果您试图保持代码有序，将过渡效果打包到组件中可能是一个很好的策略。在这个示例中，您将构建一个简单的过渡组件。
- en: Getting ready
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Following this recipe makes sense if you have already worked your way through
    the transition with Vue. Also, since we are working with components, you should
    at least have an idea of what they are. Skim through the next chapter for a primer
    on components. In particular, we will create a functional component, the anatomy
    of which is detailed in the *Creating a functional component* recipe.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经通过Vue的过渡效果工作过，那么遵循这个示例是有意义的。此外，由于我们正在使用组件，您至少应该对它们有所了解。浏览下一章以了解组件的基础知识。特别是，我们将创建一个功能性组件，其解剖结构在*创建功能性组件*示例中有详细说明。
- en: How to do it...
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: We will build a signature transition for a news portal. Actually, we will use
    a premade transition in the excellent magic library ([https://github.com/miniMAC/magic](https://github.com/miniMAC/magic)),
    so you should add it to your project as a dependency. You can find the CDN link
    at [https://cdnjs.com/libraries/magic](https://cdnjs.com/libraries/magic) [(go
    to the page to find the link, don't copy it as a link).](https://github.com/miniMAC/magic)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为新闻门户构建一个特色过渡效果。实际上，我们将使用优秀的magic库中的预制过渡效果（[https://github.com/miniMAC/magic](https://github.com/miniMAC/magic)），因此您应该将其添加到项目中作为依赖项。您可以在[https://cdnjs.com/libraries/magic](https://cdnjs.com/libraries/magic)找到CDN链接（[转到页面查找链接，不要将其复制为链接](https://github.com/miniMAC/magic)）。
- en: First, you will build the website page, then you will build the transition itself.
    Lastly, you will just add the transition to different elements.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将构建网站页面，然后构建过渡效果本身。最后，您将只需将过渡效果添加到不同的元素中。
- en: Building the basic web page
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基本网页
- en: 'Our web page will consist of two buttons each that will display a card: one
    is a recipe and the other is the last breaking news:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网页将包括两个按钮，每个按钮将显示一个卡片：一个是食谱，另一个是最新的突发新闻：
- en: '[PRE80]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The cards will have their unique touch, thanks to the following CSS rule:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以下CSS规则，卡片将具有其独特的触感：
- en: '[PRE81]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The JavaScript part will be a very simple Vue instance:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript部分将是一个非常简单的Vue实例：
- en: '[PRE82]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Running this code will already display your web page:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将会显示您的网页：
- en: '![](assets/ed375e27-7280-4136-94b9-add992772c44.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ed375e27-7280-4136-94b9-add992772c44.png)'
- en: Building the reusable transition
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建可重用的过渡效果
- en: We decided that our website will feature a transition whenever a card is displayed.
    Since we intend to reuse the animation with everything in our website, we'd better
    package it in a component.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定我们的网站在显示卡片时将会有一个过渡效果。由于我们打算在网站的所有地方重复使用动画，最好将其打包在一个组件中。
- en: 'Before the Vue instance, we declare the following component:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue实例之前，我们声明了以下组件：
- en: '[PRE83]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `puffIn` and `puffOut` animations are defined in `magic.css`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`puffIn`和`puffOut`动画在`magic.css`中定义。'
- en: Using our transition with the elements in our page
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们网页中使用我们的过渡效果
- en: 'Now, we will just edit our web page to add the `<puff>` component to our cards:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编辑我们的网页，向卡片中添加`<puff>`组件：
- en: '[PRE84]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The cards will now appear and disappear when pressing the button with a "puff"
    effect.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当按下按钮时，卡片将以“puff”效果出现和消失。
- en: How it works...
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The only tricky part in our code is building the `<puff>` component. Once we
    have that in place, whatever we put inside will appear and disappear according
    to our transition. In our example, we used an already made transition. In the
    real world, we may craft a seriously complex animation that can be difficult to
    apply every time in the same manner. Having it packaged in a component is much
    easier and maintainable.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中唯一棘手的部分是构建`<puff>`组件。一旦我们把它放在那里，无论我们放进去什么都会根据我们的过渡效果出现和消失。在我们的例子中，我们使用了一个已经制作好的过渡。在现实世界中，我们可能会制作一个非常复杂的动画，每次以相同的方式应用可能会很困难。将其打包在一个组件中更容易维护。
- en: 'Two things make the `<puff>` component work as a reusable transition:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事使`<puff>`组件作为可重用的过渡工作：
- en: '[PRE85]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, we specify the classes the component must adopt when entering and leaving;
    there is nothing too special here, we have already done it in the *Integrating
    with third-party CSS animation libraries such as animate.css* recipe.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了组件在进入和离开时必须采用的类；这里没有什么特别的，我们已经在*与第三方CSS动画库集成，比如animate.css*配方中做过了。
- en: 'At the end we return the actual element:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们返回实际元素：
- en: '[PRE86]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This line creates the root of our element that is a `<transition>` tag with
    only one child--`context.children`. This means that the child is unspecified;
    the component will put as child whatever actual child is passed in the template.
    In our examples, we passed some cards that were promptly displayed.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行创建了我们元素的根，是一个`<transition>`标签，只有一个子元素--`context.children`。这意味着子元素是未指定的；组件将把模板中传递的实际子元素作为子元素。在我们的例子中，我们传递了一些卡片，它们很快就显示出来了。
- en: Dynamic transitions
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态过渡
- en: In Vue, a constant theme is reactivity and, of course, transitions can be dynamic
    because of that. Not only the transition themselves, but all their properties
    can be bound to reactive variables. This gives us a lot of control over which
    transition to use at any given moment.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue中，一个常数主题是反应性，当然，由于这个原因，过渡可以是动态的。不仅过渡本身，而且所有它们的属性都可以绑定到响应式变量上。这使我们对在任何给定时刻使用哪种过渡有很多控制。
- en: Getting ready
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds on top of the *Transitioning between elements* recipe. You
    don't need to go back if you already know about transitions, but if you feel like
    you're missing something, it might be a good idea to complete that first.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是建立在*元素之间过渡*配方之上的。如果你已经了解过渡，你不需要回去，但如果你觉得有所遗漏，最好先完成那个。
- en: How to do it...
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will transform a frog into a princess with some kisses, but if we kiss too
    much the princess will turn into Santa. Of course, we are talking about emojis.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一些吻把青蛙变成公主，但如果我们亲吻得太多，公主就会变成圣诞老人。当然，我们说的是表情符号。
- en: 'Our HTML setup is very simple:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML设置非常简单：
- en: '[PRE87]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Just note that most of the attributes here are bound to variables. Here is how
    the JavaScript unfolds.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 只需注意这里大多数属性都绑定到变量上。以下是JavaScript的展开方式。
- en: 'First, we will create a simple Vue instance with all of our data:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个包含所有数据的简单Vue实例：
- en: '[PRE88]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The fade transformation we are referring to is the following CSS:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所指的淡入淡出效果是以下CSS：
- en: '[PRE89]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The variables transformation and emoji are defined by two computed properties:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 变量transformation和emoji由两个计算属性定义：
- en: '[PRE90]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'While we are using the fade transition between the frog and the princess, we
    want something else between the princess and the frog. We will use the following
    transition classes:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在青蛙和公主之间使用淡入淡出过渡时，我们希望在公主和青蛙之间使用其他过渡。我们将使用以下过渡类：
- en: '[PRE91]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, since we bound the name of the transition to a variable, we can easily
    switch that programmatically. We can do that by adding the following highlighted
    lines to the computed property:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们将过渡的名称绑定到一个变量，我们可以很容易地以编程方式进行切换。我们可以通过将以下突出显示的行添加到计算属性中来实现这一点：
- en: '[PRE92]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The first added line is to avoid having an overlap while the zoom transition
    starts (more on that in the *Letting an element leave before the enter phase in
    a transition* recipe).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行添加的是为了避免在缩放转换开始时出现重叠（关于这一点，可以参考*让元素在过渡期离开之前离开*的内容）。
- en: The second added line switches the animation to "zoom".
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行添加的代码将动画切换为“缩放”。
- en: 'To make everything appear the right way, we need one more CSS rule:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一切都以正确的方式出现，我们需要再添加一个CSS规则：
- en: '[PRE93]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This is much nicer.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这样好多了。
- en: 'Now run the app and see how the two different transitions are used dynamically:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，看看两种不同的转换是如何动态使用的：
- en: '![](assets/0019baba-8d2b-4051-9b82-f9a8dbae600b.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0019baba-8d2b-4051-9b82-f9a8dbae600b.png)'
- en: 'As the number of kisses increase, the princess zooms out:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 随着亲吻的次数增加，公主会缩小：
- en: '![](assets/bca613d9-9f69-4f92-b620-fbecfa645773.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bca613d9-9f69-4f92-b620-fbecfa645773.png)'
- en: 'With this, the Santa zooms in:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，圣诞老人会放大：
- en: '![](assets/6827d454-44cf-4588-850d-b4dd0f82efdb.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6827d454-44cf-4588-850d-b4dd0f82efdb.png)'
- en: How it works...
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you understand how reactivity works in Vue, there is not much to add. We
    bound the name of the transition to the `kindOfTransformation` variable and switched
    from fade to zoom in our code. We also demonstrated that the other attributes
    of the `<transition>` tag can be changed on the fly as well.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解Vue中响应式的工作原理，就没有太多要补充的了。我们将过渡的名称绑定到`kindOfTransformation`变量，并在代码中从淡入淡出切换到缩放。我们还演示了`<transition>`标签的其他属性也可以随时更改。
