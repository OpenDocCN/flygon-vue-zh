- en: Pre-Caching Other Folders and Files for Faster Navigation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预缓存其他文件夹和文件以实现更快的导航
- en: In this chapter, the last of this section, we are going to look at speeding
    up our Dropbox file explorer further by introducing, even more, caching to the
    app. So far, we have built an app that can query the Dropbox API, and return files
    and folders. From there, we added folder navigation, including updating the URL
    for link sharing and being able to use the back and forward buttons. With that
    in place, in Chapter 6, *Caching the Current Folder Structure Using Vuex*, we
    introduced Vuex for storing the current folder path and the contents of the folders
    we had visited.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，本节的最后一章，我们将通过引入更多的缓存来进一步加快Dropbox文件浏览器的速度。到目前为止，我们已经构建了一个可以查询Dropbox API并返回文件和文件夹的应用程序。从那里开始，我们添加了文件夹导航，包括更新用于链接共享的URL以及能够使用后退和前进按钮。有了这个功能，我们在第6章《使用Vuex缓存当前文件夹结构》中引入了Vuex来存储当前文件夹路径和我们访问过的文件夹的内容。
- en: 'This chapter is going to look at:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下内容：
- en: Pre-caching not only the folder the user is currently in but also the child
    folders. This will be done by looping through the folders in the current display
    and checking if they have been cached yet. If not, we can gather the data from
    the API.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预缓存不仅用户当前所在的文件夹，还包括子文件夹。这将通过循环遍历当前显示的文件夹并检查它们是否已被缓存来完成。如果没有，我们可以从API中获取数据。
- en: Storing the parent folder's contents, should the user have entered via a direct
    URL. This will be done by utilizing the breadcrumb path to traverse up the tree.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户通过直接URL进入，存储父文件夹的内容。这将通过利用面包屑路径向上遍历来完成。
- en: Cache the download links for the files. This currently requires an API for every
    file encountered, regardless of whether the folder has been cached by our code
    or not.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存文件的下载链接。目前，这需要为遇到的每个文件都进行一次API调用，无论该文件夹是否已被我们的代码缓存。
- en: With these improvements, we can ensure the app only contacts the API once for
    every item, rather than the countless times it was originally doing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些改进，我们可以确保应用程序每个项目只与API联系一次，而不是像原来那样无数次。
- en: Caching subfolders
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存子文件夹
- en: With both the subfolder and parent folder caching, we won't necessarily be writing
    new code, but reorganizing and repurposing the existing code into a more modular
    system, so that each part can be called separately.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对子文件夹和父文件夹进行缓存，我们不一定需要编写新代码，而是将现有代码重新组织和重新用途化为一个更模块化的系统，以便可以单独调用每个部分。
- en: 'The following flowchart should help you visualize the steps required to cache
    the current folder and subfolders:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下流程图应该能帮助您可视化缓存当前文件夹和子文件夹所需的步骤：
- en: '![](assets/19044051-429f-4af7-94b7-91796581710b.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/19044051-429f-4af7-94b7-91796581710b.jpg)'
- en: When looking at the flowchart, you can immediately see some duplication in events
    required for the app. At two points the app needs to decide whether a folder exists
    in the cache and, if it does not, query the API to get the data and store the
    result. Although it appears only twice on the flowchart, this functionality is
    required several times, once for every folder in the current location.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看流程图时，您可以立即看到应用程序所需的事件中存在一些重复。在两个点上，应用程序需要决定缓存中是否存在一个文件夹，如果不存在，则查询API以获取数据并存储结果。尽管在流程图上只出现两次，但这个功能需要多次，每个当前位置的文件夹都需要一次。
- en: We will also need to separate out our displaying logic from our querying and
    storing logic, as we may need to load from the API and store, without updating
    the view.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将显示逻辑与查询和存储逻辑分开，因为我们可能需要从API加载和存储，而不更新视图。
- en: Planning app methods
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划应用程序方法
- en: With the previous section in mind, we can take the opportunity to revise and
    refactor the methods on our `dropbox-viewer` app, ensuring each action has its
    own method. This would allow us to call each action as and when we want to. Before
    we head into the code, let's plan out the methods we need to create based on the
    preceding flowchart.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑前一节的内容时，我们可以借此机会修订和重构我们的`dropbox-viewer`应用程序中的方法，确保每个操作都有自己的方法。这将允许我们在需要时调用每个操作。在进入代码之前，让我们根据前面的流程图规划需要创建的方法。
- en: The first thing to note is that every time the API is queried, we need to store
    the result in the cache. As we don't need to store anything in the cache *unless*
    the API is called, we can combine these two actions in the same method. We also
    often need to check whether there are contents in the cache for a particular path
    and either load it or retrieve it from the API. We can add this to its own method
    that returns the data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，每次查询API时，我们都需要将结果存储在缓存中。由于我们不需要在缓存中存储任何东西，*除非*调用了API，所以我们可以将这两个操作合并在同一个方法中。我们还经常需要检查特定路径的缓存中是否有内容，并加载它或从API中检索它。我们可以将此添加到自己的方法中，并返回数据。
- en: 'Let''s map out the methods we need to create:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出我们需要创建的方法：
- en: '`getFolderStructure`: This method will accept a single parameter of the path
    and return an object of the folder entries. This will be responsible for checking
    if the data is in the cache and, if not, querying the Dropbox API.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFolderStructure`：此方法将接受一个路径参数，并返回一个包含文件夹条目的对象。它将负责检查数据是否在缓存中，如果不在，则查询Dropbox
    API。'
- en: '`displayFolderStructure`: This method will fire the preceding function and
    use the data to update the `structure` object on the component to display the
    files and folders in the View.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`displayFolderStructure`：这个方法将调用前面的函数，并使用数据来更新组件上的`structure`对象，以在视图中显示文件和文件夹。'
- en: '`cacheFolderStructure`: This method will include the `getFolderStructure` method
    to cache each subfolder—we''ll explore a couple of ways this can be triggered.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cacheFolderStructure`：这个方法将包含`getFolderStructure`方法来缓存每个子文件夹，我们将探讨几种触发它的方式。'
- en: 'We may need to create more methods than this, but these three will be the backbone
    of the component. We will keep the path and slug-computed properties, along with
    the `dropbox()` method. Remove the rest of the objects, methods, and functions
    so your `dropbox-viewer` is back to basics:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要创建更多的方法，但这三个方法将是组件的主干。我们将保留路径和slug-computed属性，以及`dropbox()`方法。删除其余的对象、方法和函数，使您的`dropbox-viewer`回到基本状态：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating the getFolderStructure method
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`getFolderStructure`方法
- en: 'Create a new method on your component called `getFolderStructure`. As mentioned
    previously, this method needs to accept a single path parameter. This is so we
    can use with both the current path and children paths:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件上创建一个名为`getFolderStructure`的新方法。如前所述，此方法需要接受一个路径参数。这样我们就可以同时使用当前路径和子路径：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This method needs to check the cache and return the data. Make a new variable,
    titled `output`, inside the method and return it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法需要检查缓存并返回数据。在方法内部创建一个名为`output`的新变量，并返回它：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When caching the data in [Chapter 6](https://cdp.packtpub.com/vue_js_by_example/wp-admin/post.php?post=82&action=edit#post_71), *Caching
    the Current Folder Structure Using Vuex*, we were using the `slug` as the key
    in the store. The `slug` was generated by using the current path; however, we
    cannot use this in the new methods as it is fixed to its current location.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](https://cdp.packtpub.com/vue_js_by_example/wp-admin/post.php?post=82&action=edit#post_71)中缓存数据时，我们使用`slug`作为存储中的键。`slug`是通过使用当前路径生成的；然而，在新的方法中我们不能使用它，因为它固定在当前位置。
- en: 'Create a new method called `generateSlug`. This will accept one parameter,
    the path, and return a converted string using the replacements from the slug-computed
    function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`generateSlug`的新方法。它将接受一个参数`path`，并返回使用slug-computed函数中的替换后的字符串：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can now delete the computed `slug` function, so we don't have any repeating
    code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以删除计算的`slug`函数，这样我们就不会有重复的代码了。
- en: 'Going back to our `getFolderStructure` method, create a new variable that stores
    the slug version of the path using the new method. For this, we are going to use
    `const` to create a variable that cannot be changed:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`getFolderStructure`方法，创建一个新变量，使用新方法存储路径的slug版本。为此，我们将使用`const`创建一个不可更改的变量：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last variable we will create is the data path, as we did in Chapter 8,
    *Introducing Vue-Router and Loading URL-Based Components*. This will use the new
    `slug` variable we''ve just created:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的最后一个变量是数据路径，就像在第8章“介绍Vue-Router和加载基于URL的组件”中所做的那样。这将使用我们刚刚创建的新`slug`变量：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now use the `data` `if` statement from the previous code inside of here,
    with space for the Dropbox function call. We can assign the `data` to `output`
    straight away if it exists in the store:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在这里使用先前代码中的`data` `if`语句，并留出空间用于Dropbox函数调用。如果`data`存在于存储中，我们可以立即将其分配给`output`：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the Dropbox API call, however, we can tweak it to suit this new code. Previously,
    it was retrieving the data from the API and then firing a method that then saved
    and displayed the structure. As we need to store the data retrieved in the `output`
    variable, we are going to alter the flow of data. Instead of firing a method,
    we are going to use this opportunity to first store the response in the cache
    and then return the data to the `output` variable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过调整Dropbox API调用，我们可以使其适应这段新代码。以前，它是从API检索数据，然后触发一个方法来保存和显示结构。由于我们需要将检索到的数据存储在`output`变量中，我们将改变数据的流动方式。我们将使用这个机会首先将响应存储在缓存中，然后将数据返回给`output`变量。
- en: 'As we only use the entries from the API call, we are also going to update the
    store to only cache this part of the response. This will reduce the code and complexity
    of the app:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只使用API调用的条目，我们还将更新存储以仅缓存响应的这部分。这将减少应用程序的代码和复杂性：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Dropbox `filesListFolder` method uses the passed-in `path` variable, rather
    than the global one it was previously using. The entries from the response are
    then stored in a variable before being cached in the Vuex store using the same
    mutation. The `entries` variable is then returned from the promise, which stores
    the result in `output`. The `catch()` function is the same as before.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Dropbox的`filesListFolder`方法使用传入的`path`变量，而不是之前使用的全局变量。然后将响应中的条目存储在一个变量中，然后使用相同的mutation将其缓存在Vuex存储中。然后，`entries`变量从promise中返回，该promise将结果存储在`output`中。`catch()`函数与之前相同。
- en: With the data being returned from either the cache or the API, we can trigger
    and process this data when the component is created and when the path is updated.
    Before we do that, however, we have a mix of data types to deal with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从缓存或API返回的数据，我们可以在组件创建和路径更新时触发和处理这些数据。然而，在此之前，我们需要处理各种数据类型的混合。
- en: 'When returned from the API, the data is still a promise that needs to be resolved;
    assigning it to a variable merely passes on the promise to be resolved later.
    Data from the store, however, is a plain array that is handled very differently.
    To give us a single data type to deal with, we are going to `resolve` the stored
    array as a promise, meaning the `getFolderStructure` returns a promise, regardless
    of where the data is loaded from:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从API返回的数据仍然是一个需要解析的promise；将其分配给一个变量只是将promise传递给以后解析。然而，来自存储的数据是一个处理方式非常不同的普通数组。为了给我们一个单一的数据类型来处理，我们将把存储的数组作为promise来`resolve`，这意味着`getFolderStructure`无论数据从何处加载，都返回一个promise：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this `getFolderStructure` method, we now have the ability to load some
    data from the API and store the result in the global cache without updating the
    view. The function does, however, return the information should we wish to process
    it further with a JavaScript promise.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个`getFolderStructure`方法，我们现在可以从API中加载一些数据并将结果存储在全局缓存中，而不需要更新视图。然而，该函数确实返回信息，以便我们可以使用JavaScript
    promise进一步处理它。
- en: We can now proceed with creating our next method, `displayFolderStructure`,
    which will take the result of the method we have just created and update our View,
    so the app is navigable once again.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续创建我们的下一个方法`displayFolderStructure`，该方法将使用我们刚刚创建的方法的结果来更新我们的视图，以便应用程序可以再次导航。
- en: Showing the data with the displayFolderStructure method
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`displayFolderStructure`方法显示数据
- en: 'With our data now ready to be cached and served up from the store, we can go
    ahead and actually *display* the data with our new method. Create a new method
    in your `dropbox-viewer` component labeled `displayFolderStructure`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据已经准备好可以缓存并从存储中提供，我们可以继续使用我们的新方法*显示*数据。在你的`dropbox-viewer`组件中创建一个名为`displayFolderStructure`的新方法：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method will borrow a lot of code from the previous incarnation of this
    component. Remember, this method is used purely for displaying the folder and
    has nothing to do with caching the contents.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将从此组件的先前版本中借用很多代码。请记住，该方法仅用于显示文件夹，与缓存内容无关。
- en: 'The process of the method will be:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的过程将是：
- en: Set the loading state as `active` in the app. This lets the user know something
    is happening.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中将加载状态设置为`active`。这让用户知道有事情正在发生。
- en: Create an empty `structure` object.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的`structure`对象。
- en: Load the contents of the `getFolderStructure` method.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`getFolderStructure`方法的内容。
- en: Loop through the result and add each item to either the `folders` or `files`
    array.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历结果，并将每个项目添加到`folders`或`files`数组中。
- en: Set the global structure object to the new one created.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将全局结构对象设置为新创建的对象。
- en: Set the loading state to `false` so the contents can be displayed.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将加载状态设置为`false`，以便可以显示内容。
- en: Set the loading state to true and create an empty structure object
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将加载状态设置为true，并创建一个空的结构对象
- en: 'The first step of this method is to hide the structure tree and show the loading
    message. This can be done as before, by setting the `isLoading` variable to `true`.
    We can also create our empty `structure` object here, ready to be populated by
    the data:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的第一步是隐藏结构树并显示加载消息。这可以像之前一样通过将`isLoading`变量设置为`true`来完成。我们还可以在这里创建一个空的`structure`对象，准备好由数据填充：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Load the contents of the getFolderStructure method
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载`getFolderStructure`方法的内容
- en: 'As the `getFolderStructure` method returns a promise, we need to resolve the
    result before proceeding on to manipulate it. This is done with the `.then()`
    function; we have already used this with the Dropbox class. Call the method and
    then assign the result to a variable:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`getFolderStructure`方法返回一个promise，我们需要在继续操作之前解析结果。这可以通过`.then()`函数来完成；我们已经在Dropbox类中使用过这个函数。调用该方法，然后将结果分配给一个变量：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code passes the `path` object of the component into the method. This path
    is the *current* path that the user is trying to view. Once the data is returned,
    we can assign it to the `data` variable, which can then be used inside the function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将组件的`path`对象传递给方法。这个路径是用户正在尝试查看的*当前*路径。一旦数据返回，我们可以将其赋值给`data`变量，然后在函数内部使用它。
- en: Loop through the result and add each item to either the folders or files array
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环遍历结果，并将每个项添加到文件夹或文件数组中。
- en: We are already familiar with the code that loops through the entries and examines
    the `.tag` attribute of each one. If this results in a folder, it is added to
    the `structure.folders` array, otherwise it is appended to `structure.files`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了循环遍历条目并检查每个条目的`.tag`属性的代码。如果结果是一个文件夹，它将被添加到`structure.folders`数组中，否则将被追加到`structure.files`中。
- en: 'We are only storing the entries in the cache, so make sure the `for` loop is
    updated to use the data as is, rather than accessing the property of entries:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只在缓存中存储条目，因此确保`for`循环更新为直接使用数据，而不是访问条目的属性：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Update the global structure object and remove the loading state
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新全局结构对象并移除加载状态
- en: 'The last task in this method is to update the global structure and remove the
    loading state. This code is unchanged from before:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法中的最后一个任务是更新全局结构并移除加载状态。这段代码与之前的代码没有变化：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We now have a method that will display the result of our data retrieval.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个显示数据检索结果的方法。
- en: Instigating the method
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动该方法
- en: 'This method can now be called when the `dropbox-viewer` component gets created.
    The path will already be populated, thanks to the `created` function on the global
    Vue instance that commits the URL hash to the store, thus creating the path variable.
    Because of this, we don''t need to pass anything to the function. Add the `created`
    function to your component and call the new method inside:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当`dropbox-viewer`组件被创建时，现在可以调用这个方法。由于全局Vue实例的`created`函数将URL哈希提交到存储中，从而创建了路径变量，因此路径已经被填充。因此，我们不需要向函数传递任何内容。将`created`函数添加到您的组件中，并在其中调用新方法：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Refreshing the app now will load your folder contents. Updating the URL hash
    and reloading the page will also show the contents of that folder; however, clicking
    any folder links will update the breadcrumb, but not the data structure. This
    can be resolved by watching the computed `path` variable. This will get updated
    when the hash updates and so can trigger a function in the `watch` object. Add
    a function that watches for the `path` variable to update and fires the new method
    when it has:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新应用程序将加载您的文件夹内容。更新URL哈希并重新加载页面也将显示该文件夹的内容；然而，点击任何文件夹链接将更新面包屑，但不会更新数据结构。可以通过监视计算属性`path`变量来解决这个问题。当哈希更新时，它将被更新，因此可以触发`watch`对象中的一个函数。添加一个函数来监视`path`变量的更新，并在更新时触发新方法：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this, we have created an app that, once again, caches any folder you have
    visited. Clicking through the structure the first time will seem quite slow, but
    once you navigate back up the tree and re-enter subfolders you will barely see
    the loading screen.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们创建了一个应用程序，再次缓存您访问过的任何文件夹。第一次点击结构时，速度可能会很慢，但是一旦您返回到树的上层并重新进入子文件夹，您几乎看不到加载屏幕。
- en: Despite the app having the same functionality as it did at the beginning of
    the chapter, we have refactored the code to separate out the retrieval and caching
    and the displaying of the data. Let's move on to enhancing our app further by
    pre-caching the subfolders of the selected path.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该应用程序的功能与本章开始时相同，但我们已经重构了代码，将数据检索和缓存与数据显示分开。让我们进一步增强我们的应用程序，通过预缓存所选路径的子文件夹。
- en: Caching the subfolders
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存子文件夹
- en: Now that we have the ability to cache a folder without updating the Vue, we
    can use our `structure` object to get the contents of the subfolders. Using the
    `folders` array in the `structure` object, we can loop through this and cache
    each folder in turn.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在不更新Vue的情况下缓存文件夹，然后使用我们的`structure`对象获取子文件夹的内容。使用`structure`对象中的`folders`数组，我们可以循环遍历并依次缓存每个文件夹。
- en: We have to make sure we do not hinder the performance of the app; the caching
    must be done asynchronously, so the user is not aware of this process. We also
    need to make sure we aren't running the caching unnecessarily.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保不会影响应用程序的性能；缓存必须是异步完成的，这样用户就不会意识到这个过程。我们还需要确保不会不必要地运行缓存。
- en: To achieve this, we can watch the `structure` object. This only gets updated
    once the data has been loaded from the cache or the API and the Vue has updated.
    With the user viewing the contents of the folder, we can proceed with looping
    through the folders to store their contents.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以监听`structure`对象。只有在数据从缓存或API加载并且Vue已更新后，才会更新此对象。当用户查看文件夹的内容时，我们可以继续循环遍历文件夹以存储其内容。
- en: There is a slight issue, however. If we watch the `structure` variable, our
    code will never run as the direct *contents* of the object does not update, despite
    the fact we replace the `structure` object with a new one every time. From folder
    to folder, the structure object always has two keys, of `files` and `folders`,
    which are both arrays. As far as Vue and JavaScript are concerned, the `structure`
    object never changes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个小问题。如果我们监听`structure`变量，我们的代码将永远不会运行，因为对象的直接*内容*不会更新，尽管我们每次都用新的对象替换`structure`对象。从一个文件夹到另一个文件夹，结构对象始终有两个键，即`files`和`folders`，它们都是数组。就Vue和JavaScript而言，`structure`对象从不改变。
- en: Vue can, however, detect nested changes with the `deep` variable. This can be
    enabled on a per variable basis. Similar to the props on a component, to enable
    more options on a watch property, you pass it an object instead of a direct function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Vue可以检测到`deep`变量的嵌套更改。这可以在每个变量的基础上启用。与组件上的props类似，要在watch属性上启用更多选项，您需要将其传递给一个对象而不是直接函数。
- en: 'Create a new `watch` key for structure, which is an object with two values, `deep`
    and `handler`. The `deep` key will be set to `true`, while the `handler` will
    be the function fired when the variable is changed:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为`structure`创建一个新的`watch`键，它是一个包含两个值的对象，`deep`和`handler`。`deep`键将设置为`true`，而`handler`将是在变量改变时触发的函数：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Inside this `handler`, we can now loop through each of the folders and run
    the `getFolderStructure` method for each one, using the `path_lower` property
    of each one as the function argument:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`handler`中，我们现在可以循环遍历每个文件夹，并对每个文件夹运行`getFolderStructure`方法，使用每个文件夹的`path_lower`属性作为函数参数：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this simple piece of code, our app appears to speed up tenfold. Every
    subfolder you navigate to loads instantly (unless you have a particularly long
    folder list and you navigate to the last one very quickly). To give you an idea
    of the speed and timing of the caching, add a `console.log()` inside your `getFolderStructure`
    method and open the browser developer tools:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段简单的代码，我们的应用程序似乎加快了十倍。您导航到的每个子文件夹都会立即加载（除非您的文件夹列表特别长，并且您非常快速地导航到最后一个文件夹）。为了让您了解缓存的速度和时间，可以在`getFolderStructure`方法中添加一个`console.log()`并打开浏览器开发者工具：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This allows you to see all the API calls are done asynchronously too—the app
    isn't waiting for the previous folder to be loaded and cached before moving on
    to the next one. This has the advantage of allowing smaller folders to be cached
    without waiting for bigger ones to be returned from the API.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以让您看到所有的API调用都是异步完成的——应用程序在继续下一个文件夹之前不会等待前一个文件夹加载和缓存。这样做的好处是可以在不等待较大的文件夹从API返回的情况下缓存较小的文件夹。
- en: Alternative caching method
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代缓存方法
- en: As with everything, when making an app, there are many approaches to achieving
    the same result. The downside with this method is that even if your folder contains
    only files, this function will trigger—albeit with nothing to do.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何事物一样，在创建应用程序时，有许多方法可以实现相同的结果。这种方法的缺点是，即使您的文件夹只包含文件，这个函数也会被触发，尽管没有任何操作。
- en: An alternative approach would be to use our `created` function once again, this
    time on the `folder` component itself, triggering the parent method with the path
    as the argument.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是再次使用我们的`created`函数，这次在`folder`组件本身上，以路径作为参数触发父组件的方法。
- en: One way of doing this is using the `$parent` property. When in the `folder`
    component, using `this.$parent` will allow access to the variables, methods, and
    computed values on the `dropbox-viewer` component.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用`$parent`属性来实现。在`folder`组件中，使用`this.$parent`可以访问`dropbox-viewer`组件上的变量、方法和计算属性。
- en: 'Add a `created` function to the `folder` component and delete the `structure`
    `watch` property from the Dropbox component. From there, call the parent `getFolderStructure`
    method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`folder`组件中添加一个`created`函数，并从Dropbox组件中删除`structure`的`watch`属性。然后，调用父组件的`getFolderStructure`方法：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Previewing the app proves the validity of this method. Only triggering when
    there are folders in the structure, this cleaner technique ties the folder-caching
    with the folder itself, rather than getting mixed in with the Dropbox code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 预览应用程序可以证明这种方法的有效性。只有在结构中有文件夹时才触发，这种更清晰的技术将文件夹缓存与文件夹本身联系在一起，而不是与Dropbox代码混在一起。
- en: However, `this.$parent` should be avoided unless necessary, and should only
    be used in edge cases. As we have the opportunity to use props, we should do so.
    It also gives us the chance to give the function a more meaningful name in the
    folder context.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除非必要，否则应避免使用`this.$parent`，并且只应在特殊情况下使用。由于我们有机会使用props，我们应该这样做。这还给了我们在文件夹上下文中给函数一个更有意义的名称的机会。
- en: 'Navigate to your HTML view and update the folder component to accept a new
    prop. We''ll call the prop cache and pass the function in as the value. As the
    property is dynamic, don''t forget to add a preceding colon:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到HTML视图并更新文件夹组件以接受一个新的prop。我们将称之为cache，并将函数作为值传递。由于属性是动态的，请不要忘记添加一个前导冒号：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the `cache` keyword to the props key in the JavaScript `folder` component.
    Inform Vue that the input will be a function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript的`folder`组件中将`cache`关键字添加到props键中。告诉Vue输入将是一个函数：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, we can call our new `cache()` method in the `created` function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`created`函数中调用我们的新`cache()`方法：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The caching can be verified, once again, by using the console logs as before.
    This creates cleaner code that is easier for yourself, and any other developers, to
    read.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用之前的控制台日志来验证缓存。这样可以创建更清晰的代码，更容易阅读，也方便你和其他开发人员使用。
- en: With our Dropbox app now progressing, we can move on to caching parent folders,
    should you enter a subfolder using a hash in the URL.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Dropbox应用程序正在进展，如果您使用URL中的哈希进入子文件夹，我们可以继续缓存父文件夹。
- en: Caching parent folders
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存父文件夹
- en: Caching the parent structure is the next preemptive thing we can do to help
    speed up our app. Say we had navigated to our images directory, `/images/holiday/summer`,
    and wished to share this with a friend or colleague. We would send them the URL
    with this in the URL hash and, on page load, they would see the contents. If they
    then navigated up the tree using the breadcrumb to `/images/holiday`, for example,
    they would need to wait for the app to retrieve the contents.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存父结构是我们可以采取的下一个预防措施，以帮助加快应用程序的速度。假设我们导航到了我们的图像目录`/images/holiday/summer`，并希望与朋友或同事共享。我们会将带有此URL的URL哈希发送给他们，在页面加载时，他们将看到内容。如果他们然后使用面包屑向上导航到`/images/holiday`，例如，他们需要等待应用程序检索内容。
- en: Using the `breadcrumb` component, we can cache the parent directories and so,
    on navigating to the `holiday` folder, the user would be presented instantly with
    its contents. While the user is then browsing this folder, all of its subfolders
    are being cached with the previous methods.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`breadcrumb`组件，我们可以缓存父目录，因此当用户导航到`holiday`文件夹时，将立即显示其内容。当用户浏览此文件夹时，所有子文件夹都将使用先前的方法进行缓存。
- en: To cache the parent folders, we already have a component displaying the path
    with access to the slugs of all the parent folders we can loop through—the breadcrumb.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓存父文件夹，我们已经有一个组件显示具有访问所有父文件夹的slug的路径，我们可以通过面包屑循环遍历。
- en: 'Before we start the caching process, we need to update the `folders` computed
    function within the component. This is because currently, we store the path with
    the hash prepended, which creates an invalid path for the Dropbox API. Remove
    the hash from the object being pushed to the output array and add it in the template,
    in a similar fashion to the `folder` component:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始缓存过程之前，我们需要更新组件内的`folders`计算函数。这是因为目前我们存储的路径是带有散列前缀的，这会导致Dropbox API无效的路径。从被推送到输出数组的对象中删除散列，并在模板中以类似的方式添加它，就像`folder`组件一样：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can now use the output for both displaying the breadcrumb and caching the
    parent structure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以同时使用输出来显示面包屑和缓存父级结构。
- en: 'The first step is to allow the `breadcrumb` component access to the caching
    function. In a similar fashion to the `folder` component, add the function as
    a prop to the `breadcrumb` component in your View:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是允许`breadcrumb`组件访问缓存函数。类似于`folder`组件，将函数作为prop添加到你的视图中的`breadcrumb`组件中：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the `props` object to the component in the JavaScript code. Declare the
    `cache` prop as a function so Vue knows what to expect:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript代码中，将`props`对象添加到组件中。将`cache`属性声明为一个函数，以便Vue知道要期望什么：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The parent structure is going to be on the creation of the `breadcrumb` component.
    However, as we don't want this to hold up the loading process, we are going to
    trigger it when the component is `mounted`, not `created`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 父结构将在`breadcrumb`组件创建时生成。然而，由于我们不希望这会阻碍加载过程，我们将在组件被`mounted`而不是`created`时触发它。
- en: 'Add a `mounted` function to your component and assign the folder''s computed
    value to a variable:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 给你的组件添加一个`mounted`函数，并将文件夹的计算值赋给一个变量：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We now need to start caching the folders; however, we can be smart in the order
    that we do it. We can assume that the user will generally go back up the folder
    tree, so we should ideally cache the direct parent before moving onto its parent,
    and so on and so forth. As our folder's variable goes from the top down, we need
    to reverse it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要开始缓存文件夹；然而，我们可以在执行缓存的顺序上做得更聪明。我们可以假设用户通常会返回到文件夹树的上一级，所以我们应该在移动到其父级之前理想地缓存直接父级，依此类推。由于我们的文件夹变量是从上到下的，所以我们需要将其反转。
- en: 'The other thing we can do to improve performance is to remove the current folder;
    as we are already in it, the app would have cached it already. In your component,
    reverse the array and remove the first item:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，我们还可以删除当前文件夹；因为我们已经在其中，应用程序已经缓存了它。在你的组件中，反转数组并删除第一个项：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we add a console log to the function of the parent''s variable, we can see
    it contains the folders we now wish to cache. We can now loop through this array,
    calling the `cache` function for each item in the array:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在父变量的函数中添加一个控制台日志，我们可以看到它包含了我们现在希望缓存的文件夹。现在，我们可以遍历这个数组，为数组中的每个项调用`cache`函数：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this, our parent and child folders are being cached by the app, making
    navigation both up and down the tree lightning fast. However, running a `console.log()`
    inside the `mounted` function reveals the breadcrumb gets re-mounted every time
    a folder gets navigated to. This is because of the `v-if` statements in the View,
    which removes and adds the HTML each time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们的父文件夹和子文件夹都被应用程序缓存，使得导航树的上下导航都非常快速。然而，在`mounted`函数内部运行`console.log()`会发现，每次导航到一个文件夹时，面包屑都会重新挂载。这是因为View中的`v-if`语句会每次删除和添加HTML。
- en: As we only need to cache the parent folders once, on initial app load, let's
    look at changing where it gets triggered. We only need to run this function the
    first time; once the user has started navigating up and back down the tree, all
    the folders visited will be cached along the way.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要在初始应用加载时缓存父文件夹一次，让我们看看如何改变触发它的位置。我们只需要在第一次运行此函数时运行它；一旦用户开始在树中向上和向下导航，所有访问过的文件夹都将被缓存。
- en: Caching parent folders once
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存父文件夹一次
- en: To ensure we are using the least amount of resources, we can keep the array
    of folders used for the breadcrumb in the store. This means that both the `breadcrumb`
    component and our parent caching function can access the same array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们使用的资源最少，我们可以将用于面包屑的文件夹数组保留在store中。这意味着`breadcrumb`组件和我们的父级缓存函数都可以访问相同的数组。
- en: 'Add a `breadcrumb` key to your store state—this is where we will store the
    array:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的store状态中添加一个`breadcrumb`键，这是我们将存储数组的地方：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, move the code from the `breadcrumb` component into the `updateHash` mutation
    so we can update both the `path` and `breadcrumb` variables:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`breadcrumb`组件中的代码移动到`updateHash`mutation中，这样我们就可以同时更新`path`和`breadcrumb`变量：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that rather than returning the `output` array, it is getting stored in
    the `state` object. We can now update the folder''s computed function on the `breadcrumb`
    component to return the store data:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不再返回`output`数组，而是将其存储在`state`对象中。现在我们可以更新`breadcrumb`组件上的文件夹计算函数，以返回存储的数据：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With the data now available globally, we can create a new method on the `dropbox-viewer`
    component, `cacheParentFolders`, which triggers the code we wrote for the `breadcrumb`
    component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`dropbox-viewer`组件上创建一个新的方法`cacheParentFolders`，触发我们为`breadcrumb`组件编写的代码。
- en: 'Create a new method on the `Dropbox` component and move your code to it. Update
    the location of the parents and ensure you are firing the correct path:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Dropbox`组件上创建一个新的方法，并将你的代码移到其中。更新父级的位置，并确保触发正确的路径：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now fire this method once when the Dropbox component gets created. Add
    it after the existing method call in the `created` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当创建Dropbox组件时，我们可以触发此方法一次。在`created`函数中的现有方法调用之后添加它：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can now do some housekeeping and delete the `mounted` method from the `breadcrumb`
    component, along with the `props` object and the `:cache` prop from the view.
    This means our `breadcrumb` component is now simpler than it was before:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进行一些清理工作，删除`breadcrumb`组件中的`mounted`方法，以及视图中的`props`对象和`:cache`属性。这意味着我们的`breadcrumb`组件现在比以前更简单：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The HTML returns to what it was:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: HTML恢复到原来的状态：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also tidy up the `updateHash` mutation in the store to be a bit neater
    and more understandable:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将存储中的`updateHash`变异整理得更整洁、更易理解：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: All the variables are now being declared at the top, with the `state` being
    updated at the bottom. The number of variables has also been reduced.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的变量都在顶部声明，`state`在底部更新。变量的数量也减少了。
- en: Viewing the app now, it appears to work correctly; however, upon closer inspection,
    the `breadcrumb` seems to lag a bit with the folder structure on initial page
    load. Once a folder has been navigated to, it catches up but on the first load
    it seems to have one fewer item, and when viewing the root of the Dropbox none
    at all.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看应用程序，它似乎正常工作；然而，仔细检查后，`breadcrumb`在初始页面加载时似乎有点滞后于文件夹结构。一旦导航到一个文件夹，它就会追上来，但在第一次加载时，它似乎少了一个项目，在查看Dropbox的根目录时则没有任何项目。
- en: 'This is because the store has not been fully initialized before we are committing
    the `updateHash` mutation. If we remember back to the Vue instance lifecycle,
    covered in Chapter 4, *Getting a List of Files Using the Dropbox API*, we can
    see the created function gets fired very early on. Updating the main Vue instance
    to trigger the mutation on `mounted` instead resolves the issue:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在我们提交`updateHash`变异之前，存储还没有完全初始化。如果我们回忆一下Vue实例的生命周期，在第4章“使用Dropbox API获取文件列表”中介绍过，我们可以看到created函数在非常早期就被触发了。将主Vue实例更新为在`mounted`上触发变异可以解决这个问题：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With all the folders being cached as well as they can be, we can move on to
    caching more API calls by storing the download link for each file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有文件夹都已经被缓存，我们可以继续通过存储每个文件的下载链接来缓存更多的API调用。
- en: We could also look into caching subfolders of subfolders, looping through the
    contents of each cached folder to eventually cache the whole tree. We won't go
    into that, but feel free to give it a go yourself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以尝试缓存子文件夹的子文件夹，通过循环遍历每个缓存文件夹的内容，最终缓存整个树。我们不会详细介绍这个，但你可以自己尝试一下。
- en: Caching download links on files
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存文件的下载链接
- en: When the user is navigating around the document tree, the Dropbox API is still
    being queried more than necessary. This is because every time a file is displayed,
    we query the API to retrieve the download link. Extra API queries can be negated
    by storing the download link response in the cache and re-displaying the folder
    it is navigated back into.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在文档树中导航时，Dropbox API仍然被查询了多次。这是因为每次显示一个文件时，我们都会查询API来获取下载链接。通过将下载链接响应存储在缓存中，并在导航回所在的文件夹时重新显示，可以避免额外的API查询。
- en: Every time a file is displayed, a new component gets initialized using data
    from the store. We can use this to our advantage as it means we only need to update
    the component instance and then the result gets cached.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每次显示一个文件时，都会使用存储中的数据初始化一个新的组件实例。我们可以利用这一点，因为这意味着我们只需要更新组件实例，然后结果就会被缓存。
- en: In your file component, update the API response to not only save the result
    on the `link` property of the data attribute but the on the file instance, `f`,
    as well. This will be stored as a new key, `download_link`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件组件中，更新API响应，不仅将结果保存在数据属性的`link`属性上，还保存在文件实例`f`上。这将作为一个新的键`download_link`存储。
- en: 'When storing the data, rather than having two separate commands, we can combine
    them into one with two equal signs:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储数据时，我们可以将两个单独的命令合并为一个命令，使用两个等号：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This essentially means `this.f.download_link` is equal to `this.link`, which
    is also equal to `data.link`, the download link from the API. With this being
    stored and displayed when the folder is navigated to, we can add an `if` statement
    to see whether the data exists and, if not, query the API to get it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着`this.f.download_link`等于`this.link`，也等于来自API的`data.link`下载链接。通过在导航到文件夹时存储和显示此信息，我们可以添加一个`if`语句来检查数据是否存在，如果不存在，则查询API获取它。
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Doing this on file creation saves the API being queried unnecessarily. If we
    obtained this information when caching the folders, we could slow down the app
    and be storing non-essential information. Imagine a folder with hundreds of photos
    in it—we wouldn't want to query the API for every one of these just on the off
    chance the user might enter that folder.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件创建时这样做可以避免不必要地查询API。如果我们在缓存文件夹时获取了这些信息，可能会减慢应用程序的速度并存储非必要的信息。想象一下一个包含数百张照片的文件夹-我们不希望为每个照片都查询API，只是为了用户可能进入该文件夹。
- en: This means everything in our app only needs to query the API once to get the
    information. The user can navigate up and down folder structures as many times
    as they want, with the app only getting faster as they do so.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应用程序中的所有内容只需要查询API一次以获取信息。用户可以随意在文件夹结构中上下导航，随着操作次数的增加，应用程序只会变得更快。
- en: The complete code—with added documentation
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整的代码-附加了文档
- en: With our app complete, we can now add some much-needed documentation. It's always
    good to document your code as this gives it reasoning and explanation. Good documentation
    should not just say what the code does, but why it does it, what is allowed, and
    what is not allowed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的应用程序后，我们现在可以添加一些非常需要的文档。文档化代码总是很好的，因为它给出了它的原因和解释。良好的文档不仅应该说明代码的功能，还应该说明为什么这样做，允许什么，不允许什么。
- en: 'A popular method for documentation is the JavaScript DocBlock standard. This
    set of conventions lays out style guide-like rules for you to follow when documenting
    your code. DocBlock is formatted in a comment block and features keywords starting
    with an `@`, such as `@author`, `@example`, or listing what parameters a function
    can accept with the `@param` keyword. An example would be:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常用的文档方法是JavaScript DocBlock标准。这套约定规定了在文档化代码时要遵循的样式指南。DocBlock以注释块的形式进行格式化，并以`@`开头的关键字为特色，例如`@author`，`@example`，或者使用`@param`关键字列出函数可以接受的参数。一个示例是：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Starting off with a description, DocBlock has several keywords to help lay out
    the documentation. We'll walk through our completed Dropbox app with added documentation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从描述开始，DocBlock有几个关键字可以帮助布置文档。我们将通过添加文档来完成我们的Dropbox应用程序。
- en: 'Let us first take a look at the `breadcrumb` component:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下`breadcrumb`组件：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Moving on to the `folder` component:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 继续到`folder`组件：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, in line, we see the `file` component:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在行中，我们看到`file`组件：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we take a look at the `dropbox-viewer` component:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下`dropbox-viewer`组件：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let us also check the Vuex store:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也检查一下Vuex存储：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We furthermore move to the Vue app*:*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进一步转到Vue应用程序*：*
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And in the end, we go through the `window.onhashchange` function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过`window.onhashchange`函数：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, the HTML from the view looks like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，视图中的HTML如下所示：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And the template for the Dropbox viewer looks like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Dropbox查看器的模板如下所示：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You will notice not *everything* has been documented. A simple function or variable
    assignment doesn't need to re-explain what it does, but a note of the main variables
    will help anyone looking at it in the future.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到并非所有内容都已记录。一个简单的函数或变量赋值不需要重新解释它的作用，但是对主要变量的注释将帮助任何查看它的人在将来理解。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this section of the book, we've covered quite a lot! We started with querying
    the Dropbox API to get a list of files and folders. We then moved on to adding
    navigation, allowing the user to click on folders and download files. We then
    introduced Vuex and the store into our app, which meant we could centralize the
    path, breadcrumb, and most importantly, cache the folder contents. Lastly, we
    looked at caching sub-folders and the file download link.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们涵盖了很多内容！我们从查询Dropbox API以获取文件和文件夹列表开始。然后我们继续添加导航功能，允许用户点击文件夹并下载文件。接下来，我们介绍了Vuex和store到我们的应用程序中，这意味着我们可以集中路径、面包屑，最重要的是，缓存文件夹内容。最后，我们看了一下缓存子文件夹和文件下载链接。
- en: In the next section of the book, we are going to look at making a shop. This
    will include browsing products in a category and product pages using a new Vue
    plugin called Vue router. We will also look at adding products to a basket and
    storing both the product list and preferences in the Vuex store.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一部分，我们将看看如何创建一个商店。这将包括使用一个名为Vue router的新Vue插件浏览类别和产品页面。我们还将研究如何将产品添加到购物篮中，并将产品列表和偏好存储在Vuex
    store中。
