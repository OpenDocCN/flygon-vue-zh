- en: '*Chapter 6*: Building a Vacation Booking App with the PrimeVue UI Framework'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：使用PrimeVue UI框架构建度假预订应用'
- en: In [*Chapter 5*](B14405_05_ePub_RK.xhtml#_idTextAnchor056), *Building a Multipurpose
    Calculator Mobile App with Ionic*, we built a mobile app with the Ionic mobile
    app framework, which is built upon Vue.js. However, so far in this book, we have
    not built any web apps using the UI libraries or frameworks that are based on
    Vue.js. Additionally, we have not built anything that has its own backend. A backend
    is definitely something that is required in most systems because we need somewhere
    to store our data, authenticate users, run background tasks, and more. In this
    chapter, we will build a vacation booking application with the PrimeVue UI framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B14405_05_ePub_RK.xhtml#_idTextAnchor056)中，*使用Ionic构建多用途计算器移动应用*，我们使用Ionic移动应用框架构建了一个移动应用，该框架构建在Vue.js之上。然而，到目前为止，在本书中，我们尚未使用基于Vue.js的UI库或框架构建任何Web应用程序。此外，我们还没有构建具有自己后端的任何内容。大多数系统肯定需要后端，因为我们需要一个地方来存储我们的数据、验证用户、运行后台任务等。在本章中，我们将使用PrimeVue
    UI框架构建度假预订应用。
- en: We will be using the Vue 3 frontend for administration and another frontend
    for users to add their bookings. We will also include a simple backend to authenticate
    any administrators before they carry out tasks that can only be done by them.
    To keep the project as simple as possible, the frontend for the general public
    won't require authentication.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Vue 3前端进行管理，另一个前端供用户添加他们的预订。我们还将包括一个简单的后端，以在管理员执行只有他们才能完成的任务之前对其进行身份验证。为了尽可能简化项目，普通公众的前端不需要身份验证。
- en: 'In this chapter, we will focus on the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于以下主题：
- en: Building a frontend with the PrimeVue UI framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PrimeVue UI框架构建前端
- en: Building a simple backend with Express for authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express构建简单的后端进行身份验证
- en: Persisting data in the backend with SQLite
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQLite在后端持久化数据
- en: Using Vue Router for authentication on the frontend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前端使用Vue Router进行身份验证
- en: Form validation with Vee-Validate and Yup
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vee-Validate和Yup进行表单验证
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter is located at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter06](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter06).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于[https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter06](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter06)。
- en: '**PrimeVue** is a UI framework based on Vue 3\. This means we can use it for
    Vue 3 apps. Frameworks that are based on Vue 2 cannot be used by Vue 3 apps because
    the API has gone through significant changes. The underlying code of Vue 3 is
    also different from Vue 2\. PrimeVue includes a number of common components that
    we use in web apps, such as text inputs, buttons, menu bars, tables, and more.
    It is very comprehensive in terms of what is included. Additionally, it comes
    with styles for items in the form of themes. This means that we can use the built-in
    components right away. Since PrimeVue is made for Vue 3, we can simply register
    the components, import the CSS, and use the components in our code. We can also
    register them either locally or globally depending on which components we need
    for the given components.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**PrimeVue**是基于Vue 3的UI框架。这意味着我们可以将其用于Vue 3应用程序。基于Vue 2的框架无法用于Vue 3应用程序，因为API已经经历了重大变化。Vue
    3的底层代码也与Vue 2不同。PrimeVue包括许多我们在Web应用程序中使用的常见组件，如文本输入、按钮、菜单栏、表格等。它在包含的内容方面非常全面。此外，它还提供了主题样式。这意味着我们可以立即使用内置组件。由于PrimeVue是为Vue
    3而制作的，我们可以简单地注册组件、导入CSS，并在我们的代码中使用组件。我们还可以根据需要为给定组件在本地或全局注册它们。'
- en: Understanding PrimeVue
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解PrimeVue
- en: PrimeVue comes with styles for the inputs and various kinds of text, such as
    validation errors and buttons. It also comes with flexbox helpers, which we can
    use to set the spacing for the components easily. This is very useful because
    we can simply use the CSS classes that PrimeVue comes with to set the position
    and spacing of our components.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PrimeVue带有输入框和各种文本的样式，例如验证错误和按钮。它还带有flexbox助手，我们可以使用它们轻松设置组件的间距。这非常有用，因为我们可以简单地使用PrimeVue提供的CSS类来设置组件的位置和间距。
- en: So far in this book, we have not used any libraries to make form validation
    more convenient. Form validation is something that we have to do a lot for most
    web apps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们还没有使用任何库来使表单验证更加方便。表单验证是大多数Web应用程序中我们必须经常做的事情。
- en: Understanding Vee-Validate and Yup
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Vee-Validate和Yup
- en: '**Vee-Validate 4** is a form validation library that is compatible with Vue
    3\. With it, we can add components that will add validation to our forms on the
    frontend. We will use it with the Yup data validation library to create the form
    validation schema, which Vee-Validate can use for validation. With the `Form`
    component, we can add a form that enables us to do form validation with Vee-Validate
    4\. Then, the `Field` component can be used to validate the form control components
    that come with PrimeVue. It does this by wrapping around them and passing the
    slot props that come with the `Field` components as props to the input components.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vee-Validate 4**是与Vue 3兼容的表单验证库。借助它，我们可以添加组件，以在前端对我们的表单进行验证。我们将与Yup数据验证库一起使用它，以创建表单验证模式，Vee-Validate可以用于验证。通过`Form`组件，我们可以添加一个表单，使我们能够使用Vee-Validate
    4进行表单验证。然后，`Field`组件可以用于验证PrimeVue提供的表单控件组件。它通过包装它们并将`Field`组件提供的插槽属性作为输入组件的属性传递来实现这一点。'
- en: The Yup library will be used with Vee-Validate to let us validate form values
    easily without writing all the code from scratch. It lets us create form validation
    schema objects that we can pass into forms created with Vee-Validate to add form
    validation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Yup库将与Vee-Validate一起使用，让我们可以轻松验证表单值，而无需从头开始编写所有代码。它允许我们创建表单验证模式对象，我们可以将其传递到使用Vee-Validate创建的表单中，以添加表单验证。
- en: Understanding Express
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Express
- en: To create a simple backend to store data, we use the **Express framework**.
    This is a very simple Node.js backend framework, which allows us to create a simple
    backend quickly. To store data, we will use an SQLite database to keep the project
    simple. We will use the Express framework to create an API to enable the frontend
    to make HTTP requests to it. We let them make requests by exposing the API endpoint,
    which the frontend can use by adding routes into it. Each route has a handler
    function that handles the data submitted by the frontend. We get request data
    from the HTTP requests made by the frontend, which includes the headers and the
    body, and we use them in the route handlers to get and store the data the way
    we want.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个简单的后端来存储数据，我们使用**Express框架**。这是一个非常简单的Node.js后端框架，可以让我们快速创建一个简单的后端。为了存储数据，我们将使用SQLite数据库来保持项目简单。我们将使用Express框架创建一个API，以便前端可以向其发出HTTP请求。我们通过公开API端点来让他们发出请求，前端可以通过添加路由来使用它。每个路由都有一个处理程序函数，用于处理前端提交的数据。我们从前端发出的HTTP请求中获取请求数据，其中包括头部和主体，并在路由处理程序中使用它们来获取和存储我们想要的数据。
- en: Connecting the frontend and the backend
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接前端和后端
- en: To make the frontend app communicate with the backend app, we'll need to enable
    cross-domain communication on the backend so that the traffic from the frontend
    can go through to the backend. This can easily be done with the **Cross-Origin
    Resource Sharing** (**CORS**) middleware that we will add to our Express app.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前端应用与后端应用通信，我们需要在后端启用跨域通信，以便来自前端的流量可以通过到达后端。这可以通过我们将添加到Express应用程序的**跨域资源共享**（**CORS**）中间件轻松完成。
- en: To work with SQLite databases, we use the `sqlite3` library, which lets us manipulate
    the SQLite database within the Node.js apps. We can make queries and run SQL commands
    to insert or remove data from our database.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用SQLite数据库，我们使用`sqlite3`库，它允许我们在Node.js应用程序中操作SQLite数据库。我们可以进行查询并运行SQL命令来插入或删除数据库中的数据。
- en: Additionally, we will have simple authentication for the admin frontend. We
    will check the username and password for the admin login, and if it's valid, we
    can issue a token and send it to the frontend. Then, the frontend will use the
    token, which is stored in the header, to check whether the request can be made
    from the frontend. We add authentication for the *admin-only* routes only, so
    we only need to check the token for the routes that requires authentication before
    loading them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将为管理员前端设置简单的身份验证。我们将检查管理员登录的用户名和密码，如果有效，我们可以发放一个令牌并将其发送到前端。然后，前端将使用存储在标头中的令牌来检查请求是否可以从前端发出。我们仅为*仅限管理员*路由添加身份验证，因此我们只需要在加载需要身份验证的路由之前检查令牌。
- en: To create and check the token, we use the `jsonwebtoken` library. This allows
    us to create a token and sign it with a secret string. It also enables us to check
    the token with a secret to see whether it is valid. We put the `jsonwebtoken`
    library inside a middleware that is run before the route handler to do the check.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建和检查令牌，我们使用`jsonwebtoken`库。这允许我们创建一个令牌并用秘密字符串签名。它还使我们能够使用秘密检查令牌是否有效。我们将`jsonwebtoken`库放在一个中间件中，在路由处理程序之前运行以进行检查。
- en: If the token is valid, then we call a function to proceed to the route handler.
    Otherwise, we send a `401` status back to the client.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果令牌有效，则调用函数继续到路由处理程序。否则，我们向客户端发送`401`状态。
- en: Now, we are going to build the project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将构建项目。
- en: Creating the vacation booking project
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建度假预订项目
- en: To create the vacation booking application, we need to create subprojects for
    the frontend, the admin frontend, and the backend. To create the `frontend` and
    `admin frontend` project scaffolds, we use the Vue CLI. To create the `backend`
    folder, we use the `Express Generator` global package.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 创建度假预订应用程序，我们需要为前端、管理员前端和后端创建子项目。我们使用Vue CLI来创建`frontend`和`admin frontend`项目脚手架。我们使用`Express
    Generator`全局包来创建`backend`文件夹。
- en: 'Follow these steps to set up the project:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置项目：
- en: First, create the `travel-booking-app` folder to house all of the projects.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建`travel-booking-app`文件夹来容纳所有项目。
- en: Next, create the `admin-frontend`, `frontend`, and `backend` folders inside
    the main folder.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在主文件夹内创建`admin-frontend`、`frontend`和`backend`文件夹。
- en: 'Go into the `admin-frontend` folder and run the following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`admin-frontend`文件夹并运行以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will add the scaffolding code for the Vue project inside the `admin-frontend`
    folder.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`admin-frontend`文件夹内添加Vue项目的脚手架代码。
- en: If you are asked to create the project in the current folder, select *Y*. Then,
    when you're asked to choose the Vue version of the project, choose `Vue 3`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要在当前文件夹中创建项目，请选择*Y*。然后，在要求选择项目的Vue版本时，选择`Vue 3`。
- en: Likewise, run the Vue CLI in the same way for the `frontend` folder.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以相同的方式在`frontend`文件夹中运行Vue CLI。
- en: 'To create an Express project, run the Express application generator app. To
    do this, go into the `backend` folder and run the following command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个Express项目，请运行Express应用程序生成器应用程序。要做到这一点，请进入“backend”文件夹并运行以下命令：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding command will add all of the files required for our project inside
    the `backend` folder. If you get an error, then try running `express-generator`
    as an `administrator`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在“backend”文件夹中添加我们项目所需的所有文件。如果出现错误，请尝试以“管理员”身份运行“express-generator”。
- en: Now that we have created the project scaffold files and folders, we are ready
    to start working on the backend.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目的脚手架文件和文件夹，我们准备开始在后端上工作。
- en: Creating the backend
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建后端
- en: Now that we have created the project folders with the scaffolding code, we can
    start working on the project code. We will start with the backend since we need
    it for both frontends.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了带有脚手架代码的项目文件夹，我们可以开始编写项目代码了。我们将从后端开始，因为我们需要它用于两个前端。
- en: To get started, let's add a few libraries that are needed to manipulate the
    SQLite database and add authentication to our app. Additionally, we need the library
    to add CORS to our app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们添加一些需要用来操作SQLite数据库并向我们的应用程序添加身份验证的库。此外，我们需要一个库来向我们的应用程序添加CORS。
- en: 'To install all of them, run the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它们，请运行以下命令：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After installing the packages, we are ready to work on the code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完这些包后，我们就可以开始编写代码了。
- en: Adding authentication middleware
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加身份验证中间件
- en: First, we add our middleware which we will use to check the token. We can do
    this easily with the `jsonwebtoken` library. This has the `verify` method to check
    the token.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加我们将用来检查令牌的中间件。我们可以很容易地使用jsonwebtoken库来做到这一点。它具有verify方法来检查令牌。
- en: 'To add the middleware, create the `middlewares` folder in the backend folder,
    and then add the `verify-token.js` file. Next, add the following code for the
    middleware:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加中间件，请在后端文件夹中创建“middlewares”文件夹，然后添加“verify-token.js”文件。接下来，添加以下中间件的代码：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we get the `x-token` request header with the `req.get` method. Then, we
    call `jwt.verify` with the returned `token` and `secret`, to verify that the token
    is valid. Then, we call `next` if it is valid. If it is not valid, an error will
    be thrown, and the `catch` block will be run. `res.status` with `401` is run to
    return the `401` response to the frontend since the token isn't valid in this
    scenario.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用“req.get”方法获取“x-token”请求头。然后，我们使用返回的“token”和“secret”调用“jwt.verify”来验证令牌是否有效。然后，如果有效，我们调用“next”。如果无效，将抛出错误，并运行“catch”块。运行“res.status”与“401”来将“401”响应返回给前端，因为在这种情况下令牌无效。
- en: The `module.exports` property is set to the `middleware` function as the value,
    which we are exporting. Exporting the function makes it available in the other
    modules in our backend app.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: “module.exports”属性设置为“middleware”函数作为值，我们正在导出它。导出函数使其在我们后端应用程序的其他模块中可用。
- en: Add routes to handle requests
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加处理请求的路由
- en: 'Next, we will add the `router` modules with the routes. First, add the routes
    to manipulate the bookings. To do this, add the `bookings.js` file to the `routes`
    folder. Inside the file, write the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加带有路由的“router”模块。首先，添加用于操作预订的路由。要做到这一点，请将“bookings.js”文件添加到“routes”文件夹中。在文件中，编写以下代码：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we import the required modules including the `verify-token middleware`
    file that we just created.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入所需的模块，包括我们刚刚创建的“verify-token中间件”文件。
- en: The `router.get` method allows us to create a GET request API endpoint. The
    path is in the first argument. It is the path for the route and it is relative
    to the path of the router. So, the router's route path is the first segment, and
    the path in the first argument of `router.get` forms the rest of the URL.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`router.get`方法允许我们创建一个GET请求API端点。路径在第一个参数中。它是路由的路径，相对于路由器的路径。因此，路由器的路由路径是第一个部分，而`router.get`的第一个参数中的路径形成URL的其余部分。'
- en: The second argument of the `router.get` method is the route handler. The `req`
    parameter is an object that has the request data. The `res` parameter is an object
    that lets us send various kinds of responses to the frontend. We get the database
    with the `sqlite3.Database` constructor with the path to the database file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`router.get`方法的第二个参数是路由处理程序。`req`参数是一个包含请求数据的对象。`res`参数是一个对象，让我们可以向前端发送各种类型的响应。我们使用`sqlite3.Database`构造函数获取数据库，并指定数据库文件的路径。'
- en: Next, we call the `db.serialize` function so that we can run the code inside
    the callback in sequence.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`db.serialize`函数，以便可以按顺序运行回调中的代码。
- en: The `db.all` method gets all the results returned from the query. The string
    is the SQL command that retrieves all the data from the bookings table, which
    we will create with our own SQL code. The `bookings` table is joined with the
    `catalog_items` table so that the `vacation` package data is associated with the
    booking.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.all`方法获取查询返回的所有结果。字符串是从bookings表中检索所有数据的SQL命令，我们将使用我们自己的SQL代码创建它。`bookings`表与`catalog_items`表连接，以便`vacation`套餐数据与预订相关联。'
- en: The second argument of `db.all` is the extra parameters that we want to pass
    in, which we ignore by passing in an empty array. Then, in the final argument,
    we have the function with the `err` parameter with the errors in object form.
    The `rows` parameter has the results from the query. In the callback, we call
    `res.json` to return the JSON response with the `rows` parameter data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.all`的第二个参数是我们想要传递的额外参数，我们通过传入一个空数组来忽略它们。然后，在最后一个参数中，我们有一个带有`err`参数的函数，其中包含对象形式的错误。`rows`参数包含查询结果。在回调中，我们调用`res.json`返回带有`rows`参数数据的JSON响应。'
- en: Then, we call `db.close` to close the database connection once the required
    operation is done.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`db.close`来在所需操作完成后关闭数据库连接。
- en: 'Next, we will create a POST route. This will allows us to run an `INSERT` SQL
    command to insert an entry into the bookings table. Add the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个POST路由。这将允许我们运行`INSERT` SQL命令将条目插入到bookings表中。添加以下代码：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we get the body properties with the `req.body` property. We get all the
    properties we want to insert into the entry. Next, we create a prepared statement
    with the `INSERT` statement. The values at the end are question marks; this means
    they are placeholders where we can place our own values when we run the `stmt.run`
    method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`req.body`属性获取body属性。我们获取所有要插入条目的属性。接下来，我们使用`INSERT`语句创建一个预处理语句。最后的值是问号；这意味着它们是占位符，我们可以在运行`stmt.run`方法时放入我们自己的值。
- en: Prepared statements are useful because they enable us to pass in values to our
    SQL commands securely. The values are all sanitized so that malicious code cannot
    run inside the code. We run `stmt.run` to run the prepared statement with the
    values we want to replace the placeholder with. We then call `stmt.finalize` to
    finalize the operation by writing the data. Next, we call `res.json` to return
    the JSON response to the frontend as a response. Then, we call `db.close` to close
    the database connection again.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好的语句很有用，因为它们使我们能够安全地传递值到我们的SQL命令中。这些值都经过了净化，以便恶意代码无法在代码中运行。我们运行`stmt.run`来运行带有我们想要替换占位符的值的准备好的语句。然后，我们调用`stmt.finalize`来通过写入数据来完成操作。接下来，我们调用`res.json`将JSON响应返回给前端作为响应。然后，我们调用`db.close`再次关闭数据库连接。
- en: 'Next, we will create a `DELETE` endpoint with the `router.delete` method. To
    do this, write the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`router.delete`方法创建一个`DELETE`端点。为此，请编写以下代码：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have the `/:id` path. `:id` is the URL parameter placeholder for the
    route. We also have the `verifyToken` middleware that we imported at the top of
    the `booking.js` file. We can use this to verify the token before proceeding to
    run the code for the route handler. This means that this route is an authenticated
    route that requires a token in the header for the API endpoint call to succeed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`/:id`路径。`：id`是路由的URL参数占位符。我们还有`verifyToken`中间件，我们在`booking.js`文件的顶部导入了它。我们可以使用它来在继续运行路由处理程序之前验证令牌。这意味着这个路由是一个需要在API端点调用的标头中需要令牌的经过身份验证的路由。
- en: In the route handler, we get the `id` URL parameter from the `req.params` property.
    Then, we call `db.serialize`, as we did with the previous route. In the callback,
    we have the prepared statement, so we can issue a `DELETE` SQL command with the
    `id` value that we set in the `stmt.run` method. Then, we call `stmt.finalize`,
    `res.json`, and `db.close` just as we did in the other routes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由处理程序中，我们从`req.params`属性中获取`id` URL参数。然后，我们调用`db.serialize`，就像我们在之前的路由中所做的那样。在回调中，我们有准备好的语句，因此我们可以使用`DELETE`
    SQL命令和我们在`stmt.run`方法中设置的`id`值。然后，我们调用`stmt.finalize`，`res.json`和`db.close`，就像我们在其他路由中所做的那样。
- en: 'Finally, at the end of the `booking.js` file, let''s add the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`booking.js`文件的末尾，让我们添加以下内容：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding the preceding statement allows us to import it into another file to register
    the router. Registering the router will make it accessible.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 添加上述语句使我们能够将其导入到另一个文件中以注册路由。注册路由将使其可访问。
- en: 'Next, we will create the `catalog.js` file in the `routes` folder. This file
    is a `router` module with API endpoints to add our vacation packages. First, we
    start as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`routes`文件夹中创建`catalog.js`文件。这个文件是一个具有API端点的`router`模块，用于添加我们的度假套餐。首先，我们开始如下：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is almost the same as the `GET` route in `bookings.js`; however, here,
    we retrieve all of the items from the `catalog_items` table.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与`bookings.js`中的`GET`路由相同；但是，在这里，我们从`catalog_items`表中检索所有项目。
- en: 'Next, let''s add a `POST` route to add an entry into the `catalog_items` table.
    Write the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个`POST`路由来将条目添加到`catalog_items`表中。编写以下代码：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we have `verifyToken` in the second argument to check the token in this
    route before running the route handler in the third argument.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在第二个参数中有`verifyToken`来检查此路由中的令牌，然后再运行第三个参数中的路由处理程序。
- en: 'Next, we add a route that enables us to delete a `catalog_items` entry. We
    do this using the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个路由，使我们能够删除`catalog_items`条目。我们使用以下代码来实现这一点：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we export the router:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导出路由：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This module isn't much different from `booking.js`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块与`booking.js`并没有太大的不同。
- en: 'Next, we delete the content of the `routes/users.js` file or create it if it
    doesn''t exist. Then, we add the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们删除`routes/users.js`文件的内容，或者如果不存在，则创建它。然后，我们添加以下代码：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is where we check whether the `username` and `password` for the admin user
    are valid. We only have one user to check here to keep the project simple. We
    get the `username` and `password` from the `req.body` object, which has the JSON
    request object. Then, we check for the `username` and `password` with the `if`
    statement, and if the expression in `if` returns `true`, we call `jwt.sign` to
    create a token with the token data in the first argument and `secret` in the second
    argument. Then, we return the response with the authentication token with `res.json`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们检查管理员用户的`username`和`password`是否有效的地方。我们只有一个用户需要检查，以保持项目简单。我们从`req.body`对象中获取`username`和`password`，该对象具有JSON请求对象。然后，我们使用`if`语句检查`username`和`password`，如果`if`中的表达式返回`true`，我们调用`jwt.sign`使用第一个参数中的令牌数据和第二个参数中的`secret`创建令牌。然后，我们使用`res.json`返回带有认证令牌的响应。
- en: Otherwise, we call `res.status` with `401` to return a `401` response, as the
    `username` or `password` are not valid.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们调用`res.status`和`401`返回`401`响应，因为`username`或`password`无效。
- en: 'Next, we register our `router` modules and global middleware in `app.js`. To
    do this, we write the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`app.js`中注册我们的`router`模块和全局中间件。为此，我们编写以下代码：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We import the `router` modules that we exported earlier with the last line
    of the `router` files using `require`. Then, we import the `cors` module:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了之前使用`require`导出的`router`模块。然后，我们导入了`cors`模块。
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We call `app.use` to add the `cors` middleware and then the `router` modules.
    In the last three lines, we pass in `path` as the first argument and the `router`
    module as the second argument. This allows us to access the endpoints that we
    created earlier. With the `cors` module, we can enable cross-domain communication
    in our Express app.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`app.use`添加`cors`中间件，然后添加`router`模块。在最后三行中，我们将`path`作为第一个参数，`router`模块作为第二个参数。这使我们能够访问之前创建的端点。使用`cors`模块，我们可以在Express应用程序中启用跨域通信。
- en: 'Next, let''s create our SQL script so that we can drop and create the tables
    easily. To do this, create the `db.sql` file in the `backend` folder and write
    the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的SQL脚本，以便我们可以轻松地删除和创建表。为此，在`backend`文件夹中创建`db.sql`文件，并编写以下代码：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we have created the `bookings` and `catalog_items` tables. Each of these
    tables has various fields. `TEXT` creates a text column. `NOT NULL` makes the
    column non-nullable. `PRIMARY KEY` indicates that the column is a primary key
    column. `FOREIGN KEY` indicates that one column is a foreign key for another column.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了`bookings`和`catalog_items`表。每个表都有各种字段。`TEXT`创建文本列。`NOT NULL`使列不可为空。`PRIMARY
    KEY`表示该列是主键列。`FOREIGN KEY`表示一个列是另一个列的外键。
- en: We can run the SQL code by installing the DB Browser for the SQLite program,
    which can be downloaded at [https://sqlitebrowser.org/](https://sqlitebrowser.org/),
    and then creating `db.sqlite` in the `backend` folder. Then, we can go to the
    **Execute SQL** tab and paste the code into the text input. Following this, we
    can select all the text and press *F5* to run the code. This will drop any existing
    `bookings` and `catalog_items` tables and create them again. For changes for the
    database to be written to disk, you have to save them. To do this, click on the
    **File** menu and then click on **Write** **Changes**. We can also press the *Ctrl
    + S* keyboard combination to save the changes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过安装SQLite程序的DB浏览器来运行SQL代码，可以在[https://sqlitebrowser.org/](https://sqlitebrowser.org/)下载，然后在`backend`文件夹中创建`db.sqlite`。然后，我们可以转到**执行SQL**选项卡，并将代码粘贴到文本输入中。之后，我们可以选择所有文本，按下*F5*来运行代码。这将删除任何现有的`bookings`和`catalog_items`表，并重新创建它们。要将更改写入磁盘，您必须保存它们。要做到这一点，点击**文件**菜单，然后点击**写入更改**。我们也可以按下*Ctrl
    + S*键组合来保存更改。
- en: 'Finally, to make our app run and restart automatically when we change the code,
    we can install the `nodemon` package globally. To do this, run the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使我们的应用程序在更改代码时自动运行和重新启动，我们可以全局安装`nodemon`包。要做到这一点，请运行以下命令：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, in the `package.json` file, change the `script.start` property''s value
    to the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`package.json`文件中，将`script.start`属性的值更改为以下代码：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can run `npm start` with `nodemon` instead of the regular node executable,
    which means the app will restart automatically when we change any code file and
    save it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`nodemon`来运行`npm start`，而不是常规的node可执行文件，这意味着当我们更改任何代码文件并保存时，应用程序将自动重新启动。
- en: Now that we have created a basic backend for the frontends to consume, we can
    move on to create our frontend apps with PrimeVue and Vue 3.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为前端创建了一个基本的后端来消耗，我们可以继续使用PrimeVue和Vue 3创建我们的前端应用程序。
- en: Creating the admin frontend
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建管理前端
- en: Now that the backend app is complete, we can move on to work on the admin frontend.
    We already created the Vue 3 project for the admin frontend in the `admin-frontend`
    folder earlier, so we just need to install packages that we require and work on
    the code. We will need the PrimeVue packages – that is, the Vee-Validate, Vue
    Router, Axios, and Yup packages.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在后端应用程序已经完成，我们可以继续在管理前端上工作。我们之前已经在`admin-frontend`文件夹中为管理前端创建了Vue 3项目，因此我们只需要安装所需的包并处理代码。我们将需要PrimeVue包
    - 即Vee-Validate、Vue Router、Axios和Yup包。
- en: 'To install them, run the following command in the `admin-frontend` folder:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它们，请在`admin-frontend`文件夹中运行以下命令：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Axios allows us to make HTTP requests to the backend. Vue Router lets us map
    URLs to the `page` components. Vee-Validate and Yup allow us to easily add form
    validation to our forms, and the remaining packages are the PrimeVue packages.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Axios允许我们向后端发出HTTP请求。Vue Router允许我们将URL映射到`page`组件。Vee-Validate和Yup允许我们轻松地向我们的表单添加表单验证，其余的包是PrimeVue包。
- en: Creating the admin frontend pages
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建管理前端页面
- en: 'After installing the packages, we can start working on the code. First, we
    will work on the components. In the `components` folders, add the `CatalogForm.vue`
    file and write the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完包后，我们可以开始处理代码。首先，我们将处理组件。在`components`文件夹中，添加`CatalogForm.vue`文件，并编写以下代码：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we have the `Form` component from the Vee-Validate package to add a form
    with form validation. The `submit` event is only emitted when all of the form
    values are valid. We will register the `Form` component later. The `validation-schema`
    prop is set to the validation schema object created by Yup.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有来自Vee-Validate包的`Form`组件，用于添加具有表单验证的表单。只有当所有表单值都有效时，才会触发`submit`事件。我们稍后将注册`Form`组件。`validation-schema`属性设置为Yup创建的验证模式对象。
- en: Inside the `Form` component, we have a `Field` component, which is also provided
    by the Vee-Validate package. We will also register this component globally later
    so that we can use it. Inside the `Field` component, we have the `InputText` component
    to add an input field into our app. To enable form validation for the `InputText`
    component, we pass in the `field` object to the `slot` props and pass the whole
    thing as the value of the `v-bind` directive. The `v-bind` directive allows Vee-Validate
    to handle the form values and add validation to our `form` field. The `errors`
    array gives us any validation errors that might have occurred.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Form`组件内，我们有一个`Field`组件，这也是由Vee-Validate包提供的。稍后我们还将全局注册此组件，以便我们可以使用它。在`Field`组件内，我们有`InputText`组件，用于在我们的应用程序中添加输入字段。为了为`InputText`组件启用表单验证，我们将`field`对象传递给`slot`属性，并将整个内容作为`v-bind`指令的值。`v-bind`指令允许Vee-Validate处理表单值并向我们的`form`字段添加验证。`errors`数组提供了可能发生的任何验证错误。
- en: The `p-col-12` class is provided by PrimeVue's PrimeFlex package. It lets us
    set the width of a `div` tag to full width, which means it takes 12 columns out
    of 12 on the page. With the `p-inputgroup` class, we can create an input group.
    The `p-error` class styles the text color to red so that we can show form validation
    messages in a way that is easy for the user to see. The `p-invalid` class makes
    the edge of the input red. We only change it to red if the error's length is bigger
    than `0` since this means there are validation errors, and we only show the smaller
    element when the error's length is bigger than `0`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`p-col-12`类由PrimeVue的PrimeFlex包提供。它允许我们将`div`标签的宽度设置为全宽，这意味着它占据页面上的12列中的12列。使用`p-inputgroup`类，我们可以创建一个输入组。`p-error`类将文本颜色样式设置为红色，以便我们可以以用户易于看到的方式显示表单验证消息。`p-invalid`类使输入的边缘变为红色。仅当错误的长度大于`0`时，我们才将其更改为红色，因为这意味着存在验证错误，而且仅在错误的长度大于`0`时才显示较小的元素。'
- en: The `Field` component has a `v-model` directive to bind the inputted value to
    the corresponding reactive properties. We also have a `name` attribute that is
    also used as the property name of the `value` parameter for the `submit` event
    handler, which has the inputted values. These values are always valid since the
    submit handler is only run when all of the form values are valid.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Field`组件具有`v-model`指令，将输入的值绑定到相应的响应式属性。我们还有一个`name`属性，也用作`submit`事件处理程序的`value`参数的属性名称，该处理程序具有输入的值。这些值始终有效，因为只有当所有表单值都有效时，才会运行提交处理程序。'
- en: With the `name` field, we can enter the name of the `vacation` package.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`name`字段，我们可以输入`度假`套餐的名称。
- en: 'Next, we need to add a text area to allow users to enter a description for
    the vacation package. To do this, write the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个文本区域，以允许用户为度假套餐输入描述。要做到这一点，请编写以下代码：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is almost the same as the `name` field; however, in this scenario, we switch
    out the `InputText` component for the `Textarea` component. We also change the
    `v-model` and `name` values. The `Textarea` component is from the PrimeVue package,
    which renders into a `textarea` element with its own styles.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`name`字段几乎相同；但是，在这种情况下，我们将`InputText`组件替换为`Textarea`组件。我们还更改了`v-model`和`name`的值。`Textarea`组件来自PrimeVue包，它以自己的样式呈现为`textarea`元素。
- en: 'Next, we add the image URL field so that we can add an image URL for the vacation
    package. We just let the user enter the image URL to make our project simpler.
    To add the field to the `Form` component, write the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加图像URL字段，以便为度假套餐添加图像URL。我们只需让用户输入图像URL，以使我们的项目更简单。要将字段添加到`Form`组件中，请编写以下代码：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is just another text input with a different name and `v-model` value.
    Finally, let''s add a `submit` button to the form using the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是另一个文本输入，名称和`v-model`值不同。最后，让我们使用以下代码向表单添加一个`submit`按钮：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Button` component is from the PrimeVue package, which we will register
    globally later to make it available everywhere.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`组件来自PrimeVue包，我们稍后将全局注册它，以使其在任何地方都可用。'
- en: 'Next, we add the `component` options object. We use the `component` options
    API to create our components. First, we import everything and create the form
    validation schema with the Yup library. To add the code, write the following in
    `components/CatalogForm.vue`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加`component`选项对象。我们使用`component`选项API来创建我们的组件。首先，我们导入所有内容，并使用Yup库创建表单验证模式。要添加代码，请在`components/CatalogForm.vue`中编写以下内容：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we create the schema object with the `yup.object` method, which allows
    us to validate an object with some properties. The `validation` schema is separate
    from the `v-model` binding. The property of the object that we pass into the `shape`
    method has to match the `name` attribute's value of the `Field` component.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`yup.object`方法创建了模式对象，它允许我们验证具有一些属性的对象。`validation`模式与`v-model`绑定是分开的。我们传递给`shape`方法的对象属性必须与`Field`组件的`name`属性值匹配。
- en: To validate the value of the field with `name` set to `name`, we set the `name`
    property to `yup.string().required()` to ensure that the `name` field is a string
    and has a value. We set the same value for `description`. The `imageUrl` value
    is set to `yup.string().url().required()` to ensure that the inputted value is
    a URL and that it is filled in.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证具有`name`设置为`name`的字段的值，我们将`name`属性设置为`yup.string().required()`，以确保`name`字段是一个字符串并且有值。我们为`description`设置相同的值。`imageUrl`值设置为`yup.string().url().required()`，以确保输入的值是一个URL并且已填写。
- en: The `data` method returns the schema so that we can use the `validation-schema`
    prop of the `Form` component.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`方法返回模式，以便我们可以使用`Form`组件的`validation-schema`属性。'
- en: 'To finish the component, we add the `onSubmit` method, which is called when
    the `submit` event is emitted by the `Form` component:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成组件，我们添加了`onSubmit`方法，当`Form`组件发出`submit`事件时被调用：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we simply take the `property` values from the `value` parameter, which
    has the valid form field values. Then, we make a POST request to the catalog endpoint
    with the JSON payload passed into the second argument. Following this, we call
    the `this.$emit` method to emit the `catalog-form-close` event to signal to the
    dialog component that this form will be housed in to close.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是从`value`参数中获取`property`值，该参数具有有效的表单字段值。然后，我们使用JSON负载进行POST请求到目录端点。随后，我们调用`this.$emit`方法来发出`catalog-form-close`事件，以通知对话框组件关闭此表单。
- en: Add a top bar and menu bar
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个顶部栏和菜单栏
- en: 'Next, we will add a `top bar` component into our app. To do this, create `TopBar.vue`
    in the `src/components` folder. Then, add the following template code into the
    file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的应用程序中添加一个`top bar`组件。要做到这一点，在`src/components`文件夹中创建`TopBar.vue`。然后，将以下模板代码添加到文件中：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Menubar` component is provided by the PrimeVue component. We can use it
    to add a menu bar with some items that we can click on to navigate to different
    pages. The `model` prop is set to the `items` reactive property, which is an array
    of menu item objects that we will add shortly. The `start` slot lets us add items
    to the left-hand side of the menu bar. We can put some bold text into the slot
    and it'll be displayed on the left-hand side.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Menubar`组件由PrimeVue组件提供。我们可以使用它来添加一个菜单栏，其中包含一些我们可以点击以导航到不同页面的项目。`model`属性设置为`items`响应式属性，它是一个我们即将添加的菜单项对象数组。`start`插槽让我们可以在菜单栏的左侧添加项目。我们可以将一些粗体文本放入插槽中，它将显示在左侧。'
- en: 'Next, we can add a `component` object for the component. To add it, write the
    following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以为组件添加一个`component`对象。要添加它，请编写以下代码：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we register the `title` prop, which we use to set the `document.title`
    value. The `document.title` property sets the title on the top bar. In the `data`
    method, we return an object with the item's reactive property. This is set to
    an object with the `label` and `command` properties. The `label` property is shown
    in the menu bar item for the user. The item is shown as a link. The `command`
    method is run when we click on the item.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注册`title`属性，用它来设置`document.title`的值。`document.title`属性设置了顶部栏的标题。在`data`方法中，我们返回一个具有项目的响应式属性的对象。这被设置为一个具有`label`和`command`属性的对象。`label`属性显示在用户的菜单栏项目中。该项目显示为一个链接。当我们点击该项目时，`command`方法被运行。
- en: With the `this.$router.push` method, we can navigate to the page that is mapped
    to the given URL. The `logOut` method navigates back to the page mapped to the
    `/` path, which is the *login* page that we will discuss later. Additionally,
    we clear the local storage so that we can clear the authentication token.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`this.$router.push`方法，我们可以导航到与给定URL映射的页面。`logOut`方法导航回到与`/`路径映射的页面，这是我们稍后将讨论的*login*页面。另外，我们清除本地存储，以便清除身份验证令牌。
- en: In the `beforeMount` hook, we set the `document.title` property to the value
    of the `title` prop.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`beforeMount`钩子中，我们将`document.title`属性设置为`title`属性的值。
- en: Add shared code to deal with requests
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加共享代码以处理请求
- en: 'Next, let''s write the code for the Axios request interceptor to let us add
    the authentication token to the `x-token` request header of all requests aside
    from when we make requests to the `/login` endpoint. To do this, create the `src/plugins`
    folder and add `axios.js` to it. Then, inside this file, write the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写Axios请求拦截器的代码，以便让我们将身份验证令牌添加到除了我们对`/login`端点进行请求之外的所有请求的`x-token`请求头中。为此，创建`src/plugins`文件夹，并将`axios.js`添加到其中。然后，在此文件中，编写以下代码：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we check the URL that the request is being made to by retrieving the
    URL with the `config.url` property. Then, if we make any requests to an endpoint
    other than `/login`, we set the `x-token` request header:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过检索具有`config.url`属性的URL来检查正在进行请求的URL。然后，如果我们对除`/login`之外的端点进行任何请求，我们设置`x-token`请求头：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that we get the token from local storage and set it to the value of `config.headers['x-token']`.
    The `config.headers` property is an object with the request headers. The second
    argument is the request error handler. Here, we simply return a rejected promise
    with `Promise.reject` so that we can handle the error.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从本地存储中获取令牌，并将其设置为`config.headers['x-token']`的值。`config.headers`属性是一个具有请求头的对象。第二个参数是请求错误处理程序。在这里，我们只是返回一个带有`Promise.reject`的拒绝承诺，以便我们可以处理错误。
- en: 'Next, we add Vue Router routes to our routes. We stay in the `src/plugins`
    folder and create a `vue-router.js` file. Then, we add the following code to the
    file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向我们的路由添加Vue Router路由。我们留在`src/plugins`文件夹中，并创建一个`vue-router.js`文件。然后，我们向文件中添加以下代码：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We add the `beforeEnter` function to check for the token if we go to any page
    on the frontend other than the home page. We can check the path that the user
    tries to go to with the `to.fullPath` property. If it is anything other than `'/'`
    and there is no token in local storage, then we call `next` with an object, and
    the `fullPath` property set to `'/'` to go to the login page. Otherwise, we call
    `next` with no argument to go to the page we are supposed to go to. If we have
    an error, then we also go to the login page, as you can see from the code in the
    `catch` block.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加`beforeEnter`函数来检查前端页面上除首页之外的任何页面的令牌。我们可以使用`to.fullPath`属性检查用户尝试访问的路径。如果不是`'/'`，并且本地存储中没有令牌，那么我们调用带有对象的`next`，并将`fullPath`属性设置为`'/'`以转到登录页面。否则，我们调用没有参数的`next`以转到我们应该去的页面。如果出现错误，那么我们也转到登录页面，正如您从`catch`块中的代码所看到的。
- en: Next, we have the `routes` array with the route definitions. This has the `route`
    path in the `path` property, and `component` is the component that the path maps
    to. The `beforeEnter` property is added to the last two route objects so that
    we can only go there once we are logged in.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有包含路由定义的`routes`数组。这个数组中`path`属性是路由的路径，`component`是路径映射到的组件。`beforeEnter`属性被添加到最后两个路由对象，这样我们只能在登录后才能访问那里。
- en: Then, to create the `router` object, we call `createRouter` with an object with
    the `history` property set to the object returned by the `createWebHashHistory`
    function; this is so that we can keep the hash between the hostname and the rest
    of the URL. We set the `routes` property to the `routes` array in order to register
    the routes. This is so we can see the right component when we go to the routes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了创建`router`对象，我们使用带有`history`属性设置为`createWebHashHistory`函数返回的对象的对象调用`createRouter`。这样我们就可以在主机名和URL的其余部分之间保持哈希。我们将`routes`属性设置为`routes`数组，以便注册路由。这样我们就可以在访问路由时看到正确的组件。
- en: Finally, we export the `router` object as a default export so that we can add
    the router object to our app later with `app.use`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`router`对象作为默认导出，以便稍后可以使用`app.use`将路由对象添加到我们的应用中。
- en: 'Next, we create the `views` folder inside the `src` folder. This means we can
    add the pages that users can go to. Now, let''s add a page to allow the admins
    to manage any bookings by adding the `Bookings.vue` file to the `src/views` folder.
    We open the file and add the following template to the component. This is so that
    we can add the `TopBar` component that we created earlier:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`src`文件夹内创建`views`文件夹。这意味着我们可以添加用户可以访问的页面。现在，让我们通过将`Bookings.vue`文件添加到`src/views`文件夹来添加一个页面，以允许管理员管理任何预订。我们打开文件并向组件添加以下模板。这样我们就可以添加之前创建的`TopBar`组件：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we add the heading for the page using the `h1` element. Then, we add
    the `Card` component to display the bookings to the admin. The `Card` component
    is provided by PrimeVue, and we will register it later. We use the `v-for` directive
    to render the bookings array into multiple `Card` components. The `key` prop is
    set to a unique ID so that Vue 3 can distinguish each item properly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`h1`元素添加页面标题。然后，我们添加`Card`组件来向管理员显示预订情况。`Card`组件由PrimeVue提供，我们稍后将注册它。我们使用`v-for`指令将预订数组渲染为多个`Card`组件。`key`属性设置为唯一ID，以便Vue
    3可以正确区分每个项目。
- en: We populate the `title`, `content`, and `footer` slots with different content.
    The `footer` slot has a `Button` component that runs the `deleteBooking` function
    when we click on the button. The `icon` prop allows us to set the icon on the
    left-hand side of the button. The `label` prop has the `button` text on the right-hand
    side of the icon. With the `p-button-secondary` class, we can set the color of
    the button.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用不同的内容填充`title`、`content`和`footer`插槽。`footer`插槽有一个`Button`组件，当我们点击按钮时运行`deleteBooking`函数。`icon`属性允许我们在按钮的左侧设置图标。`label`属性在图标的右侧有按钮文本。通过`p-button-secondary`类，我们可以设置按钮的颜色。
- en: 'Next, we can add the `component` options object with the `getBooking` and `deleteBooking`
    methods to retrieve bookings and delete bookings via the backend API, respectively.
    To add them, write the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加`component`选项对象，其中包含`getBooking`和`deleteBooking`方法，分别通过后端API检索预订和删除预订。要添加它们，请编写以下代码：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We also register the `TopBar` component in the `components` property. The `getBookings`
    method calls `axios.get` to make a GET request and sets the value of the `this.bookings`
    reactive property to the response object.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`components`属性中注册了`TopBar`组件。`getBookings`方法调用`axios.get`发出GET请求，并将`this.bookings`的值设置为响应对象的响应式属性。
- en: '`bookings` is stored inside the `data` property of the object that is returned
    as the resolved value of the returned promise.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`bookings`存储在返回的解析值的对象的`data`属性中。'
- en: Likewise, we call `axios.delete` inside the `deleteBooking` method to make a
    `DELETE` request to delete the items. Then, we call `this.getBookings` to get
    the data again. We also call `this.getBookings` in the `beforeMount` hook to get
    the data when the page loads.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们在`deleteBooking`方法中调用`axios.delete`发出`DELETE`请求以删除项目。然后，我们调用`this.getBookings`再次获取数据。我们还在`beforeMount`钩子中调用`this.getBookings`，以在页面加载时获取数据。
- en: 'Next, we add a page to allow admins to manage the vacation package items. To
    do this, let''s add the `Catalog.vue` file to the `src/views` folder. Then, inside
    the file, write the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个页面，允许管理员管理度假套餐项目。为此，让我们将`Catalog.vue`文件添加到`src/views`文件夹中。然后，在文件中，编写以下内容：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we add the `TopBar` component to display the top bar; `h1` displays a
    heading. Next, we add a button that will let us show the dialog by setting `displayCatalog`
    to `true`. Then, we display the `Dialog` component by setting the `v-model` directive
    with the visible modifier to the `displayCatalog` value. Using this, we can control
    when the `Dialog` component is displayed. The `Dialog` component displays a dialog
    box, and this component is provided by PrimeVue.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加`TopBar`组件来显示顶部栏；`h1`显示一个标题。接下来，我们添加一个按钮，通过将`displayCatalog`设置为`true`来显示对话框。然后，我们通过将`v-model`指令与可见修饰符设置为`displayCatalog`值来显示`Dialog`组件。使用这个，我们可以控制`Dialog`组件何时显示。`Dialog`组件显示一个对话框，这个组件由PrimeVue提供。
- en: 'The `header` prop sets the header text for the dialog box. We use `CatalogForm`
    as the content, and we listen to the `catalog-form-close` event emitted by the
    `CatalogForm` component. When it is emitted, we set `displayCatalog` to `false`
    and call `getCatalog` to get the data again:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`header`属性设置对话框框的标题文本。我们使用`CatalogForm`作为内容，并监听`CatalogForm`组件发出的`catalog-form-close`事件。当它被发出时，我们将`displayCatalog`设置为`false`，并调用`getCatalog`再次获取数据：'
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we add the `Card` components that are rendered from the catalog reactive
    property with the `v-for` directive to render the catalog entries. The remaining
    code is similar to what we had in the `Bookings.vue` file, but now the render
    properties are different, and `Button` calls a different method when we click
    on it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加从目录响应属性渲染的`Card`组件，使用`v-for`指令来渲染目录条目。其余代码与我们在`Bookings.vue`文件中的代码类似，但现在渲染属性不同，当我们点击它时，`Button`调用不同的方法。
- en: 'Following this, we add the component object by adding the following code to
    `src/views/Catalog.vue`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们通过向`src/views/Catalog.vue`添加以下代码来添加组件对象：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the code is similar to what we had in `src/views/Bookings.vue` except
    that, here, we make requests to the catalog endpoints to get and delete the data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码与我们在`src/views/Bookings.vue`中的代码类似，只是在这里，我们向目录端点发出请求以获取和删除数据。
- en: 'Then, we create the last page in the admin frontend app, which is the login
    page. To add the login page, we add the `Login.vue` file to the `src/views` folder.
    Then, inside the file, we add the `form` and the `username` field using the following
    code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在管理前端应用程序中创建最后一个页面，即登录页面。要添加登录页面，我们将`Login.vue`文件添加到`src/views`文件夹中。然后，在文件内部，我们使用以下代码添加`form`和`username`字段：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `username` field is similar to all of the other fields that we have added
    before. Next, we add the `password` input and button using the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`username`字段与我们之前添加的所有其他字段类似。接下来，我们使用以下代码添加`password`输入和按钮：'
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We set the `type` prop to `password` to make the field a password input. The
    button's `type` prop is set to `submit` so that we can trigger the `submit` event
    when we click on it and all of the form values remain valid.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`type`属性设置为`password`，使字段成为密码输入。按钮的`type`属性设置为`submit`，以便在单击按钮时触发`submit`事件，并且所有表单值保持有效。
- en: 'Next, we add the component object portion of the `Login.vue` file, which has
    the `onSubmit` method to make the login request:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加`Login.vue`文件的组件对象部分，其中包含`onSubmit`方法来发起登录请求：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We create the `schema` object with the validation schema, which is similar to
    the other schemas we have used previously. Then, we add that to the object we
    returned in the `data` method. The `onSubmit` method takes the `username` and
    `password` properties from the `value` parameter so that we can use it to make
    the POST request to the `/users/login` endpoint.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了验证模式的`schema`对象，它类似于我们之前使用的其他模式。然后，我们将其添加到`data`方法中返回的对象中。`onSubmit`方法从`value`参数中获取`username`和`password`属性，以便我们可以将其用于向`/users/login`端点发起POST请求。
- en: Once we have done that, we get a token from the response if the request is successful
    along with the `localStorage.setItem` method. Next, we call the `this.$router.push`
    method to redirect to the `/bookings` URL. If there are any errors, we show an
    alert with the `"Login failed"` message.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，如果请求成功，我们从响应中获取一个令牌，以及`localStorage.setItem`方法。接下来，我们调用`this.$router.push`方法重定向到`/bookings`
    URL。如果有任何错误，我们将显示一个带有“登录失败”消息的警报。
- en: 'Next, we add the `router-view` component provided by Vue Router to `App.vue`.
    This is so we can show the page that we created in the `routes` object. To add
    it, write the admin frontend:shared code, adding to deal with requests" following
    code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`router-view`组件添加到`App.vue`中，这样我们就可以显示在`routes`对象中创建的页面。要添加它，编写管理前端：共享代码，添加以处理请求的代码：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We also have a `style` tag to set the font family and set the margin of the
    body to `0px`, so there is no white space between the elements and the edge of
    the page.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`style`标签来设置字体系列，并将页面的边距设置为`0px`，这样元素与页面边缘之间就没有空白。
- en: 'Next, we add `constants.js` to the `src` folder and then add `APIURL` to it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`constants.js`添加到`src`文件夹，然后将`APIURL`添加到其中：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In `main.js`, we register all of the global components along with the router
    object we created earlier. We also import the global styles provided by PrimeVue,
    so everything looks good:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.js`中，我们注册了所有全局组件以及之前创建的路由对象。我们还导入了PrimeVue提供的全局样式，所以一切看起来都很好：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In `package.json`, we change the port that the development server runs on by
    changing the `script.serve` property to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中，通过将`script.serve`属性更改为以下内容，更改开发服务器运行的端口：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, when we run `npm run serve`, we get the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行`npm run serve`时，我们会得到以下截图：
- en: '![Figure 6.1 – Admin Frontend'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 - 管理前端'
- en: '](image/Figure_6.1_B14405.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.1_B14405.jpg)'
- en: Figure 6.1 – Admin Frontend
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 - 管理前端
- en: Now that we have created the admin frontend app, all we have left to add is
    the user frontend.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了管理前端应用程序，我们唯一需要添加的是用户前端。
- en: Creating the user frontend
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户前端
- en: Now that we have finished with the admin frontend, we will complete this chapter's
    project by creating the user's frontend. The user frontend is similar to the admin
    frontend; however, in this case, there is no authentication required to use it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了管理前端，我们将通过创建用户前端来完成本章的项目。用户前端与管理前端类似；但是，在这种情况下，不需要身份验证即可使用。
- en: 'We will start by installing the same packages that we installed for the admin
    frontend. Navigate to the frontend folder and run the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从安装与管理前端相同的软件包开始。转到前端文件夹并运行以下命令：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, create the `src/components` folder, if it doesn't exist. Then, create
    the `BookingForm.vue` file inside of `src/components` so that users can add their
    bookings.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果不存在，创建`src/components`文件夹。然后，在`src/components`中创建`BookingForm.vue`文件，以便用户可以添加他们的预订。
- en: 'Add the `form` and `name` fields to allow users to enter their name:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`form`和`name`字段，以允许用户输入他们的姓名：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is very similar to the other text input fields that we added earlier.
    Then, add the `address` field using the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前添加的其他文本输入字段非常相似。然后，使用以下代码添加`地址`字段：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s add the `Calendar` component that is provided by PrimeVue, which
    we have not used before in this project. The `Calendar` component lets users pick
    a date. We can add the `Start Date` field to allow the user to pick the start
    date of their vacation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加PrimeVue提供的`Calendar`组件，这是我们在此项目中以前未使用过的。`Calendar`组件允许用户选择日期。我们可以添加`开始日期`字段，以允许用户选择他们假期的开始日期：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, we have the `minDate` prop, which sets the earliest date that the user
    can pick. The `inline` prop will make the date picker display on the form instead
    of in a popup. Likewise, we can add the `End Date` field using the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`minDate`属性，它设置用户可以选择的最早日期。`inline`属性将使日期选择器显示在表单上，而不是在弹出窗口中。同样，我们可以使用以下代码添加`结束日期`字段：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, we set the `minDate` prop to a day after `startDate`. `24 * 3600 * 1000`
    milliseconds is equivalent to one day. Finally, we add the `submit` button just
    as we did in our other forms:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`minDate`属性设置为`startDate`后的一天。`24 * 3600 * 1000`毫秒等于一天。最后，我们添加`submit`按钮，就像我们在其他表单中所做的那样：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we create `schema` by writing the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过编写以下内容创建`schema`：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To validate `endDate`, we call the `when` method with the `field` name that
    we want to check against. Then, we call `schema.min` to make sure that the `endDate`
    is later than the `startDate`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证`endDate`，我们使用`when`方法调用要检查的`field`名称。然后，我们调用`schema.min`来确保`endDate`晚于`startDate`。
- en: 'Next, we add the `component` object to register the `selectedCatalogId` prop
    and add the `onSubmit` method. We write the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加`component`对象来注册`selectedCatalogId`属性并添加`onSubmit`方法。我们编写以下代码：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `onSubmit` method gets the form field values from the `values` parameter
    and makes a POST request to the bookings endpoint to add a booking. We use `selectedCatalogId`
    to add the booking. Then, we emit the `booking-form-close` event to emit an event
    to the parent to signal the form to close.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSubmit`方法从`values`参数中获取表单字段值，并向bookings端点发出POST请求以添加预订。我们使用`selectedCatalogId`来添加预订。然后，我们发出`booking-form-close`事件，向父级发出事件，以信号表单关闭。'
- en: 'Next, we add Vue Router to our app by adding `vue-router.js` to the `src/plugins`
    folder:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过将`vue-router.js`添加到`src/plugins`文件夹中，向我们的应用程序添加Vue Router：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is very similar to what we had in the admin frontend.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在管理前端中所做的非常相似。
- en: 'Next, we create a page to show all of the vacation packages to the user by
    adding the `src/views/Catalog.vue` file and then adding the following template
    code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个页面，通过添加`src/views/Catalog.vue`文件，然后添加以下模板代码来向用户展示所有的度假套餐：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we simply render a form from the catalog array. We have a `Dialog` component
    with the `BookingForm` component inside. We listen to the `booking-form-close`
    event emitted by it to close the `Dialog` component by setting `displayBookingForm`
    to `false` and calling `displayMessage` to display the alert. We pass in `selectedCatalogId`
    as the value of the prop with the same name.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是从目录数组中呈现一个表单。我们有一个带有`BookingForm`组件的`Dialog`组件。我们监听由其发出的`booking-form-close`事件，通过将`selectedCatalogId`作为同名prop的值传递给其来关闭`Dialog`组件，将`displayBookingForm`设置为`false`并调用`displayMessage`来显示警报。
- en: The remainder of the template code is almost the same as what we had previously,
    except for the property names displayed and the addition of the image inside the
    header slot.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '模板代码的其余部分几乎与我们之前的相同，除了显示的属性名称和标题插槽中图像的添加。 '
- en: 'Next, we add the `component` options object to the same file by writing the
    following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过编写以下代码将`component`选项对象添加到同一文件中：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We register the `BookingForm` component within the `components` property. The
    `getCatalog` function gets the vacation package catalog items from the API. The
    `booking` function sets `displayBookingForm` to `true` to open the `Dialog` component,
    and `selectedCatalogId` is also set there. The `beforeMount` hook calls `getCatalog`
    to retrieve the catalog data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`components`属性中注册`BookingForm`组件。`getCatalog`函数从API获取度假套餐目录项。`booking`函数将`displayBookingForm`设置为`true`以打开`Dialog`组件，并在那里也设置了`selectedCatalogId`。`beforeMount`钩子调用`getCatalog`以检索目录数据。
- en: Adding the router view and entry point code
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加路由视图和入口点代码
- en: 'In `App.vue`, we write the following code to add `router-view` and set the
    same styles that we did in the admin frontend:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.vue`中，我们编写以下代码来添加`router-view`并设置与我们在管理前端中相同的样式：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we create `constants.js` in the `src` folder and add the following line
    to add `APIURL`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`src`文件夹中创建`constants.js`，并添加以下行来添加`APIURL`：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, in `main.js`, we replace the contents of the file with the following
    code to register the components and the router globally. We also import the styles
    provided by PrimeVue to make our app look good:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`main.js`中，我们用以下代码替换文件的内容，以全局注册组件和路由。我们还导入了PrimeVue提供的样式，让我们的应用程序看起来很好：
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In `package.json`, we change the port that the development server runs on by
    changing the `script.serve` property to the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中，我们通过将`script.serve`属性更改为以下内容来更改开发服务器运行的端口：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, when we run `npm run serve`, we get the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行`npm run serve`时，我们会得到以下截图：
- en: '![Figure 6.2 – The user frontend'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 - 用户前端'
- en: '](image/Figure_6.2_B14405.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.2_B14405.jpg)'
- en: Figure 6.2 – The user frontend
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 - 用户前端
- en: With the user frontend created, the vacation booking system is now complete.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 用户前端创建完成后，度假预订系统现在已经完成。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use PrimeVue effectively to build a vacation
    booking application. With PrimeVue, we can create good-looking Vue 3 web apps
    easily. PrimeVue comes with many useful components that we can add to create our
    web apps, such as inputs, text areas, tables, dialog boxes, date pickers, and
    more. It also comes with styles built-in, so we don't have to add any styles from
    scratch ourselves. Additionally, we can add the PrimeFlex package that is also
    provided by PrimeVue; with flexbox, we can change the spacing and positions of
    elements and components easily.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何有效地使用PrimeVue来构建一个度假预订应用程序。通过PrimeVue，我们可以轻松创建漂亮的Vue 3 web应用程序。PrimeVue带有许多有用的组件，我们可以添加到我们的web应用程序中，比如输入框、文本区域、表格、对话框、日期选择器等等。它还内置了样式，因此我们不必自己从头开始添加任何样式。此外，我们还可以添加PrimeVue提供的PrimeFlex包；通过flexbox，我们可以轻松地改变元素和组件的间距和位置。
- en: Vee-Validate and Yup allow us to add form validation into our Vue 3 app. This
    integrates easily with the input components provided by PrimeVue. These two libraries
    make a lot of the form validation work easy, as we don't have to write all the
    form validation code ourselves.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Vee-Validate和Yup允许我们在Vue 3应用程序中添加表单验证。这与PrimeVue提供的输入组件很容易集成。这两个库使得大部分表单验证工作变得简单，因为我们不必自己编写所有的表单验证代码。
- en: To make a simple backend, we used Express to create a simple API to interact
    with the frontend. We also used the `sqlite3` package to manipulate data with
    the SQLite databases in our API. Express comes with many add-ons that we can use
    to add a lot of functionality, such as cross-domain communication. We can also
    easily add JSON Web Token authentication to our Express app via the `jsonwebtoken`
    library.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个简单的后端，我们使用Express创建了一个简单的API来与前端交互。我们还使用了`sqlite3`包来操作我们API中的SQLite数据库。Express带有许多附加组件，我们可以使用它们来添加许多功能，比如跨域通信。我们还可以通过`jsonwebtoken`库很容易地向我们的Express应用程序添加JSON
    Web Token身份验证。
- en: In the next chapter, we will learn how to build a storefront with GraphQL and
    Vue 3.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用GraphQL和Vue 3构建一个商店前端。
