- en: '*Chapter 5*: Building a Multipurpose Calculator Mobile App with Ionic'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章：使用Ionic构建多功能计算器移动应用
- en: In the first four chapters, we have built various kinds of web applications
    with Vue 3\. We can also create mobile applications with Vue 3, but we can't create
    them with Vue 3 alone. We can create mobile apps with mobile app frameworks that
    use Vue 3 as its base framework. In [*Chapter 4*](B14405_04_ePub_RK.xhtml#_idTextAnchor046),
    *Building a Photo Management Desktop App*, we built a web app with Vue Router
    so that we could have multiple pages in our app. Vue Router lets us create apps
    that are slightly complex.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前四章中，我们使用Vue 3构建了各种类型的Web应用程序。我们也可以使用Vue 3创建移动应用程序，但不能仅使用Vue 3创建它们。我们可以使用将Vue
    3作为基础框架的移动应用程序框架来创建移动应用程序。在第四章《构建照片管理桌面应用程序》中，我们使用Vue Router构建了一个Web应用程序，以便我们的应用程序可以拥有多个页面。Vue
    Router让我们能够创建稍微复杂的应用程序。
- en: In this chapter, we will move further from our knowledge of building web apps
    so that we can start building mobile apps. The app we will build is a calculator
    app that lets us convert currencies and calculate tips. It will also remember
    the calculations that we made so we can go back to redo them easily.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步从构建Web应用程序的知识中迈出，以便开始构建移动应用程序。我们将构建一个计算器应用程序，让我们能够转换货币和计算小费。它还会记住我们所做的计算，因此我们可以轻松地返回重新进行。
- en: 'In addition, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将涵盖以下主题：
- en: Introducing Ionic Vue
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Ionic Vue
- en: Creating our Ionic Vue mobile app project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的Ionic Vue移动应用项目
- en: Installing the packages for our project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装项目的包
- en: Adding the calculators to our calculator app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将计算器添加到我们的计算器应用程序中
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code for this chapter's project can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter05](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter05).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章项目的源代码可以在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter05](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter05)找到。
- en: Introducing Ionic Vue
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Ionic Vue
- en: '**Ionic Vue** is a mobile app framework that lets us build apps with TypeScript
    and Vue. It also has versions based on React and Angular. It comes with many components
    that we can add to our app, just like any other UI framework. They include common
    things such as inputs, menus, icons, lists, and much more. A compiled Ionic app
    runs in a web view, so we can use web technologies such as local storage, geolocation,
    and other browser APIs in our apps.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ionic Vue**是一个移动应用程序框架，让我们能够使用TypeScript和Vue构建应用程序。它还有基于React和Angular的版本。它配备了许多组件，我们可以像其他UI框架一样将其添加到我们的应用程序中。它们包括常见的输入、菜单、图标、列表等等。编译后的Ionic应用程序在Web视图中运行，因此我们可以在我们的应用程序中使用本地存储、地理位置和其他浏览器API等Web技术。'
- en: It also comes with built-in tools that let us build mobile apps automatically,
    without the need to set up everything from scratch ourselves. Ionic Vue creates
    components that use the Composition API by default, so we will use that to build
    Vue apps that are more modular and work better with TypeScript.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它还配备了内置工具，让我们能够自动构建移动应用程序，无需从头开始设置所有内容。Ionic Vue默认创建使用组合API的组件，因此我们将使用它来构建更模块化并且与TypeScript更好地配合的Vue应用程序。
- en: Understanding the Composition API
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解组合API
- en: The Composition API works better with TypeScript because it does not reference
    the `this` keyword, which has a dynamic structure. Instead, everything that is
    part of the Composition API, including its libraries, are compatible with it functions,
    which have clear parameters and return types. This lets us define TypeScript type
    definitions for them easily. Vue Router 4 and Vuex 4 are compatible with Vue 3's
    Composition API, so we can use them together in our Ionic Vue app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Composition API更适合与TypeScript一起使用，因为它不引用具有动态结构的`this`关键字。相反，Composition API的所有部分，包括其库，都与具有清晰参数和返回类型的函数兼容。这使我们可以轻松为它们定义TypeScript类型定义。Vue
    Router 4和Vuex 4与Vue 3的Composition API兼容，因此我们可以在Ionic Vue应用程序中一起使用它们。
- en: With the Composition API, we still have the component object, but its structure
    is completely different from what we have in the Options API. The only property
    that is the same between the options and the Composition API is the `components`
    property. They both let us register components in both APIs. Our component logic
    is mostly in the `setup()` method. This is where we define our reactive properties,
    computed properties, watchers, and methods. Third-party libraries may also provide
    us with hooks, which are functions that we can call in our setup function to give
    us functionality that we want from the library. For example, Vuex 4 gives us the
    `useStore` hook so that we can gain access to the store. Vue Router 4 comes with
    the `useRouter` hook to let us navigate in our app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Composition API，我们仍然有组件对象，但其结构与选项API中的完全不同。选项和Composition API之间唯一相同的属性是`components`属性。它们都允许我们在两个API中注册组件。我们的组件逻辑主要在`setup()`方法中。这是我们定义响应式属性、计算属性、观察者和方法的地方。第三方库还可以为我们提供钩子，这些钩子是我们可以在setup函数中调用的函数，以便从库中获得我们想要的功能。例如，Vuex
    4为我们提供了`useStore`钩子，以便我们可以访问存储。Vue Router 4带有`useRouter`钩子，让我们在应用程序中导航。
- en: The way we define reactive and computed properties is different from the options
    API. In the options API, which we used in the previous chapters, we define and
    initialize our reactive properties in the `data()` method. In the Composition
    API, we call the `ref` function to define reactive properties that hold primitive
    values; we then call `reactive` to define reactive properties that have object
    values. To define computed properties in the Composition API, we call the `computed`
    function with a callback that references other reactive properties to create the
    computed property.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义响应式和计算属性的方式与选项API不同。在选项API中，我们在`data()`方法中定义和初始化我们的响应式属性。在Composition API中，我们调用`ref`函数来定义持有原始值的响应式属性；然后我们调用`reactive`来定义具有对象值的响应式属性。要在Composition
    API中定义计算属性，我们调用带有回调的`computed`函数，该回调引用其他响应式属性以创建计算属性。
- en: Watchers are created with the `watch` function. It takes a callback to return
    the reactive property we want to watch the value for. The second argument we pass
    into the `watch` function is a callback that lets us do something when the watched
    value changes. We can get the latest value of the reactive property being watched
    with the first parameter of the callback. The third argument contains the options
    for the watchers. We can set the deep and immediate properties in there as we
    do with watchers in the Options API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者是使用`watch`函数创建的。它接受一个回调来返回我们想要观察值的响应式属性。我们传递给`watch`函数的第二个参数是一个回调，让我们在观察的值发生变化时执行某些操作。我们可以使用回调的第一个参数获取被观察的响应式属性的最新值。第三个参数包含观察者的选项。我们可以在其中设置深度和立即属性，就像在选项API中观察者一样。
- en: Methods are also added to the `setup` function. We can use arrow functions or
    regular functions to define them since the value of this doesn't matter. Reactive
    properties and methods must be returned in the object we return in the `setup()`
    method to expose them to the template. This way, they can be used in our code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也被添加到`setup`函数中。我们可以使用箭头函数或常规函数来定义它们，因为this的值并不重要。响应式属性和方法必须在我们在`setup()`方法中返回的对象中返回，以便在模板中使用它们。这样，它们可以在我们的代码中使用。
- en: Understanding TypeScript
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解TypeScript
- en: '**TypeScript** is a language made by Microsoft that is an extension of JavaScript.
    It provides us with compile-time checking for data types in our code. However,
    it doesn''t provide us with extra runtime data type checks since TypeScript compiles
    to JavaScript before they are run. With the Composition API, our components do
    not reference the `this` keyword, so we don''t have to worry about it having the
    wrong value.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeScript**是微软开发的一种语言，它是JavaScript的扩展。它为我们的代码提供了编译时的数据类型检查。然而，它并没有为我们提供额外的运行时数据类型检查，因为TypeScript在运行之前会编译成JavaScript。在组合API中，我们的组件不引用`this`关键字，因此我们不必担心它具有错误的值。'
- en: The benefit of using TypeScript is to ensure the type safety of primitive values,
    objects, and variables, which do not exist within JavaScript. In JavaScript, we
    can assign anything to any variable. This is, of course, going to be a problem
    since we may assign things to data types that we wouldn't usually. Also, functions
    can take anything as parameters and we can pass in any argument in any order into
    functions, so we may run into problems there if we pass in arguments that a function
    doesn't expect. Also, things may become `null` or `undefined` anywhere, so we
    must make sure that only places where we expect things to be null or undefined
    have those values. JavaScript functions can also return anything, so TypeScript
    can also restrict that.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript的好处是确保原始值、对象和变量的类型安全，这在JavaScript中是不存在的。在JavaScript中，我们可以将任何东西赋给任何变量。这当然会成为一个问题，因为我们可能会将东西赋给我们通常不会使用的数据类型。此外，函数可以接受任何参数，我们可以以任何顺序传递任何参数给函数，因此如果我们传递函数不期望的参数，可能会遇到问题。此外，任何地方都可能变成`null`或`undefined`，因此我们必须确保只有我们期望为null或undefined的地方才有这些值。JavaScript函数也可以返回任何东西，因此TypeScript也可以限制这一点。
- en: Another big feature of TypeScript is that we can create interfaces to restrict
    the structure of objects. We can specify object properties and their types so
    that we can restrict objects to have the given properties, and so that the properties
    have the data types that we specify. This prevents us from assigning objects to
    variables and parameters that we don't expect, and it also provides us with autocomplete
    functionality in text editors that support TypeScript that we can't get with JavaScript
    objects. This is because the structures of objects are set. Interfaces can have
    optional and dynamic properties to let us maintain the flexibility of JavaScript
    objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的另一个重要特性是我们可以创建接口来限制对象的结构。我们可以指定对象属性及其类型，以便限制对象具有给定的属性，并且属性具有我们指定的数据类型。这可以防止我们将对象分配给我们不期望的变量和参数，并且还为我们提供了在支持TypeScript的文本编辑器中无法获得的自动完成功能。这是因为对象的结构是固定的。接口可以具有可选和动态属性，以便让我们保持JavaScript对象的灵活性。
- en: To retain the flexibility of JavaScript, TypeScript comes with union and intersection
    types. **Union** types are where we have more than one type joined together with
    a logical OR operator. A variable with a union type means that a variable can
    be one of the list of types that is of the union type. **Intersection** types
    are multiple types joined together with a logical AND operator. A variable with
    a type set to an intersection type must have all the members of all the types
    in the intersection.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持JavaScript的灵活性，TypeScript带有联合和交集类型。**联合**类型是指我们使用逻辑OR运算符将多个类型组合在一起的情况。具有联合类型的变量意味着变量可以是联合类型列表中的一个类型。**交集**类型是使用逻辑AND运算符将多个类型组合在一起的情况。将类型设置为交集类型的变量必须具有交集中所有类型的成员。
- en: To keep type specifications short, TypeScript comes with the `type` keyword,
    which lets us create a type alias. Type aliases can be used like regular types,
    so we can assign type aliases to variables, properties, parameters, return types,
    and so on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持类型规范的简洁，TypeScript带有`type`关键字，它允许我们创建类型别名。类型别名可以像常规类型一样使用，因此我们可以将类型别名分配给变量、属性、参数、返回类型等等。
- en: In our mobile app, we will add pages for a tip calculator, currency converter,
    and a home page with a past list of calculations. We have any calculations that
    we have made in local storage so that we can go back to them later. The history
    is saved to local storage via the `vuex- persistedstate` plugin. This plugin is
    compatible with Vuex 4 and it lets us save the Vuex state to local storage directly,
    without us writing any extra code to do that ourselves.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的移动应用中，我们将为小费计算器、货币转换器和一个带有过去计算列表的主页添加页面。我们将我们所做的任何计算都保存在本地存储中，以便以后可以返回到它们。历史记录通过`vuex-persistedstate`插件保存到本地存储中。该插件与Vuex
    4兼容，它允许我们直接将Vuex状态保存到本地存储中，而无需编写任何额外的代码来实现这一点。
- en: Now that we've looked at the basics of Vue's Composition API, TypeScript, and
    Ionic, we can start building our app with it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Vue的组合API、TypeScript和Ionic的基础知识，我们可以开始用它构建我们的应用程序。
- en: Creating our Ionic Vue mobile app project
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的Ionic Vue移动应用项目
- en: 'We can create our Ionic Vue project by installing the Ionic CLI. First, we
    must install the Ionic CLI by running the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过安装Ionic CLI来创建我们的Ionic Vue项目。首先，我们必须通过运行以下命令来安装Ionic CLI：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we must create our Ionic Vue project by going to the folder where we
    want our project folder to be running. We can do this with the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须通过转到我们想要运行项目文件夹的文件夹来创建我们的Ionic Vue项目。我们可以使用以下命令来做到这一点：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `sidemenu` option lets us create an Ionic project with a side menu added
    to its pages. This will save us time with we're creating the menus and pages.
    The `--type vue` option lets us create an Ionic Vue project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`sidemenu`选项允许我们创建一个带有侧边菜单的Ionic项目。这将在创建菜单和页面时节省我们的时间。`--type vue`选项允许我们创建一个Ionic
    Vue项目。'
- en: 'We can get help with all the options and look at an explanation of each by
    using the following commands:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令获取所有选项的帮助，并查看每个选项的解释：
- en: '`ionic –help`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ionic –help`'
- en: '`ionic <command> --help`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ionic <command> --help`'
- en: '`ionic <command><subcommand> --help`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ionic <command><subcommand> --help`'
- en: We should run `ionic <command> --help` in our project directory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在我们的项目目录中运行`ionic <command> --help`。
- en: Using Capacitor and Genymotion
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Capacitor和Genymotion
- en: Ionic Vue projects are served and built with Capacitor. Capacitor will open
    the project in Android Studio; then, we can launch it from there and preview our
    app in an emulator or device. For this project, we will preview our app with the
    Genymotion emulator. It is fast and has a plugin that lets us launch from Android
    Studio. We can download Genymotion emulator from [https://www.genymotion.com/download/](https://www.genymotion.com/download/)
    and Android Studio can be downloaded from [https://developer.android.com/studio](https://developer.android.com/studio).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ionic Vue 项目使用 Capacitor 进行服务和构建。Capacitor 将在 Android Studio 中打开项目；然后，我们可以从那里启动并在模拟器或设备中预览我们的应用程序。对于这个项目，我们将使用
    Genymotion 模拟器预览我们的应用程序。它速度快，并且有一个插件，让我们可以从 Android Studio 中启动。我们可以从 [https://www.genymotion.com/download/](https://www.genymotion.com/download/)
    下载 Genymotion 模拟器，而 Android Studio 可以从 [https://developer.android.com/studio](https://developer.android.com/studio)
    下载。
- en: Once we've installed Genymotion, we must create a virtual machine from the Genymotion
    UI. To do this, we can click the *plus* button, and then add the device that we
    want. We should add a device that has a recent version of Android, such as Android
    7 or later. The other options can be chosen according to our preference. To install
    the Genymotion plugin for Android Studio, follow the instructions at [https://www.genymotion.com/plugins/](https://www.genymotion.com/plugins/).
    This will let us run our Android Studio project in Genymotion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 Genymotion 后，我们必须从 Genymotion UI 中创建一个虚拟机。为此，我们可以点击 *加号* 按钮，然后添加我们想要的设备。我们应该添加一个具有较新版本的
    Android（如 Android 7 或更高版本）的设备。其他选项可以根据我们的喜好选择。要安装 Android Studio 的 Genymotion
    插件，请按照 [https://www.genymotion.com/plugins/](https://www.genymotion.com/plugins/)
    上的说明进行操作。这将让我们在 Genymotion 中运行我们的 Android Studio 项目。
- en: 'Next, in the `package.json` file in our project, if we don''t see the `ionic:serve`
    and `ionic:build` scripts in the scripts section, we can add them by writing the
    following code inside the scripts section of our `package.json` file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们项目的 `package.json` 文件中，如果在脚本部分看不到 `ionic:serve` 和 `ionic:build` 脚本，我们可以通过在
    `package.json` 文件的脚本部分中写入以下代码来添加它们：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, we can run `ionic build` to build our code so that it can be served with
    Capacitor later.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行 `ionic build` 来构建我们的代码，以便稍后使用 Capacitor 进行服务。
- en: 'Once we''ve done that, we can run the following command to add the dependencies
    for an Android project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以运行以下命令为 Android 项目添加依赖项：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is also required so that we can run our project as an Android app.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是必需的，这样我们才能将我们的项目作为 Android 应用程序运行。
- en: 'Once we''ve run those commands, we can run the following command so that we
    can run our app with live reload and make network access available from Genymotion:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些命令后，我们可以运行以下命令，以便我们可以使用实时重新加载运行我们的应用程序，并从 Genymotion 中进行网络访问。
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This way, we can access the internet just like any other app can. It also runs
    the `ionic:serve` script so that we can preview our app in the browser. Previewing
    our app in the browser is faster than in the emulator, so we may want to do that:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以像任何其他应用程序一样访问互联网。它还运行 `ionic:serve` 脚本，这样我们就可以在浏览器中预览我们的应用程序。在浏览器中预览我们的应用程序比在模拟器中更快，所以我们可能会想要这样做：
- en: '![Figure 5.1 – Genymotion emulator'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – Genymotion 模拟器'
- en: '](image/Figure_5.1_B14405.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.1_B14405.jpg)'
- en: Figure 5.1 – Genymotion emulator
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Genymotion 模拟器
- en: If we want to preview in Genymotion, we can go to Android Studio, which should
    open automatically once we run the `ionic capacitor run` command. Then, we can
    press *Alt*+*Shift*+*F10* to open the run app dialog, and then choose the app
    to run it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 Genymotion 中预览，我们可以转到 Android Studio，一旦我们运行 `ionic capacitor run` 命令，它应该会自动打开。然后，我们可以按
    *Alt*+*Shift*+*F10* 打开运行应用程序对话框，然后选择要运行的应用程序。
- en: Now that we have set up our Vue Ionic project, we must install a few more packages
    so that we can create our mobile app.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了 Vue Ionic 项目，我们必须安装一些额外的软件包，以便创建我们的移动应用程序。
- en: Installing the packages for our project
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的项目安装包
- en: We must install some dependencies that are needed in the project, but they aren't
    installed yet. We can use Axios to make HTTP requests to get the exchange rate.
    The `uuid` module lets us generate unique IDs for our history entries. Vuex doesn't
    come with the Ionic project, so we have to install that. We must also install
    the `vuex-persistedstate` module so that we can save Vuex state data to local
    storage.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须安装一些项目中需要的依赖项，但它们尚未安装。我们可以使用Axios来进行HTTP请求以获取汇率。`uuid`模块让我们可以为我们的历史记录生成唯一的ID。Vuex不随Ionic项目一起提供，因此我们必须安装它。我们还必须安装`vuex-persistedstate`模块，以便我们可以将Vuex状态数据保存到本地存储中。
- en: 'To install these packages, run the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些包，请运行以下命令：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next version of Vuex is the 4.x version, which is compatible with Vue 3.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个版本的Vuex是4.x版本，与Vue 3兼容。
- en: Adding the calculators to our calculator app
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将计算器添加到我们的计算器应用程序中
- en: Now that we have our project ready, we can start working on our app. We start
    with adding the route definition to map URL paths to the page components that
    we will create. Then we will work on the components for each feature. And then
    we will add the Vuex store with code to persist the store data to local storage
    so we can use the data whenever we want.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目准备好了，我们可以开始在我们的应用程序上工作。我们首先添加路由定义，将URL路径映射到我们将创建的页面组件。然后我们将为每个功能添加组件。然后我们将添加Vuex存储，其中包含将存储数据持久化到本地存储的代码，这样我们可以随时使用数据。
- en: Adding routes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加路由
- en: 'First, we will work on adding routing to our calculator app. In the `src/router/index.ts`
    file, write the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将致力于为我们的计算器应用程序添加路由。在`src/router/index.ts`文件中，编写以下代码：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this file, we have the `routes` array, which we can use to add the routes
    for the pages that we are going to add to our calculator app. The `routes` array
    is of the `Array<RouteRecordRaw>` type. This means that the objects in the `routes`
    array must have the path and component properties. The `path` property must be
    a string, while the component can be a component or function that returns a promise
    that resolves to a component. If the objects don't match the structure specified
    by `Array<RouteRecordRaw>`, the TypeScript compiler will give us an error when
    we build the code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们有`routes`数组，我们可以用它来添加我们将要添加到计算器应用程序中的页面的路由。`routes`数组的类型是`Array<RouteRecordRaw>`。这意味着`routes`数组中的对象必须具有路径和组件属性。`path`属性必须是一个字符串，而组件可以是一个组件或返回一个解析为组件的promise的函数。如果对象不符合`Array<RouteRecordRaw>`指定的结构，TypeScript编译器在构建代码时会给我们一个错误。
- en: The code is built whenever we change any code file since we have the `livereload`
    option set, so we will get compiler errors almost immediately. This prevents most
    data type-related errors from occurring during runtime. The type definitions are
    built into the `vue-router` module, so we don't have to worry about missing data
    types.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们更改任何代码文件时，代码都会被构建，因为我们设置了`livereload`选项，所以我们几乎立即会得到编译器错误。这可以防止大多数与数据类型相关的错误在运行时发生。类型定义内置在`vue-router`模块中，因此我们不必担心缺少数据类型。
- en: Adding the currency converter page
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加货币转换器页面
- en: 'Next, we will add the currency converter page. To add it, first, create the
    `src/views/CurrencyConverter.vue` file. Then, we must add the header to the template
    by writing the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加货币转换器页面。要添加它，首先创建`src/views/CurrencyConverter.vue`文件。然后，我们必须通过编写以下代码将标题添加到模板中：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ion-page` component is the page container that lets us add content inside
    it. The `ion-toolbar` component adds a toolbar to the top of the page. The `ion-buttons`
    component is a container for buttons and inside it, we must add the `ion-menu-button`
    to the start slot so that we can add a menu button to the top-left corner of the
    screen. The `ion-menu- button` component will open the left-hand side menu when
    we click it. The `ion-title` component contains the page title. It is located
    at the top-left corner.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ion-page`组件是页面容器，让我们可以在其中添加内容。`ion-toolbar`组件在页面顶部添加了一个工具栏。`ion-buttons`组件是按钮的容器，在其中，我们必须在开始插槽中添加`ion-menu-button`，这样我们就可以在屏幕左上角添加一个菜单按钮。当我们点击它时，`ion-menu-button`组件将打开左侧菜单。`ion-title`组件包含页面标题。它位于左上角。'
- en: 'Next, we must add the `ion-content` component to add the content to the currency
    converter page. For instance, we can write the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加`ion-content`组件，以在货币转换页面上添加内容。例如，我们可以编写以下代码：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we added the `ion-list` component so that we can add a list to our page.
    It lets us add a list of items to our app. In `ion-list`, we add `ion-item` to
    add a list item component. `ion-label` lets us add the label into the list item.
    The `color` property of the label text is set by the `color` prop. The `amountValid`
    prop is a computed property that checks whether the `amount` reactive property
    is valid. The `ion-input` component renders an input into our app. We set `type`
    to `number` to make the input a numeric input.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`ion-list`组件，以便在我们的页面上添加一个列表。它让我们可以向我们的应用程序添加一个项目列表。在`ion-list`中，我们添加`ion-item`以添加列表项组件。`ion-label`让我们将标签添加到列表项中。标签文本的`color`属性由`color`属性设置。`amountValid`属性是一个计算属性，用于检查`amount`响应式属性是否有效。`ion-input`组件将输入呈现到我们的应用程序中。我们将`type`设置为`number`，以使输入成为数字输入。
- en: The `placeholder` prop lets us add a placeholder to our app. The `ion-text-right`
    class lets us put the input on the right-hand side. This is a class that comes
    with the Ionic framework. The `v-model` directive lets us bind the `amount` reactive
    property to the inputted value so that we can use the inputted value in the component
    code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`placeholder`属性让我们可以向我们的应用程序添加占位符。`ion-text-right`类让我们把输入放在右侧。这是Ionic框架提供的一个类。`v-model`指令让我们将`amount`响应式属性绑定到输入值，这样我们就可以在组件代码中使用输入的值。'
- en: The `fullscreen` prop of `ion-content` makes the page full screen.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ion-content`的`fullscreen`属性使页面全屏。'
- en: 'Next, we will add more items to the `ion-list` component:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向`ion-list`组件添加更多项目：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we have added more `ion-items` to our `ion-list`. The `ion-select` component
    lets us add the currency to convert from dropdown, which lets us choose the currency
    that the amount is in. We bind `fromCurrency` to the value we selected in the
    dropdown to get the selected item inside our component code. The `ok-text` prop
    sets the OK text in the dropdown, while the `cancel-text` prop contains the text
    for the cancel button. The `ion-select` component lets us show a dialog with radio
    buttons that lets us display the items for us to choose from. Then, when we click
    or tap on the **OK** button, we can select the item.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向我们的`ion-list`添加了更多`ion-items`。`ion-select`组件让我们可以从下拉菜单中添加要转换的货币，这样我们就可以选择金额所在的货币。我们将`fromCurrency`绑定到我们在下拉菜单中选择的值，以在组件代码中获取所选项目。`ok-text`属性设置下拉菜单中的确定文本，而`cancel-text`属性包含取消按钮的文本。`ion-select`组件让我们显示一个带有单选按钮的对话框，让我们显示可供我们选择的项目。然后，当我们点击或轻触**确定**按钮时，我们可以选择该项目。
- en: The `ion-select-option` component lets us add options to the select dialog box.
    We use the `v-for` directive to loop through the `fromCurrencies` reactive property,
    which is a computed property that we create from filtering out the `selected`
    option from the **Currency to Convert To** dialog, which we will add later. This
    way, we can't select the same currency in both dropdowns, so currency conversion
    makes sense.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ion-select-option`组件让我们向选择对话框框添加选项。我们使用`v-for`指令循环遍历`fromCurrencies`响应式属性，这是我们从**要转换的货币**对话框中筛选出的`selected`选项创建的计算属性，稍后我们将添加。这样，我们就不能在两个下拉菜单中选择相同的货币，因此货币转换是有意义的。'
- en: 'Next, we will add another select dialog to let us select the currency that
    we want to convert the amount into. To do this, we can write the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加另一个选择对话框，让我们选择要将金额转换为的货币。为此，我们可以编写以下代码：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `toCurrencies` reactive property is a computed property that contains an
    entry that has the value of `fromCurrency` filtered out. This means we can't select
    the same currency in both dropdowns.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`toCurrencies`响应式属性是一个计算属性，其中包含一个条目，其值为从`fromCurrency`中筛选出的值。这意味着我们不能在两个下拉菜单中选择相同的货币。'
- en: We also added the **Calculate** button, which lets us calculate the converted
    amount. We will add the `calculate()` method shortly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了**Calculate**按钮，这样我们就可以计算转换后的金额。我们将很快添加`calculate()`方法。
- en: 'Next, we will add another `ion-list`. This will add a list that adds the labels
    to display the converted amount. To do this, we can write the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加另一个`ion-list`。这将添加一个列表，用于显示转换后的金额的标签。为此，我们可以编写以下代码：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we have displayed the amount and `fromCurrency` that we entered. We also
    displayed the result and the `toCurrency` option that we selected. We called `toFixed`
    with argument `2` to round the result to two decimal places.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们显示了输入的金额和`fromCurrency`。我们还显示了结果和我们选择的`toCurrency`选项。我们调用了带有参数`2`的`toFixed`来将结果四舍五入到两位小数。
- en: Adding the script tag
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加脚本标签
- en: 'Next, we will add a `script` tag with the `lang` attribute set to `ts` so that
    we can add the TypeScript code. First, we will add the `import` statements in
    order to add the components and other items that we will use in our code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个带有`lang`属性设置为`ts`的`script`标签，以便我们可以添加TypeScript代码。首先，我们将添加`import`语句，以便添加我们在代码中将使用的组件和其他项目：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See this book's GitHub repository for the full list of components that can be
    registered.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本书的GitHub存储库，了解可以注册的完整组件列表。
- en: The `computed` function lets us create the computed properties that we can use
    with the Composition API. The `reactive` function lets us create reactive properties
    that have objects as values. The `ref` property lets us create computed properties
    that have primitive values. The `watch` function lets us create watchers that
    can be used with the Composition API.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`computed`函数让我们可以创建与Composition API一起使用的计算属性。`reactive`函数让我们可以创建具有对象值的响应式属性。`ref`属性让我们可以创建具有原始值的计算属性。`watch`函数让我们可以创建与Composition
    API一起使用的观察者。'
- en: The `currenciesArray` variable is an array of currencies that we will use to
    create the `fromCurrencies` and `toCurrencies` computed properties. The `axios`
    object lets us use the Axios HTTP client to make HTTP requests. The `useStore`
    variable is a function that lets us get access to our Vuex store. The `CurrencyConversion`
    interface provides the interface that we use to restrict the structure for the
    object that we add to the history list. The `uuidv4` variable is a function that
    lets us create UUIDs, which are unique IDs that we assign to the history entries
    to identify them. The `useRoute` function lets us access the route object to get
    the current URL path and other parts of the URL.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`currenciesArray`变量是一个货币数组，我们将使用它来创建`fromCurrencies`和`toCurrencies`计算属性。`axios`对象让我们可以使用Axios
    HTTP客户端进行HTTP请求。`useStore`变量是一个函数，让我们可以访问我们的Vuex存储。`CurrencyConversion`接口提供了我们用来限制添加到历史记录列表的对象结构的接口。`uuidv4`变量是一个函数，让我们可以创建UUID，这是我们分配给历史记录条目以标识它们的唯一ID。`useRoute`函数让我们可以访问路由对象，以获取当前URL路径和URL的其他部分。'
- en: 'Next, we will register the components by adding the `components` property and
    the component we imported into it. To do this, we can write the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过将导入的组件添加到`components`属性中来注册组件。为此，我们可以编写以下代码：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See this book's GitHub repository for the full list of components that can be
    registered. We just put all the `import` components into the `component` property
    to register them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看此书的GitHub存储库，以获取可以注册的所有组件的完整列表。我们只需将所有`import`组件放入`component`属性中进行注册。
- en: Working on the setup method
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`setup`方法上工作
- en: 'Next, we will start working on the `setup()` method and add the reactive and
    computed properties to it. We will also add the watchers, which let us watch for
    route changes. First, we will write the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始在`setup()`方法上工作，并向其中添加响应式和计算属性。我们还将添加watchers，它们让我们可以观察路由的变化。首先，我们将编写以下代码：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We call the `useStore()` method to return the store object, which contains the
    Vuex store. We need the Vuex store to commit mutations, which lets us add entries
    to our history. Because we will add the `vuex-persistsedstate` plugin to our Vuex
    store, the history entries will be added to local storage automatically. Similarly,
    we call the `useRoute` function to return the route object, which lets us get
    access to the route object. We need the route object to let us watch the query
    string for the `id query` parameter. If we find an item by their ID, then we can
    set the `fromCurrency`, `toCurrency`, and `amount` values by using their values
    from the Vuex store, which we get from local storage.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`useStore()`方法返回存储对象，其中包含Vuex存储。我们需要Vuex存储来提交mutations，这让我们可以向历史记录中添加条目。因为我们将向Vuex存储添加`vuex-persistsedstate`插件，历史记录条目将自动添加到本地存储中。同样，我们调用`useRoute`函数返回路由对象，让我们可以访问路由对象。我们需要路由对象来让我们观察`id
    query`参数的查询字符串。如果我们通过ID找到项目，那么我们可以使用它们从本地存储中获取的值，从而设置`fromCurrency`、`toCurrency`和`amount`的值。
- en: Also, we call the `ref` function to create the `amount` reactive properties,
    which are number values. The `fromCurrency` and `toCurrency` reactive properties
    are string values and they contain the currency code of the currency that we choose.
    The `currencies` reactive property is a reactive array that is set to `currenciesArray`
    as its initial value. The arguments that we pass into `ref` and `reactive` are
    the initial values for each reactive property.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们调用`ref`函数来创建`amount`响应式属性，它们是数字值。`fromCurrency`和`toCurrency`响应式属性是字符串值，它们包含我们选择的货币的货币代码。`currencies`响应式属性是一个响应式数组，其初始值设置为`currenciesArray`。我们传递给`ref`和`reactive`的参数是每个响应式属性的初始值。
- en: 'Next, we can add the computed properties by writing the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过编写以下代码来添加计算属性：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We call the `computed` function with a callback to create the computed property.
    Like with the options API, we return the value that we want for the computed property.
    The only thing that's different is that we get the value of a primitive value
    reactive property with the `value` property. The `fromCurrencies` reactive property
    is created by filtering the currencies entry with the abbreviation that has the
    same value as `toCurrency`. `toCurrencies` is created by filtering the currencies
    entry with the abbreviation value, which is the same as the value of `fromCurrency`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`computed`函数并使用回调来创建计算属性。与选项API一样，我们返回我们想要的计算属性的值。唯一不同的是，我们使用`value`属性获取基本值响应式属性的值。`fromCurrencies`响应式属性是通过筛选具有与`toCurrency`相同值的缩写的货币条目创建的。`toCurrencies`是通过筛选具有与`fromCurrency`值相同的缩写值的货币条目创建的。
- en: The `amountValid` computed property lets us determine whether the amount that's
    entered inside `ion-input` is valid. We want it to be a number that's at least
    `0`, so we return that condition so that we can check for this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`amountValid`计算属性让我们确定在`ion-input`中输入的金额是否有效。我们希望它是至少为`0`的数字，因此我们返回该条件，以便我们可以检查这一点。'
- en: 'Next, we will add these methods to our `CurrencyConverter` component by adding
    more items to the `setup()` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过向`setup()`方法添加更多项目来向`CurrencyConverter`组件添加这些方法：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `addToHistory()` method lets us add a history entry to our Vuex store and
    local storage so that we can show the activities on the **Home** page. This way,
    we can choose them later and do the same calculation. In the signature, we annotate
    the type of the entry parameter with the `CurrencyConversion` interface so that
    we know we are adding the right thing to the Vuex store and local storage. We
    commit `addToHistory` to the store with the history entry as the payload.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`addToHistory()`方法让我们向Vuex存储和本地存储添加历史记录条目，以便我们可以在**主页**上显示活动。这样，我们以后可以选择它们并进行相同的计算。在签名中，我们使用`CurrencyConversion`接口注释条目参数的类型，以便我们知道我们向Vuex存储和本地存储添加了正确的内容。我们将`addToHistory`提交到存储，并将历史记录条目作为有效负载。'
- en: Working on the calculate method
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正在处理计算方法
- en: In the `calculate()` method, we reset the value of result to `0`. Then, we call
    `addToHistory` to add the entry to the history. The `id` property is generated
    from the `uuidv4` function to generate a unique ID for the entry. We set the other
    properties from the reactive property values. The `value` property is required
    to access primitive value reactive properties.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`calculate()`方法中，我们将结果的值重置为`0`。然后，我们调用`addToHistory`将条目添加到历史记录中。`id`属性是从`uuidv4`函数生成的，用于为条目生成唯一ID。我们从响应式属性值设置其他属性。`value`属性是访问基本值响应式属性所必需的。
- en: Then, we use Axios to get the exchange rate from the free to use Exchange Rate
    API. We just have to set the base query parameter to the code of the currency
    that we are converting from. Finally, we compute the result of the converted value
    by multiplying the amount by the exchange rate retrieved from the API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用Axios从免费使用的汇率API获取汇率。我们只需将基本查询参数设置为我们要转换的货币代码。最后，我们通过将从API检索到的汇率乘以金额来计算转换值的结果。
- en: 'Then, to finish off the `CurrencyConverter` component, we add the watcher for
    the query string. We watch the `queryID` parameter, which will change if we open
    the history entry from the home page. To add the watcher, we can write the following
    code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了完成`CurrencyConverter`组件，我们添加了查询字符串的监视器。我们监视`queryID`参数，如果我们从主页打开历史记录条目，它将发生变化。要添加监视器，我们可以编写以下代码：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To create the watcher, we pass in a function that returns `route.query` to return
    the query object. The `route` variable is assigned to the returned value of the
    `useRoute` function that we called earlier. Then, we get the query object's value
    from the first parameter of the function in the second argument. We get the `id`
    property from the query object. Then, we get the history state from the store,
    which contains all the entries we stored in local storage. Local storage is automatically
    synchronized by `vuex-persistedstate` to the Vuex store.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建观察者，我们传入一个返回`route.query`的函数来返回查询对象。`route`变量被分配给我们之前调用的`useRoute`函数的返回值。然后，我们从函数的第二个参数中获取查询对象的值。我们从查询对象中获取`id`属性。然后，我们从存储中获取历史状态，其中包含我们在本地存储中存储的所有条目。本地存储会自动由`vuex-persistedstate`同步到Vuex存储中。
- en: We call the `history.find()` method to find the entry by its `id`. Then, an
    entry is returned, and we set the `retrieved` property values to the reactive
    properties values. This automatically populates them when we choose an entry from
    the history.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`history.find()`方法来通过其`id`查找条目。然后，返回一个条目，并将`retrieved`属性值设置为响应式属性值。当我们从历史记录中选择条目时，它会自动填充它们。
- en: In the third argument, we have an object that has the immediate property set
    to `true` so that the watcher runs immediately when the component is being mounted.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个参数中，我们有一个对象，其中的immediate属性设置为`true`，以便在组件挂载时立即运行观察者。
- en: We return everything that we want to expose to the templates with the `return`
    statement at the end. We include all the reactive properties, computed properties,
    and methods so that they can be used in templates.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`return`语句返回要在模板中公开的所有内容。我们包括所有的响应式属性、计算属性和方法，以便它们可以在模板中使用。
- en: 'Once we''re finished with the project, the currency converter should look as
    follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 项目完成后，货币转换器应如下所示：
- en: '![Figure 5.2 – Currency Converter'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 - 货币转换器'
- en: '](image/Figure_5.2_B14405.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.2_B14405.jpg)'
- en: Figure 5.2 – Currency Converter
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 - 货币转换器
- en: Adding the Tips calculator
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加小费计算器
- en: 'Next, we will add the `TipsCalculator` page component. To add it, we must add
    the `src/views/TipCalculator.vue` file. Inside it, we will start by adding the
    template and a header:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加`TipsCalculator`页面组件。要添加它，我们必须添加`src/views/TipCalculator.vue`文件。在其中，我们将首先添加模板和标题：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`ion-header` is almost the same as the `CurrencyConverter` one, except the
    `ion-title` content is different.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`ion-header`与`CurrencyConverter`几乎相同，只是`ion-title`内容不同。'
- en: 'Next, we add the `ion-content` component to add the content for the page. To
    do this, we can write the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加`ion-content`组件以添加页面内容。为此，我们可以编写以下代码：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we added `ion-list` and the ion items for the form controls.
    We have one that lets us enter the subtotal on the page. This is the amount before
    the tip. The second `ion-item` component lets us add the `country ion-select`
    control. It lets us choose a country so that we can get the tip rate for that
    country. The tipping rate is computed from the `tippingRate` computed property.
    `ion-select-option` is created from the `countries` reactive array property, which
    provides the list of countries that we can choose from to get their tipping rates.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们添加了`ion-list`和表单控件的ion项。我们可以在页面上输入小费前的金额。第二个`ion-item`组件让我们添加`country
    ion-select`控件。它让我们选择一个国家，以便我们可以获得该国家的小费率。小费率是从`tippingRate`计算属性计算出来的。`ion-select-option`是从`countries`响应式数组属性创建的，它提供了我们可以选择的国家列表，以获取它们的小费率。
- en: 'Next, we will add the display for the tipping rate and the **Calculate Tip**
    button. To do this, we will write the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加小费率的显示和**计算小费**按钮。为此，我们将编写以下代码：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We just display the `tippingRate` computed property's value and the **Calculate
    Tip** button. We add a click handler by adding the `@click` directive and setting
    that to the `calculateTip()` method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只显示`tippingRate`计算属性的值和**计算小费**按钮。我们通过添加`@click`指令并将其设置为`calculateTip()`方法来添加点击处理程序。
- en: 'The final part of the template is the calculated results. We add `ion-list`
    to component to add the results. We display the tip and the subtotal added together.
    To add it, we can write the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的最后部分是计算结果。我们向组件添加`ion-list`来添加结果。我们显示小费和合计。要添加它，我们可以编写以下代码：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will add the TypeScript code for the `TipsCalculator` component. Its
    structure is similar to the `CurrencyConverter` component. First, we add the imports
    by writing the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为`TipsCalculator`组件添加TypeScript代码。它的结构类似于`CurrencyConverter`组件。首先，我们通过编写以下代码添加导入：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We import all the components and libraries as we did with `CurrencyConverter.vue`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像在`CurrencyConverter.vue`中一样导入所有组件和库。
- en: 'Then, we register the components as we did with `CurrencyConverter`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们像在`CurrencyConverter`中一样注册组件：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we define the reactive properties and get the store and route within
    the `setup()` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`setup()`方法中定义响应式属性并获取存储和路由：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We call `useStore` and `useRoute` as we did within `CurrencyConverter`. Then,
    we create the `subtotal` reactive property with the `ref` function. Since its
    value is a number, we use the `ref` function to create it. The `country` array's
    reactive property is created with the reactive function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像在`CurrencyConverter`中一样调用`useStore`和`useRoute`。然后，我们使用`ref`函数创建`subtotal`响应式属性。由于它的值是一个数字，我们使用`ref`函数来创建它。`country`数组的响应式属性是用`reactive`函数创建的。
- en: 'Next, we must add some computed properties by writing the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须通过编写以下代码来添加一些计算属性：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we computed the tipping rate according to the country we selected.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据所选的国家计算小费率。
- en: The `amountValid` computed property lets us check whether the `subtotal` value
    is valid. We want to it to be `0` or bigger.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`amountValid` 计算属性让我们检查`subtotal`值是否有效。我们希望它为`0`或更大。'
- en: 'Next, we will add the rest of the items to the component:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把其余的项目添加到组件中：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `result` reactive property contains the result of the tip calculation. The
    `tip` property contains the tip amount. Finally, the `total` property contains
    the total of both `subtotal` and `tip`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`result` 响应式属性包含小费计算的结果。`tip` 属性包含小费金额。最后，`total` 属性包含`subtotal`和`tip`的总和。'
- en: The `calculateTip()` method lets us calculate the tip. The value of the `result`
    property is initiated to `0` first. Then, we check if `amountValid` is true. If
    it's not, we stop running the function. Otherwise, we add the history entry to
    the store and local storage with the `addToHistory` function. Next, we do the
    tip calculation with the last two lines of the `calculateTip()` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateTip()` 方法让我们计算小费。`result` 属性的值首先被初始化为`0`。然后，我们检查`amountValid`是否为真。如果不是，我们停止运行该函数。否则，我们使用`addToHistory`函数将历史记录条目添加到存储和本地存储中。接下来，我们在`calculateTip()`方法的最后两行进行小费计算。'
- en: 'Finally, we add the watcher to the `setup()` method by writing the following
    code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过编写以下代码将观察者添加到`setup()`方法中：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Just like in `CurrencyConverter.vue`, we watch the parsed query string object
    and populate the value from the history entry if it is found.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`CurrencyConverter.vue`中一样，我们监视解析的查询字符串对象，并在找到时从历史记录条目中填充值。
- en: 'And finally, we return all the items we want to expose to the template, including
    any reactive and computed properties and the method with the `return` statement.
    Once we''ve finished the project, we should see the following screen:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`return`语句返回所有要暴露给模板的项目，包括任何响应式和计算属性以及方法。完成项目后，我们应该看到以下屏幕：
- en: '![Figure 5.3 – Tips Calculator'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 - 小费计算器'
- en: '](image/Figure_5.3_B14405.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.3_B14405.jpg)'
- en: Figure 5.3 – Tips Calculator
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 小费计算器
- en: Adding the Home page
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加主页
- en: 'Next, we will add the `Home.vue` page component, which will let us view the
    calculations that we have done so far. We can redo the calculation by opening
    the page for the calculation with the values populated from our history. To add
    the calculation history list, we will start with its template:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加`Home.vue`页面组件，这将让我们查看到目前为止我们所做的计算。我们可以通过打开页面重新进行计算，使用历史记录中填充的数值。为了添加计算历史列表，我们将从其模板开始：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have used the same header that we've used on the other pages, but this one
    has a different title.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了与其他页面相同的标题，但这个页面有不同的标题。
- en: Then, we render the `historyWithTypes` computed property to render the items
    from the history. If the `type` property is set to `tip`, we render the tip calculation
    data. Otherwise, we show the currency conversion data. In each row, we have the
    **Open** button, which calls the `go()` method when we click it. This takes us
    to the page with the given values from the history that have been populated on
    the page by the watchers of `CurrencyCoverter` or `TipsCalculator`. The **Delete**
    button calls the `deleteEntry()` method, which deletes the entry by its index.
    We must remember to set the `key` prop to the unique ID for each entry so that
    Vue can keep track of them properly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们渲染`historyWithTypes`计算属性来渲染历史记录中的项目。如果`type`属性设置为`tip`，我们渲染小费计算数据。否则，我们显示货币转换数据。在每一行中，我们有**打开**按钮，当我们点击它时调用`go()`方法。这将带我们到页面，该页面由`CurrencyCoverter`或`TipsCalculator`的`watchers`填充了历史记录中给定的数值。**删除**按钮调用`deleteEntry()`方法，通过其索引删除条目。我们必须记得为每个条目设置`key`属性为唯一ID，以便Vue可以正确跟踪它们。
- en: 'Next, we will add the imports by writing the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过编写以下代码来添加导入：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we will add the `type` alias for our history entries and register the
    component code by writing the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为我们的历史记录条目添加`type`别名，并通过编写以下代码注册组件代码：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We create the `HistoryEntry` TypeScript type alias, which is the union of the
    `CurrencyConversion` and `TipCalculation` interfaces. Objects of the `HistoryEntry`
    type must have the structure of either the `CurrencyConversion` or `TipCalculation`
    interface. Then, we register the components just like we registered the other
    components.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`HistoryEntry` TypeScript类型别名，它是`CurrencyConversion`和`TipCalculation`接口的联合。`HistoryEntry`类型的对象必须具有`CurrencyConversion`或`TipCalculation`接口的结构。然后，我们像注册其他组件一样注册组件。
- en: 'Next, we will add the `setup()` method to add the component''s logic:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加`setup()`方法来添加组件的逻辑：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We get the store and the router as usual with `useStore` and `useRouter`, respectively.
    Then, we get the history state from the Vuex store with the `history` computed
    property. Then, we use the `history` computed property to create the `historyWithTypes`
    computed property. This lets us add the `type` property to the object so that
    we can distinguish the types of items in the template easily. In the `map` callback,
    we set the return type to `HistoryEntry & { type: string }` to create an intersection
    type with the interfaces that `HistoryEntry` is composed of and the `{ type: string
    }` type. `HistoryEntry & { type: string` } is the same as `CurrencyConversion
    & { type: string } | TipCalculation & { type: string }` since the `&` operator
    distributes when it''s used with the union `(|)` operator.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '我们像往常一样使用 `useStore` 和 `useRouter` 获取存储和路由。然后，我们使用 Vuex 存储中的 `history` 计算属性获取历史状态。然后，我们使用
    `history` 计算属性创建 `historyWithTypes` 计算属性。这使我们可以向对象添加 `type` 属性，以便我们可以轻松地在模板中区分项目的类型。在
    `map` 回调中，我们将返回类型设置为 `HistoryEntry & { type: string }`，以创建与 `HistoryEntry` 组成的接口和
    `{ type: string }` 类型的交集类型。`HistoryEntry & { type: string` } 与 `CurrencyConversion
    & { type: string } | TipCalculation & { type: string }` 相同，因为 `&` 运算符在与联合 `(|)`
    运算符一起使用时会分发。'
- en: The `go()` method lets us navigate to the right page with the `id` property
    as the value of the `id` query parameter when we call `router.push`. The `path`
    property contains the URL path we specified in the route definitions, while the
    `query` property contains the object that is used to form the query string after
    the path.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`go()` 方法允许我们使用 `id` 属性作为 `id` 查询参数的值导航到正确的页面，当我们调用 `router.push` 时。`path`
    属性包含了我们在路由定义中指定的 URL 路径，而 `query` 属性包含了用于在路径之后形成查询字符串的对象。'
- en: The `deleteEntry()` method lets us delete an entry by committing the `removeHistoryEntry`
    mutation to do so.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteEntry()` 方法允许我们通过提交 `removeHistoryEntry` 突变来删除条目。'
- en: 'We return all the methods and computed properties so that they can be used
    in the template. The **Home** page should look as shown in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回所有方法和计算属性，以便它们可以在模板中使用。**主页** 应该如下截图所示：
- en: '![Figure 5.4 – Home screen'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 – 主屏幕'
- en: '](image/Figure_5.4_B14405.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.4_B14405.jpg)'
- en: Figure 5.4 – Home screen
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 主屏幕
- en: Creating the Vuex store
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Vuex 存储
- en: 'Now, we need to create the Vuex store. To do this, we will create the `src/vue/index.ts`
    file and write the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建 Vuex 存储。为此，我们将创建 `src/vue/index.ts` 文件并编写以下代码：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we have the interfaces and the same type alias as `Home.vue`. We created
    the Vuex store with the `createStore` function. The `plugins` property is set
    to the array that the `createPersistedState` function returns to let us save the
    store state to local storage. We have the history state in the `state()` method.
    The `mutations()` method has the `addToHistory` mutation, which lets us add entries
    to the history array state. We also have `removeHistoryEntry`, which lets us remove
    history items from the history state by its index. We must remember to export
    the store at the end so that we can import it later.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有与 `Home.vue` 相同的接口和类型别名。我们使用 `createStore` 函数创建了 Vuex 存储。`plugins` 属性设置为
    `createPersistedState` 函数返回的数组，以便我们将存储状态保存到本地存储中。我们在 `state()` 方法中有历史状态。`mutations()`
    方法有 `addToHistory` 突变，它允许我们向历史数组状态添加条目。我们还有 `removeHistoryEntry`，它允许我们根据索引从历史状态中删除历史项目。我们必须记得在最后导出存储，以便我们以后可以导入它。
- en: 'Then, we need to add the list of countries and currencies. To add them, we
    will create the `src/constants.ts` file and add the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要添加国家和货币列表。为了添加它们，我们将创建 `src/constants.ts` 文件并添加以下代码：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The full file's content can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter05/src/constants.ts](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter05/src/constants.ts).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文件内容可以在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter05/src/constants.ts](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter05/src/constants.ts)找到。
- en: 'Now, we will add the interfaces we imported by adding the `src/interfaces.ts`
    file and add the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过添加`src/interfaces.ts`文件并添加以下代码来添加我们导入的接口：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In `main.ts`, we must add the store to our app by writing the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.ts`中，我们必须通过编写以下代码向我们的应用程序添加存储：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We added `.use(store)` so that we can use the store in our app.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`.use(store)`，这样我们就可以在我们的应用程序中使用存储。
- en: 'Finally, in `App.vue`, we must update to change the items of the left menu.
    In the template, we must write the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`App.vue`中，我们必须更新左侧菜单的项目。在模板中，我们必须编写以下内容：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `ion-menu-toggle` component contains the menu items we can click or tap
    on to go to the given page, as specified by the `router-link` prop. The `ion-router-outlet`
    component is where the pages we created earlier are created. The `ion-icon` component
    lets us show the icon for each entry.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`ion-menu-toggle`组件包含我们可以点击或轻触以转到给定页面的菜单项，由`router-link`属性指定。`ion-router-outlet`组件是我们之前创建的页面所在的位置。`ion-icon`组件让我们显示每个条目的图标。'
- en: 'Next, we will add the imports for `App.vue` by writing the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过编写以下代码为`App.vue`添加导入项：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will now add the component logic by writing the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过编写以下代码添加组件逻辑：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, we registered the components and added the `appPages` property to render
    the items. It is not a reactive property as we didn''t create it with reactive,
    but we can use it our template since we returned it. Now, we will add some styles
    by writing the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注册了组件并添加了`appPages`属性来渲染项目。它不是一个响应式属性，因为我们没有使用reactive创建它，但是我们可以在模板中使用它，因为我们返回了它。现在，我们将通过编写以下代码添加一些样式：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will add some global styles by writing the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过编写以下代码添加一些全局样式：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By creating the project, we have learned how to use the Composition API, which
    is used by Ionic to create the Vue project. We also learned how to add type annotations
    with TypeScript to our JavaScript code to prevent data type errors in our code.
    And finally, we learned how to create mobile apps from web apps with Ionic.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建项目，我们学会了如何使用Composition API，这是Ionic用来创建Vue项目的。我们还学会了如何在JavaScript代码中添加TypeScript类型注释，以防止代码中的数据类型错误。最后，我们学会了如何从Web应用程序创建移动应用程序。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With Ionic Vue, we can create mobile apps easily with Vue 3\. It makes use of
    the composition API, TypeScript, and Vue Router, along with the components provided
    by Ionic, to create good-looking apps that can work as web or mobile apps. It
    also comes with all the tools required to preview the app in a device or emulator
    and build it into an app package that we can deploy to app stores.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ionic Vue，我们可以轻松地使用Vue 3创建移动应用程序。它利用组合API、TypeScript和Vue Router，以及Ionic提供的组件，创建出外观良好的应用程序，可以作为Web应用程序或移动应用程序运行。它还配备了所有必要的工具，可以在设备或模拟器中预览应用程序，并将其构建成应用程序包，我们可以部署到应用商店。
- en: With the Composition API, we can add the logic like we can with the Vue Options
    API, but we can add them all with functions instead of referencing them. Ionic
    Vue also makes TypeScript the default language of components. This lets us prevent
    type errors at compile time to reduce the chance of type errors happening at runtime.
    This is a convenience feature that reduces frustration with JavaScript development.
    We made use of interfaces, union and intersection types, and type aliases to define
    types for objects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Composition API，我们可以像使用Vue Options API一样添加逻辑，但我们可以使用函数而不是引用它们来添加所有逻辑。Ionic
    Vue还将TypeScript作为组件的默认语言。这使我们能够在编译时防止类型错误，减少类型错误在运行时发生的几率。这是一个方便的功能，可以减少JavaScript开发中的挫败感。我们利用接口、联合和交集类型以及类型别名来定义对象的类型。
- en: In the next chapter, we will look at how to build a travel booking app with
    PrimeVue and Express.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何使用PrimeVue和Express构建旅行预订应用程序。
