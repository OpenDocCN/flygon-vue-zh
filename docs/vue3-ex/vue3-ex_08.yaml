- en: '*Chapter 8*: Building a Chat App with Vue 3, Laravel, and Socket.IO'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：使用Vue 3、Laravel和Socket.IO构建聊天应用'
- en: In the previous chapters, we have created frontend projects or full stack projects
    that only communicate via HTTP. There is no real-time communication between the
    frontend and the backend. Real-time communication is sometimes necessary if we
    need to communicate data from the server side to the client side and vice versa
    instantly. Without some real-time communication mechanism, there is no way to
    communicate from the server side to the client side without the client initiating
    the request. This is something that we can add easily with the Laravel framework
    and Socket.io.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们创建了仅通过HTTP通信的前端项目或全栈项目。前端和后端之间没有实时通信。如果我们需要从服务器端实时向客户端通信数据，或者反过来，实时通信有时是必要的。没有一些实时通信机制，就没有办法在客户端不发起请求的情况下从服务器端向客户端通信。这是我们可以很容易通过Laravel框架和Socket.io添加的功能。
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下主题：
- en: Creating the API endpoints with Laravel
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Laravel创建API端点
- en: Setting up JWT authentication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置JWT身份验证
- en: Creating the frontend to let users chat
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建前端以让用户聊天
- en: Laravel is a backend web framework that is written with PHP. It is a comprehensive
    backend framework that includes processing HTTP requests, database manipulation,
    and real-time communication.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel是用PHP编写的后端Web框架。它是一个包括处理HTTP请求、数据库操作和实时通信的全面后端框架。
- en: In this chapter, we will look at how to get all these parts working together
    so that we can create a chat app with Vue 3, Laravel, Laravel Echo Server, and
    Redis working together.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何让所有这些部分一起工作，以便我们可以使用Vue 3、Laravel Echo Server和Redis一起创建一个聊天应用。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To fully understand this chapter, the following is required:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解本章，需要以下内容：
- en: A basic understanding of PHP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对PHP的基本理解
- en: The ability to create basic apps with Vue components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue组件创建基本应用的能力
- en: The ability to send and receive HTTP requests with the Axios HTTP client
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Axios HTTP客户端发送和接收HTTP请求的能力
- en: The code for this chapter's project is available at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter08](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter08).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章项目的代码可在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter08](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter08)找到。
- en: Creating the API endpoints with Laravel
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Laravel创建API端点
- en: The first step to create our chat app is to create a backend app with Laravel.
    Creating the API with Laravel is the main thing that we have to learn for this
    chapter. This is something that we have not done before. It also means that we
    have to write code in PHP since Laravel is a PHP-based web framework. Therefore,
    you should learn some basic PHP syntaxes before reading this code. Like JavaScript
    and other object-oriented languages, they share similar concepts such as using
    objects, arrays, dictionaries, loops, classes, and other basic object-oriented
    programming concepts. Therefore, it should not be too different from JavaScript
    in terms of difficulty of learning.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们的聊天应用的第一步是使用Laravel创建后端应用。使用Laravel创建API是我们必须学习的主要内容。这是我们以前没有做过的事情。这也意味着我们必须使用PHP编写代码，因为Laravel是基于PHP的Web框架。因此，在阅读此代码之前，您应该学习一些基本的PHP语法。与JavaScript和其他面向对象的语言一样，它们共享类似的概念，如使用对象、数组、字典、循环、类和其他基本的面向对象编程概念。因此，在学习难度方面，它与JavaScript应该没有太大的不同。
- en: Installing the required libraries
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装所需的库
- en: To create our API with Laravel, we don't have to create all the files ourselves,
    we just have to run a few commands and that will create all the files and configuration
    settings for us automatically. Before we create our API, we have to have PHP running.
    In Windows, the easiest way to add PHP to our Windows installation is to use XAMPP.
    We can download and install it by going to [https://www.apachefriends.org/download.html](https://www.apachefriends.org/download.html).
    It is also available for macOS and Linux.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Laravel创建我们的API，我们不必自己创建所有文件，只需运行几个命令，就会自动为我们创建所有文件和配置设置。在创建API之前，我们必须运行PHP。在Windows中，将PHP添加到我们的Windows安装的最简单方法是使用XAMPP。我们可以通过访问[https://www.apachefriends.org/download.html](https://www.apachefriends.org/download.html)来下载和安装它。它也适用于macOS和Linux。
- en: 'Once we install it, then we can create our Laravel API with **Composer**. Composer
    is a package manager for PHP that we will use to install more libraries later
    on. The easiest way to create a project is to create our project folder and then
    run the command to create the Laravel project after we go to the folder:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以使用**Composer**创建我们的Laravel API。Composer是PHP的包管理器，我们将在以后使用它来安装更多的库。创建项目的最简单方法是创建我们的项目文件夹，然后在转到文件夹后运行创建Laravel项目的命令：
- en: First, we create a project folder called `vue-example-ch8-chat-app` that will
    hold both the frontend and backend in their own separate folders.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`vue-example-ch8-chat-app`的项目文件夹，其中将分别放置前端和后端的文件夹。
- en: Then, within this folder, we create the backend folder to house our Laravel
    project code files.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在这个文件夹中，我们创建后端文件夹来存放我们的Laravel项目代码文件。
- en: Now we go to the command line, then we go into `vue-example-ch8-chat-app` and
    then run `composer global require laravel/installer`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们转到命令行，然后进入`vue-example-ch8-chat-app`，然后运行`composer global require laravel/installer`。
- en: 'This will install the Laravel installer, which will let us create our Laravel
    project. The locations at which the global libraries are located are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Laravel安装程序，让我们创建Laravel项目。全局库的位置如下：
- en: '**macOS**: `$HOME/.composer/vendor/bin`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: `$HOME/.composer/vendor/bin`'
- en: '**Windows**: `%USERPROFILE%\AppData\Roaming\Composer\vendor\bin`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `%USERPROFILE%\AppData\Roaming\Composer\vendor\bin`'
- en: '**GNU / Linux Distributions**: `$HOME/.config/composer/vendor/bin` or `$HOME/.composer/vendor/bin`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GNU / Linux发行版: `$HOME/.config/composer/vendor/bin` 或 `$HOME/.composer/vendor/bin`'
- en: We can also run `composer global about` to find out where the library files
    are located.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以运行`composer global about`来查找库文件的位置。
- en: Once that is done, we create the scaffold with all the files and also include
    all the configuration files and install all the required libraries for us with
    one command.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们使用一个命令创建包含所有文件和配置文件的脚手架，并为我们安装所有所需的库。
- en: We go into the `vue-example-ch8-chat-app` folder through the command line, and
    then we run `laravel new backend` to create the Laravel app in the backend folder.
    The Laravel installer will run and create the scaffolding for our Laravel. Also,
    Composer will install all the PHP libraries that we need to run Laravel. Once
    that is all done, we should have a full Laravel installation with all the files
    and configuration that we need to run our app.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过命令行进入`vue-example-ch8-chat-app`文件夹，然后运行`laravel new backend`在后端文件夹中创建Laravel应用程序。Laravel安装程序将运行并为我们的Laravel创建脚手架。此外，Composer将安装我们运行Laravel所需的所有PHP库。完成所有这些后，我们应该拥有一个完整的Laravel安装，其中包含我们运行应用程序所需的所有文件和配置。
- en: Creating databases and migration files
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库和迁移文件
- en: Now, with the creation of the Laravel app and all the associated libraries being
    installed, we can work on the Laravel app to create our API. First, we create
    our database by creating some migration files. We need them to create the `chats`
    and `messages` tables. The `chats` table has the chat room data. And the `messages`
    table has the chat messages that are associated with a chat room. It will also
    have a reference to the user who sent the message.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着Laravel应用程序的创建和所有相关库的安装，我们可以开始在Laravel应用程序上创建我们的API。首先，我们通过创建一些迁移文件来创建我们的数据库。我们需要它们来创建`chats`和`messages`表。`chats`表包含聊天室数据。而`messages`表包含与聊天室相关联的聊天消息。它还将引用发送消息的用户。
- en: We don't have to create a `users` table since that is created automatically
    when we create the Laravel app. Almost every app needs to hold user data so this
    is included automatically. With the Laravel scaffold, we can create users with
    a username, email, and password, and log in with the username and password for
    the user that we just created. Laravel also has the ability to send emails for
    user verification without having to add any code to do that.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要创建`users`表，因为在创建Laravel应用程序时会自动创建。几乎每个应用程序都需要保存用户数据，因此这是自动包含的。使用Laravel脚手架，我们可以创建具有用户名、电子邮件和密码的用户，并使用刚刚创建的用户的用户名和密码登录。Laravel还具有发送电子邮件进行用户验证的功能，而无需添加任何代码。
- en: 'To create the migrations, we run the following commands:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建迁移，我们运行以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding commands will create the migration files for us with the date
    and time prepended to the filename of the migration files. All the migration files
    are in the `database/migrations` folder. So we can go into this folder and open
    the files. In the one with the `create_chats_table` as the filename, we add the
    following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将为我们创建带有日期和时间前缀的迁移文件。所有迁移文件都在`database/migrations`文件夹中。因此，我们可以进入此文件夹并打开文件。在文件名为`create_chats_table`的文件中，我们添加以下代码：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code will create the `chats` table. The `up()` method has the
    code that we want to run when we run our migration. The `down()` method has the
    method we run when we want to reverse the migration.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建`chats`表。`up()`方法包含我们在运行迁移时要运行的代码。`down()`方法包含我们在要撤消迁移时要运行的方法。
- en: In the `up()` method, we call `Schema::create` to create the table. The `::`
    symbols indicate that the method is a static method. The first argument is the
    table name, and the second argument is a callback function that we add code to
    create the table with. The `$table` object has the `id()` method to create an
    `id` column. The `string()` method creates a `string` column with the column name
    in the argument. The `timestamp()` method lets us create a `timestamp` column
    with the given column name. The `useCurrent()` method lets us set the default
    value of the timestamp to the current date and time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`up()`方法中，我们调用`Schema::create`来创建表。`::`符号表示该方法是静态方法。第一个参数是表名，第二个参数是一个回调函数，我们在其中添加创建表的代码。`$table`对象具有`id()`方法来创建`id`列。`string()`方法创建一个带有参数中列名的`string`列。`timestamp()`方法让我们创建一个带有给定列名的`timestamp`列。`useCurrent()`方法让我们将时间戳的默认值设置为当前日期和时间。
- en: In the `down()` method, we have the `Schema::dropIfExists()` method to drop
    the table with the given name in the argument to drop the table if it exists.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`down()`方法中，我们有`Schema::dropIfExists()`方法来删除具有参数中给定名称的表，如果存在的话。
- en: A migration file must have a class that inherits from the `Migration` class
    for it to be used as a migration.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件必须具有从`Migration`类继承的类，才能用作迁移。
- en: 'Likewise, in the migration file with the `create_message_table` name in the
    file name, we write the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在文件名为`create_message_table`的迁移文件中，我们编写以下内容：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding file has the code to create the `messages` table. This table has
    more columns. We have the same `id` and `timestamp` columns as in the `chats`
    table, but we also have the `user_id` unsigned `integer` column to reference the
    ID of the user who posted the message and the `chat_id` unsigned `integer` column
    to reference an entry in the `chats` table to associate the message with the chat
    session that it is created in.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件中有创建`messages`表的代码。这个表有更多的列。我们有与`chats`表中相同的`id`和`timestamp`列，但我们还有`user_id`无符号`integer`列来引用发布消息的用户的ID，以及`chat_id`无符号`integer`列来引用`chats`表中的条目，将消息与创建它的聊天会话关联起来。
- en: The `foreign()` method lets us specify what the `user_id` and `chat_id` columns
    are referencing in the users and `chats` tables respectively.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreign()`方法让我们指定`user_id`和`chat_id`列分别引用用户和`chats`表中的内容。'
- en: Configuring our database
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置我们的数据库
- en: Before we can run our migration, we have to configure our database that we will
    use to store the data for our backend. To do that, we create the `.env` file in
    the project's `root` folder by copying the `.env.example` file and then renaming
    it `.env`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行迁移之前，我们必须配置我们将用于存储后端数据的数据库。为此，我们通过复制`.env.example`文件并将其重命名为`.env`来在项目的`root`文件夹中创建`.env`文件。
- en: 'The `.env` file has many settings that we will need to run our Laravel app.
    To configure which database we will use, we run the following command to let us
    connect to a SQLite database:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`.env`文件有许多设置，我们需要运行我们的Laravel应用程序。为了配置我们将使用的数据库，我们运行以下命令，以便连接到SQLite数据库：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The full configuration file is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/.env.example](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/.env.example).
    We just copy its contents into the `.env` file in the same folder to use the configuration.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的配置文件在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/.env.example](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/.env.example)。我们只需将其内容复制到同一文件夹中的`.env`文件中以使用该配置。
- en: We use SQLite for simplicity in this chapter so that we can focus on creating
    the chat app with Vue 3\. However, we should use a production-quality database
    that has better security and management capabilities if we are building a production
    app. The `DB_CONNECTION` environment variable has the database type we want to
    use, which is SQLite. In the `DB_DATABASE` setting, we specify the absolute path
    of our database file. Laravel will not create this file automatically for us,
    so we have to create it ourselves. To create the SQLite file, we can use the DB
    Browser for SQLite program. It supports Windows, macOS, and Linux so we can run
    this on all the popular platforms. You can download the program from [https://sqlitebrowser.org/dl/](https://sqlitebrowser.org/dl/).
    Once this is installed, just click on **New Database** at the top left and click
    on the **File** menu and click **Save** to save the database file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们使用SQLite是为了简化，这样我们就可以专注于使用Vue 3创建聊天应用程序。然而，如果我们要构建生产应用程序，我们应该使用具有更好安全性和管理能力的生产级数据库。`DB_CONNECTION`环境变量具有我们想要使用的数据库类型，即SQLite。在`DB_DATABASE`设置中，我们指定了数据库文件的绝对路径。Laravel不会自动为我们创建这个文件，所以我们必须自己创建。要创建SQLite文件，我们可以使用DB
    Browser for SQLite程序。它支持Windows、macOS和Linux，因此我们可以在所有流行的平台上运行它。您可以从[https://sqlitebrowser.org/dl/](https://sqlitebrowser.org/dl/)下载该程序。安装完成后，只需在左上角点击**New
    Database**，然后点击**File**菜单，再点击**Save**以保存数据库文件。
- en: Configuring a connection to Redis
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置到Redis的连接
- en: 'In addition to using SQLite as the main database for our app, we also need
    to configure the connection to Redis so that we can use Laravel''s queuing feature
    to broadcast our data to the Redis server, which will then be picked up by the
    Laravel Echo Server so that the event will be sent to the Vue 3 frontend. The
    environment variables for the Redis configuration are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将SQLite用作我们应用程序的主要数据库之外，我们还需要配置与Redis的连接，以便我们可以使用Laravel的排队功能将数据广播到Redis服务器，然后由Laravel
    Echo服务器接收，以便事件将被发送到Vue 3前端。 Redis配置的环境变量如下：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And we add the Redis configuration with the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加以下Redis配置：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first group of environment variables configures where the queue directs
    the data to. The `BROADCAST_DRIVER` setting is set to `redis` so that we direct
    our event to Redis. `QUEUE_CONNECTION` also has to be set to `redis` for the same
    reason. `QUEUE_DRIVER` is set to `sync` so that the events will be sent to the
    queue immediately after they are broadcast.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组环境变量配置了队列将数据发送到的位置。`BROADCAST_DRIVER`设置为`redis`，以便我们将事件发送到Redis。`QUEUE_CONNECTION`也必须设置为`redis`，出于同样的原因。`QUEUE_DRIVER`设置为`sync`，以便事件在广播后立即发送到队列。
- en: Running the migration files
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行迁移文件
- en: 'Now that we have created our migrations and configured which database to use,
    we run `php artisan migrate` to run the migrations. Running the migrations will
    add the tables to our SQLite database. After adding the tables, we can add the
    seed data so we will not have to recreate the data ourselves when we want to reset
    our database or when we have an empty database. To create the seed data, we add
    some code to the `database/seeders/DatabaseSeeder.php` file. In the file, we write
    the following code to add the files for our database:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了迁移并配置了要使用的数据库，我们运行`php artisan migrate`来运行迁移。运行迁移将向我们的SQLite数据库添加表。添加表后，我们可以添加种子数据，这样当我们想要重置数据库或者数据库为空时，我们就不必重新创建数据。要创建种子数据，我们在`database/seeders/DatabaseSeeder.php`文件中添加一些代码。在文件中，我们编写以下代码来添加我们数据库的文件：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have the `addUsers()` method to add a few users into the `users` table. We
    create a loop that calls `DB::table('users')->insert` to insert some entries into
    the `users` table. The `->` symbol is the same as the period in JavaScript. It
    lets us access object properties or methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`addUsers()`方法将一些用户添加到`users`表中。我们创建一个循环，调用`DB::table('users')->insert`向`users`表中插入一些条目。`->`符号与JavaScript中的句号相同。它允许我们访问对象属性或方法。
- en: 'In the `insert()` method, we pass in an associative array or dictionary with
    the keys and values that we want to insert:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`insert()`方法中，我们传入一个带有我们要插入的键和值的关联数组或字典：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `addChats()` method lets us add the chat room entries. We only have to
    insert the name. In the `addMessages()` method, we insert the entries for the
    `messages` table. We get the user entry''s `id` value that we want to set as the
    value from an existing entry in the `users` table. Likewise, we do the same for
    `chat_id` by getting an entry from the `chats` table and use the `id` value for
    that entry and set that as the value of `chat_id`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`addChats()`方法让我们添加聊天室条目。我们只需要插入名称。在`addMessages()`方法中，我们插入`messages`表的条目。我们获取要设置为`id`值的用户条目的值，该值来自`users`表中的现有条目。同样，我们对`chat_id`执行相同的操作，通过从`chats`表中获取条目并使用该条目的`id`值将其设置为`chat_id`的值。'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once we have written the seeder, we may want to regenerate Composer's autoloader
    to update the autoloader with the dependencies that we have. We can do that by
    running `composer dump-autoload`. This is handy in case references to any dependencies
    are outdated and we want to refresh the references so that they won't be outdated.
    Then we run `php artisan db:seed` to run the seeder to populate all the data into
    the tables.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了seeder，我们可能希望重新生成Composer的自动加载程序，以便使用我们的依赖项更新自动加载程序。我们可以通过运行`composer
    dump-autoload`来做到这一点。这在引用任何依赖项过时并且我们想要刷新引用以使其不过时时非常方便的。然后我们运行`php artisan db:seed`来运行seeder以将所有数据填充到表中。
- en: To reset the data to a pristine state, we can run the migration and the seeder
    at the same time by running `php artisan migrate:refresh –seed`. We can also just
    empty the database and rerun all the migrations by running `php artisan migrate:refresh`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据重置为原始状态，我们可以通过运行`php artisan migrate:refresh –seed`来同时运行迁移和seeder。我们也可以只清空数据库并重新运行所有迁移，通过运行`php
    artisan migrate:refresh`。
- en: Creating our application logic
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的应用逻辑
- en: 'Now that we have got the database structure and the seed data down, we can
    move on to creating our app logic. We create some controllers so that we can receive
    requests in from the frontend. Laravel controllers should be in the `app/Http/Controllers`
    folder. We create one for receiving requests or manipulating the `chats` table
    and another for receiving requests to manipulate the `messages` table. Laravel
    comes with a command for creating controllers. First, we create the `ChatController.php`
    file by running the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了数据库结构和种子数据，我们可以继续创建我们的应用逻辑。我们创建一些控制器，这样我们就可以从前端接收请求。Laravel控制器应该在`app/Http/Controllers`文件夹中。我们创建一个用于接收请求或操作`chats`表的控制器，另一个用于接收请求来操作`messages`表。Laravel自带一个用于创建控制器的命令。首先，我们通过运行以下代码创建`ChatController.php`文件：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then we should get the `app/Http/Controllers/ChatController.php` file added
    to our project. The full code is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/ChatController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/ChatController.php).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们应该将`app/Http/Controllers/ChatController.php`文件添加到我们的项目中。完整的代码在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/ChatController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/ChatController.php)。
- en: A Laravel controller has a class that inherits from the `Controller` class.
    Inside the class, we have the methods that will be mapped to URLs later so that
    we can run these methods and do what we want. Each method takes a request object
    with the request data, including the headers, URL parameters, and body.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Laravel控制器有一个继承自`Controller`类的类。在这个类里，我们有一些方法，这些方法将被映射到URL，这样我们就可以运行这些方法并做我们想做的事情。每个方法都接受一个请求对象，其中包括请求数据，包括头部、URL参数和主体。
- en: The `get()` method finds a single `Chat` entry. `Chat` is the model class for
    the `chats` table. In Laravel, the convention is that the class name corresponds
    to the table name by transforming the table name by removing the *s* at the end
    and then converting the first letter to uppercase. Therefore, the `Chat` model
    class is used to manipulate the entries in the `chats` table. Laravel does the
    mapping automatically so we don't have to do anything ourselves. We just have
    to remember this convention, so we won't get confused by it. The `find()` method
    is a `static` method that we use to get a single entry by its ID.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法查找单个`Chat`条目。`Chat`是`chats`表的模型类。在Laravel中，约定是类名对应于表名，通过去掉末尾的`s`然后将第一个字母转换为大写来转换表名。因此，`Chat`模型类用于操作`chats`表中的条目。Laravel会自动进行映射，因此我们不必自己做任何事情。我们只需要记住这个约定，这样我们就不会被搞混。`find()`方法是一个我们用来通过ID获取单个条目的`static`方法。'
- en: In all controller functions, we can just return a string, an associative array,
    a response object, or the results returned from a `query()` method to return that
    as the response. Therefore, the return value of the `Chat::find` method will be
    returned as the response when we make a request and the `get` method is called.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有控制器函数中，我们可以返回一个字符串，一个关联数组，一个响应对象，或者从`query()`方法返回的结果作为响应返回。因此，当我们发出请求并调用`get`方法时，`Chat::find`方法的返回值将作为响应返回。
- en: The `getAll()` method is used to get all the entries from the `chats` table.
    The `all()` method is a static method that returns all entries.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAll()`方法用于从`chats`表中获取所有条目。`all()`方法是一个静态方法，返回所有条目。'
- en: 'The `create()` method is used to create an entry from the request data. We
    call the `Validate::make` static method to create a validator for the request
    data. The first argument is `$request->all()`, which is a method that returns
    all the items in a request object. The second argument is an associative array
    with the key of the request body to validate. The value of it is a string with
    the validation rules. The required rule makes sure the name is filled. The string
    rule checks that value set as the value of the name key is a string. The `max:255`
    rule is the maximum number of characters we can have in the `name` value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()`方法用于从请求数据创建条目。我们调用`Validate::make`静态方法为请求数据创建验证器。第一个参数是`$request->all()`，这是一个返回请求对象中所有项目的方法。第二个参数是一个关联数组，其中包含要验证的请求体的键。它的值是一个包含验证规则的字符串。`required`规则确保`name`被填写。`string`规则检查作为`name`键值的值是否为字符串。`max:255`规则是`name`值中我们可以拥有的最大字符数：'
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We check whether validation fails with the `$validator->fails()` method. `$validator`
    is the object that is returned by the `Validator::make` method. In the `if` block,
    we call `response()->json()` to return the error to the user with the 400 status
    code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`$validator->fails()`方法来检查验证是否失败。`$validator`是由`Validator::make`方法返回的对象。在`if`块中，我们调用`response()->json()`将错误以400状态码返回给用户。
- en: Otherwise, we call `Chat::create` to create the `chats` table entry. We get
    the value of the `name` field from the request body with the `$request->get` method
    with the key that we want to get. Then we set that as the value of the `'name'`
    key in the associative array that we pass into the `create` method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们调用`Chat::create`来创建`chats`表条目。我们使用`$request->get`方法从请求体中获取`name`字段的值，使用我们想要获取的键。然后我们将其设置为我们传递给`create`方法的关联数组中`'name'`键的值。
- en: 'We do something similar with the `update()` method, except that we call `Chat::find`
    to find the item by its `id` value. Then we assign the value of the `name` field
    from the request body to the `name` property of the returned chat object. Then
    we call `$chat->save()` to save the latest value. Then we return the response
    by calling `response()->json($chat)` to return the latest chat entry converted
    to JSON:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`update()`方法做类似的操作，只是我们调用`Chat::find`来通过其`id`值找到项目。然后我们将请求体中的`name`字段的值分配给返回的聊天对象的`name`属性。然后我们调用`$chat->save()`来保存最新值。然后我们通过调用`response()->json($chat)`返回响应，以将最新的聊天条目转换为JSON：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `delete()` method is called when we make a *DELETE* request to the API
    to delete a chat room entry. We call `Chat::find` again to find the entry from
    the `chats` table with the given ID. Then we call `$chat->delete()` to delete
    the returned entry. Then we return an empty response:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向API发出*DELETE*请求以删除聊天室条目时，将调用`delete()`方法。我们再次调用`Chat::find`来查找具有给定ID的`chats`表中的条目。然后我们调用`$chat->delete()`来删除返回的条目。然后我们返回一个空响应：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have similar logic for `MessageController.php` to let us save chat messages.
    We have the `UserController.php` file with code to let us save user data when
    we register for a user account.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有类似的逻辑`MessageController.php`，让我们保存聊天消息。我们有`UserController.php`文件，其中包含注册用户帐户时保存用户数据的代码。
- en: 'Important:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要：
- en: These files can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/MessageController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/MessageController.php)
    and [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/UserController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/UserController.php)
    respectively.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件可以在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/MessageController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/MessageController.php)和[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/UserController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/UserController.php)找到。
- en: Exposing controller methods for endpoints
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公开控制器方法以供端点使用
- en: 'Next, we have to map our controller methods to the URLs that we will make our
    requests to call. We do that by adding some code to the `routes/api.php` file.
    To do that, we replace what is in the file with the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须将我们的控制器方法映射到我们将发出请求调用的URL。我们通过向`routes/api.php`文件添加一些代码来实现这一点。为此，我们用以下代码替换文件中的内容：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We expose the controller methods as POST and GET endpoints to the client by
    calling the `Route::post` and `Route::get` methods respectively.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过分别调用`Route::post`和`Route::get`方法，将控制器方法公开为客户端的POST和GET端点。
- en: The `jwt.verify` middleware is what we use to check the JSON web token before
    we run the `controller` method for the route. This way, the `controller()` method
    will only be run when the token is valid.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`jwt.verify`中间件是我们在运行路由的`controller`方法之前用来检查JSON Web令牌的方法。这样，只有在令牌有效时才会运行`controller()`方法。'
- en: Then we have to create `AuthController` to let us do the JSON web token authentication.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须创建`AuthController`来进行JSON Web令牌身份验证。
- en: 'First, we run the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们运行以下命令：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then in the `app/Http/Controllers/AuthController.php` file, we add methods for
    endpoints to let us get the current user's data, log in, and log out. The code
    for this file is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/AuthController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/AuthController.php).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`app/Http/Controllers/AuthController.php`文件中，我们添加了用于获取当前用户数据、登录和注销的端点方法。该文件的代码位于[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/AuthController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/AuthController.php)。
- en: If you don't have the `app/Http/Middleware/JwtMiddleware.php` file, the full
    code for this file is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Middleware/JwtMiddleware.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Middleware/JwtMiddleware.php).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有`app/Http/Middleware/JwtMiddleware.php`文件，该文件的完整代码位于[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Middleware/JwtMiddleware.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Middleware/JwtMiddleware.php)。
- en: It lets us enable authentication with a JSON web token between the Vue client
    and this app.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它使我们能够在Vue客户端和此应用程序之间启用JSON Web令牌身份验证。
- en: Setting up JWT authentication
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置JWT身份验证
- en: 'Now we have to set up the JSON web token authentication with our Laravel app
    so that we can host our frontend separately from our backend. To do that, we use
    the `tymon/jwt-auth` library. To install it, we run the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须设置JSON Web令牌身份验证与我们的Laravel应用程序，以便我们可以将我们的前端与后端分开托管。为此，我们使用了`tymon/jwt-auth`库。要安装它，我们运行以下命令：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we run the following command to publish the package configuration files:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行以下命令来发布软件包配置文件：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding command will add all the required configuration for us. We should
    now have `config/jwt.php` added to our app. Then we generate the secret key to
    sign the JSON web token by running the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将为我们添加所有必需的配置。现在我们应该在我们的应用程序中添加`config/jwt.php`。然后，我们通过运行以下命令生成秘密密钥以签署JSON
    Web令牌：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `secret` key will be added to the `.env` file with the key `JWT_SECRET`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`secret`密钥将被添加到`.env`文件中，密钥为`JWT_SECRET`。'
- en: Configuring our authentication
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置我们的身份验证
- en: 'Next, we have to configure our authentication so that we can verify our JSON
    web token before we can successfully make a request to routes that requires authentication.
    In `config/auth.php`, we have the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须配置我们的身份验证，以便在成功发出需要身份验证的路由请求之前，我们可以验证我们的JSON Web令牌。在`config/auth.php`中，我们有以下代码：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `guards` section, we have an `api` key that has a value being an associative
    array with the driver key set to `'jwt'` and the provider set to `'users'` to
    let us authenticate users with the JSON web token issued by the `jwt-auth` library.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`guards`部分，我们有一个`api`密钥，其值为一个关联数组，其中驱动程序键设置为`'jwt'`，提供者设置为`'users'`，以便我们使用`jwt-auth`库发行的JSON
    Web令牌对用户进行身份验证。
- en: Next, we add the code to enable CORS so that our Vue.js 3 app can communicate
    with it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加代码以启用CORS，以便我们的Vue.js 3应用程序可以与其通信。
- en: Enabling cross-domain communication
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用跨域通信
- en: 'To enable us to do cross-domain communication between the frontend and backend,
    we install the `fruitcake/laravel-cors` package. To do this, we run the following
    command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们能够在前端和后端之间进行跨域通信，我们安装了`fruitcake/laravel-cors`软件包。为此，我们运行以下命令：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, in `app/Http/Kernel.php`, we should have the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`app/Http/Kernel.php`中，我们应该有以下内容：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We register the `HandleCors` middleware that comes with the `laravel-cors`
    package, and register the `jwt.verify` middleware in the `$routeMiddleware` associative
    array by writing the following code in the `$routesMiddleware` associative array:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`$routesMiddleware`关联数组中写入以下代码，注册了`laravel-cors`包中提供的`HandleCors`中间件，并在`$routeMiddleware`关联数组中注册了`jwt.verify`中间件：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This way, we can use the `jwt.verify` middleware to verify the token.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以使用`jwt.verify`中间件来验证令牌。
- en: The full code is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Kernel.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Kernel.php).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Kernel.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Kernel.php)。
- en: 'Also, we install the `predis` package so that we can talk to our Redis database
    more easily. To install the `predis` package, we run the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们安装`predis`包，这样我们就可以更轻松地与我们的Redis数据库进行通信。要安装`predis`包，我们运行以下命令：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, in `config/database.php`, we write the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`config/database.php`中，我们编写以下代码：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We configure our Redis database connection within the associative array we set
    for `'redis'` so that we can connect to Redis.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在关联数组中配置了Redis数据库连接，以便我们可以连接到Redis。
- en: The full file is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/config/database.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/config/database.php).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文件在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/config/database.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/config/database.php)。
- en: Now that we have created the API for storing users' data and their chat messages,
    we'll move on to add real-time communication capabilities to the Laravel app so
    that users can save and get chat messages in real time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为存储用户数据和他们的聊天消息创建了API，我们将继续为Laravel应用程序添加实时通信功能，以便用户可以实时保存和获取聊天消息。
- en: Adding real-time communication
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加实时通信
- en: Now that we are done with adding the routes, authentication, and database configuration
    and manipulation code, we are ready to add the code for letting us communicate
    between the frontend and backend in real time. First, we need to create an `event`
    class in our Laravel backend so that we can call the `event` function to broadcast
    the event as we did in `MessageController`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了添加路由、身份验证和数据库配置和操作代码，我们准备添加让我们在前端和后端实时通信的代码。首先，我们需要在Laravel后端创建一个`event`类，这样我们就可以调用`event`函数来广播事件，就像我们在`MessageController`中所做的那样。
- en: 'To do that, we run the `php artisan make:event MessageSent` command to create
    the `MessageSent` event class. The class should now be in the `backend/app/Events/MessageSent.php`
    file. Once the file is created, we replace what is inside the file with the following
    code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们运行`php artisan make:event MessageSent`命令来创建`MessageSent`事件类。该类现在应该在`backend/app/Events/MessageSent.php`文件中。创建文件后，我们用以下代码替换文件中的内容：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `__constructor()` method is the constructor; we get the `$user` and `$message`
    objects and then assign them to the class variables with the same name. The `broadcastOn()`
    method returns the `Channel` object, which creates a channel that we can listen
    to in the frontend. The `broadCastAs()` method returns the event name that we
    listen to in the chat channel. We will use this in the frontend to listen to the
    broadcast events. An `event` class should implement the `ShouldBroadcast` interface
    so that events can be broadcast from it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`__constructor()`方法是构造函数；我们获取`$user`和`$message`对象，然后将它们分配给同名的类变量。`broadcastOn()`方法返回`Channel`对象，它创建一个我们可以在前端监听的频道。`broadCastAs()`方法返回我们在聊天频道中监听的事件名称。我们将在前端使用这个来监听广播事件。一个`event`类应该实现`ShouldBroadcast`接口，以便可以从中广播事件。'
- en: The full code of `MessageSent.php` is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Events/MessageSent.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Events/MessageSent.php).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageSent.php`的完整代码位于[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Events/MessageSent.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Events/MessageSent.php)。'
- en: 'In the `backend/routes/channels.php` file, we should have the following code
    so that all users can listen to the chat channel:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`backend/routes/channels.php`文件中，我们应该有以下代码，以便所有用户都可以监听聊天频道：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first argument is the name of the channel we are subscribing to. The callback
    is a function that returns `true` if the user can listen to the event and `false`
    otherwise. An optional parameter is the `user` object so that we can check whether
    the user can listen to a given event.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们要订阅的频道的名称。回调是一个函数，如果用户可以监听事件则返回`true`，否则返回`false`。一个可选参数是`user`对象，以便我们可以检查用户是否可以监听给定事件。
- en: The full code of this file is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/routes/channels.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/routes/channels.php).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件的完整代码位于[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/routes/channels.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/routes/channels.php)。
- en: 'The communication flow is as shown in the following diagram:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通信流程如下图所示：
- en: '![Figure 8.1 – Diagram of the chat app''s architecture'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 - 聊天应用程序架构图'
- en: '](image/Figure_8.1_B14405.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.1_B14405.jpg)'
- en: Figure 8.1 – Diagram of the chat app's architecture
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - 聊天应用程序架构图
- en: The Vue 3 frontend makes an HTTP request to the Laravel app with the message
    we want to send. The Laravel app saves the message to the `messages` table with
    the ID of the chat session and the user. It also broadcasts an event via the queue
    to the Redis server. Then the Laravel Echo Server watches Redis to see whether
    there is anything saved to the Redis database. If there is anything new saved,
    then the Laravel Echo Server pushes that to the Vue 3 frontend. The Vue 3 frontend
    picks that up by listening to the Laravel Echo Server for the events with the
    Laravel Echo client and the Socket.IO client.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3前端通过HTTP请求将要发送的消息发送到Laravel应用程序。Laravel应用程序将消息保存到`messages`表中，并带有聊天会话和用户的ID。它还通过队列向Redis服务器广播事件。然后Laravel
    Echo服务器监视Redis，看是否有任何内容保存到Redis数据库。如果有任何新保存的内容，那么Laravel Echo服务器将其推送到Vue 3前端。Vue
    3前端通过使用Laravel Echo客户端和Socket.IO客户端监听Laravel Echo服务器上的事件来接收它。
- en: Communication with Socket.IO
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Socket.IO通信
- en: To make our backend app communicate with the frontend via Socket.IO, we need
    the Laravel Echo Server. To do this, we first need to install the Laravel Echo
    Server `npm` package globally. We install it by running `npm install –g laravel-echo-server`.
    Then we will run this package to create the configuration file for setting up
    the communication.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的后端应用通过Socket.IO与前端通信，我们需要使用Laravel Echo Server。为此，我们首先需要全局安装Laravel Echo
    Server的`npm`包。我们可以通过运行`npm install –g laravel-echo-server`来安装它。然后我们将运行这个包来创建配置文件以设置通信。
- en: To do this, we create a new folder and then run `laravel-echo-server init` to
    run the command-line wizard to create the Laravel Echo Server configuration file
    in the folder. At this point, we can just answer all the questions that are asked
    with the default settings. This is because we are going to edit the configuration
    file that it creates once this wizard is done.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们创建一个新文件夹，然后运行`laravel-echo-server init`来运行命令行向导，在文件夹中创建Laravel Echo Server配置文件。在这一点上，我们可以用默认设置回答所有问题。这是因为一旦向导完成，我们将编辑它创建的配置文件。
- en: 'Once the wizard is done, we should see the `laraval-echo-server.json` file
    in the folder. Now we open it and replace whatever is in there with the following
    code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 向导完成后，我们应该在文件夹中看到`laraval-echo-server.json`文件。现在我们打开它，并用以下代码替换其中的内容：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we have the JSON code for the configuration so that the
    Laravel Echo Server can listen to the items that are saved in Redis and then send
    whatever is in the Redis database to the frontend via the Socket.IO client. The
    `devMode` property is set to `true` so that we can see all the events that are
    sent. The host has the host IP address of the Laravel Echo Server. The `port`
    property is set to `6001` so this server will listen to port 6001\. Another important
    part of this file is the `apiOriginAllow` property. It is set to an object with
    `allowCors` set to `true` so that we can do cross-domain communication with our
    frontend.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有配置的JSON代码，以便Laravel Echo Server可以监听保存在Redis中的项目，然后通过Socket.IO客户端将Redis数据库中的内容发送到前端。`devMode`属性设置为`true`，以便我们可以看到所有发送的事件。主机具有Laravel
    Echo Server的主机IP地址。`port`属性设置为`6001`，因此此服务器将监听6001端口。此文件的另一个重要部分是`apiOriginAllow`属性。它设置为一个对象，其中`allowCors`设置为`true`，以便我们可以与前端进行跨域通信。
- en: The `allowOrigin` property lets us set the domains that are allowed to listen
    to the emitted events. The `allowMethods` property has the HTTP methods that are
    allowed to be received from the frontend. The `allowHeaders` property has the
    list of HTTP request headers that are allowed to be sent from the frontend to
    the Laravel Echo Server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowOrigin`属性让我们设置允许监听发出的事件的域。`allowMethods`属性具有允许从前端接收的HTTP方法。`allowHeaders`属性具有允许从前端发送到Laravel
    Echo Server的HTTP请求标头列表。'
- en: '`authHost` has the base URL of the Laravel app so that it can listen to the
    events broadcast by the Laravel app. `authEndpoint` has the authentication endpoint
    that is used to check whether the user is authenticated for listening to events
    that require authentication.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`authHost`具有Laravel应用的基本URL，以便它可以监听Laravel应用广播的事件。`authEndpoint`具有用于检查用户是否经过身份验证以便监听需要身份验证的事件的身份验证端点。'
- en: Another important part of this configuration file is the database configuration
    properties. The database property is set to `"redis"` so that it will listen to
    the Redis server for saved items. The `databaseConfig` property has the settings
    to let us connect to the Redis server. The `"redis"` property is set to an object
    with the `"port"` property set to the `port` that the Redis server listens to.
    The default port for Redis is `6379`. The `host` property is the location of the
    Redis server. The `publishPresence` property is set to `true` so that Redis publishes
    items that are saved in its database.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件的另一个重要部分是数据库配置属性。数据库属性设置为`“redis”`，以便它将监听Redis服务器以保存项目。`databaseConfig`属性具有设置，让我们连接到Redis服务器。`“redis”`属性设置为一个对象，其中`“port”`属性设置为Redis服务器监听的`端口`。Redis的默认端口是`6379`。`host`属性是Redis服务器的位置。`publishPresence`属性设置为`true`，以便Redis发布保存在其数据库中的项目。
- en: The full configuration is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/laravel-echo-server/laravel-echo-server.json](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/laravel-echo-server/laravel-echo-server.json).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的配置在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/laravel-echo-server/laravel-echo-server.json](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/laravel-echo-server/laravel-echo-server.json)。
- en: 'The latest version of Redis is only available for Linux or macOS. To install
    Redis on Ubuntu Linux, run the following command to install the Redis server:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Redis的最新版本仅适用于Linux或macOS。要在Ubuntu Linux上安装Redis，请运行以下命令安装Redis服务器：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you are running Windows 10, you can use the Window Subsystem for Linux to
    install a copy of Ubuntu Linux so you can run the latest version of Redis. To
    install Ubuntu on Windows 10, do the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows 10，可以使用Windows子系统来安装Ubuntu Linux的副本，以便运行最新版本的Redis。要在Windows
    10上安装Ubuntu，请执行以下操作：
- en: Type in `Turn Windows Features on and Off` in the **Start** menu.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**开始**菜单中键入`打开或关闭Windows功能`。
- en: Then we scroll to the bottom and click on **Window Subsystem for Linux** to
    install it. It will ask you to restart, and you should do that before continuing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们滚动到底部，点击**Windows子系统用于Linux**进行安装。它会要求您重新启动，您应该在继续之前这样做。
- en: Once your computer has restarted, go to the **Windows Store** and search for
    **Ubuntu**, then you can click it and click **Get**.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算机重新启动后，转到**Windows商店**，搜索**Ubuntu**，然后您可以点击它并点击**获取**。
- en: After it is installed, then you can type in `Ubuntu` in the **Start** menu and
    start it. Now just follow the instructions to finish the installation.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，您可以在**开始**菜单中键入`Ubuntu`并启动它。现在只需按照说明完成安装。
- en: Then you can run the preceding two commands to install Redis.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以运行上述两个命令来安装Redis。
- en: 'Once Redis is installed, we run the following command to run the Redis server:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完Redis后，我们运行以下命令来运行Redis服务器：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now the backend part of our project is done. Now we run `php artisan serve`
    and `php artisan queue:listen` to run the Laravel app and the queue worker. We
    also have to run the Laravel Echo Server by running `laravel-echo-server start`
    to start the Laravel Echo Server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们项目的后端部分已经完成。现在我们运行`php artisan serve`和`php artisan queue:listen`来运行Laravel应用程序和队列工作程序。我们还必须运行Laravel
    Echo Server，通过运行`laravel-echo-server start`来启动Laravel Echo Server。
- en: 'If you run into any issues, then you may have to clear the cache to make sure
    that the latest code is actually running. To do that, you can run the following
    commands to clear all the caches:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到任何问题，您可能需要清除缓存以确保最新的代码实际在运行。要做到这一点，您可以运行以下命令来清除所有缓存：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the cache is cleared and the code is still not working, then you can go back
    to check the code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缓存已清除，代码仍然无法正常工作，那么您可以返回检查代码。
- en: Now that we have added real-time communication to our Laravel app, we are ready
    to move on to creating the frontend to let users register an account, log in,
    and start chatting in a chat room.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的Laravel应用程序添加了实时通信，我们准备继续创建前端，让用户注册帐户，登录并在聊天室中开始聊天。
- en: Creating the frontend to let users chat
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建前端以让用户聊天
- en: Now that we have the backend code all finished and running, we can work on the
    frontend. The frontend is not very different from what we had in the earlier chapters.
    We use the Vue CLI to create our project in the `frontend` folder of the `vue-example-ch8-chat-app`
    folder and then we can start writing our code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成并运行了后端代码，我们可以开始工作在前端。前端与前几章的内容并没有太大的不同。我们使用Vue CLI在“vue-example-ch8-chat-app”文件夹的“frontend”文件夹中创建我们的项目，然后我们可以开始编写我们的代码。
- en: In the `vue-example-ch8-chat-app/frontend` folder, we run `vue create`, then
    we choose **select version**, then we select the **Vue 3** option with **Vue Router**
    option enabled. Once the Vue CLI wizard finishes running, we can start building
    our frontend.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在“vue-example-ch8-chat-app / frontend”文件夹中，我们运行“vue create”，然后选择**选择版本**，然后选择启用**Vue
    Router**选项的**Vue 3**选项。一旦Vue CLI向导完成运行，我们就可以开始构建我们的前端。
- en: Installing the Vue dependencies
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Vue依赖项
- en: 'In addition to the Vue dependencies, we also need to install the Axios HTTP
    client, the Socket.IO client, and the Laravel Echo client package to make HTTP
    requests and listen to events emitted from the server side via the Laravel Echo
    Server respectively. To install those, we run the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Vue依赖项之外，我们还需要安装Axios HTTP客户端、Socket.IO客户端和Laravel Echo客户端包，以通过Laravel Echo服务器分别进行HTTP请求和监听从服务器端发出的事件。要安装这些，我们运行以下命令：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'First, in the `src` folder, we create the `constants.js` file and add the following
    code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在“src”文件夹中，我们创建“constants.js”文件并添加以下代码：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We add the `APIURL` constant that we will use when we make requests to our
    API endpoints. In `src/main.js`, we replace the code we have with the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`APIURL`常量，当我们向API端点发出请求时将使用它。在`src/main.js`中，我们用以下代码替换我们已有的代码：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have two things that are new in this file. We have the Axios request and
    response interceptors so that we can apply the same settings to all requests without
    repeating the same code when we make each request. The `axios.interceptors.request.use()`
    method takes a callback that lets us return a new `config` object according to
    our needs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中有两件新事物。我们有Axios请求和响应拦截器，这样我们就可以在每次请求时应用相同的设置，而不必重复相同的代码。`axios.interceptors.request.use（）`方法接受一个回调，让我们根据需要返回一个新的`config`对象。
- en: If the request URL doesn't include `login` or `register`, then we need to add
    the token to the `Authorization` header. This is what we did in the callback we
    passed into the `use()` method. We add the token to the request configuration
    for the endpoints that need them. The second callback is an error handler, and
    we just return a rejected promise so we can handle them when we make the request.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的URL不包括“登录”或“注册”，那么我们需要将令牌添加到“Authorization”标头中。这就是我们在传递给“use（）”方法的回调中所做的。我们将令牌添加到需要它们的端点的请求配置中。第二个回调是一个错误处理程序，我们只是返回一个拒绝的承诺，这样我们就可以在发出请求时处理它们。
- en: Similarly, we have the `axios.interceptor.response.use()` method to check for
    each response with the callback in the first argument. We check whether the response
    body has the `status` property set to the `"Token is expired"` string so we can
    redirect to the login page when we get this message and return the response. Otherwise,
    we just return the response as is. The error handler in the second argument is
    the same with the request interceptor.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们有`axios.interceptor.response.use()`方法来检查每个响应，并使用第一个参数中的回调函数。我们检查响应体是否具有将`status`属性设置为`"Token
    is expired"`字符串，以便在收到此消息时重定向到登录页面并返回响应。否则，我们原样返回响应。第二个参数中的错误处理程序与请求拦截器相同。
- en: Creating our components
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的组件
- en: 'Next, we create our components. We start with the form to let us set or edit
    the chat room name. To do that, we go into the `src/components` folder and create
    the `ChatroomForm.vue` file. Then, in the file, we write the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的组件。我们从表单开始，让我们设置或编辑聊天室名称。为此，我们进入`src/components`文件夹并创建`ChatroomForm.vue`文件。然后，在文件中，我们编写以下代码：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This component takes the `edit` prop, which has the type boolean and the `id`
    prop that has the type string. It has one reactive property, which is the `form`
    property. It is used to bind the input value to the reactive property. We have
    the `submit()` method that checks the name to see whether it is filled. If it
    is, then we go ahead and submit it. If the `edit` prop is true, then we make a
    PUT request to update an existing entry in the `chats` table with the given ID.
    Otherwise, we create a new entry in the same table with the given name value.
    Once that is done, we redirect to the home page, which has the list of chat rooms.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件接受`edit`属性，其类型为布尔值，以及`id`属性，其类型为字符串。它有一个响应式属性，即`form`属性。它用于将输入值绑定到响应式属性。我们有`submit()`方法来检查名称是否已填写。如果是，则我们继续提交。如果`edit`属性为true，则我们进行PUT请求以更新`chats`表中具有给定ID的现有条目。否则，我们在相同的表中创建一个具有给定名称值的新条目。完成后，我们重定向到具有聊天室列表的主页。
- en: 'In the `created` hook, we check whether the `edit` reactive property is true.
    If it is, then we get the entry in the `chats` table with the given ID and set
    it as the value of the `form` reactive property so that we can see the value of
    the `form.name` property in the input box:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`created`钩子中，我们检查`edit`响应式属性是否为true。如果是，则我们获取具有给定ID的`chats`表中的条目，并将其设置为`form`响应式属性的值，以便我们可以在输入框中看到`form.name`属性的值：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, in the `src/components` folder, we create `NavBar.vue` to create a component
    to render a navigation bar. Inside the file, we write the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`src/components`文件夹中，我们创建`NavBar.vue`来创建一个渲染导航栏的组件。在文件内，我们编写以下代码：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have a `router-link` component that goes to the **Chatrooms** page. This
    is done by setting the `to` prop to the `/` route. We also have a link to call
    the `logout()` method when we click it. The `logout()` method makes a POST request
    to the `/api/auth/logOut` endpoint to invalidate the JSON web token. Then we call
    the `localStorage.clear()` method to clear local storage. Then we call `this.$router.push`
    to redirect to the login page.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`router-link`组件，可以转到**聊天室**页面。这是通过将`to`属性设置为`/`路由来实现的。我们还有一个链接，当我们点击它时调用`logout()`方法。`logout()`方法发出POST请求到`/api/auth/logOut`端点来使JSON
    web token失效。然后我们调用`localStorage.clear()`方法来清除本地存储。然后我们调用`this.$router.push`来重定向到登录页面。
- en: 'In the styles section, we have some styles for the `ul` and `li` elements so
    the `li` display horizontally with some margins between them. We also have the
    `list-style-type` property set to `none` so that we remove the bullets from the
    list:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式部分，我们为`ul`和`li`元素设置了一些样式，使`li`水平显示，并在它们之间设置了一些边距。我们还将`list-style-type`属性设置为`none`，以便从列表中移除项目符号：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `src/views` folder, we have the components for the pages that we map
    to a URL with Vue Router so that we can access these components from the browser.
    First, we create the `AddChatroomForm.vue` component file in the `src/views` folder
    and add the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/views`文件夹中，我们有页面组件，我们使用Vue Router将其映射到URL，以便我们可以从浏览器访问这些组件。首先，在`src/views`文件夹中创建`AddChatroomForm.vue`组件文件，并添加以下代码：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We just register the `NavBar` and the `ChatroomForm` component in the `components`
    property and then add them to the template.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在`components`属性中注册`NavBar`和`ChatroomForm`组件，然后将它们添加到模板中。
- en: 'Next, we create the `ChatRoom.vue` component to display our chat messages and
    add the code to listen to the `laravel_database_chat` channel''s `MessageSent`
    event that we emit from the Laravel app via the Redis database and the Laravel
    Echo Server in this file. In this file, we write the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建`ChatRoom.vue`组件来显示我们的聊天消息，并在此文件中添加代码来监听从Laravel应用程序通过Redis数据库和Laravel
    Echo服务器发出的`laravel_database_chat`频道的`MessageSent`事件。在此文件中，我们编写以下代码：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then we add the methods to the same file to get and send the chat messages
    by writing the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在同一文件中添加方法来获取和发送聊天消息，编写以下代码：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `getChatMessages` method gets the chat messages for the chat room from the
    API and the `sendChatMessage` method sends a message to the chatroom by submitting
    the chat message via an HTTP request to the API. Then, the API endpoint would
    send a message to the queue through the Laravel Echo Server back to the Socket.IO
    chat client used in this app. We call `addChatListener` to listen to the `laravel_database_chat`
    event from the server, which calls `getChatMessages` to get the latest messages.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`getChatMessages`方法从API获取聊天室的聊天消息，`sendChatMessage`方法通过向API发出HTTP请求提交聊天消息来向聊天室发送消息。然后，API端点会通过Laravel
    Echo服务器将消息发送到队列，然后返回到此应用中使用的Socket.IO聊天客户端。我们调用`addChatListener`来监听服务器发送的`laravel_database_chat`事件，该事件调用`getChatMessages`以获取最新消息。'
- en: 'The component template just uses the `v-for` directive to render each entry
    of the `chatMessages` reactive property and render them. The `form` element in
    the following code is used to let us enter a message and then submit it to Laravel
    by making an HTTP request. The endpoint saves the message to the `messages` table
    and also emits an event that we listen to, which is sent via the Redis database
    and the Laravel Echo Server. The frontend only knows about the Laravel Echo Server
    from the real-time communication point of view:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 组件模板只是使用`v-for`指令来渲染`chatMessages`响应式属性的每个条目并将它们呈现出来。以下代码中的`form`元素用于让我们输入消息，然后通过发出HTTP请求将其提交到Laravel。端点将消息保存到`messages`表，并且还会触发一个我们监听的事件，该事件通过Redis数据库和Laravel
    Echo服务器发送。前端只从实时通信的角度了解Laravel Echo服务器：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the `component` object, we have the `beforeMount` hook to call the `getChatMessage`
    method to get chat messages. The `addChatListener()` method creates an event listener
    with the Socket.IO client to let us listen to events emitted from the Laravel
    Echo Server. In the `getChatMessage()` method, we call the `this.$nextTick()`
    method with a callback so that we always scroll to the bottom of the `div` tag
    that holds the messages once we get the messages. We have run that code in the
    `$nextTick` callback because we need to make sure the scrolling code runs after
    all the messages are rendered.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`component`对象中，我们有`beforeMount`钩子来调用`getChatMessage`方法来获取聊天消息。`addChatListener()`方法使用Socket.IO客户端创建事件侦听器，让我们监听从Laravel
    Echo服务器发出的事件。在`getChatMessage()`方法中，我们调用`this.$nextTick()`方法并带有一个回调，以便我们在获取消息后始终滚动到包含消息的`div`标签的底部。我们在`$nextTick`回调中运行该代码，因为我们需要确保滚动代码在所有消息都呈现后运行。
- en: The `this.$nextTick()` method lets us wait for the component to be re-rendered
    after reactive properties are updated before running the code in the callback.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.$nextTick()`方法让我们在响应式属性更新后等待组件重新渲染，然后再运行回调中的代码。'
- en: In the `addChatListener()` method, we subscribe to the `laravel_database_chat`
    channel, which is the same as the chat channel we defined in the Laravel app.
    We can make sure that we subscribe to the right channel by watching the output
    of the Laravel Echo Server. The `.MessageSent` event is the same one that we defined
    in the backend app. The dot before the event name is required so that it listens
    to the right event in the right namespace. In the callback that we pass in to
    listen, we call `this.getChatMessages()` to get the latest messages.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addChatListener()`方法中，我们订阅了`laravel_database_chat`频道，这与我们在Laravel应用程序中定义的聊天频道相同。我们可以通过观察Laravel
    Echo Server的输出来确保我们订阅了正确的频道。`.MessageSent`事件与我们在后端应用程序中定义的事件相同。事件名称前的点是必需的，以便它在正确的命名空间中监听到正确的事件。在我们传递给监听器的回调函数中，我们调用`this.getChatMessages()`来获取最新的消息。
- en: 'The container for the chat messages is set to the height 300px so that it won''t
    be too tall when we have too many messages. It also lets us scroll to the bottom
    when we have enough messages to overflow the container:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天消息的容器高度设置为300px，这样当我们有太多消息时，它不会太高。它还让我们在有足够的消息溢出容器时滚动到底部：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, in the `src/views` folder, we create the `Chatrooms.vue` component file
    by writing the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`src/views`文件夹中，我们通过编写以下代码创建`Chatrooms.vue`组件文件：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We render a table with the list of chat rooms that we can go to, edit the name
    of, or delete. The method just gets the chat room data and goes to the routes
    for editing the chatroom with the given ID, adding the chat room, redirecting
    to the chat room page with the given ID, and deleting the chat room respectively.
    When we delete a chat room, we get the latest entries again with the `getChatRooms()`
    method so that we can get the latest data.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们渲染了一个包含我们可以进入、编辑名称或删除的聊天室列表的表格。该方法只是获取聊天室数据，并转到编辑具有给定ID的聊天室的路由，添加聊天室的路由，重定向到具有给定ID的聊天室页面的路由，以及删除聊天室的路由。当我们删除聊天室时，我们再次使用`getChatRooms()`方法获取最新条目，以便获取最新数据。
- en: 'We get the chat room list in the `beforeMount` hook so we see the table entries
    when the page loads. Next, in the same folder, we create the `EditChatroomForm.vue`
    file and add the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`beforeMount`钩子中获取聊天室列表，以便在页面加载时看到表格条目。接下来，在相同的文件夹中，我们创建`EditChatroomForm.vue`文件并添加以下代码：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It has the same content as the `AddChatroomForm.vue` file but with the `edit`
    prop on `ChatroomForm` set to `true` and the `id` prop set to the `id` URL parameter
    from the URL that we get from Vue Router.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 它与`AddChatroomForm.vue`文件具有相同的内容，但是`ChatroomForm`上的`edit`属性设置为`true`，`id`属性设置为从Vue
    Router获取的`id` URL参数。
- en: Creating the login page
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建登录页面
- en: 'Next, we create the login page by creating `src/views/Login.vue` and adding
    the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过创建`src/views/Login.vue`并添加以下代码来创建登录页面：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The template just has a login form that takes the email and password to let
    us log in. When we submit the form, the `login()` method is called. It first checks
    whether all the fields are filled in properly, then it makes an HTTP request to
    the `/api/auth/login` route with the credentials to see whether we can log in.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 模板只有一个登录表单，用于输入电子邮件和密码以便我们登录。当我们提交表单时，将调用`login()`方法。它首先检查所有字段是否填写正确，然后使用凭据向`/api/auth/login`路由发出HTTP请求，以查看我们是否可以登录。
- en: The form also has a `Register.vue` file to go to the **Register** page so that
    we can register for an account and join the chat rooms.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表单还有一个`Register.vue`文件，用于转到**注册**页面，以便我们可以注册账户并加入聊天室。
- en: 'The last page that we have to create is a page for housing the registration
    form. To create it, we write the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的最后一个页面是用于容纳注册表单的页面。为了创建它，我们编写以下代码：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The form has the **Name**, **Email**, **Password**, and **Confirm Password**
    fields that are all required to register an account. When we submit the form,
    we call the `register()` method. We do the checks for the fields to see whether
    they're filled out properly. The `test()` method is called on the `email` regular
    expression to check for a valid email address. If it is valid, the `test()` method
    returns `true`. Otherwise, it returns `false`. We also check whether the password
    is the same as the `confirmPassword` variable. If everything is valid, then we
    make a POST request to register for a user account.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中有**姓名**、**电子邮件**、**密码**和**确认密码**字段，所有这些字段都是注册账户所必需的。当我们提交表格时，我们调用`register()`方法。我们对字段进行检查，以查看它们是否填写正确。调用`email`正则表达式上的`test()`方法来检查有效的电子邮件地址。如果有效，则`test()`方法返回`true`。否则，它返回`false`。我们还检查密码是否与`confirmPassword`变量相同。如果一切正常，我们就会发出POST请求来注册用户账户。
- en: 'In `src/App.vue`, we replace what is there with the following code to add the
    `router-view` component so that we can see the route components from the `src/views`
    folder:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/App.vue`中，我们用以下代码替换现有内容，以添加`router-view`组件，以便我们可以从`src/views`文件夹中看到路由组件：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, in the `src/router/index.js` file, we replace what is there with the
    following code to register all the routes and also create the `Socket.io` event
    to listen with the Laravel Echo library:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`src/router/index.js`文件中，我们用以下代码替换现有内容，以注册所有路由，并使用Laravel Echo库创建`Socket.io`事件来监听：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The Laravel Echo client is used with the Socket.IO client so that we can listen
    to events broadcast from the Laravel Echo Server. The `broadcaster` property is
    set to `'socket.io'` so that we can listen to the events from the Laravel Echo
    Server. The `host` property is set to the URL of the Laravel Echo Server.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Echo客户端与Socket.IO客户端一起使用，以便我们可以监听从Laravel Echo服务器广播的事件。`broadcaster`属性设置为`'socket.io'`，以便我们可以监听来自Laravel
    Echo服务器的事件。`host`属性设置为Laravel Echo服务器的URL。
- en: Also, we have the `beforeEnter` navigation guard that we have seen in previous
    chapters for when we need to restrict a route to be available only after authentication
    is successful. We just check whether the token exists. If it exists, we call `next`
    to proceed to the next route. Otherwise, we redirect to the login page.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有`beforeEnter`导航守卫，我们在之前的章节中已经看到了，当我们需要限制路由仅在身份验证成功后才可用时。我们只需检查令牌是否存在。如果存在，我们调用`next`来继续下一个路由。否则，我们重定向到登录页面。
- en: 'Now we can run the frontend by running `npm run serve` as we do in all the
    other projects. Now we should see something like the following screenshots. The
    following screenshot has the **Chatroom** user interface:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过运行`npm run serve`来运行前端，就像我们在所有其他项目中所做的那样。现在我们应该看到类似以下屏幕截图的东西。以下屏幕截图显示了**聊天室**用户界面：
- en: '![Figure 8.2 – Screenshot of the Chatroom'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – 聊天室的屏幕截图'
- en: '](image/Figure_8.2_B14405.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.2_B14405.jpg)'
- en: Figure 8.2 – Screenshot of the Chatroom
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 聊天室的屏幕截图
- en: 'The following screenshot is the Laravel Echo Server working. We should see
    the name of the event that is broadcast and the channel that it is sent through:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图是Laravel Echo服务器的工作情况。我们应该看到广播的事件名称以及发送的频道：
- en: '![Figure 8.3 – The output from Redis when chat events are sent to the frontend'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 当聊天事件发送到前端时，Redis的输出'
- en: '](image/Figure_8.3_B14405.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.3_B14405.jpg)'
- en: Figure 8.3 – The output from Redis when chat events are sent to the frontend
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 当聊天事件发送到前端时，Redis的输出
- en: 'The following screenshot is the log of the event of the queue:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图是队列事件的日志：
- en: '![Figure 8.4 – Output of Laravel events'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 - Laravel事件的输出'
- en: '](image/Figure_8.4_B14405.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.4_B14405.jpg)'
- en: Figure 8.4 – Output of Laravel events
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - Laravel事件的输出
- en: We started the queue earlier by running `php artisan queue:listen` in the `backend`
    folder, which is the folder with the Laravel project.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`backend`文件夹中运行`php artisan queue:listen`来启动队列，该文件夹是Laravel项目所在的文件夹。
- en: Now that we have the chat app's frontend working, we have created a simple chat
    system with Laravel and Vue.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让聊天应用的前端工作了，我们使用Laravel和Vue创建了一个简单的聊天系统。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to build a chat app with Laravel and Vue.
    We built our backend with Laravel and we added controllers to receive requests.
    And we used the queue system built into Laravel to send data to the frontend.
    We also added JSON web token authentication into our Laravel app.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何使用Laravel和Vue构建聊天应用。我们用Laravel构建了后端，并添加了控制器来接收请求。我们还使用了Laravel内置的队列系统将数据发送到前端。我们还在我们的Laravel应用中添加了JSON
    Web Token身份验证。
- en: On the frontend, we used the Socket.IO client to listen to events sent from
    the Laravel Echo Server, which gets its data from Laravel via Redis.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端，我们使用Socket.IO客户端来监听从Laravel Echo服务器发送的事件，该服务器通过Redis从Laravel获取数据。
- en: Now that we have gone through Vue 3 projects with various levels of difficulty,
    we can adapt what we learned here to real-life situations. Real-life Vue apps
    will almost always make HTTP requests to a server. The Axios library makes this
    easy. Some apps also communicate in real time with the server like the chat app
    in this chapter.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过Vue 3项目的各种难度，可以将我们在这里学到的东西应用到现实生活中。现实生活中的Vue应用几乎总是会向服务器发出HTTP请求。Axios库使这变得容易。一些应用还会与服务器实时通信，就像本章中的聊天应用一样。
- en: The only difference is that in real-life apps, there would be checks to see
    whether the user is authenticated and authorized to send the data to the server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别在于，在现实生活中的应用中，会有检查来查看用户是否经过身份验证并且被授权将数据发送到服务器。
