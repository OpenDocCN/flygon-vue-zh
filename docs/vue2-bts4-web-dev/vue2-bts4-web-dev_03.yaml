- en: Chapter 4. Let It Pomodoro!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。让它成为番茄钟！
- en: 'The previous chapter ended with a nice set of mockups for the *ProFitOro* application.
    We have previously defined what the application should do; we have also determined
    an average user profile, and we are ready to implement it. In this chapter, we
    will finally start coding. So, in this chapter, we will do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章以一组*ProFitOro*应用程序的模拟图结束。我们之前已经定义了应用程序应该做什么；我们还确定了一个平均用户配置文件，并且准备好实现它。在这一章中，我们将最终开始编码。因此，在这一章中，我们将做以下事情：
- en: Scaffold *ProFitOro* using vue-cli with the `webpack` template
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`webpack`模板使用vue-cli搭建*ProFitOro*
- en: Define all the needed application's components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义所有需要的应用程序组件
- en: Create placeholders for all the components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有组件创建占位符
- en: Implement a component that will be responsible for rendering the Pomodoro timer
    using Vue.js and Bootstrap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个组件，负责使用Vue.js和Bootstrap渲染番茄钟计时器
- en: Revisit the basics of trigonometric functions (you were not expecting that,
    right?)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视三角函数的基础知识（你没想到会有这个吧？）
- en: Scaffolding the application
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序的骨架
- en: Before everything, let's make sure that we are on the same page, at least regarding
    the node version. The version of Node.js I'm using is *6.11.1*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在一切之前，让我们确保我们至少在节点版本上是一致的。我使用的Node.js版本是*6.11.1*。
- en: 'Let''s start by creating a skeleton for our application. We will use vue-cli
    with the `webpack` template. If you don''t remember what **vue-cli** is about
    and where it comes from, check the official Vue documentation in this regard at
    [https://github.com/vuejs/vue-cli](https://github.com/vuejs/vue-cli). If for some
    reason you still haven''t installed it, proceed with its installation:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为我们的应用程序创建一个骨架开始。我们将使用`webpack`模板的vue-cli。如果你不记得**vue-cli**是什么以及它来自哪里，请查看官方Vue文档，网址为[https://github.com/vuejs/vue-cli](https://github.com/vuejs/vue-cli)。如果由于某种原因你还没有安装它，请继续安装：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s bootstrap our application. I''m sure you remember that, in order
    to initialize the application with `vue-cli,` you must run the `vue init` command
    followed by the name of the template to be used and the name of the project itself.
    We are going to use the `webpack` template, and our application''s name is `profitoro`.
    So, let''s initialize it:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们引导我们的应用程序。我相信你记得，为了使用`vue-cli`初始化应用程序，你必须运行`vue init`命令，后面跟着要使用的模板名称和项目本身的名称。我们将使用`webpack`模板，我们的应用程序名称是`profitoro`。所以，让我们初始化它：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'During the initialization process you will be asked some questions. Just keep
    hitting *Enter* to answer the default `Yes` to all of them; `Yes` because for
    this application we will need everything: linters, vue-router, unit testing, end-to-end
    testing, everything. This is gonna be huge!'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化过程中，会有一些问题需要回答。只需一直按*Enter*键回答默认的`Yes`即可；因为对于这个应用程序，我们需要一切：代码检查、vue-router、单元测试、端到端测试，全部都需要。这将会很庞大！
- en: 'Your console output should look nearly the same as mine:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你的控制台输出应该几乎和我的一样：
- en: '![Scaffolding the application](../images/00062.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![创建应用程序的骨架](../images/00062.jpeg)'
- en: Console output on application's initialization
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序初始化时的控制台输出
- en: 'Now, run `npm install` inside the newly created `profitoro` directory:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在新创建的`profitoro`目录中运行`npm install`：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s install the `sass` loader because we are going to use the `sass` preprocessor
    to style our application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装`sass`加载器，因为我们将使用`sass`预处理器来为我们的应用程序添加样式：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we are ready to run it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备运行它：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your new Vue application is ready to be worked on. In order to have a clean
    playground for our ProFitOro, remove everything related to the `Hello` component
    that are installed, along with the default installation process. As an alternative,
    just open the code files of [Chapter 4](part0036_split_000.html#12AK81-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 4. Let It Pomodoro!"), *Let it Pomodoro!* and get the boilerplate code
    from the `chapter4/1/profitoro` folder.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新Vue应用程序已准备就绪。为了让我们的ProFitOro有一个干净的工作环境，删除与默认安装过程一起安装的`Hello`组件相关的一切。作为替代方案，只需打开[第4章](part0036_split_000.html#12AK81-449ee41b57ea4c048225480b41c8dbe3
    "第4章。让它番茄钟！") *让它番茄钟！*的代码文件，并从`chapter4/1/profitoro`文件夹中获取样板代码。
- en: Defining ProFitOro components
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义ProFitOro组件
- en: Our application consists of two main screens.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序由两个主要屏幕组成。
- en: 'One of the screens is the so-called *Landing page*; this page consists of the
    following parts:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个屏幕是所谓的*登陆页面*；该页面由以下部分组成：
- en: A logo
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标志
- en: A tagline
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标语
- en: An authentication section
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个认证部分
- en: A link to the application to be used without being registered
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可供未注册用户使用的应用程序链接
- en: 'Schematically, this is how our components are positioned on the screen:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表上看，这是我们组件在屏幕上的位置：
- en: '![Defining ProFitOro components](../images/00063.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![定义ProFitOro组件](../images/00063.jpeg)'
- en: Landing page that contains logo, tagline, authentication section, and a link
    to the application
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 包含标志、标语、认证部分和应用程序链接的登陆页面
- en: 'The second screen is the main application screen. This screen contains three
    parts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个屏幕是主应用程序屏幕。该屏幕包含三个部分：
- en: A header
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个页眉
- en: A footer
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个页脚
- en: The content
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容
- en: 'The content part contains the Pomodoro timer. If the user is authenticated,
    it will contain settings, workouts, and statistics as well:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 内容部分包含番茄钟计时器。如果用户已经认证，它将包含设置、锻炼和统计信息：
- en: '![Defining ProFitOro components](../images/00064.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![定义ProFitOro组件](../images/00064.jpeg)'
- en: Main application's screen that contains header, footer, and content
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 包含页眉、页脚和内容的主应用程序屏幕
- en: Let's create a folder called `components` and subfolders called `main`, `landing,`
    and `common` for the corresponding sub-components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`components`的文件夹，以及名为`main`、`landing`和`common`的子文件夹，用于相应的子组件。
- en: Components for the landing and main pages will reside in the `components` folder;
    the remaining 11 components will be distributed between the respective subfolders.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 登陆页面和主页面的组件将存放在`components`文件夹中；其余的11个组件将分布在相应的子文件夹中。
- en: 'For each defined component file, add the `template`, `script`, and `style`
    sections. Add the `lang="sass"` attribute to the `style` tag because, as I already
    mentioned, we are going to use the `sass` preprocessor to style our components.
    So, for example, `HeaderComponent.vue` will look as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个定义的组件文件，添加`template`、`script`和`style`部分。在`style`标签中添加`lang="sass"`属性，因为正如我之前提到的，我们将使用`sass`预处理器来为我们的组件添加样式。因此，例如，`HeaderComponent.vue`将如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As a result, we have 13 placeholders for our components ready to be filled
    with the necessary data. These components are going to be used and reused. This
    is because Vue components are *re-usable components*, and that is why they are
    so powerful. During the development process, we will inevitably add more components
    and subcomponents, but here is our base:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有13个准备好填充必要数据的组件占位符。这些组件将被使用和重复使用。这是因为Vue组件是*可重用组件*，这就是它们如此强大的原因。在开发过程中，我们将不可避免地添加更多组件和子组件，但这是我们的基础：
- en: '![Defining ProFitOro components](../images/00065.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![定义ProFitOro组件](../images/00065.jpeg)'
- en: 13 base components for ProFitOro
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ProFitOro的13个基础组件
- en: Check our bootstrapped components in the `chapter4/2/profitoro` folder.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们在`chapter4/2/profitoro`文件夹中的基础组件。
- en: 'Let''s also prepare our `LandingPage` and `MainContent` components by filling
    them with the needed subcomponents. Before that, add an `index.js` file to every
    subfolder and export the corresponding subfolder''s content in it. This will enable
    an easier import afterwards. Thus, start with the folder `common` and add `index.js`
    file with the following content:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也通过填充所需的子组件来准备我们的`LandingPage`和`MainContent`组件。在此之前，为每个子文件夹添加一个`index.js`文件，并在其中导出相应子文件夹的内容。这将使之后的导入更容易。因此，从`common`文件夹开始，并添加以下内容的`index.js`文件：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Repeat the same operation for the folders `sections`, `main`, and `landing`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对`sections`，`main`和`landing`文件夹重复相同的操作。
- en: 'Now we can compose our landing page and main content components. Let''s start
    with `LandingPage.vue`. This component consists of a logo, an authentication section,
    a link to the app, and a tagline. Import all these components, export them to
    the `components` object, and use them in the `template`! The fact that we have
    exported these components in the `index.js` file allows us to import them as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以组合我们的登陆页面和主要内容组件。让我们从`LandingPage.vue`开始。这个组件包括一个标志，一个认证部分，一个指向应用程序的链接和一个标语。导入所有这些组件，将它们导出到`components`对象中，并在`template`中使用它们！我们在`index.js`文件中导出这些组件的事实使我们可以像下面这样导入它们：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can use these imported components in the `components` object of the
    `LandingPage` component. By the way, have you ever seen so many words *component*
    in the same phrase? "Component, component, component" and the exported object
    looks as the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`LandingPage`组件的`components`对象中使用这些导入的组件。顺便说一句，你有没有见过同一个短语中有这么多*组件*这个词？"组件，组件，组件"，导出的对象看起来如下：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After being exported within the `components` object, all these components can
    be used inside the template. Note that everything that is **CamelCased** will
    become **KebabCased** inside the template. So, our `GoToAppLink` will look like
    `go-to-app-link`. Thus, our components inside the template will look as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`对象中导出后，所有这些组件都可以在模板中使用。请注意，所有**驼峰命名**的内容在模板中都会变成**短横线命名**。因此，我们的`GoToAppLink`看起来会像`go-to-app-link`。因此，我们模板中的组件将如下所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Hence, our whole `LandingPage` component will have the following code for now:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们整个`LandingPage`组件现在将有以下代码：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s tell `App.vue` to render this component:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们告诉`App.vue`来渲染这个组件：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Check the page. Can you see your components? I''m sure, you can:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 检查页面。你能看到你的组件吗？我相信你可以：
- en: '![Defining ProFitOro components](../images/00066.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![定义ProFitOro组件](../images/00066.jpeg)'
- en: LandingPage component
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: LandingPage组件
- en: Now, we *only* have to implement the corresponding components and our landing
    page is ready!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们*只需*实现相应的组件，我们的登陆页面就准备好了！
- en: Exercise
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Do the same for the `MainContent` component—import and export all necessary
    subcomponents and add them to the template. After that, call the `MainContent`
    component in the `App.vue,` just like we just did with the `LandingPage` component.
    If in doubt, check the code in the `chapter4/3/profitoro` folder.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`MainContent`组件也要做同样的操作——导入和导出所有必要的子组件，并将它们添加到模板中。之后，在`App.vue`中调用`MainContent`组件，就像我们刚刚在`LandingPage`组件中所做的那样。如果有疑问，请检查`chapter4/3/profitoro`文件夹中的代码。
- en: Implementing the Pomodoro timer
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现番茄钟计时器
- en: One of the most important components of our application is, without any doubt,
    the Pomodoro timer. It performs the main functionality of the application. So,
    it might be a good idea to implement it in the first place.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中最重要的组件之一，毫无疑问，就是番茄钟计时器。它执行应用程序的主要功能。因此，首先实现它可能是一个好主意。
- en: 'I am thinking of some kind of a circular timer. Something like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我在想一种圆形计时器。类似这样的：
- en: '![Implementing the Pomodoro timer](../images/00067.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![实现番茄钟计时器](../images/00067.jpeg)'
- en: Circular timer to be implemented as a Pomodoro timer
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形计时器将被实现为番茄钟
- en: 'As time passes, the highlighted sector will move counterclockwise and the time
    will count down as well. To implement this kind of structure, I am thinking of
    three components:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，突出显示的扇形将逆时针移动，时间也将倒计时。为了实现这种结构，我考虑了三个组件：
- en: '*SvgCircleSector*: This component will just receive an angle as a property
    and color the corresponding sector of the SVG circle.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SvgCircleSector*：此组件将只接收一个角度作为属性，并着色SVG圆的相应扇形。'
- en: '*CountDownTimer*: This component will receive the number of seconds to countdown,
    implement the timer and calculate the angle to pass to the `SvgCircularComponent`
    on each timer update.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CountDownTimer*：此组件将接收要倒计时的秒数，实现计时器并在每次计时器更新时计算要传递给`SvgCircularComponent`的角度。'
- en: '*PomodoroTimer*: We have already bootstrapped this component. This component
    will be responsible to call the `CountDownTimer` component with the initial time
    and update it to the corresponding number of seconds depending on the current
    working Pomodoro or break interval.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PomodoroTimer*：我们已经引导了这个组件。此组件将负责使用初始时间调用`CountDownTimer`组件，并根据当前工作的番茄钟或休息间隔更新到相应的秒数。'
- en: SVG and trigonometry
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SVG和三角函数
- en: 'Let''s start by defining our `SvgCircleSector` component. This component will
    receive `angle` and `text` as properties and draw an SVG circle with a highlighted
    sector of a given angle. Create a folder called `timer` inside the `components/main/sections`
    folder and then create an `SvgCircleSector.vue` file in it. Define the needed
    sections for `template`, `script,` and `style`. You can also export `props` with
    the `angle` and `text` properties that this component will receive from its parent:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义我们的`SvgCircleSector`组件。这个组件将接收`angle`和`text`作为属性，并绘制一个具有给定角度突出显示扇形的SVG圆。在`components/main/sections`文件夹内创建一个名为`timer`的文件夹，然后在其中创建一个`SvgCircleSector.vue`文件。定义`template`、`script`和`style`所需的部分。您还可以导出`props`，其中包括此组件将从其父级接收的`angle`和`text`属性：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, how do we draw a circle using the SVG and by highlighting its sector? First
    of all, let''s draw two circles: one inside the other. Let''s make the bigger
    one of `100px` radius and the smaller one of `90px` radius. Essentially, we have
    to provide the center, *x* and *y* coordinates, the radius (`r`), and the `fill`
    attributes. Check the documentation regarding the circles in SVG at [https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle).
    We will end up with something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用SVG绘制圆并突出显示其扇形？首先，让我们绘制两个圆：一个在另一个内部。让我们将较大的圆半径设为`100px`，较小的圆半径设为`90px`。基本上，我们必须提供中心、*x*和*y*坐标、半径（`r`）和`fill`属性。查看SVG中关于圆的文档，网址为[https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle)。我们最终会得到类似于这样的东西：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Thus, we''ve obtained our two circles, one inside the other:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了两个圆，一个在另一个内部。
- en: '![SVG and trigonometry](../images/00068.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![SVG和三角函数](../images/00068.jpeg)'
- en: Two circles drawn with the SVG circle element
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SVG圆元素绘制的两个圆
- en: Now, in order to draw a circle's highlighted sector, we will use the *path*
    SVG element ([https://developer.mozilla.org/en-US/docs/Web/SVG/Element/path](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/path)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了绘制圆的突出显示扇形，我们将使用*path* SVG元素（[https://developer.mozilla.org/en-US/docs/Web/SVG/Element/path](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/path)）。
- en: 'With the SVG path element, you are able to draw whatever you want. Its main
    attribute, called `d`, is basically a way to program your path using, let''s say,
    the SVG domain-specific language. For example, this is how to draw a triangle
    inside our circles:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SVG路径元素，您可以绘制任何您想要的东西。它的主要属性称为`d`，基本上是一种使用SVG特定领域语言编程路径的方式。例如，这是如何在我们的圆内绘制一个三角形：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What do these codes stand for? `M` means *move*, `L` means *line*, `V` means
    *vertical line*, `H` means *horizontal line*, and `z` means *stop the path here*.
    So, we tell our path to first move to `100`,`100` (the circle center), then to
    draw a vertical line until it reaches the `0` point of the *y* axis, then to draw
    a line to the `0`, `100` *x*,*y* coordinates, then to draw a horizontal line until
    it reaches the `100` *x* coordinate, and then to stop. Our two-dimension coordinates
    area is composed of the *x* and *y* axes, where *x* starts at `0` and goes up
    until `200` from the left to the right and *y* starts at `0` and goes up until
    `200` from top to bottom.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码代表什么？ `M`代表*移动*，`L`代表*线*，`V`代表*垂直线*，`H`代表*水平线*，`z`代表*在此停止路径*。因此，我们告诉我们的路径首先移动到`100`，`100`（圆心），然后画一条垂直线直到达到*y*轴的`0`点，然后画一条线到`0`，`100`
    *x*，*y*坐标，然后画一条水平线直到达到`100` *x*坐标，然后停止。我们的二维坐标区由*x*和*y*轴组成，其中*x*从左到右从`0`开始，直到`200`，*y*从上到下从`0`开始，直到`200`。
- en: 'This is how the (*x*, *y*) coordinates look for the center and extreme points
    of our small circle coordinate system:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们小圆坐标系的中心和极端点的(*x*, *y*)坐标的样子：
- en: '![SVG and trigonometry](../images/00069.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![SVG和三角函数](../images/00069.jpeg)'
- en: Marked points represent the (x,y) coordinates of our SVG circle with the center
    at (100,100)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 标记的点代表SVG圆的(x,y)坐标，圆心在(100,100)
- en: 'Thus, if we start at (`100`,`100`), draw a vertical line to (`100`,`0`), and
    then draw a line to (`0`, `100`) and then draw a horizontal line until (`100`,`100`),
    we end up with a right triangle drawn in the upper-left quadrant of our circle:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们从(`100`,`100`)开始，画一条垂直线到(`100`,`0`)，然后画一条线到(`0`, `100`)，然后画一条水平线直到(`100`,`100`)，我们最终得到一个在我们的圆的左上象限内绘制的直角三角形：
- en: '![SVG and trigonometry](../images/00070.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![SVG和三角函数](../images/00070.jpeg)'
- en: Path draws a triangle inside the circle
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 路径在圆内绘制一个三角形
- en: 'This was just a small introduction into the path SVG element and what is achievable
    with it. However, we still need to draw a circle sector and not just a triangle.
    In order to draw a sector using path, we can use a command `A` inside a `d` attribute.
    `A` means *arc*. It''s probably the most complicated command of the path. It receives
    the following information: *rx, ry, x-axis-rotation, large-arc-flag, sweep-flag,
    x, y*.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对路径SVG元素的一个小介绍，以及它可以实现的内容。然而，我们仍然需要绘制一个圆形扇区，而不仅仅是一个三角形。为了使用路径绘制扇区，我们可以在`d`属性内部使用`A`命令。
    `A`代表*弧*。这可能是路径中最复杂的命令。它接收以下信息：*rx, ry, x-axis-rotation, large-arc-flag, sweep-flag,
    x, y*。
- en: The first four attributes in our case can always be `100`, `100`, `0`, `0`.
    If you want to understand why, check the w3c documentation regarding arc path
    attributes at [https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands](https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的情况下，前四个属性始终可以是`100`，`100`，`0`，`0`。如果您想了解原因，请查看w3c关于弧路径属性的文档[https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands](https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands)。 '
- en: 'For us, the most important attributes are the last three ones. The *sweep-flag*
    means the orientation of the *arc*; it can be either `0` or `1` for clockwise
    and counterclockwise orientation. In our case, it will always be *0* because this
    is how we want our arc to be drawn (counterclockwise). As for the last *x* and
    *y* values, these are the values that determine where the arc will stop. So, for
    example, if we want to draw the upper-left sector at *90* degrees, we would stop
    the arc at the (`0`, `100`) coordinates—*x* is `0` and *y* is `100`—thus our `d`
    attribute will look as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，最重要的属性是最后三个。*sweep-flag*表示*弧*的方向；它可以是`0`或`1`，分别表示顺时针和逆时针方向。在我们的情况下，它将始终为*0*，因为这是我们希望弧线绘制的方式（逆时针）。至于最后的*x*和*y*值，这些值决定了弧线的停止位置。因此，例如，如果我们想在*90*度处绘制左上方的扇形，我们将在(`0`,
    `100`)坐标处停止弧线—*x*为`0`，*y*为`100`—因此我们的`d`属性将如下所示：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The whole SVG element containing two circles and the sector would look like
    this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 包含两个圆和扇形的整个SVG元素将如下所示：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code produces the following result:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生了以下结果：
- en: '![SVG and trigonometry](../images/00071.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![SVG和三角函数](../images/00071.jpeg)'
- en: Sector of 90 degrees drawn with path SVG element
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用SVG元素的路径绘制的90度扇形
- en: 'We must actually define this `d` attribute as a dynamic attribute on which
    the computed value will depend. To express this, we must use `v-bind` with an
    attribute following the semicolon: `v-bind:d`, or just simply, `:d`. Let''s name
    the corresponding property path and add it to the exported object `computed` of
    our component:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上必须将这个`d`属性定义为一个动态属性，其计算值将取决于。为了表示这一点，我们必须使用`v-bind`，后面跟着一个分号和属性：`v-bind:d`，或者简单地写为`:d`。让我们给相应的属性路径命名，并将其添加到我们组件的导出对象`computed`中：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I introduced a function called `calcPath` that will determine our path string.
    For now, it returns the path that will highlight the *90* degree area.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我引入了一个名为`calcPath`的函数，它将确定我们的路径字符串。目前，它返回的路径将突出显示*90*度的区域。
- en: We are almost done. We can actually draw a segment, but what is missing is the
    ability to draw a segment for any angle. Our `SvgCircleSector` component will
    receive an angle as a property. This angle will not always equal *90* degrees.
    We should come up with a formula that will calculate the end *x* and *y* coordinates,
    given the `angle`. If you are not interested in revisiting basic trigonometry,
    just skip this part and proceed to the end of this section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。我们实际上可以绘制一个段，但缺少的是能够为任何角度绘制一个段的能力。我们的`SvgCircleSector`组件将接收一个角度作为属性。这个角度不总是等于*90*度。我们应该想出一个公式，根据`angle`来计算结束的*x*和*y*坐标。如果你对重新学习基本的三角函数不感兴趣，可以跳过这部分，继续阅读本节的结尾。
- en: 'This is how I calculate the *x*, *y* coordinates for the angles that are less
    than *180* degrees:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我计算小于180度角的*x*，*y*坐标的方法：
- en: '![SVG and trigonometry](../images/00072.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![SVG和三角函数](../images/00072.jpeg)'
- en: To calculate (x,y) for angle α, we need to calculate the a and b sides of the
    right triangle
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算角度α的(x,y)坐标，我们需要计算直角三角形的a和b边。
- en: 'From the figure, we can see that:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中我们可以看到：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Thus, we just need to calculate `a` and `b`. This is an easy task. We can calculate
    the legs of the right triangle knowing the angle and the hypotenuse. The hypotenuse
    `c` is equal to the circle''s radius (`100` in our case). The leg `a`, which is
    adjacent to the angle, is equal to `c * cosα` and the leg `b`, which is the opposite
    to the angle''s leg, is equal to `c * sin` `α`. Thus:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需要计算`a`和`b`。这是一项简单的任务。我们可以通过知道角度和斜边来计算直角三角形的两条腿。斜边`c`等于圆的半径（在我们的例子中为`100`）。与角度相邻的腿`a`等于`c
    * cosα`，而与角度相对的腿`b`等于`c * sin` `α`。因此：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the angle that is greater than *180* degrees, we have the following scheme:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大于180度的角度，我们有以下方案：
- en: '![SVG and trigonometry](../images/00073.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![SVG和三角学](../images/00073.jpeg)'
- en: For the angle greater than 180°, we also have to calculate the sides of the
    right triangle
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大于180°的角度，我们还必须计算右三角形的两边
- en: Can I tell you a secret? I am really bad at drawing these kind of schemes. I
    tried everything from sketches on paper to drawing using Gimp. Everything was
    looking really ugly. Fortunately, I have my brother *Illia* who created these
    graphics in five minutes using Sketch. Thank you very much, *Ilushka*!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以告诉你一个秘密吗？我真的很不擅长画这种图。我尝试过从纸上的草图到使用Gimp进行绘画。一切看起来都很丑。幸运的是，我有我的哥哥*伊利亚*，他用Sketch在五分钟内创建了这些图形。非常感谢你，*伊鲁什卡*！
- en: 'Back to our case. In this case, the angle of the right triangle equals `270°
    -` `α`. Our `x` equals `100 + b` and `y` equals `100 + a`. Here are the simple
    calculations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子。在这种情况下，右三角形的角度等于`270° -` `α`。我们的`x`等于`100 + b`，`y`等于`100 + a`。以下是简单的计算：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Therefore:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is exactly the same as for the angles that are less than *180* degrees!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这与小于*180*度的角度完全相同！
- en: 'This is what the JavaScript code for the calculations of the *x*, *y* coordinates
    will look like:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于计算*x*，*y*坐标的JavaScript代码：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can finally define a function that will determine a `d` string attribute
    for the path element depending on the angle. This function will call the `calcEndPoint`
    function and will return a `string` containing a final `d` attribute:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以定义一个函数，根据角度确定路径元素的`d`字符串属性。这个函数将调用`calcEndPoint`函数，并返回一个包含最终`d`属性的`string`：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To finalize our component, let''s introduce a text SVG element that will just
    render a text property passed to the component. It should also be possible to
    draw a circle without any text; therefore, let''s make this element conditional.
    We achieve it using the `v-if` directive:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的组件，让我们引入一个文本SVG元素，它将只渲染传递给组件的文本属性。也应该可以绘制一个没有任何文本的圆；因此，让我们使用`v-if`指令来实现这一点：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s also extract the styling for the big and small circles, and for the
    path and text to the `style` section. Let''s define meaningful classes so that
    our template will look as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还提取大圆和小圆的样式，以及路径和文本的样式到`style`部分。让我们定义有意义的类，这样我们的模板将如下所示：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside the `style` tags, let''s define variables for colors and use them for
    our circles. Extracting colors to the variables will help us to change them easily
    in the future, if we decide to change the color scheme of our application. Thus,
    the styling for our SVG component will look like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`style`标签内，让我们定义颜色变量，并将它们用于我们的圆。将颜色提取到变量中将有助于我们在将来轻松地更改它们，如果我们决定更改应用程序的颜色方案。因此，我们的SVG组件的样式将如下所示：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Exercise
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Until now, we were using an absolute size for our circle; it always had a radius
    of `100` pixels. Use the `viewBox` and `preserveAspectRatio` attributes applied
    to the `svg` element to make our circle responsive. Play with it; invoke this
    component in the `PomodoroTimer` component with different angle property to see
    how it works. I was able to come up with this kind of crazy page:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用绝对大小的圆；它的半径始终为`100`像素。使用`viewBox`和`preserveAspectRatio`属性应用于`svg`元素，使我们的圆响应式。试着玩一下；在`PomodoroTimer`组件中调用这个组件，使用不同的角度属性来看看它是如何工作的。我能想出这样疯狂的页面：
- en: '![Exercise](../images/00074.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![练习](../images/00074.jpeg)'
- en: Crazy page composed of lots of SVG circles with sector defined by a given angle
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由许多SVG圆组成的疯狂页面，其扇形由给定角度定义
- en: Check the code in the `chapter4/4/profitoro` folder. Particularly, pay attention
    to the `SvgCircleSector.vue` component that resides inside the `components/sections/timer`
    folder and to the `PomodoroTimer.vue` component where the circle component is
    being called plenty of times with different angle properties.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`chapter4/4/profitoro`文件夹中的代码。特别注意`components/sections/timer`文件夹中的`SvgCircleSector.vue`组件，以及调用圆形组件多次并使用不同的角度属性的`PomodoroTimer.vue`组件。
- en: Implementing the countdown timer component
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现倒计时计时器组件
- en: 'Now that we have a fully functional component that renders a circle with a
    highlighted area given an angle, we will implement the `CountDownTimer` component.
    This component will receive a number of seconds to count down as a property. It
    will contain the controls element: a set of buttons that will allow you to *start*,
    *pause* and *stop* the timer. Once the timer is started, the seconds will be counted
    down and the angle will be recalculated accordingly. This recalculated angle is
    passed to the `SvgCircleSector` component as well as the calculated text. The
    text will contain the number of minutes and seconds that are left on the timer
    to end.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全功能的组件，它可以根据给定的角度渲染一个带有高亮区域的圆形，我们将实现`CountDownTimer`组件。这个组件将接收一个倒计时的秒数作为属性。它将包含控件元素：一组按钮，允许你*开始*、*暂停*和*停止*计时器。一旦计时器启动，秒数将被倒计时，并相应地重新计算角度。这个重新计算的角度被传递给`SvgCircleSector`组件，以及计算出的文本。文本将包含计时器结束时剩余的分钟和秒数。
- en: 'To start, create a `CountDownTimer.vue` file inside the `components/main/sections/timer`
    folder. Let''s invoke the `SvgCircleSector` component from this component with
    some arbitrary values for the `angle` and `text` properties:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`components/main/sections/timer`文件夹中创建一个`CountDownTimer.vue`文件。让我们从这个组件中调用`SvgCircleSector`组件，并为`angle`和`text`属性设置一些任意值：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Open the page. It''s a bit huge. It doesn''t even fit on my screen:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面。有点太大了。甚至不适合我的屏幕：
- en: '![Implementing the countdown timer component](../images/00075.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![实现倒计时计时器组件](../images/00075.jpeg)'
- en: Our component doesn't fit on my screen
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件不适合我的屏幕
- en: 'However, if I open it on a mobile, it renders without any problem and actually
    looks nice:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我在手机上打开它，它会渲染得很好，实际上看起来很好：
- en: '![Implementing the countdown timer component](../images/00076.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![实现倒计时计时器组件](../images/00076.jpeg)'
- en: Our component actually fits quite well on the mobile screen
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件在移动屏幕上实际上非常合适
- en: It happens because our circle is responsive. If you try to resize your browser,
    you will see that the circle resizes accordingly. Its width is always *100%* of
    the browser. When the height of the page is bigger than the width (which is the
    case of the mobile browser) it looks nice, but when the width is greater than
    the height (as in the case of the desktop screen), it looks really big and ugly.
    So, our circle is responsive but not really adaptive. But we are using Bootstrap!
    Bootstrap is a big friend when it comes to responsiveness and adaptiveness.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的圆是响应式的。如果你尝试调整浏览器的大小，你会发现圆形会相应地调整大小。它的宽度始终是浏览器的*100%*。当页面的高度大于宽度时（这是移动浏览器的情况），它看起来很好，但当宽度大于高度时（如在桌面屏幕的情况下），它看起来非常大和丑陋。所以，我们的圆是响应式的，但并不是真正适应性的。但我们正在使用Bootstrap！Bootstrap在响应性和适应性方面是一个很好的朋友。
- en: Responsiveness and adaptiveness of the countdown timer using Bootstrap
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Bootstrap实现倒计时计时器的响应性和适应性
- en: In order to achieve adaptiveness to any device, we will build our layout using
    the Bootstrap grid system at [https://v4-alpha.getbootstrap.com/layout/grid/](https://v4-alpha.getbootstrap.com/layout/grid/).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现对任何设备的适应性，我们将使用Bootstrap网格系统来构建我们的布局，网址为[https://v4-alpha.getbootstrap.com/layout/grid/](https://v4-alpha.getbootstrap.com/layout/grid/)。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mind that this URL is for the alpha version, and the next version will be available
    on the official website.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此URL是用于alpha版本的，下一个版本将在官方网站上提供。
- en: 'This system is based on a twelve-column row layout. The `row` and `col` classes
    include different tiers, one for each media query. Thus, the same element can
    have different relative sizes based on the device size. The names of these classes
    are self-explanatory. The wrapping row class name is `row`. Then, each column
    may have a class called `col`. This is, for example, a simple row with four columns
    of equal size:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此系统基于十二列行布局。`row`和`col`类包括不同的层级，每个媒体查询一个。因此，相同的元素可以根据设备大小具有不同的相对大小。这些类的名称是不言自明的。包装行类名为`row`。然后，每列可能有一个名为`col`的类。例如，这是一个具有相等大小的四列的简单行：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code will produce the following result:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将产生以下结果：
- en: '![Responsiveness and adaptiveness of the countdown timer using Bootstrap](../images/00077.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap实现倒计时器的响应性和适应性](../images/00077.jpeg)'
- en: Bootstrap row with four equal-sized columns
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 具有四个相等大小列的Bootstrap行
- en: 'The class `col` can be combined with the size that you want to give to your
    column:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 类`col`可以与您要为列指定的大小相结合：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, `*` can be anything from `1` to `12` since each row can contain up to
    twelve columns. Here''s the example of a row with four columns of different sizes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`*`可以是从`1`到`12`的任何内容，因为每行最多可以包含十二列。以下是具有四个不同大小列的行的示例：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, the first column will occupy half of the row, the second will be the fourth
    part of the row, the third one is 1/6th part of the row, and the last on is 1/12th
    part of the row. Here''s what it looks like:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一列将占据一半的行，第二列将占据四分之一的行，第三列将占据六分之一的行，最后一列将占据十二分之一的行。这是它的样子：
- en: '![Responsiveness and adaptiveness of the countdown timer using Bootstrap](../images/00078.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap实现倒计时器的响应性和适应性](../images/00078.jpeg)'
- en: Bootstrap row with different-sized columns
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 具有不同大小列的Bootstrap行
- en: Don't mind the black borders; I've added them so the column width becomes more
    obvious. Bootstrap will draw your layout without any borders, unless you tell
    it to include them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在意黑色边框；我添加它们是为了使列宽更加明显。Bootstrap将在没有任何边框的情况下绘制您的布局，除非您告诉它包括它们。
- en: Bootstrap also provides a technique for offsetting columns for a given number
    of columns at [https://v4-alpha.getbootstrap.com/layout/grid/#offsetting-columns](https://v4-alpha.getbootstrap.com/layout/grid/#offsetting-columns).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap还提供了一种偏移列的技术，可以在[https://v4-alpha.getbootstrap.com/layout/grid/#offsetting-columns](https://v4-alpha.getbootstrap.com/layout/grid/#offsetting-columns)上找到。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mind that this URL is for the alpha version, and the next version will be available
    on the official website.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此URL是用于alpha版本的，下一个版本将在官方网站上提供。
- en: 'This is how, for example, we make two columns, one of which is of the size
    `6` and the other is of the size `2` with an offset of `4`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们如何制作两列，其中一列的大小为`6`，另一列的大小为`2`，偏移量为`4`：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s what it looks like:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的样子：
- en: '![Responsiveness and adaptiveness of the countdown timer using Bootstrap](../images/00079.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap实现倒计时器的响应性和适应性](../images/00079.jpeg)'
- en: Row with two columns, one of which is displayed with an offset of size 4
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 具有两列的行，其中一列显示偏移量为4。
- en: You can even play with the columns and change their order by playing with `push-*`
    and `pull-*` classes. For more information, visit [https://v4-alpha.getbootstrap.com/layout/grid/#push-and-pull](https://v4-alpha.getbootstrap.com/layout/grid/#push-and-pull).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以通过使用`push-*`和`pull-*`类来玩转列并更改它们的顺序。有关更多信息，请访问[https://v4-alpha.getbootstrap.com/layout/grid/#push-and-pull](https://v4-alpha.getbootstrap.com/layout/grid/#push-and-pull)。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mind that this URL is for the alpha version, and the next version will be available
    on the official website
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此URL是用于alpha版本的，下一个版本将在官方网站上提供
- en: 'These classes play almost the same role as the `offset-*` classes; they allow
    more flexibility for your columns. For example, if we want to render a column
    of size `3` and a column of size `9` and change their order, we will need to push
    the column of size `3` for `9` positions and pull column of size `9` for `3` positions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类几乎扮演了`offset-*`类的相同角色；它们为您的列提供了更多的灵活性。例如，如果我们想要呈现大小为`3`的列和大小为`9`的列并更改它们的顺序，我们将需要将大小为`3`的列推送到`9`的位置，并将大小为`9`的列拉到`3`的位置：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This code will produce the following layout:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将产生以下布局：
- en: '![Responsiveness and adaptiveness of the countdown timer using Bootstrap](../images/00080.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap实现倒计时计时器的响应和适应性](../images/00080.jpeg)'
- en: Changed columns order using push-* and pull-* classes
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用push-*和pull-*类更改列的顺序
- en: Try all these examples and check that, however you resize your page, the proportions
    of your layout will always be the same. This is a powerful feature of Bootstrap's
    layouts; you don't even have to bother making your layout responsive. What about
    the different devices that I mentioned in the first paragraph of this section?
    Until now, we were exploring classes called `col-*`, `offset-*`, `push-*`, and
    `pull-*`. Bootstrap also provides this set of classes for each kind of media query.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试所有这些示例，并检查无论如何调整页面大小，布局的比例都将始终相同。这是Bootstrap布局的一个强大功能；您甚至不必费心使您的布局响应。我在本节的第一段中提到的不同设备怎么样？到目前为止，我们一直在探索称为`col-*`、`offset-*`、`push-*`和`pull-*`的类。Bootstrap还为每种媒体查询提供了这组类。
- en: 'There are five types of devices in Bootstrap:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap中有五种设备类型：
- en: '| **xs** | Extra small devices | Portrait phones (<544px) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **xs** | 超小设备 | 竖屏手机（<544px） |'
- en: '| **sm** | Small devices | Landscape phones (≥544px - <768px) |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **sm** | 小设备 | 横屏手机（≥544px - <768px） |'
- en: '| **md** | Medium devices | Tablets (≥768px - <992px) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **md** | 中等设备 | 平板电脑（≥768px - <992px） |'
- en: '| **lg** | Large devices | Desktops (≥992px - <1200px) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **lg** | 大设备 | 桌面电脑（≥992px - <1200px） |'
- en: '| **xl** | Extra-large devices | Desktops (≥1200px) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **xl** | 超大设备 | 桌面电脑（≥1200px） |'
- en: 'In order to indicate the desired behavior on a given device, you just pass
    the device designation between the class name and its size. So, for example, if
    you want two columns of size `8` and `4,` respectively, to transform into two
    stacked columns on mobile, you could do something like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指示在给定设备上的期望行为，您只需在类名和其大小之间传递设备指定。因此，例如，如果您希望大小分别为`8`和`4`的两列在移动设备上转换为两个堆叠的列，您可以执行以下操作：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you open this code in the browser and try to resize the page, you will see
    that once the size is less than `544` pixels, the columns will stack:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开此代码并尝试调整页面大小，您会发现一旦大小小于`544`像素，列将堆叠：
- en: '![Responsiveness and adaptiveness of the countdown timer using Bootstrap](../images/00081.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap实现倒计时计时器的响应和适应性](../images/00081.jpeg)'
- en: Two-column layout becomes a stacked equal-sized column layout on a small screen
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 两列布局在小屏幕上变成了堆叠的等大小列布局
- en: 'So what should we do with our timer? I would say that it can occupy the whole
    width (*100%*) on small devices, 2/3 of the width on medium-width devices, become
    half of the width on large devices, and 1/3 of the width of extra-large devices.
    So, it will require the following classes:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们应该怎么处理我们的计时器？我会说它可以在小设备上占据整个宽度（*100%*），在中等宽度设备上占据宽度的2/3，在大设备上变为宽度的一半，在超大设备上为宽度的1/3。因此，它将需要以下类：
- en: '**col-sm-12** for small devices'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**col-sm-12** 用于小设备'
- en: '**col-md-8** for medium-width devices'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**col-md-8** 用于中等宽度设备'
- en: '**col-lg-6** for large devices'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**col-lg-6** 用于大设备'
- en: '**col-xl-4** for extra-large devices'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**col-xl-4** 用于超大设备'
- en: 'I also want my circle to appear in the center of the screen. For this, I will
    use the `justify-content-center` class, applied to the row:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我还希望我的圆圈出现在屏幕中央。为此，我将应用`justify-content-center`类到行中：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Open the page and try to resize it and simulate different devices, testing the
    portrait and landscape view. Our circle resizes accordingly. Check the code in
    the `chapter4/5/profitoro` folder; particularly, pay attention to the `components/CountDownTimer.vue`
    component.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面并尝试调整大小，模拟不同的设备，测试纵向和横向视图。我们的圆圈会相应地调整大小。检查`chapter4/5/profitoro`文件夹中的代码；特别注意`components/CountDownTimer.vue`组件。
- en: Countdown timer component – let's count down time!
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 倒计时计时器组件- 让我们倒计时！
- en: 'We have already achieved the responsiveness of the countdown timer component.
    Let''s finally make it a real countdown timer component. Let''s start by adding
    controls: start, pause, and stop buttons. For now, I will make them look like
    links. For this, I will use the `btn-link` class of Bootstrap at [https://v4-alpha.getbootstrap.com/components/buttons/](https://v4-alpha.getbootstrap.com/components/buttons/).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了倒计时计时器组件的响应性。让我们最终将其变成一个真正的倒计时计时器组件。让我们首先添加控件：开始、暂停和停止按钮。现在，我会让它们看起来像链接。为此，我将使用Bootstrap的`btn-link`类在[https://v4-alpha.getbootstrap.com/components/buttons/](https://v4-alpha.getbootstrap.com/components/buttons/)。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mind that this URL is for the alpha version, and the next version will be available
    on the official website.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此URL是用于alpha版本的，下一个版本将在官方网站上提供。
- en: 'I will also use the Vue''s `v-on` directive to bind a method on each button
    click at [https://vuejs.org/v2/api/#v-on](https://vuejs.org/v2/api/#v-on):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将使用Vue的`v-on`指令在每个按钮点击时绑定一个方法在[https://vuejs.org/v2/api/#v-on](https://vuejs.org/v2/api/#v-on)：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alternatively, we could simply use:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以简单地使用：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Hence, the code for buttons will look like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，按钮的代码将如下所示：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the `text-center` class to the wrapping container `div,` so the buttons
    are centrally aligned. Now, with the control buttons, our timer looks like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将`text-center`类添加到包装容器`div`中，以便按钮居中对齐。现在，有了控制按钮，我们的计时器看起来像这样：
- en: '![Countdown timer component – let''s count down time!](../images/00082.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![倒计时计时器组件- 让我们倒计时！](../images/00082.jpeg)'
- en: Countdown timer with control buttons
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 带控制按钮的倒计时计时器
- en: 'When we started discussing this component, we said that it will receive the
    time in seconds to countdown from its parent. Let''s add a property called `time`
    and let''s pass this property from the parent component:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始讨论这个组件时，我们说它将从其父组件接收以秒为单位的倒计时时间。让我们添加一个名为`time`的属性，并让我们从父组件传递这个属性：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For now, let''s export this property as a computed hard-coded property in the
    `PomodorTimer` component and bind it to the `CountDownTimer` component. Let''s
    hardcode it to `25` minutes, or `25 * 60` seconds:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个属性作为计算的硬编码属性导出到`PomodorTimer`组件中，并将其绑定到`CountDownTimer`组件。让我们将其硬编码为`25`分钟，或`25
    * 60`秒：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Ok, so our countdown component receives the time in seconds. How will it update
    the `angle` and the `text`? Since we cannot change the parent''s property (`time`),
    we need to introduce a value belonging to this component and then we will be able
    to change it inside the component and compute angle and text values based on this
    value. Let''s introduce this new value and call it `timestamp`. Put it inside
    the data function of the countdown component:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们的倒计时组件接收以秒为单位的时间。它将如何更新`角度`和`文本`？由于我们无法更改父级的属性(`时间`)，我们需要引入属于该组件的值，然后我们将能够在组件内部更改它，并根据该值计算角度和文本值。让我们引入这个新值并称之为`时间戳`。将其放在倒计时组件的数据函数中：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s now add a computed value for the `angle`. How do we calculate the angle
    based on the timestamp in seconds? If we knew the value in degrees for each second,
    then we would just multiply this value by the number of needed seconds:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`angle`添加一个计算值。我们如何根据时间戳（以秒为单位）计算角度？如果我们知道每秒的角度值，那么我们只需将该值乘以所需秒数即可：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Knowing the initial time in seconds, it''s easy to calculate the number of
    degrees for each second. Since the whole circumference has *360 degrees*, we just
    need to divide *360* by the *initial time*:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 知道初始时间（以秒为单位），很容易计算每秒的度数。由于整个周长为*360度*，我们只需将*360*除以*初始时间*即可：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Last, but not least, since our timer is a counterclockwise timer, we need to
    pass the inverse angle to the `SvgCircleSector` component, so our final computed
    value for the angle will look like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，由于我们的计时器是逆时针计时器，我们需要将逆角度传递给`SvgCircleSector`组件，因此我们的最终计算角度值将如下所示：
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Replace the hardcoded angle binding in the template by the value of the angle:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过角度的值替换模板中的硬编码角度绑定：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Play with the value of `timestamp`; try to set it from `0 * 60` to `25 * 60`.
    You will see how the highlighted area changes accordingly:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 调整`timestamp`的值；尝试将其从`0 * 60`设置为`25 * 60`。您将看到高亮区域如何相应地更改：
- en: '![Countdown timer component – let''s count down time!](../images/00083.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![倒计时计时器组件-让我们倒计时！](../images/00083.jpeg)'
- en: The circle's highlighted area changes accordingly with the given timestamp
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 圆圈的高亮区域随着给定的时间戳而相应地变化
- en: 'I''m not sure about you, but I am tired of seeing this Hello. Let''s do something
    about it. The text of the timer should display the number of minutes and seconds
    remaining until the end of the countdown time; it corresponds to the un-highlighted
    area of the timer circle. This is a pretty easy calculation. If we divide our
    timestamp by `60` and obtain the whole part of the division, we will get the current
    number of minutes. If we obtain the rest of this division, we will obtain the
    current number of seconds. The text should display minutes and seconds divided
    by the colon (`:`). So, let''s add these three computed values:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定你，但我已经厌倦了看到这个Hello。让我们做点什么。计时器的文本应显示剩余时间直到倒计时结束的分钟数和秒数；它对应于计时器圆圈的未高亮区域。这是一个非常简单的计算。如果我们将时间戳除以`60`并获得除法的整数部分，我们将得到当前分钟数。如果我们获得这个除法的余数，我们将得到当前秒数。文本应该显示分钟和秒数除以冒号（`:`）。因此，让我们添加这三个计算值：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that we are using `ES6` templates for computing our text ([https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals)).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在计算文本时使用了`ES6`模板（[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals)）。
- en: 'Finally, replace the hardcoded string `Hello` from the property binding with
    the text value:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用文本值替换属性绑定中的硬编码字符串`Hello`：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Isn't it much better now?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了吧？
- en: '![Countdown timer component – let''s count down time!](../images/00084.jpeg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![倒计时计时器组件-让我们倒计时！](../images/00084.jpeg)'
- en: The text of the timer changes according to the remaining time
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器的文本根据剩余时间而变化
- en: 'Well, the only missing thing now is to actually start the timer and make it
    countdown. We already invoked the `start`, `pause`, and `stop` methods on each
    of the corresponding button clicks. Let''s create these methods:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一缺少的是实际启动计时器并进行倒计时。我们已经在每个相应的按钮点击上调用了`start`、`pause`和`stop`方法。让我们创建这些方法：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'What should happen inside these methods? The `start` method should set an interval
    that each second will decrease the timer by one second. The `pause` method should
    pause this interval and the `stop` method should clear this interval and reset
    the timestamp. Introduce a new variable called `interval` in the data function
    of the component and add the needed methods:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法内部应该发生什么？`start`方法应该设置一个间隔，每秒减少一秒的计时器。`pause`方法应该暂停这个间隔，`stop`方法应该清除这个间隔并重置时间戳。在组件的数据函数中引入一个名为`interval`的新变量，并添加所需的方法：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: And… we are done! Open the page, click on the control buttons, play with different
    values for the initial time, and check how nicely it works! Check the code for
    the `CountDownTimer` component in the `chapter4/6/profitoro` folder.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后...我们完成了！打开页面，点击控制按钮，尝试不同的初始时间值，并检查它的工作情况！检查`chapter4/6/profitoro`文件夹中`CountDownTimer`组件的代码。
- en: Exercise
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Our countdown timer looks really nice, but it still has some problems. First
    of all, the text doesn't look that nice. When the number of minutes or seconds
    is less than `9`, it displays the corresponding text without the trailing `0`,
    for example, **5:5** for *5 minutes and 5 seconds*. This doesn't look exactly
    like time. Introduce a method, let's call it `leftpad`, that will add an extra
    `0` for this kind of cases. And please, try to not to break the internet! ([https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/](https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/))
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的倒计时器看起来很不错，但仍然存在一些问题。首先，文本看起来不太好。当分钟或秒数少于`9`时，它会显示相应的文本，而不带有尾随的`0`，例如，*5分钟5秒*显示为**5:5**。这看起来并不像时间。引入一个方法，让我们称之为`leftpad`，它将为这种情况添加一个额外的`0`。请尽量不要破坏互联网！（[https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/](https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/)）
- en: 'Another problem with our timer is that we can click on any button at any time.
    If you click a lot on the start button, the result will be unexpectedly ugly.
    Introduce three data variables—`isStarted`, `isPaused`, and `isStopped`—that will
    be toggled on each method accordingly. Bind the `disabled` class to the control
    buttons. This class should be activated based on the mentioned variable''s values.
    So, the behaviour should be the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计时器的另一个问题是我们可以随时点击任何按钮。如果你频繁点击启动按钮，结果会出乎意料地难看。引入三个数据变量——`isStarted`，`isPaused`和`isStopped`——它们将根据每个方法进行切换。将`disabled`类绑定到控制按钮。这个类应该根据提到的变量的值来激活。所以，行为应该是以下的：
- en: The start button should be disabled if the timer is already started and is not
    paused.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果计时器已经启动并且没有暂停，启动按钮应该被禁用。
- en: The pause and stop buttons should be disabled if the timer is not started. They
    should also be disabled if the timer is already paused or stopped.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果计时器没有启动，暂停和停止按钮应该被禁用。如果计时器已经暂停或停止，它们也应该被禁用。
- en: 'To bind the class conditionally, use `v-bind:className={expression}`, or simply
    the `:className={expression}` notation. For example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要有条件地绑定类，使用`v-bind:className={expression}`，或者简单地使用`:className={expression}`表示法。例如：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To check it for yourself, have a look at the `chapter4/7/profitoro` directory,
    particularly at the `components/CountDownTimer.vue` component.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要自己检查一下，请查看`chapter4/7/profitoro`目录，特别是`components/CountDownTimer.vue`组件。
- en: Pomodoro timer
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 番茄钟计时器
- en: So, we already have a fully functional countdown timer. We are more than close
    to the final purpose of our application with the countdown timer that is able
    to countdown any given amount of time. We just have to implement a Pomodoro timer
    based on it. Our Pomodoro timer has to initialize the countdown component with
    the working Pomodoro time and reset it to the resting time once Pomodoro is done.
    After the break is over, it has to reset it again to the working Pomodoro time.
    and so on. Don't forget that the break after three regular pomodoros is slightly
    bigger than the usual one.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经有了一个完全功能的倒计时计时器。我们离应用程序的最终目的——能够倒计时任何给定的时间——已经非常接近了。我们只需要基于它实现一个番茄钟计时器。我们的番茄钟计时器必须使用工作番茄钟时间初始化倒计时组件，并在番茄钟结束后将其重置为休息时间。休息结束后，它必须再次将其重置为工作番茄钟时间。依此类推。不要忘记，三个常规番茄钟后的休息时间略长于通常的休息时间。
- en: 'Let''s create a `config` file with these values so we can easily change it
    whenever we need to test the application with different timings. So, we need to
    specify the `workingPomodoro`, `shortBreak`, and `longBreak` values. Let''s also
    specify the number of working *pomodoros* until the long break. By default, it
    will be three, but in case you are a workaholic, you can specify a longer Pomodoro
    break only after *23485* regular Pomodoros (don''t do that, I still need you!).
    So, our config file is a regular `.js` file and its content looks like the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`config`文件，其中包含这些值，这样我们就可以在需要用不同的时间测试应用程序时轻松更改它。因此，我们需要指定`workingPomodoro`、`shortBreak`和`longBreak`的值。我们还需要指定到长休息之前工作的*番茄钟*数量。默认情况下，这个值将是三，但是如果你是一个工作狂，你可以在*23485*个常规番茄钟后指定更长的番茄钟休息（不要这样做，我还需要你！）。因此，我们的配置文件是一个常规的`.js`文件，其内容如下：
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Import this file in the `PomodoroTimer` component. Let''s also define the essential
    data for this component. So, the Pomodoro timer has three main states; it is either
    in its working state, or it''s on a short break, or it''s on a long break. It
    should also count the amount of Pomodoros until the long break. So, our data for
    the `PomodoroTimer` component will look like the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PomodoroTimer`组件中导入这个文件。让我们还为这个组件定义必要的数据。因此，番茄钟计时器有三种主要状态；它要么处于工作状态，要么处于短休息状态，要么处于长休息状态。它还应该计算到长休息之前的番茄钟数量。因此，我们的`PomodoroTimer`组件的数据将如下所示：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can compute the value of `time` based on the current state of the Pomodoro
    timer. For this, we just need to multiply the number of minutes corresponding
    to the current interval by `60`. We need to define which interval in minutes is
    the correct one and base our decision on the current state of the application.
    Here it comes, our nice `if-else` construction for the computed value:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以根据番茄钟计时器的当前状态计算`time`的值。为此，我们只需要将当前间隔对应的分钟数乘以`60`。我们需要定义哪个间隔是正确的分钟数，并根据应用程序的当前状态做出决定。下面是我们漂亮的计算值的`if-else`构造：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is more than clear, right? Now, we must write the code that will toggle
    between working Pomodoro, short break, and long break. Let''s call this method
    `togglePomodoro`. What should this method do? First of all, the `isWorking` state
    should be set to `true` or `false` depending on the previous value (`this.isWorking
    = !this.isWorking`). Then, we should reset both `isShortBreak` and `isLongBreak`
    values. Then we have to check whether the state of `isWorking` is `false`, which
    means that we are currently on a break. If yes, we have to increase the number
    of pomodoros performed until that moment. And then we need to set one of the breaking
    states to `true` depending on the number of pomodoros. Here''s the method:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这比较清楚，对吧？现在，我们必须编写代码，以在工作的番茄钟、短休息和长休息之间切换。让我们称这个方法为`togglePomodoro`。这个方法应该做什么？首先，`isWorking`状态应该根据先前的值设置为`true`或`false`（`this.isWorking
    = !this.isWorking`）。然后，我们应该重置`isShortBreak`和`isLongBreak`的值。然后我们必须检查`isWorking`的状态是否为`false`，这意味着我们目前正在休息。如果是的话，我们必须增加到目前为止完成的番茄数量。然后根据番茄数量，我们需要将其中一个休息状态设置为`true`。这是这个方法：
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we just have to find a way to call this method. When should it be called?
    It''s clear that this method should be called each time that the countdown timer
    reaches its zero, but how can we be aware of that? Somehow, the countdown timer
    component has to communicate to its parent that it has stopped at zero. Luckily
    for us, with Vue.js, components can emit events using the `this.$emit` method.
    So, we will trigger this event from the countdown component and bind its handler
    to the component invoked from the `PomodoroTimer`. Let''s call this event `finished`.
    Open the `CountDownTimer.vue` component and find a place where we check that the
    decreased timestamp has reached its zero value. At this point, we have to shout
    *Hey, parent! I have finished my task! Give me another one*. This is a simple
    code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要找到一种调用这个方法的方式。它应该在什么时候被调用？很明显，每当倒计时器达到零时，应该调用这个方法，但我们如何能意识到这一点呢？某种程度上，倒计时器组件必须向其父组件通知它已经停在零上。幸运的是，使用Vue.js，组件可以使用`this.$emit`方法发出事件。因此，我们将从倒计时组件触发此事件，并将其处理程序绑定到从`PomodoroTimer`调用的组件上。让我们称这个事件为`finished`。打开`CountDownTimer.vue`组件，并找到一个地方，我们在那里检查减少的时间戳是否达到了零值。在这一点上，我们必须大喊“嘿，父组件！我完成了我的任务！给我另一个”。这是一个简单的代码：
- en: '[PRE54]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Binding this event is more than simple. It''s like any other event; just use
    `@` followed by the event name attached to the component inside the template of
    `PomodoroTimer`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定这个事件非常简单。就像任何其他事件一样；只需在`PomodoroTimer`模板内使用`@`后跟附加到组件的事件名称。
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Check the application's page now. Try to play with the timing values in the
    config file. Check that everything works.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查应用程序的页面。尝试在配置文件中玩弄时间值。检查一切是否正常工作。
- en: Exercise
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锻炼
- en: Have you already started to use your fresh Pomodoro timer for your daily routine?
    If yes, I am sure that while the timer is doing its job, you are very happily
    navigating other tabs and doing other things. Have you noticed that the time is
    taking longer than it should? Our browsers are really clever; in order to not
    screw up with your CPU, they stay pretty idle in the inactive tabs. This actually
    makes perfect sense. Why should inactive tabs perform complex calculations or
    run some crazy animations based on `setIntervals` and `setTimeout` functions if
    you are not looking at them? While it makes perfect sense in terms of performance,
    it doesn't make much sense for our application.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经开始使用新的番茄钟来安排你的日常生活了吗？如果是的话，我相信当计时器在工作时，你会非常愉快地浏览其他标签并做其他事情。你有没有注意到时间比应该的时间长？我们的浏览器真的很聪明；为了不影响你的CPU，它们在非活动的标签中保持相当空闲。这实际上是完全合理的。如果你不看它们，为什么非活动的标签要执行复杂的计算或者基于`setIntervals`和`setTimeout`函数运行一些疯狂的动画呢？虽然从性能方面来说这是完全合理的，但对我们的应用程序来说并没有太多意义。
- en: 'It should countdown 25 minutes no matter what. For this exercise, improve our
    countdown timer so that it always counts down the exact number of seconds passed
    to it, even if it is open in the hidden or inactive browser tab. Google it; you
    will see a whole internet of *Stackoverflow* results:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 不管怎样，它都应该倒数25分钟。为了这个练习，改进我们的倒计时器，使其始终倒计时准确的秒数，即使它在隐藏或非活动的浏览器标签中打开。谷歌一下，你会看到整个互联网上关于*Stackoverflow*的结果：
- en: '![Exercise](../images/00085.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![锻炼](../images/00085.jpeg)'
- en: The internet full of the results googling the strange behaviour of setInerval
    in the inactive tabs
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在非活动标签中使用setInerval的奇怪行为充斥着互联网
- en: Another thing that I would like you to do for this exercise is to add a watcher
    for the `time` property in the `CountDownTimer` component that will restart the
    timer. This will allow us to be more precise with the timer resets whenever the
    time is changed in the `PomodoroTimer` component. Check the Vue documentation
    in this regard, at [https://vuejs.org/v2/guide/computed.html#Watchers](https://vuejs.org/v2/guide/computed.html#Watchers).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我还希望你在这个练习中为`CountDownTimer`组件的`time`属性添加一个监视器，以便重新启动计时器。这将使我们能够更精确地在`PomodoroTimer`组件中更改时间时重置计时器。在这方面，请查看Vue文档，网址为[https://vuejs.org/v2/guide/computed.html#Watchers](https://vuejs.org/v2/guide/computed.html#Watchers)。
- en: For both tasks, take a look at the `chapter4/8/profitoro` application's folder
    to check for yourself. The only component where the changes are applied is the
    `CountDownTimer.vue` component. Pay attention to the `setInterval` function and
    how the `timestamp` is updated.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个任务，请查看`chapter4/8/profitoro`应用程序文件夹，自行检查。唯一应用更改的组件是`CountDownTimer.vue`组件。注意`setInterval`函数以及如何更新`timestamp`。
- en: Introducing workouts
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入锻炼
- en: I have been so enthusiastic writing this chapter, calculating sine, cosine,
    drawing SVG, implementing a timer, and taking care of the inactive tabs and stuff
    that I almost forgot to do my workout! I like planks and pushups, what about you?
    By the way, haven't you also forgotten that workouts are a part of our application?
    During the breaks, we are supposed to do simple exercises and not just check our
    social networks!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我写这一章时非常热情，计算正弦、余弦，绘制SVG，实现计时器，并照顾非活动标签等等，以至于我几乎忘记了做锻炼！我喜欢做平板支撑和俯卧撑，你呢？顺便说一句，你难道也忘了锻炼是我们应用程序的一部分吗？在休息时间，我们应该做简单的锻炼，而不仅仅是查看社交网络！
- en: 'We will implement full-fledged workouts and their management in the next chapters;
    for now, let''s just leave a nice placeholder for the workout and hard code one
    exercise in this placeholder (I vote for pushups since the book is mine, but you
    can add the workout or exercise of your own preference). Open the `PomodoroTimer.vue`
    component and wrap up a countdown component into a `div` with a class `row`. We
    will make this row contain two columns, one of which will be the countdown timer,
    and the other is a conditionally rendered element containing a workout. Why conditionally?
    Because we only need this element displayed during the Pomodoro breaks. We will
    use the `v-show` directive so that the containing element will always be present,
    and only the `display` property will change. The markup will thus look like the
    following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中实现完整的锻炼和管理；现在，让我们为锻炼留下一个漂亮的占位符，并在这个占位符中硬编码一个锻炼（我投票支持俯卧撑，因为这本书是我的，但你可以添加你自己喜欢的锻炼或者锻炼）。打开`PomodoroTimer.vue`组件，并将倒计时组件包装在一个带有`row`类的`div`中。我们将使这一行包含两列，其中一列将是倒计时器，另一列是一个有条件渲染的包含锻炼的元素。为什么有条件呢？因为我们只需要在番茄钟休息时显示这个元素。我们将使用`v-show`指令，以便包含元素始终存在，只有`display`属性会改变。因此，标记看起来像下面这样：
- en: '[PRE56]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note `col-sm-4` and `col-sm-8`. Again, I want the columns to look different
    on bigger devices and stacked on small ones!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`col-sm-4`和`col-sm-8`。再次强调，我希望在更大的设备上列看起来不同，在小设备上堆叠！
- en: What element should we use to display our workout? For some reason, I like Bootstrap's
    `jumbotrons` ([https://v4-alpha.getbootstrap.com/components/jumbotron/](https://v4-alpha.getbootstrap.com/components/jumbotron/))
    very much, so I will use a `jumbotron` containing a header element for the workout's
    title, the lead element for the workout's description, and an image element to
    display the workout's image.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用什么元素来显示我们的锻炼？出于某种原因，我非常喜欢Bootstrap的`jumbotrons`（[https://v4-alpha.getbootstrap.com/components/jumbotron/](https://v4-alpha.getbootstrap.com/components/jumbotron/)），所以我将使用一个包含锻炼标题的标题元素，锻炼描述的引导元素，以及一个图像元素来显示锻炼图像的`jumbotron`。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mind that the URL of Bootstrap's Jumbotron component is for the alpha version,
    and the next version will be available on the official website
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Bootstrap的Jumbotron组件的URL是alpha版本的，下一个版本将在官方网站上提供
- en: 'So, my markup structure for displaying the workout looks like the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我用于显示锻炼的标记结构如下：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Feel free to add another nice workout for you in this section, so you are able
    to exercise until you finish reading the book. Check the code for this section
    in the `section4/9/profitoro` folder.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，随意添加另一个适合你的好锻炼，这样你就能在读完这本书之前锻炼了。检查`section4/9/profitoro`文件夹中的此部分的代码。
- en: 'This is how my Pomodoro looks on my laptop''s screen:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的笔记本电脑屏幕上的番茄钟的样子：
- en: '![Introducing workouts](../images/00086.jpeg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![介绍锻炼](../images/00086.jpeg)'
- en: Pomodoro timer on the laptop's screen
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本电脑屏幕上的番茄钟
- en: 'This is how it looks on the mobile screen:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它在手机屏幕上的样子：
- en: '![Introducing workouts](../images/00087.jpeg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![介绍锻炼](../images/00087.jpeg)'
- en: Pomodoro timer on the mobile screen
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 手机屏幕上的番茄钟
- en: It's not that beautiful, of course, but it's responsive and adaptive, and we
    haven't done any CSS black magic for it!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它并不那么美观，但它是响应式和自适应的，我们没有为它做任何CSS黑魔法！
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have done a lot of things. We have implemented the main
    functionality of our Pomodoro timer, and now it is fully functional, configurable,
    usable, and responsive. We bootstrapped our ProFitOro application, separated it
    into components, created a skeleton for each of the defined components, and fully
    implemented one of them. We even revisited some trigonometry, because math is
    everywhere. We implemented our timer and we made it work, even on the hidden and
    inactive tabs. We made the application responsive and adaptive to different device
    sizes using the powerful Bootstrap layout classes. Our application is functional,
    but it is far from beautiful. Don't mind these shades of gray though; let's stick
    to them for now. In the end of the book, you will get your beautiful ProFitOro
    styles, I promise you!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们做了很多事情。我们实现了我们的番茄钟计时器的主要功能，现在它是完全功能的、可配置的、可用的和响应的。我们启动了我们的ProFitOro应用程序，将其分成组件，为每个定义的组件创建了一个骨架，并完全实现了其中的一个。我们甚至重新学习了一些三角学，因为数学无处不在。我们实现了我们的计时器，并让它在隐藏和非活动标签上也能工作。我们使用强大的Bootstrap布局类使应用程序对不同设备尺寸具有响应性和适应性。我们的应用程序是功能性的，但离美观还有很大差距。不过，暂时不要在意这些灰色调；让我们暂时坚持它们。在本书的最后，你将得到你漂亮的ProFitOro样式，我向你保证！
- en: 'We are ready to continue our journey in the world of technology. In the next
    chapter, we will learn how to configure our Pomodoro and how to store the configuration
    and usage statistics using Firebase. Thus, in the next chapter we will:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备继续在技术世界中的旅程。在下一章中，我们将学习如何配置我们的番茄钟，以及如何使用Firebase存储配置和使用统计数据。因此，在下一章中我们将：
- en: Get back to Vuex centralized state management architecture and combine it with
    the Google Firebase storage system to store the application's critical data, such
    as configuration and statistics
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回到Vuex集中式状态管理架构，并将其与Google Firebase存储系统结合起来，以存储应用程序的关键数据，如配置和统计信息。
- en: Implement the configuration of ProFitOro
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现ProFitOro的配置
- en: Implement the storing, retrieval, and displaying of ProFitOro usage statistics
    data
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现ProFitOro使用统计数据的存储、检索和显示
