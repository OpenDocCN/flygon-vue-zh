- en: Chapter 9. Test Test and Test
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。测试测试和测试
- en: 'In the previous chapter, we implemented the workout management page. We learned
    how to use the Google Firebase data storage mechanism to store static files and
    we again used the real-time database to store the workout objects. We used Bootstrap
    to build a responsive layout for the workout'' management page and we learned
    how to use Bootstrap''s modal component to display each individual workout in
    a nice popup. Now we have a totally responsible application. Thanks to Bootstrap,
    we had to implement nothing special to have a nice mobile representation. Here''s
    what adding new workouts looks like on a mobile screen:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了锻炼管理页面。我们学习了如何使用Google Firebase数据存储机制来存储静态文件，并且再次使用了实时数据库来存储锻炼对象。我们使用Bootstrap为锻炼管理页面构建了一个响应式布局，并学习了如何使用Bootstrap的模态组件在一个漂亮的弹出窗口中显示每个单独的锻炼。现在我们有一个完全负责的应用程序。多亏了Bootstrap，我们不需要实现任何特殊的东西来获得一个漂亮的移动表示。在移动屏幕上添加新的锻炼的样子如下：
- en: '![Test Test and Test](../images/00141.jpeg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![测试测试和测试](../images/00141.jpeg)'
- en: Adding a new workout on a mobile screen
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动屏幕上添加新的锻炼
- en: 'And this is what our modal looks like on a mobile device:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的模态在移动设备上的样子：
- en: '![Test Test and Test](../images/00142.jpeg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![测试测试和测试](../images/00142.jpeg)'
- en: Workout modal displayed on a mobile device
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上显示的锻炼模态
- en: 'Now it''s time to test our application. We are going to use Jest ([https://facebook.github.io/jest/](https://facebook.github.io/jest/))
    to build unit tests and run snapshot testing. In this chapter, we are going to
    do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是测试我们的应用程序的时候了。我们将使用Jest（[https://facebook.github.io/jest/](https://facebook.github.io/jest/)）来构建单元测试和运行快照测试。在本章中，我们将做以下事情：
- en: Learn how to configure our Vue.js application to work with Jest
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何配置我们的Vue.js应用程序与Jest一起工作
- en: Test Vuex stores using Jest assertions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jest断言测试Vuex存储
- en: Learn how to mock complex objects with the `jest.mock` and `jest.fn` methods
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`jest.mock`和`jest.fn`方法模拟复杂对象
- en: Learn how to implement snapshot testing for Vue components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何为Vue组件实现快照测试
- en: Why is testing important?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么测试很重要？
- en: Our ProFitOro application works just fine, doesn't it? We have opened it so
    many times in the browser, we have checked all the implemented features, so it
    just works, right? Yes, that's true. Now go to your settings page and try to change
    the values of the timer to something strange. Try it with negative values, try
    it with huge values, try it with strings, and try it with empty values…do you
    think that can be called a nice user experience?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的ProFitOro应用程序运行得很好，是吗？我们在浏览器中打开了它很多次，检查了所有实现的功能，所以它只是工作，对吧？是的，这是真的。现在去你的设置页面，尝试将计时器的值更改为一些奇怪的值。尝试使用负值，尝试使用巨大的值，尝试使用字符串，尝试使用空值……你认为这可以称为良好的用户体验吗？
- en: '![Why is testing important?](../images/00143.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![为什么测试很重要？](../images/00143.jpeg)'
- en: You wouldn't like to work during this number of minutes, would you?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会想要在这么多分钟内工作，对吧？
- en: Have you tried to create a strange workout? Have you tried to introduce a huge
    workout name at its creation and see how it displays? There are thousands of corner
    cases and all of them should be carefully tested. We want our application to be
    maintainable, reliable, and something that offers an amazing user experience.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你尝试过创建一个奇怪的锻炼吗？你尝试过在创建时输入一个巨大的锻炼名称并看看它是如何显示的吗？有成千上万种边缘情况，所有这些都应该仔细测试。我们希望我们的应用程序是可维护的、可靠的，并且提供令人惊叹的用户体验。
- en: What is Jest?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Jest？
- en: 'You know that Facebook guys are never tired of creating new tools. React, redux,
    react-native and all this reactive family was not enough for them and they created
    a really powerful, easy-to-use testing framework called Jest: [https://facebook.github.io/jest/](https://facebook.github.io/jest/).
    Jest is pretty cool because it''s self-contained enough for you to not to be distracted
    by extensive configuration or by looking for asynchronous testing plugins, mocking
    libraries, or fake timers to use along with your favorite framework. Jest is all
    in one, although pretty lightweight. Besides that, on every run, it only runs
    those tests that have been changed since the last test run, which is pretty elegant
    and nice because it''s fast!'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道Facebook的人永远不会厌倦创造新工具。React、redux、react-native以及所有这些响应式家族对他们来说还不够，他们创建了一个真正强大、易于使用的测试框架，叫做Jest：[https://facebook.github.io/jest/](https://facebook.github.io/jest/)。Jest非常酷，因为它足够自包含，让你不必分心于繁琐的配置或寻找异步测试插件、模拟库或伪计时器来与你喜欢的框架一起使用。Jest是一个多合一的工具，虽然非常轻量级。此外，在每次运行时，它只运行自上次测试运行以来发生变化的测试，这非常优雅和快速！
- en: Initially created for testing React applications, Jest turned out to be suitable
    for other purposes, including Vue.js applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最初为测试React应用程序而创建，Jest被证明适用于其他用途，包括Vue.js应用程序。
- en: Check out the great talk given by Roman Kuba during the Vue.js conference in
    June 2017 in Poland ([https://youtu.be/pqp0PsPBO_0](https://youtu.be/pqp0PsPBO_0)),
    where he explains in a nutshell how to test Vue components with Jest.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 查看罗曼·库巴在2017年6月波兰Vue.js大会上的精彩演讲([https://youtu.be/pqp0PsPBO_0](https://youtu.be/pqp0PsPBO_0))，他在其中简要解释了如何使用Jest测试Vue组件。
- en: Our application is not just a Vue application, it is a Nuxt application that
    uses Vuex stores and Firebase in it. All these dependencies make it a little bit
    more difficult to test because of all the things we have to mock and because of
    the Nuxt application particularities themselves. However, it is possible and after
    everything is set up, the joy of writing tests is enormous! Let's go!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用不仅仅是一个Vue应用程序，它是一个使用了Vuex存储和Firebase的Nuxt应用程序。所有这些依赖项使得测试变得有点困难，因为我们必须模拟所有这些东西，还有Nuxt应用程序本身的特殊性。然而，这是可能的，一切设置好之后，编写测试的乐趣是巨大的！让我们开始吧！
- en: Getting started with Jest
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Jest
- en: Let's start by testing a small sum function and check that it correctly sums
    two numbers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试一个小的求和函数开始，检查它是否正确地对两个数字求和。
- en: 'The first step would be, of course, to install Jest:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先当然是安装Jest：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a directory `test` and add a file called `sum.js` with the following
    content:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`test`的目录，并添加一个名为`sum.js`的文件，内容如下：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now add a test spec file for this function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为这个函数添加一个测试规范文件：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We need a command to run tests. Add an entry `"test"` to the `package.json`
    file that will call a command `jest`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个命令来运行测试。在`package.json`文件中添加一个`"test"`条目，它将调用一个`jest`命令：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now if you run `npm test`, you will see some errors:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你运行`npm test`，你会看到一些错误：
- en: '![Getting started with Jest](../images/00144.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用Jest](../images/00144.jpeg)'
- en: Errors in the test output with when we run tests with Jest
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jest运行测试时的测试输出中的错误
- en: 'This happens because our Jest is not aware we are using *ES6*! So, we need
    to add the `babel-jest` dependency:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的Jest不知道我们在使用*ES6*！所以，我们需要添加`babel-jest`依赖项：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After *babel-jest* is installed, we have to add a `.babelrc` file with the
    following content:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完*babel-jest*之后，我们需要添加一个`.babelrc`文件，内容如下：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Aren''t you annoyed about your IDE warnings regarding `describe`, `it`, and
    other globals that are not being recognized? Just add an entry `jest: true` to
    your `.eslintrc.js` file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '你是否对IDE关于`describe`、`it`和其他未被识别的全局变量的警告感到烦恼？只需在你的`.eslintrc.js`文件中添加一个`jest:
    true`条目：'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now if you run `npm test`, the tests are passing!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你运行`npm test`，测试通过了！
- en: '![Getting started with Jest](../images/00145.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用 Jest](../images/00145.jpeg)'
- en: Congratulations! You've just set up and run your first Jest test!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚设置并运行了你的第一个 Jest 测试！
- en: Coverage
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖率
- en: 'Unit tests help to guarantee that the pieces (units) of code that they are
    checking work for any possible and impossible input. Every written unit test covers
    the corresponding piece of code as a blanket, protecting this code from future
    failures and making ourselves comfortable with our code''s functionality and maintainability.
    There are different types of code coverage: statement coverage, line coverage,
    branch coverage, and so on. The more the code is covered, the more stable it is
    and the more comfortable we are. That''s why, while we are writing unit tests,
    it is very important to check the code coverage every time we run it. It''s easy
    to check the code coverage with Jest. You don''t need to install any external
    tool or write extra configuration. Just execute the test command with the coverage
    flag:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试有助于确保它们检查的代码片段（单元）对于任何可能和不可能的输入都能正常工作。每个编写的单元测试都覆盖了相应的代码片段，就像一条毯子一样，保护这段代码免受未来的故障，并使我们对代码的功能和可维护性感到舒适。代码覆盖有不同的类型：语句覆盖、行覆盖、分支覆盖等等。代码覆盖越多，代码就越稳定，我们就越舒适。这就是为什么在编写单元测试时，每次运行时检查代码覆盖率非常重要。使用
    Jest 很容易检查代码覆盖率。你不需要安装任何外部工具或编写额外的配置。只需执行带有覆盖率标志的测试命令：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will magically see this beautiful coverage output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你会神奇地看到这个美丽的覆盖率输出：
- en: '![Coverage](../images/00146.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![覆盖率](../images/00146.jpeg)'
- en: Running Jest tests with coverage
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用覆盖率运行 Jest 测试
- en: Works like a charm, right?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 像魔术一样，对吧？
- en: Find the code in the `chapter9/1/profitoro` directory. Don't forget to run `npm
    install` on it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter9/1/profitoro`目录中找到代码。别忘了在其上运行`npm install`。
- en: Testing utility functions
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试实用函数
- en: 'Let''s test our code now! Let''s start with utils. Create a file called `utils.spec.js`
    and import the `leftPad` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试我们的代码！让我们从 utils 开始。创建一个名为`utils.spec.js`的文件，并导入`leftPad`函数：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Have a look at this function again:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看这个函数：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function should return the input string if this string's length is greater
    than `1`. If the string's length is `1`, it should return the string with a preceding
    `0`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入字符串的长度大于`1`，则此函数应返回输入字符串。如果字符串的长度为`1`，则应返回带有前导`0`的字符串。
- en: 'Seems quite easy to test it, right? We would write two test cases:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 测试起来似乎很容易，对吧？我们将编写两个测试用例：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Argh...if you run this test, you will get an error:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 啊...如果你运行这个测试，你会得到一个错误：
- en: '![Testing utility functions](../images/00147.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![测试实用函数](../images/00147.jpeg)'
- en: 'Of course, poor Jest, it is not aware of the aliases we''ve been using in our
    Nuxt application. The `~` notation for it equals nothing! Luckily for us, it is
    easy to fix. Just add the `jest` entry to the `package.json` file with a name
    mapper entry inside it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可怜的 Jest，并不知道我们在 Nuxt 应用程序中使用的别名。对于它来说，`~`符号什么都不等于！幸运的是，这很容易解决。只需在`package.json`文件中添加`jest`条目，并在其中添加一个名称映射条目：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now Jest will know that everything that starts with `~` should be mapped to
    the root directory. If you run `npm test -- --coverage` now, you will see that
    the tests are passing!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Jest 将知道以`~`开头的所有内容都应映射到根目录。如果你现在运行`npm test -- --coverage`，你会看到测试通过了！
- en: '![Testing utility functions](../images/00148.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![测试实用函数](../images/00148.jpeg)'
- en: After mapping the root directory alias, tests run without any problem
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 映射根目录别名后，测试可以正常运行
- en: The code coverage, however, is really low. It's because we have another function
    in our utils to be tested. Check the `utils.js` file. Can you see the `numberOfSecondsFromNow`
    method? It also needs some test coverage. It calculates the time that has passed
    from the given input time until now. How should we deal with this `Date.now`?
    We can't predict the test result because we can't guarantee that the moment of
    *now* of test running will be the same as when we check it. Every millisecond
    matters. Easy! We should mock the `Date.now` object!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码覆盖率确实很低。这是因为我们的工具中还有另一个要测试的函数。检查`utils.js`文件。你能看到`numberOfSecondsFromNow`方法吗？它也需要一些测试覆盖率。它计算了从给定输入时间到现在经过的时间。我们应该如何处理这个`Date.now`？我们无法预测测试结果，因为我们无法保证测试运行时的*现在*时刻与我们检查时的时刻相同。每一毫秒都很重要。简单！我们应该模拟`Date.now`对象！
- en: Mocking with Jest
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Jest进行模拟
- en: Turns out that even something that seems impossible (stopping time) is possible
    with Jest. Mocking the `Date.now` object is fairly easy using the `jest.fn()`
    function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，即使是看似不可能的事情（停止时间）在Jest中也是可能的。使用`jest.fn()`函数很容易模拟`Date.now`对象。
- en: 'Check the documentation about mocking with Jest:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 查看关于使用Jest进行模拟的文档：
- en: '[http://facebook.github.io/jest/docs/en/snapshot-testing.html#tests-should-be-deterministic](http://facebook.github.io/jest/docs/en/snapshot-testing.html#tests-should-be-deterministic)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://facebook.github.io/jest/docs/en/snapshot-testing.html#tests-should-be-deterministic](http://facebook.github.io/jest/docs/en/snapshot-testing.html#tests-should-be-deterministic)'
- en: We can mock the `Date.now` function by just invoking `Date.now = jest.fn(()
    => 2000)`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`Date.now = jest.fn(() => 2000)`来模拟`Date.now`函数。
- en: 'Now we can easily test the `''numberOfSecondsFromNow''` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松测试`'numberOfSecondsFromNow'`函数：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The coverage is better now but it could be perfect if we could cover our funny
    `beep` function. What should we test in it? Let''s try to test that when the `beep`
    function is invoked, the `Audio.play` method is called. Mocked functions have
    a special property called **mock** that contains all the information about this
    function—the number of calls that have been performed on it, the information that
    has been passed to them, and so on. Thus, we can mock the `Audio.prototype.play`
    method like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在覆盖率更好了，但如果我们能覆盖我们有趣的`beep`函数，那就更完美了。我们应该在其中测试什么？让我们尝试测试一下，当调用`beep`函数时，`Audio.play`方法被调用。模拟函数有一个特殊的属性叫做**mock**，其中包含了关于这个函数的所有信息——已经对它执行的调用次数，传递给它的信息等等。因此，我们可以像这样模拟`Audio.prototype.play`方法：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After invoking the beep method, we can check the number of performed calls
    on the mock like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用beep方法后，我们可以像这样检查模拟上执行的调用次数：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Or we can assert that the mock has been called like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以断言模拟已经被调用了，就像这样：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The whole test might look like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 整个测试可能看起来像下面这样：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to avoid side effects due to mocking the native function, we might
    want to reset our mock after the test:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免由于模拟原生函数而产生的副作用，我们可能希望在测试后重置我们的模拟：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check the Jest documentation in this regard: [https://facebook.github.io/jest/docs/en/mock-function-api.html#mockfnmockreset](https://facebook.github.io/jest/docs/en/mock-function-api.html#mockfnmockreset).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面查看Jest文档：[https://facebook.github.io/jest/docs/en/mock-function-api.html#mockfnmockreset](https://facebook.github.io/jest/docs/en/mock-function-api.html#mockfnmockreset)。
- en: 'Alternatively, you might configure your Jest settings to reset mocks automatically
    after each test. For this, add the `clearMocks` attribute to the Jest `config`
    object inside the `package.json` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以配置Jest设置，以便在每次测试后自动重置模拟。为此，在`package.json`文件中的Jest`config`对象中添加`clearMocks`属性：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Yay! The tests are passing. Check the coverage. It looks quite nice; however,
    the branch coverage is still not perfect:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 耶！测试通过了。检查一下覆盖率。看起来相当不错；然而，分支覆盖率仍然不完美：
- en: '![Mocking with Jest](../images/00149.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jest进行模拟](../images/00149.jpeg)'
- en: Branch coverage in for the utils.js file is only 75%
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: utils.js文件的分支覆盖率仅为75%
- en: 'Why is this happening? First of all, check the column `Uncovered Lines`. It
    shows us the line that hasn''t been covered by the test. It''s line `22` of the
    `numberOfSecondsFromNow` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？首先，检查`未覆盖的行`列。它显示了测试未覆盖的行。这是`numberOfSecondsFromNow`方法的第`22`行：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As an alternative, you can check the `coverage` folder inside your project''s
    directory and open the `lcov-report/index.html` file in the browser to check in
    a more visual way what exactly is going on:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，您可以检查项目目录中的`coverage`文件夹，并在浏览器中打开`lcov-report/index.html`文件，以更直观地了解发生了什么：
- en: '![Mocking with Jest](../images/00150.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jest进行模拟](../images/00150.jpeg)'
- en: Code coverage HTML shows the covered and uncovered lines in a nice visual way
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率HTML以一种美观的方式显示了覆盖和未覆盖的行
- en: 'Here, you can clearly see that line `22` is marked as red, which means it has
    not been covered by tests. Well, let''s cover it! Just add a new test covering
    the case when the `startTime` property is not passed to this method and ensure
    that it returns `0`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以清楚地看到第`22`行标记为红色，这意味着它没有被测试覆盖。好吧，让我们来覆盖它！只需添加一个新的测试，覆盖`startTime`属性未传递给此方法的情况，并确保它返回`0`：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the tests with the coverage flag now. OMG! Isn't it just fantastic?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在带着覆盖标志运行测试。天啊！这不是很棒吗？
- en: '![Mocking with Jest](../images/00151.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jest进行模拟](../images/00151.jpeg)'
- en: 100% code coverage, isn't it fantastic?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 100%的代码覆盖率，是不是很棒？
- en: The final code for this section can be found in the `chapter9/2/profitoro` folder.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最终代码可以在`chapter9/2/profitoro`文件夹中找到。
- en: Testing Vuex store with Jest
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest测试Vuex存储
- en: 'Let''s now try to test our Vuex store. The most critical parts of our store
    to test are our actions and mutations because they can actually mutate the store''s
    state. Let''s start with the mutations. Create the `mutations.spec.js` file in
    the `test` folder and import `mutations.js`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试测试我们的Vuex存储。我们要测试的存储最关键的部分是我们的操作和突变，因为它们实际上可以改变存储的状态。让我们从突变开始。在`test`文件夹中创建`mutations.spec.js`文件并导入`mutations.js`：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are ready to write unit tests for our mutation functions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好为我们的突变函数编写单元测试。
- en: Testing mutations
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试突变
- en: 'Mutations are very simple functions that receive a state object and set some
    of its attribute to the given value. Thus, testing mutations is fairly easy—we
    have just to mock the state object and pass it to the mutation we want to test
    with a value we want to set. In the end, we have to check whether the value has
    been actually set. Let''s, for example, test the mutation `setWorkingPomodoro`.
    This is what our mutation looks like:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 突变是非常简单的函数，它接收一个状态对象，并将其属性设置为给定值。因此，测试突变非常简单——我们只需模拟状态对象，并将其传递给我们想要测试的突变，以及我们想要设置的值。最后，我们必须检查该值是否已实际设置。例如，让我们测试`setWorkingPomodoro`突变。这是我们的突变的样子：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In our test, we need to create a mock for the state object. It doesn''t need
    to represent the complete state; it needs to at least mock the `workingPomodoro`
    property of the state''s `config` object. Then we will call the mutation, passing
    it our mocked state and the new value for the `workingPomodoro` and we will assert
    that this value has been applied to our mock. Thus, these are the steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们需要为状态对象创建一个模拟。它不需要代表完整的状态；它至少需要模拟状态的`config`对象的`workingPomodoro`属性。然后我们将调用突变，传递给它我们的模拟状态和`workingPomodoro`的新值，并断言这个值已经应用到我们的模拟中。因此，这些是步骤：
- en: 'Create a mock for the state object: `let state = {config: {workingPomodoro:
    1}}`'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '为状态对象创建一个模拟：`let state = {config: {workingPomodoro: 1}}`'
- en: 'Call the mutation with a new value: `mutations.setWorkingPomodoro(state, 30)`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新值调用突变：`mutations.setWorkingPomodoro(state, 30)`
- en: 'Assert that the value has been set to the mocked object: `expect(state.config).toEqual({workingPomodoro:
    30})`'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '断言该值已设置为模拟对象：`expect(state.config).toEqual({workingPomodoro: 30})`'
- en: 'The complete code for this test looks like the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的完整代码看起来如下：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The exact same mechanism should be applied to test the rest of the mutations.
    Go ahead and finish them all!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的机制应该被应用于测试其余的变化。继续并完成它们吧！
- en: Asynchronous testing with Jest – testing actions
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Jest进行异步测试——测试动作
- en: 'Let''s move on to the more complex stuff to test—our actions! Our actions are
    mostly asynchronous and they use complex Firebase application objects inside.
    This makes them quite challenging to test but we do love challenges, don''t we?
    Let''s have a look at the first action in the `actions.js` file. It''s the `uploadImages`
    action that looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续测试更复杂的东西——我们的动作！我们的动作大多是异步的，并且它们在内部使用复杂的Firebase应用程序对象。这使得它们非常具有挑战性，但我们确实喜欢挑战，不是吗？让我们来看看`actions.js`文件中的第一个动作。它是`uploadImages`动作，看起来是这样的：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What could we possibly test here? We could, for example, test that the `_uploadImage`
    function has been called the exact same number of times as the size of the array
    of images that was passed. For this, we must mock the `_uploadImage` method. In
    order to do that, let''s export it as well in our `actions`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能在这里测试什么呢？例如，我们可以测试`_uploadImage`函数被调用的次数与传递的图像数组的大小完全相同。为此，我们必须模拟`_uploadImage`方法。为了做到这一点，让我们在`actions`中也导出它：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we can mock this method and check the number of times the `mock` has been
    called. The mocking itself is pretty easy; we just need to assign the `actions._uploadImage`
    to the `jest.fn()`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以模拟这个方法并检查`mock`被调用的次数。模拟本身非常简单；我们只需要将`actions._uploadImage`分配给`jest.fn()`：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'From now on, our `actions._uploadImage` has a special magical property called
    `mock` that we have already talked about. This object gives us the opportunity
    of accessing the number of calls being done on the `_uploadImage` method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们的`actions._uploadImage`具有一个特殊的魔法属性叫做`mock`，我们已经谈论过了。这个对象让我们有机会访问对`_uploadImage`方法的调用次数：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, to assert that the number of calls is three, we can just run the following
    assertion:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要断言调用次数为三，我们只需运行以下断言：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Check the full documentation regarding mocking functions in Jest here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里查看有关在Jest中模拟函数的完整文档：
- en: '[https://facebook.github.io/jest/docs/mock-functions.html#content](https://facebook.github.io/jest/docs/mock-functions.html#content)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/jest/docs/mock-functions.html#content](https://facebook.github.io/jest/docs/mock-functions.html#content)'
- en: 'Very well, but where should we call this expectation? The `uploadImages` function
    is asynchronous; it returns a promise. Somehow, we could sneak into the future
    and listen to the promise resolution and call our assertion there. Shall we define
    some *callbacks* and invoke them once the promise is resolved? No, no need for
    that. Just call your function and run the assertions inside the `then` callback.
    Thus, our test will look as simple as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，但我们应该在哪里调用这个期望呢？`uploadImages`函数是异步的；它返回一个promise。不知何故，我们可以窥视未来并监听promise的解析，然后在那里调用我们的断言。我们应该定义一些*回调*，并在promise解析后调用它们吗？不，不需要。只需调用您的函数，并在`then`回调中运行断言。因此，我们的测试将如下所示：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It just works!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它就是这样工作的！
- en: 'Let''s now create a more complex mock – for our `firebaseApp`. How do we decide
    what and how to mock? Just look at the code and check what''s being done. So let''s,
    for example, check the `createNewWorkout` method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个更复杂的模拟——针对我们的`firebaseApp`。我们如何决定模拟什么以及如何模拟？只需查看代码并检查正在执行的操作。因此，让我们例如检查`createNewWorkout`方法：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What's going on here? Some new key is generated by the state's `workoutsReference`
    and then the object called `updates` is created. This object contains two entries—one
    for each of the Firebase database resources that held the workout object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？状态的`workoutsReference`生成了一些新的键，然后创建了名为`updates`的对象。该对象包含两个条目 - 分别为保存了workout对象的Firebase数据库资源。
- en: 'Then Firebase''s database `update` method is called with this object. Thus,
    we have to mock the database''s `update` method so we can check the data that
    it''s being called with. We have also to inject this mock somehow into the big
    Firebase application mock. Create a folder to hold our mock files and call it
    `__mocks__`. Add two files to this directory—`firebaseMocks.js` and `firebaseAppMock.js`.
    Create an empty function for the `update` method in the `firebaseMocks` file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用Firebase的数据库`update`方法与此对象。因此，我们必须模拟数据库的`update`方法，以便我们可以检查调用它时传入的数据。我们还必须以某种方式将此模拟注入到大型Firebase应用程序模拟中。创建一个文件夹来保存我们的模拟文件，并将其命名为`__mocks__`。在此目录中添加两个文件
    - `firebaseMocks.js`和`firebaseAppMock.js`。在`firebaseMocks`文件中为`update`方法创建一个空函数：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a mock for the `firebaseApp` object that will call the mocked `update`
    function inside its `database` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`firebaseApp`对象的模拟，它将在其`database`方法内调用模拟的`update`函数：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In order to test the `createNewWorkout` method, we will use the `jest.mock`
    function to bind the Firebase object to its mock. Check the detailed documentation
    regarding the `jest.mock` function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`createNewWorkout`方法，我们将使用`jest.mock`函数将Firebase对象绑定到其模拟。查看有关`jest.mock`函数的详细文档：
- en: '[http://facebook.github.io/jest/docs/en/jest-object.html#jestmockmodulename-factory-options](http://facebook.github.io/jest/docs/en/jest-object.html#jestmockmodulename-factory-options).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://facebook.github.io/jest/docs/en/jest-object.html#jestmockmodulename-factory-options](http://facebook.github.io/jest/docs/en/jest-object.html#jestmockmodulename-factory-options)。'
- en: 'We need to bind our mock before importing the `actions.js` module. In this
    way, it will already use the mocked object. Thus, our import section will look
    like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入`actions.js`模块之前，我们需要绑定我们的模拟。这样，它将已经使用模拟对象。因此，我们的导入部分将如下所示：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s see what is going on with a workout object so we know what and how to
    mock and have a deterministic test. We have these lines:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`workout`对象的情况，以便了解如何模拟和进行确定性测试。我们有以下这些行：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So, our mock of the state object must contain the user object with the predefined
    `displayName` and `uid`. Let''s create it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们状态对象的模拟必须包含具有预定义的`displayName`和`uid`的用户对象。让我们创建它：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What happens next?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来会发生什么？
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once again, we need to mock the `Date.now` object. Let''s do the same as we
    did in the `utils` test spec:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要模拟`Date.now`对象。让我们像在`utils`测试规范中所做的那样做同样的事情：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s read our method further. It contains a line that generates the `newWorkoutKey`
    variable based on the `workoutsRef` state''s object:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步阅读我们的方法。它包含一行代码，根据`workoutsRef`状态对象生成`newWorkoutKey`变量：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s mock the `workoutsRef` in our state mock as well:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的状态模拟中也模拟`workoutsRef`：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we know that when we call the `addNewWorkout` method, in the end it is
    expected to call the Firebase database `update` method with an object that will
    contain two entries – one with a key `/user-workouts/1/59` and another with a
    key `/workouts/59`, both with the same entry for the `workout` object:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，当我们调用`addNewWorkout`方法时，最终预期会调用Firebase数据库的`update`方法，该方法将包含两个条目的对象 -
    一个带有键`/user-workouts/1/59`，另一个带有键`/workouts/59`，两者都具有相同的`workout`对象的条目：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So, first we need to create a spy. A spy is a special function that will replace
    the function we bind it to and spy on whatever has been happening with this function.
    Again, you don't need to install any external plugin or library for spies. Jest
    provides them out of the box.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，首先我们需要创建一个间谍。间谍是一个特殊的函数，它将替换我们绑定到它的函数，并监视这个函数发生的任何事情。再次强调，你不需要为间谍安装任何外部插件或库。Jest已经内置了它们。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Check out Jest spies in the official documentation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方文档中查看Jest间谍：
- en: '[http://facebook.github.io/jest/docs/jest-object.html#jestspyonobject-methodname](http://facebook.github.io/jest/docs/jest-object.html#jestspyonobject-methodname)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://facebook.github.io/jest/docs/jest-object.html#jestspyonobject-methodname](http://facebook.github.io/jest/docs/jest-object.html#jestspyonobject-methodname)'
- en: 'So, we want to spy on the `update` mock function. Let''s create a spy on it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们想在`update`模拟函数上创建一个间谍。让我们创建一个间谍：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the end, our assertion will look like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的断言将如下所示：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The whole test will look like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 整个测试将如下所示：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now you know how to create mocks on different Firebase methods and how to create
    spies on them, you can create the rest of test specifications to test the rest
    of the actions. Check out the code for this section in the `chapter9/3/profitoro`
    folder.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何在不同的Firebase方法上创建模拟和如何在它们上创建间谍，你可以创建其余的测试规范来测试其余的操作。在`chapter9/3/profitoro`文件夹中查看此部分的代码。
- en: Let's move forward and learn how we can actually test our Vue components with
    Jest!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续学习如何使用Jest实际测试我们的Vue组件！
- en: Making Jest work with Vuex, Nuxt.js, Firebase, and Vue components
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使Jest与Vuex、Nuxt.js、Firebase和Vue组件一起工作
- en: It's not the easiest task to test Vue components that rely on the Vuex store
    and Nuxt.js. We have to prepare several things.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 测试依赖于Vuex存储和Nuxt.js的Vue组件并不是一件容易的任务。我们必须准备好几件事情。
- en: 'First of all, we must install `jest-vue-preprocessor` in order to tell Jest
    that Vue components files are valid. We must also install `babel-preset-stage-2`,
    otherwise Jest will complain about the ES6 *spread* operator. Run the following
    command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须安装`jest-vue-preprocessor`，以便告诉Jest Vue组件文件是有效的。我们还必须安装`babel-preset-stage-2`，否则Jest会抱怨ES6的*spread*操作符。运行以下命令：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the dependencies are installed, add the `stage-2` entry to the `.babelrc`
    file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完依赖项后，在`.babelrc`文件中添加`stage-2`条目：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we need to tell Jest that it should use the `babel-jest` transformer for
    the regular JavaScript files and the `jest-vue-transformer` for the Vue files.
    In order to do so, add the following to the jest entry in the `package.json` file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉Jest它应该使用`babel-jest`转换器来处理常规的JavaScript文件，以及使用`jest-vue-transformer`来处理Vue文件。为了做到这一点，在`package.json`文件的jest条目中添加以下内容：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We use some images and styles in our components. This might result in some
    errors because Jest doesn''t know what these SVG files are about. Let''s add yet
    another entry to the `moduleNameMapper` Jest entry in the `package.json` file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的组件中使用了一些图像和样式。这可能会导致一些错误，因为Jest不知道这些SVG文件是什么。让我们在`package.json`文件的`moduleNameMapper`
    Jest条目中再添加一个条目：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We are doing this because we don't really want to test pictures or CSS/SCSS
    files.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为我们并不真的想测试图片或CSS/SCSS文件。
- en: 'Add `styleMock.js` and `fileMock.js` to the `__mocks__` directory with the
    following content:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将`styleMock.js`和`fileMock.js`添加到`__mocks__`目录，内容如下：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Check out the official documentation for more details in this regard: [https://facebook.github.io/jest/docs/webpack.html](https://facebook.github.io/jest/docs/webpack.html).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 查看官方文档以获取更多相关细节：[https://facebook.github.io/jest/docs/webpack.html](https://facebook.github.io/jest/docs/webpack.html)。
- en: 'Add name mappers for both Vue and Vuex files:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为Vue和Vuex文件添加名称映射：
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As a last step of configuration, we need to map the names for the Vue files.
    Jest is dumb and it can''t understand that we are actually importing the Vue file
    if we are importing it without its extension. Thus, we must tell it that whatever
    is being imported from the `components` or `pages` folder is a Vue file. So, in
    the end of these configuration steps, our `moduleNamMapper` entry for jest will
    look as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为配置的最后一步，我们需要映射Vue文件的名称。Jest很笨，无法理解我们实际上是在导入Vue文件，如果我们没有导入它的扩展名。因此，我们必须告诉它，从`components`或`pages`文件夹导入的任何内容都是Vue文件。因此，在这些配置步骤的最后，我们的jest的`moduleNamMapper`条目将如下所示：
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We are now ready to test our components. You can find the final code with all
    these configuration steps in the `chapter9/4/profitoro` folder.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备测试我们的组件。您可以在`chapter9/4/profitoro`文件夹中找到所有这些配置步骤的最终代码。
- en: Testing Vue components using Jest
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest测试Vue组件
- en: 'Let''s start by testing the `Header` component. Since it depends on the Vuex
    store which, in its turn, highly depends on Firebase, we must do the exact same
    thing we just did to test our Vuex actions—mock the Firebase application before
    injecting the store into the tested component. Start by creating a spec file `HeaderComponent.spec.js`
    and paste the following to its `import` section:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试`Header`组件开始。由于它依赖于Vuex存储，而Vuex存储又高度依赖于Firebase，我们必须做与测试Vuex操作相同的事情——在将存储注入到被测试的组件之前模拟Firebase应用程序。首先创建一个名为`HeaderComponent.spec.js`的规范文件，并将以下内容粘贴到其`import`部分：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note that we first mock the Firebase application and then import our store.
    Now, to be able to properly test our component with the mocked store, we need
    to inject the store into it. The best way to do that is to create a `Vue` instance
    with the `HeaderComponent` in it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们首先模拟Firebase应用程序，然后导入我们的存储。现在，为了能够使用模拟存储正确测试我们的组件，我们需要将存储注入其中。这样做的最佳方法是在其中创建一个带有`HeaderComponent`的`Vue`实例：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note that we have bound the reference to the mounted component. Now we will
    be able to access our header component by invoking `$mounted.$refs.headercomponent`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经将引用绑定到已安装的组件。现在我们将能够通过调用`$mounted.$refs.headercomponent`来访问我们的头部组件：
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'What can we test in this component? It actually doesn''t have so many functionalities.
    It has a method `onLogout` which calls the `logout` action and pushes the `/`
    path to the component''s `$router` property. So, we could actually mock the `$router`
    property, call the `onLogout` method, and check this property''s value. We can
    also spy on the `logout` action and check that it has been called. Thus, our test
    for the `onLogout` method of the component can look like the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中我们可以测试什么？它实际上没有太多的功能。它有一个名为`onLogout`的方法，该方法调用`logout`操作并将`/`路径推送到组件的`$router`属性。因此，我们实际上可以模拟`$router`属性，调用`onLogout`方法，并检查该属性的值。我们还可以对`logout`操作进行监视，并检查它是否已被调用。因此，我们对组件的`onLogout`方法的测试可以如下所示：
- en: '[PRE54]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the tests. You will see a lot of errors related to the Nuxt component not
    being properly registered:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。您将看到许多与Nuxt组件未正确注册相关的错误：
- en: '![Testing Vue components using Jest](../images/00152.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jest测试Vue组件](../images/00152.jpeg)'
- en: Vue errors regarding the nuxt-link component
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 关于nuxt-link组件的Vue错误
- en: 'Well, if you can live with these errors, just live with them. Otherwise, run
    your tests in production mode:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，如果你能忍受这些错误，就忍受吧。否则，以生产模式运行您的测试：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be aware that if you run your tests in production mode, you can actually miss
    some relevant errors.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您以生产模式运行测试，实际上可能会错过一些相关错误。
- en: Congratulations! You were able to test a Vue component that depends on Nuxt,
    Vuex and Firebase with Jest! Check the code for this test in the `chapter9/5/profitoro`
    directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经能够使用Jest测试依赖于Nuxt、Vuex和Firebase的Vue组件！检查`chapter9/5/profitoro`目录中的此测试代码。
- en: Snapshot testing with Jest
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest进行快照测试
- en: 'One of the coolest features of Jest is *snapshot testing*. What is snapshot
    testing? When our components are being rendered, they produce some HTML markup,
    right? It would be really important that once your application is stable, none
    of the newly added functionality breaks the already existing stable markup, don''t
    you think? That''s why snapshot testing exists. Once you generate a snapshot for
    some component, it will persist in the snapshot folder and on each test run, it
    will compare the output with the existing snapshot. Creating a snapshot is really
    easy. After you mount your component, you should just call the expectation `toMatchSnapshot`
    on this component''s HTML:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Jest最酷的功能之一是*快照测试*。什么是快照测试？当我们的组件被渲染时，它们会产生一些HTML标记，对吧？一旦你的应用程序稳定下来，很重要的一点是，新添加的功能不会破坏已经存在的稳定标记，你不觉得吗？这就是快照测试存在的原因。一旦你为某个组件生成了快照，它将保留在快照文件夹中，并在每次测试运行时，它将比较输出与现有的快照。创建快照非常容易。在挂载组件后，你只需要在该组件的HTML上调用期望的“toMatchSnapshot”：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'I will run snapshot testing for all the pages inside one test suite file. Before
    doing that, I will mock the getters of our Vuex store because there are some pages
    that use the user object, which is not initialized, thus resulting in an error.
    So, create a file `gettersMock` inside our `__mocks__` folder and add the following
    content:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我将为一个测试套件文件中的所有页面运行快照测试。在这之前，我将模拟我们的Vuex存储器的getter，因为有些页面使用未初始化的用户对象，从而导致错误。因此，在我们的“__mocks__”文件夹内创建一个名为“gettersMock”的文件，并添加以下内容：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s go back to the imports. As we''ve already figured out, Jest is not really
    great in figuring out what is what in our imports, thus it will complain about
    relative imports (those that start from the dot, for example, in our `index.js`
    files inside each of the `components` folders). Let''s replace all those relative
    import paths with their absolute equivalent:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到导入部分。正如我们已经发现的那样，Jest在确定导入内容时并不是很擅长，因此它会抱怨相对导入（那些从点开始的导入，例如，在每个“components”文件夹内的“index.js”文件中）。让我们用它们的绝对等价物替换所有这些相对导入路径：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'I''ve also added one more mapping to the name mapper entry inside the `package.json`
    `jest` entry:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在“package.json”“jest”条目内的名称映射器条目中添加了一个映射：
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Great! Create a `pages.snapshot.spec.js` file and import all the necessary
    mock objects and all the pages. Don''t forget to bind the corresponding mocks
    to Vuex `getters` functions and to the Firebase application object. Your import
    section should look like the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！创建一个“pages.snapshot.spec.js”文件，并导入所有必要的模拟对象和所有页面。不要忘记将相应的模拟对象绑定到Vuex“getter”函数和Firebase应用程序对象。你的导入部分应该如下所示：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will create a test spec for each of the pages. We will bind each page component
    in the same way as we have bound the `Header` component. We will export the components
    that we want to test as components of a Vue instance and mount this Vue instance
    after being created. Thus, the index component binding will look as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个页面创建一个测试规范。我们将以与我们绑定“Header”组件相同的方式绑定每个页面组件。我们将导出我们想要测试的组件作为Vue实例的组件，并在创建后挂载此Vue实例。因此，索引组件绑定将如下所示：
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The only thing that you have to do now is to execute the snapshot expectation.
    Thus, the full test spec for the index page will look as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在唯一需要做的就是执行快照期望。因此，索引页面的完整测试规范将如下所示：
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Repeat the exact same steps for all the pages. Run the tests! Check the coverage.
    Now we are talking! We''ve actually touched almost all the components of our application!
    Look at this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有页面重复相同的步骤。运行测试！检查覆盖率。现在我们在谈论！我们实际上触及了几乎所有应用程序的组件！看看这个：
- en: '![Snapshot testing with Jest](../images/00153.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jest进行快照测试](../images/00153.jpeg)'
- en: Almost all the components and files of our application appear in the coverage
    report!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的几乎所有组件和文件都出现在覆盖报告中！
- en: 'The most important thing, which is actually the whole purpose of the snapshot
    testing, is the generated folder called `__snapshots__` inside the test folder.
    Here, you will find the newly generated snapshots of all the HTML markup of all
    your pages. These snapshots look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的事情，实际上是快照测试的整个目的，就是在测试文件夹内生成的名为`__snapshots__`的文件夹。在这里，您将找到所有页面的所有HTML标记的新生成快照。这些快照看起来像这样：
- en: '![Snapshot testing with Jest](../images/00154.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jest进行快照测试](../images/00154.jpeg)'
- en: Jest snapshots of the ProFitOro pages
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ProFitOro页面的Jest快照
- en: 'Every time you do something that will affect your markup, the tests will fail.
    If you really want to update snapshots, run the tests with the update flag:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您进行影响标记的操作时，测试将失败。如果您真的想要更新快照，请使用更新标志运行测试：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: I find snapshot testing a really fun and exciting feature!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现快照测试是一个非常有趣和令人兴奋的功能！
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'It is very important that you commit your snapshot files! Check the detailed
    documentation regarding the snapshot testing in the official Jest website:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要提交您的快照文件！查看官方Jest网站上有关快照测试的详细文档：
- en: '[https://facebook.github.io/jest/docs/snapshot-testing.html](https://facebook.github.io/jest/docs/snapshot-testing.html)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/jest/docs/snapshot-testing.html](https://facebook.github.io/jest/docs/snapshot-testing.html)'
- en: The final code for this chapter can be found in the `chapter9/6/profitoro` folder.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终代码可以在`chapter9/6/profitoro`文件夹中找到。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we used very hot technology to test our Vue application. We
    used Jest and learned how to create mocks, test components, and run snapshot testing
    with it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了非常热门的技术来测试我们的Vue应用程序。我们使用了Jest，并学习了如何创建模拟，测试组件，并使用它进行快照测试。
- en: In the next chapter, we will finally see our application live! We will deploy
    it using Google Firebase Hosting and provide the necessary CI/CD tooling so our
    application is deployed and tested automatically each time it is pushed to the
    master branch. Are you ready to see your work live, up and running? Let's go!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将最终看到我们的应用程序上线！我们将使用Google Firebase Hosting部署它，并提供必要的CI/CD工具，以便我们的应用程序在每次推送到主分支时都会自动部署和测试。您准备好看到您的作品上线并运行了吗？让我们开始吧！
