- en: Basic Concepts of Vue 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 2的基本概念
- en: In this chapter, we will discuss data-driven views in Vue. We will also examine
    how DOM is manipulated with the help of directives. Next, we'll learn what components
    are and how to create them, and we'll cover concepts related to templates, methods,
    data, computed properties, and watchers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论Vue中的数据驱动视图。我们还将研究如何使用指令来操作DOM。接下来，我们将学习组件是什么以及如何创建它们，并涵盖与模板、方法、数据、计算属性和观察者相关的概念。
- en: All components have a life cycle, and we have special methods to access a component
    at certain points of its life. These methods are called **lifecycle hooks**, and
    we'll examine them in this chapter too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件都有一个生命周期，并且我们有特殊的方法在其生命周期的某些时刻访问组件。这些方法被称为**生命周期钩子**，我们也将在本章中对它们进行讨论。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Data-driven views in Vue
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue中的数据驱动视图
- en: Computed properties and methods and how to use them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性和方法以及如何使用它们
- en: Understanding components, templates, and props
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解组件、模板和属性
- en: Ways of building component templates in Vue
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue中构建组件模板的方式
- en: Quickly prototyping websites with the help of Vue components and `v-*` directives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue组件和`v-*`指令快速原型网站
- en: Utilizing watchers in Vue
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue中利用观察者
- en: The importance of lifecycle hooks and how to plug into this functionality in
    Vue
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期钩子的重要性以及如何在Vue中插入这种功能
- en: Data-driven views in Vue
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue中的数据驱动视图
- en: Data-driven views in Vue are achieved with the help of reactivity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Vue中的数据驱动视图是通过响应性来实现的。
- en: What is reactivity?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是响应性？
- en: To grasp the concept better, let's look at an example code in which there is
    no reactivity. We will use an example that is very similar to the one we had in
    the previous chapter, when we were comparing Vue and vanilla JS. In the original
    example, using JavaScript, we created an unordered list and three list items inside
    of it. The values of the three list items were added from an array we declared,
    and the unordered list was populated with these list items using a for loop.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个概念，让我们看一个例子代码，其中没有响应性。我们将使用一个非常类似于我们在上一章中比较Vue和原生JS时的例子。在原始的例子中，使用JavaScript，我们创建了一个无序列表，里面有三个列表项。三个列表项的值是从我们声明的数组中添加的，并且使用for循环将无序列表填充了这些列表项。
- en: This time, we will do something slightly different. To see the example as a
    pen, visit [https://codepen.io/AjdinImsirovic/pen/JZOZdR](https://codepen.io/AjdinImsirovic/pen/JZOZdR).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将做一些稍微不同的事情。要将示例作为一个pen查看，请访问[https://codepen.io/AjdinImsirovic/pen/JZOZdR](https://codepen.io/AjdinImsirovic/pen/JZOZdR)。
- en: 'In this non-reactive example, we are predefining the members of the array as
    variables. Then we populate the array with those variables and print them to the
    screen as list items of an unordered list that gets appended to the document:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非响应式的例子中，我们预先定义了数组的成员作为变量。然后我们用这些变量填充数组，并将它们作为无序列表的列表项打印到屏幕上，这个无序列表被附加到文档中：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, what happens when we change a member of the array and repeat the for
    loop a second time? As we can see in the pen, the first and the fourth list items
    are different. The first value is `1`, and the second value is `2`. To make it
    more obvious, these items are in bold red text and have a gray background. The
    first value is the initial value of `var a`. The second value is the value of `var
    a`, updated with this line of code: `arr1[0] = 2`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们改变数组的一个成员并再次重复for循环时会发生什么？正如我们在代码中所看到的，第一个和第四个列表项是不同的。第一个值是`1`，第二个值是`2`。为了更明显，这些项目是以粗体红色文本和灰色背景显示的。第一个值是`var
    a`的初始值。第二个值是使用这行代码更新的`var a`的值：`arr1[0] = 2`。
- en: However, the values of variables `b` and `c` are not updated in the second for
    loop, even though we defined variables `b` and `c` in terms of variable `a` increased
    by `1` and `2`, respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，变量`b`和`c`的值在第二个for循环中没有更新，尽管我们已经分别定义了变量`b`和`c`，它们分别是变量`a`增加1和2。
- en: So, we can see that there is no reactivity in JavaScript out of the box.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到JavaScript本身并没有响应性。
- en: As far as Vue is concerned, reactivity is the term that is used to refer to
    the way in which Vue tracks changes. In other words, reactivity is the way in
    which changes in state are reflected in the DOM. Practically, this means that
    when a change is made to `data`, that change will be propagated to the page so
    that the user can see it. Therefore, saying that *Vue is reactive* is the same
    as saying *Vue tracks changes*. As a concept, it's as simple as that.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 就Vue而言，响应性是指Vue跟踪变化的方式。换句话说，响应性是指状态变化如何在DOM中反映出来。实际上，这意味着当对`data`进行更改时，该更改将传播到页面，以便用户可以看到它。因此，说*Vue是响应式*就等同于说*Vue跟踪变化*。作为一个概念，就是这么简单。
- en: How does Vue achieve this?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue是如何实现这一点的呢？
- en: 'Vue stores its data in the `data` option, which is either a function or an
    object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Vue将其数据存储在`data`选项中，这可以是一个函数或一个对象：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Any change in the `data` model is reflected in the view (on the screen). Vue
    achieves this reactivity with the help of getters and setters. When the `data` object
    is received by the Vue instance, all the properties of the `data` object will
    be updated as getters and setters. This is done with the help of the `Object.defineProperty` API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`模型的任何变化都会反映在视图（屏幕）上。Vue通过getter和setter实现了这种响应性。当`data`对象被Vue实例接收时，`data`对象的所有属性都将被更新为getter和setter。这是通过`Object.defineProperty`API来实现的。'
- en: Computed properties and methods
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性和方法
- en: The usefulness of reactivity in Vue can be described in terms of the difference
    between computed properties and methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Vue中响应性的实用性可以用计算属性和方法之间的区别来描述。
- en: As we mentioned earlier, a Vue instance can have either computed properties,
    methods, or both computed properties and methods. So, what is the difference between
    the two?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Vue实例可以有计算属性、方法，或者计算属性和方法两者兼有。那么，这两者之间有什么区别呢？
- en: Methods are simply run every time they are called. On the other hand, computed
    properties are cached, meaning they are only run when the underlying data model
    changes. This is often described in terms of computed property dependencies. Also,
    methods can have parameters, whereas computed properties cannot.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 方法只是在被调用时运行。另一方面，计算属性是被缓存的，这意味着它们只在基础数据模型发生变化时才会运行。这通常是以计算属性的依赖关系来描述的。此外，方法可以有参数，而计算属性则不行。
- en: What exactly are these dependencies?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这些依赖关系到底是什么？
- en: Consider this simple Vue app, available as a pen at this link: [https://codepen.io/AjdinImsirovic/pen/qKVyry](https://codepen.io/AjdinImsirovic/pen/qKVyry).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简单的Vue应用程序，可以在这个链接中找到：[https://codepen.io/AjdinImsirovic/pen/qKVyry](https://codepen.io/AjdinImsirovic/pen/qKVyry)。
- en: 'This is the code of the simple app:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个简单应用程序的代码：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code will result in this output on the screen:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在屏幕上产生这样的输出：
- en: '![](assets/63e6e381-cd03-4ea3-a4d6-3225799a5d85.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63e6e381-cd03-4ea3-a4d6-3225799a5d85.png)'
- en: 'First off, we can see that there is this weird has a line of text in the view.
    This problem here is that we have not used our `ownerHasThing` computed property.
    In other words, these three lines in HTML are completely redundant:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以看到视图中有这样一个奇怪的“has a”文本行。问题在于我们没有使用我们的`ownerHasThing`计算属性。换句话说，HTML中的这三行是完全多余的：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Also, what if we wanted to run a computed property only after both the input
    fields have been filled out and the focus has been moved out of the inputs or
    the *Enter* key was pressed?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果我们只想在两个输入字段都填写完毕并且焦点已经移出输入框，或者按下*Enter*键后才运行计算属性，该怎么办呢？
- en: This might seem like a relatively complex thing to achieve. Luckily, in Vue
    it is very easy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个相对复杂的事情。幸运的是，在Vue中非常容易实现。
- en: 'Let''s look at the updated code (also available as a pen here: [https://codepen.io/AjdinImsirovic/pen/aKVjqj](https://codepen.io/AjdinImsirovic/pen/aKVjqj)):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下更新后的代码（也可以在这里找到：[https://codepen.io/AjdinImsirovic/pen/aKVjqj](https://codepen.io/AjdinImsirovic/pen/aKVjqj)）：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The JavaScript code is only slightly different:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码只有轻微的不同：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can conclude from this that computed properties are simply data dependencies
    that have some computations performed on them. In other words, `ownerHasThing` is
    a computed property, and its dependencies are `ownerName` and `thing`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，计算属性只是一些数据依赖关系，对它们进行了一些计算。换句话说，`ownerHasThing`是一个计算属性，它的依赖是`ownerName`和`thing`。
- en: Whenever `ownerName` or `thing` are changed, the `ownerHasThing` computed property will
    update as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`ownerName`或`thing`发生变化时，`ownerHasThing`计算属性也会更新。
- en: However, the `ownerHasThing` will not update always, since it is cached. Contrary
    to this, a method will always update; that is, it will always be run, regardless
    of whether the data model has changed or not.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ownerHasThing`不会总是更新，因为它被缓存了。相反，方法总是会更新；也就是说，它总是会运行，无论数据模型是否发生了变化。
- en: This might not seem like a very important difference, but consider a situation
    in which your method needs to fetch data from a third-party API or it has a lot
    of code to run. This might slow things down, and that's why in such cases, using
    computed properties is the way to go.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不是非常重要的区别，但考虑一种情况，你的方法需要从第三方API获取数据，或者有很多代码需要运行。这可能会减慢速度，这就是为什么在这种情况下，使用计算属性是正确的方法。
- en: Before we conclude this section, let's quickly go over the code in the previous
    example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本节之前，让我们快速回顾一下之前示例中的代码。
- en: In HTML, we are using `v-model.lazy`. The `lazy` modifier waits for the user
    to either click outside of the input or press the *Enter* key on their keyboard,
    or otherwise leave the input field (such as by pressing the *Tab* key).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，我们使用了`v-model.lazy`。`lazy`修饰符会等待用户要么点击输入框外部，要么按下键盘上的*Enter*键，或者离开输入框（比如按下*Tab*键）。
- en: Still in HTML, we are also using the `v-if` directive, and we give it `ownerName
    && thing`. Then, we add mustache templates: `{{ ownerHasThing }}` . The `v-if` directive
    will wait until both `ownerName` and `thing` are updated in the data object. So,
    once that both inputs are filled out and no longer in focus, does the computed
    property update the underlying data model, and only then is the `{{ ownerHasThing
    }}` message printed on the screen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，我们还使用了`v-if`指令，并给它传递了`ownerName && thing`。然后，我们添加了双大括号模板：`{{ ownerHasThing
    }}`。`v-if`指令会等待直到`ownerName`和`thing`在数据对象中更新。因此，一旦两个输入框都填写完毕并且不再聚焦，计算属性才会更新底层数据模型，然后才会在屏幕上打印出`{{
    ownerHasThing }}`消息。
- en: In the next section, we'll look at how we can work with templates and components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何使用模板和组件。
- en: Understanding components, templates, and props
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解组件、模板和props
- en: 'To begin, let''s look at how to make a component in Vue. First, we specify
    the component, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何在Vue中创建一个组件。首先，我们像这样指定组件：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A component is a block of code that we give a custom name. This custom name
    can be anything we come up with, and it's *a single label for that entire block
    of code* in the form of a custom HTML tag. In the previous example, we grouped
    the `article` and `span` tags and gave that custom tag the name of `custom-article`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是一段我们给予自定义名称的代码块。这个自定义名称可以是我们想到的任何东西，它是*整个代码块的一个单一标签*，以自定义HTML标签的形式。在前面的例子中，我们将`article`和`span`标签分组，并给该自定义标签命名为`custom-article`。
- en: Components are named using kebab-case.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 组件使用kebab-case命名。
- en: The code for this component is available as a Codepen at [https://codepen.io/AjdinImsirovic/pen/xzpOaJ](https://codepen.io/AjdinImsirovic/pen/xzpOaJ).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的代码可以在Codepen上找到：[https://codepen.io/AjdinImsirovic/pen/xzpOaJ](https://codepen.io/AjdinImsirovic/pen/xzpOaJ)。
- en: 'Now, to create an instance of our component, we simply use our `<custom-article>` opening
    and closing tags in our HTML, like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建我们组件的一个实例，我们只需在我们的HTML中使用`<custom-article>`开放和关闭标签，就像这样：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our custom-article component is referred to as the *child* component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的custom-article组件被称为*子*组件。
- en: The parent is the actual Vue instance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 父级是实际的Vue实例。
- en: 'Note that you can use string templates even without a component. You simply
    add the template option to your Vue instance, like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使没有组件，您也可以使用字符串模板。您只需将模板选项添加到您的Vue实例中，就像这样：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The example code for the previous example is available here: [https://codepen.io/AjdinImsirovic/pen/RJxMae](https://codepen.io/AjdinImsirovic/pen/RJxMae).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子的示例代码可以在这里找到：[https://codepen.io/AjdinImsirovic/pen/RJxMae](https://codepen.io/AjdinImsirovic/pen/RJxMae)。
- en: Next, we'll see how we can improve our component with the help of the `props` and `data` options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何通过`props`和`data`选项来改进我们的组件。
- en: Adding props and data for better components
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加props和data以改进组件
- en: 'To make our `custom-article` component more useful, we''ll add a `props` option
    to it, like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`custom-article`组件更有用，我们将向其添加一个`props`选项，就像这样：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Props are a way to pass the data from the parent to the child. They are one-way
    flows of data between the parent and the child. Props are always defined as an
    array.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Props是从父级向子级传递数据的一种方式。它们是父级和子级之间数据的单向流动。Props总是被定义为一个数组。
- en: The code for the previous example is available here: [https://codepen.io/AjdinImsirovic/pen/KeZNPr](https://codepen.io/AjdinImsirovic/pen/KeZNPr).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子的代码可以在这里找到：[https://codepen.io/AjdinImsirovic/pen/KeZNPr](https://codepen.io/AjdinImsirovic/pen/KeZNPr)。
- en: 'We have registered a prop in our component, and now we can use it in HTML as
    an attribute named just like our prop:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在组件中注册了一个prop，现在我们可以在HTML中使用它作为一个名为与我们的prop相同的属性：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Props are used when we need to make smaller changes to our components without
    having to make a whole new component. They help us reuse what we already have.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要对组件进行较小的更改而不必制作一个全新的组件时，我们使用props。它们帮助我们重复使用我们已经拥有的东西。
- en: In the next section, we'll use the Vue instance's `data` object to add content
    to our `custom-article` component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用Vue实例的`data`对象向我们的`custom-article`组件添加内容。
- en: Adding content to our components with the help of the data object
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据对象向我们的组件添加内容
- en: The code pen for this example can be found at [https://codepen.io/AjdinImsirovic/pen/QxadmE](https://codepen.io/AjdinImsirovic/pen/QxadmE).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的代码笔可以在[https://codepen.io/AjdinImsirovic/pen/QxadmE](https://codepen.io/AjdinImsirovic/pen/QxadmE)找到。
- en: 'In our HTML, we''ll change the code to the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML中，我们将代码更改为以下内容：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In our JS, we''ll update our Vue code to this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JS中，我们将更新我们的Vue代码如下：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous example, we are using the `v-bind` directive to bind the `content` prop
    in our `custom-article` component to the `datacontent` property of our `data` object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`v-bind`指令将我们的`custom-article`组件中的`content`prop绑定到我们的`data`对象的`datacontent`属性。
- en: If you think through this code, you will see that props are almost like named
    variables (with the prop's variable `name` being `content` in the example). Props
    simply pass to the child component whatever data they receive from the parent.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细思考这段代码，你会发现props几乎就像是命名变量（在示例中，prop的变量`name`是`content`）。Props只是将从父组件接收到的数据传递给子组件。
- en: 'There is also another way we can do this. Instead of using data inside our
    Vue instance, we can give it to our component; only this time it has to be a data
    function. Here is the full code for this implementation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用另一种方式来做这件事。我们可以将数据传递给组件，而不是在Vue实例内部使用数据；只是这一次它必须是一个数据函数。以下是此实现的完整代码：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To view the pen for the previous example, visit [https://codepen.io/AjdinImsirovic/pen/VdyQzW](https://codepen.io/AjdinImsirovic/pen/VdyQzW).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看上一个示例的代码，请访问[https://codepen.io/AjdinImsirovic/pen/VdyQzW](https://codepen.io/AjdinImsirovic/pen/VdyQzW)。
- en: If we used data as an object instead of as a function, then reactivity would
    apply to all instances of our component. Since the main purpose of components
    is to be reusable, it is important to remember that in this case data must be
    a function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将数据作为对象而不是函数使用，那么响应性将适用于组件的所有实例。由于组件的主要目的是可重用的，因此重要的是要记住在这种情况下数据必须是一个函数。
- en: 'Props can also be defined as objects, which allows us to give them a lot more
    information: validate incoming data, set default values in case no data comes
    through, and so on.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Props也可以被定义为对象，这样我们可以给它们更多的信息：验证传入的数据，设置默认值（如果没有数据传入的话），等等。
- en: 'In the following example, we are stating that our `custom-article` component
    is expecting the parent to pass it a prop named `message`, or type string, which
    is required:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们声明我们的`custom-article`组件期望父组件传递一个名为`message`的prop，或者是字符串类型，这是必需的：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example is available at [https://codepen.io/AjdinImsirovic/pen/mKpxGZ](https://codepen.io/AjdinImsirovic/pen/mKpxGZ).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在[https://codepen.io/AjdinImsirovic/pen/mKpxGZ](https://codepen.io/AjdinImsirovic/pen/mKpxGZ)找到。
- en: Let's say we commented out the `datacontent` property of the Vue instance's `data` function.
    Can you guess what would happen?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们注释掉了Vue实例的`data`函数中的`datacontent`属性。你能猜到会发生什么吗？
- en: In other words, what would happen if `datacontent` is not providing the correct
    data? The child component will simply revert to its `default` property in the `props` object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果`datacontent`没有提供正确的数据会发生什么？子组件将简单地回到`props`对象中的`default`属性。
- en: To see this in action, visit this link: [https://codepen.io/AjdinImsirovic/pen/BVJxKL](https://codepen.io/AjdinImsirovic/pen/BVJxKL).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个实例的效果，请访问此链接：[https://codepen.io/AjdinImsirovic/pen/BVJxKL](https://codepen.io/AjdinImsirovic/pen/BVJxKL)。
- en: Other ways of building component templates in Vue
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue中构建组件模板的其他方法
- en: 'So far, we have looked at defining templates as strings (using single or double
    quotes) and as template literals (using backticks). There are also many other
    ways to work with component templates:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过将模板定义为字符串（使用单引号或双引号）和模板字面量（使用反引号）。还有许多其他处理组件模板的方法：
- en: Inline templates
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联模板
- en: X-templates
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X-templates
- en: Render functions
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染函数
- en: Single file components
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单文件组件
- en: JSX
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX
- en: Most of them have their pros and cons. For example, using JSX in Vue is possible
    but generally frowned upon, as it in not the Vue way of doing things. Inline templates
    are made using the `inline-template` attribute in your HTML.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它们大多都有各自的优缺点。例如，在Vue中使用JSX是可能的，但通常不被赞同，因为这不是Vue的做事方式。内联模板是使用HTML中的`inline-template`属性制作的。
- en: 'If you add `type=''''text/x-template''''` to an HTML script tag, you will make
    a Vue x-template. Here''s an example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在HTML的script标签中添加`type=''text/x-template''`，你将创建一个Vue x-template。以下是一个例子：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code pen for this example is available here: [https://codepen.io/AjdinImsirovic/pen/NzXyem](https://codepen.io/AjdinImsirovic/pen/NzXyem).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码笔可在此处找到：[https://codepen.io/AjdinImsirovic/pen/NzXyem](https://codepen.io/AjdinImsirovic/pen/NzXyem)。
- en: Single-file templates are probably the most practical way of creating templates
    in Vue. You keep all your HTML, JS, and styling in a single file (with a `.vue`
    file extension), and you compile this file with a build process, such as Webpack.
    We will look into this in later chapters when we cover the use of Webpack in Vue
    (with the help of Vue-cli).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 单文件模板可能是在Vue中创建模板的最实用方式。您可以将所有的HTML、JS和样式都放在一个文件中（使用`.vue`文件扩展名），然后使用构建过程（如Webpack）编译此文件。在后面的章节中，当我们使用Vue-cli（借助Vue中Webpack的使用）时，我们将深入研究这一点。
- en: Building a simple web page out of components
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过组件构建简单的网页
- en: As we have seen in the previous section, there are many ways to build a component
    in Vue, which might make things look more complex than they have to be. While
    it is important to be aware of the versatility that Vue brings to the various
    ways we can build components, in this section we will look at a simple way to
    use components to build a web page.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中所看到的，Vue中构建组件的方式有很多种，这可能会使事情看起来比必须复杂。虽然重要的是要意识到Vue为我们构建组件的各种方式带来的多样性，但在本节中，我们将看一种简单的使用组件构建网页的方式。
- en: 'Before we begin building out our page, one thing should be clear to us: each
    component in Vue is also just another Vue instance. This means that each component
    takes an options object, which has the same key value pairs as any other Vue instance.
    The only difference to this rule is that the root Vue instance has some additional
    options that can only be used in it.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建我们的页面之前，有一件事情应该对我们清楚：Vue中的每个组件也只是另一个Vue实例。这意味着每个组件都需要一个选项对象，其中包含与任何其他Vue实例相同的键值对。唯一的例外是根Vue实例具有一些额外的选项，只能在其中使用。
- en: After these introductory clarifications, let's see how a component can be added
    to a Vue instance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些介绍性的澄清之后，让我们看看如何将组件添加到Vue实例中。
- en: Adding simple components to a Vue instance
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将简单组件添加到Vue实例中
- en: To start off this example, we'll begin with a simple Vue instance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个示例之前，我们将从一个简单的Vue实例开始。
- en: 'In our JavaScript file, let''s make the simplest possible Vue instance, with
    the `#app` element as its entry point:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JavaScript文件中，让我们创建一个最简单的Vue实例，以`#app`元素作为其入口点：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s add just one div in our HTML, so that our Vue instance has an
    element in our page to get access to its DOM:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的HTML中添加一个div，这样我们的Vue实例就有了页面中的一个元素来访问其DOM：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we will add another component to our JavaScript file. Let''s extend our
    existing JS file by adding the following code to the very top:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在我们的JavaScript文件中添加另一个组件。让我们通过将以下代码添加到顶部来扩展我们现有的JS文件：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can simply add the custom `the-header` component inside our HTML:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的HTML中简单地添加自定义的`the-header`组件：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Doing this will render Our example header text on the screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将在屏幕上呈现我们的示例标题文本。
- en: Now that we have seen just how easy it is to add one simple component to our
    Vue apps, let's add another one to drive the point home.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了向我们的Vue应用程序添加一个简单组件有多么容易，让我们再添加一个来加强这一点。
- en: 'We''ll start by extending our JS file with another component, `the-footer`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从扩展我们的JS文件开始，添加另一个组件`the-footer`：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Of course, we need to update our HTML in order to make this work:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要更新我们的HTML以使其工作：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When naming custom components, we need to use hyphens. This is done to make
    sure there are no naming collisions with regular HTML elements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名自定义组件时，我们需要使用连字符。这样做是为了确保与常规HTML元素没有命名冲突。
- en: The example code for this section is available at [https://codepen.io/AjdinImsirovic/pen/qypBbz](https://codepen.io/AjdinImsirovic/pen/qypBbz).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本节示例代码可在此处找到：[https://codepen.io/AjdinImsirovic/pen/qypBbz](https://codepen.io/AjdinImsirovic/pen/qypBbz)。
- en: Now that we understand how to add a simple component to our Vue instance, let's
    practice by adding a more complex example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何向Vue实例添加简单组件，让我们通过添加一个更复杂的例子来练习。
- en: Creating a more complex page out of components in Vue
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Vue中创建由组件组成的更复杂的页面
- en: To begin, let's add a single component to our new Vue instance. This time, we
    will employ the data option inside our custom component's options object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向我们的新Vue实例中添加一个组件。这次，我们将在自定义组件的选项对象中使用数据选项。
- en: 'This is the code we start with:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们开始的代码：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code, we have added mustache syntax to our template. Then we have utilized
    the data option to return the text, which will be interpolated in the template.
    The mustache syntax tells our component to look for the `header` inside our data
    option.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们已经在模板中添加了mustache语法。然后我们利用了数据选项来返回将在模板中插值的文本。mustache语法告诉我们的组件在数据选项中查找`header`。
- en: 'The code for this example is available here: [https://codepen.io/AjdinImsirovic/pen/wxpvxy](https://codepen.io/AjdinImsirovic/pen/wxpvxy).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码在此处可用：[https://codepen.io/AjdinImsirovic/pen/wxpvxy](https://codepen.io/AjdinImsirovic/pen/wxpvxy)。
- en: Next, under our header, we'll add some Bootstrap cards.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的页眉下，我们将添加一些Bootstrap卡片。
- en: 'For simplicity''s sake, we''ll use an existing example from the official Bootstrap
    documentation, which is available at the following URL: [https://getbootstrap.com/docs/4.0/components/card/#using-grid-markup](https://getbootstrap.com/docs/4.0/components/card/#using-grid-markup).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们将使用官方Bootstrap文档中的现有示例，该示例位于以下URL：[https://getbootstrap.com/docs/4.0/components/card/#using-grid-markup](https://getbootstrap.com/docs/4.0/components/card/#using-grid-markup)。
- en: 'The example provides the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例提供了以下代码：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Although the Bootstrap framework is not the subject of this book, it will be
    useful for us to give a real-world example of using Vue components in practice.
    Since Bootstrap has basically become the industry standard for frontend frameworks,
    it is the perfect candidate for showing not only how Vue components are used in
    general, but also how they can be incorporated with other frontend technologies.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Bootstrap框架不是本书的主题，但对我们来说，给出一个在实践中使用Vue组件的真实例子将是有用的。由于Bootstrap基本上已成为前端框架的行业标准，它是展示Vue组件不仅如何一般使用，而且如何与其他前端技术结合的完美候选者。
- en: 'Now let''s see how we can add a single card to our example Vue webpage. This
    is the code to add to our JS:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何向我们的Vue网页示例中添加一个单个卡片。这是要添加到我们的JS中的代码：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The code for this stage of the development of our code is available here: [https://codepen.io/AjdinImsirovic/pen/VByYeW](https://codepen.io/AjdinImsirovic/pen/VByYeW).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码开发的这个阶段的代码在这里可用：[https://codepen.io/AjdinImsirovic/pen/VByYeW](https://codepen.io/AjdinImsirovic/pen/VByYeW)。
- en: 'Next, let''s add our card component to our HTML. The full updated code will
    look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们的卡片组件添加到我们的HTML中。完整的更新代码将如下所示：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Adding the previous code to our HTML, with the JS updates already in place
    as described earlier, we will get the following result:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码添加到我们的HTML中，并根据之前描述的进行JS更新，我们将得到以下结果：
- en: '![](assets/063612e2-9c2b-4121-8243-2e3a46dac0d3.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/063612e2-9c2b-4121-8243-2e3a46dac0d3.png)'
- en: We have added a single card component in our JS; however, as we can see in the
    previous example, we can now reuse it in our HTML as many times as needed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在JS中添加了一个单独的卡片组件；然而，正如我们在之前的例子中看到的，我们现在可以根据需要在HTML中重复使用它。
- en: This gives us an excellent opportunity to quickly prototype complete web pages
    with the help of Vue.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个绝佳的机会，借助Vue快速原型设计完整的网页。
- en: We can take it even one step further, as we'll see in the next section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以进一步进行，正如我们将在下一节中看到的。
- en: Improving our Vue-based layouts with v-for
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用v-for改进我们基于Vue的布局
- en: In this section, we will improve our existing web page with the help of Vue
    directives.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将通过Vue指令来改进我们现有的网页。
- en: Our specific goal is to try to use the data option in our component instance
    and combine it with the powers of Vue directives to further improve our Vue apps.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的具体目标是尝试在组件实例中使用数据选项，并结合Vue指令的功能来进一步改进我们的Vue应用程序。
- en: The code for this section is available at [https://codepen.io/AjdinImsirovic/pen/Epoamy](https://codepen.io/AjdinImsirovic/pen/Epoamy).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分的代码可在[https://codepen.io/AjdinImsirovic/pen/Epoamy](https://codepen.io/AjdinImsirovic/pen/Epoamy)中找到。
- en: 'Let''s make our JS a bit easier to read with the help of the backtick ES6 JS
    syntax. This syntax allows us to write JavaScript strings which span multiple
    lines:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用ES6的反引号语法使我们的JS更容易阅读。这种语法允许我们编写跨多行的JavaScript字符串：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s add the `data` option to the `the-card` Vue component:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`data`选项添加到`the-card` Vue组件中：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see in the preceding code, we are returning a `customCard` array of
    objects, with each object holding a specific `heading` and `text`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，我们返回了一个包含特定`heading`和`text`的`customCard`对象数组。
- en: 'Next, we can use the `v-for` directive in our template, like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在我们的模板中使用`v-for`指令，就像这样：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We introduce the `v-for` directive in the `div` that has the class of `card-body`.
    We loop through each `customCard` in our collection of `customCards`, and we interpolate
    the `h5` text's content with `customCard.heading` for each object of our `customCard`
    array.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在具有`card-body`类的`div`中引入`v-for`指令。我们循环遍历我们的`customCards`集合中的每个`customCard`，并为我们`customCard`数组中的每个对象的`h5`文本内容插入`customCard.heading`。
- en: Finally, let's add a Bootstrap class to our HTML so that the `h1` tag of our
    web page is not glued to the very top of the viewport. For that, we will use Bootstrap's
    spacing utilities. You can read about them here: [https://getbootstrap.com/docs/4.0/utilities/spacing/](https://getbootstrap.com/docs/4.0/utilities/spacing/).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在HTML中添加一个Bootstrap类，这样我们网页的`h1`标签就不会紧贴在视口的顶部。为此，我们将使用Bootstrap的间距实用程序。您可以在这里阅读有关它们的信息：[https://getbootstrap.com/docs/4.0/utilities/spacing/](https://getbootstrap.com/docs/4.0/utilities/spacing/)。
- en: 'The change in our HTML will be minimal, with just an addition of another CSS
    class: `mt-5`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML中的更改将是最小的，只是添加了另一个CSS类：`mt-5`。
- en: 'Finally, what follows is the complete JS code for the improved page. First,
    we register the main title component:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是改进页面的完整JS代码。首先，我们注册主标题组件：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then we register the `list group` component:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们注册`list group`组件：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After that, we register the `card` component:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们注册了`card`组件：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We also add the `root instance`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了`root instance`：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And here is the HTML:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是HTML：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result of adding the previous code can be seen in this screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 添加上述代码的结果可以在此截图中看到：
- en: '![](assets/fe9ea47d-d62d-4da1-88a5-c7a3f0c12356.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fe9ea47d-d62d-4da1-88a5-c7a3f0c12356.png)'
- en: In this section, we have looked at components and how to get started with using
    them. Next, we'll discuss watchers in Vue.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们已经看过组件以及如何开始使用它们。接下来，我们将讨论Vue中的观察者。
- en: Watchers in Vue
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue中的观察者
- en: Every component in Vue has a watcher.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Vue中的每个组件都有一个观察者。
- en: To understand how this works, let's begin with an earlier example from this
    chapter. The example is from the *Computed properties* section, at this link: [https://codepen.io/AjdinImsirovic/pen/qKVyry](https://codepen.io/AjdinImsirovic/pen/qKVyry).
    That is our starting code. As we know from the previous section, we have two input
    fields here and we are printing out the values entered into these input fields
    in some span tags under the form.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这是如何工作的，让我们从本章的一个早期例子开始。这个例子来自*计算属性*部分，链接在这里：[https://codepen.io/AjdinImsirovic/pen/qKVyry](https://codepen.io/AjdinImsirovic/pen/qKVyry)。这是我们的起始代码。正如我们从前一节知道的，这里有两个输入字段，我们正在打印出这些输入字段中输入的值在表单下的一些span标签中。
- en: 'Let''s extend our example. The initial code is the same; we will only be adding
    a watcher to it. The updated code can be found at this Codepen URL: [https://codepen.io/AjdinImsirovic/pen/jprwKe](https://codepen.io/AjdinImsirovic/pen/jprwKe).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的例子。初始代码是一样的；我们只会添加一个观察者。更新后的代码可以在这个Codepen URL找到：[https://codepen.io/AjdinImsirovic/pen/jprwKe](https://codepen.io/AjdinImsirovic/pen/jprwKe)。
- en: 'As can be observed, the only update we made to the original pen is the addition
    of the watchers option, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到，我们对原始笔记本唯一的更新是添加了观察者选项，如下所示：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'How does the previous watcher work? It allows us to use a method that must
    have the same name as the computed property we are watching in our HTML. The watcher
    has optional parameters we can pass to it to be worked with in the body of the
    method; in this case, we gave our optional parameters some nice and descriptive
    names: `previousValue` and `currentValue`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的观察者是如何工作的？它允许我们使用一个方法，该方法的名称必须与我们在HTML中观察的计算属性相同。观察者有可选参数，我们可以将这些参数传递给它，在方法体中使用；在这种情况下，我们给我们的可选参数一些好的和描述性的名称：`previousValue`和`currentValue`。
- en: In the body of the `watch` method, we are logging out changes to input values
    to the JavaScript console. An elegant way of testing how this works is to, for
    example, highlight the *for example* section of the initial value of the first
    input field and simply erase it, leaving only the value of *Old McDonald* in the
    input.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`watch`方法的主体中，我们正在记录输入值的更改到JavaScript控制台。测试这样工作的一个优雅的方法是，例如，突出显示第一个输入字段的初始值的*例如*部分，然后简单地擦除它，只留下输入中的*Old
    McDonald*的值。
- en: 'Doing this would result in the following sentence being logged to the console:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会导致以下句子被记录到控制台中：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the next section, we will be looking at how to hook into various stages of
    a component's life and alter its behavior at that specific point with custom code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何在组件的生命周期的各个阶段挂钩，并在那个特定点用自定义代码改变其行为。
- en: Lifecycle hooks
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期钩子
- en: Life cycle hooks are methods that let us alter the behavior of components at
    various stages of their life cycle.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子是让我们在组件生命周期的各个阶段改变组件行为的方法。
- en: What is a component's lifecycle?
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是组件的生命周期？
- en: It's just the natural progression of the *life* of a component.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是组件*生命周期*的自然进展。
- en: Thus, we can say that lifecycle hooks are *points* along this journey that each
    component needs to go through. At these specific *points* in a component's life,
    we can use these methods to alter a component's behavior.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以说生命周期钩子是这个旅程中每个组件都需要经历的*点*。在组件生命周期的这些特定*点*，我们可以使用这些方法来改变组件的行为。
- en: 'The Vue team has chosen very descriptive names for these lifecycle methods.
    What follows is the list of lifecycle hooks organized in the order of the natural
    progression of a component''s life:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Vue团队为这些生命周期方法选择了非常描述性的名称。接下来是按组件生命周期的自然进展顺序组织的生命周期钩子列表：
- en: '`beforeCreate`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeCreate`'
- en: '`created`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`'
- en: '`beforeMount`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeMount`'
- en: '`mounted`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mounted`'
- en: '`beforeUpdate`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeUpdate`'
- en: '`updated`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated`'
- en: '`activated`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activated`'
- en: '`deactivated`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deactivated`'
- en: '`beforeDestroy`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeDestroy`'
- en: '`destroyed`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroyed`'
- en: 'This visual representation of a component''s lifecycle is available at this
    address: [https://vuejs.org/images/life cycle.png](https://vuejs.org/images/lifecycle.png).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件生命周期的可视化表示可以在这个地址找到：[https://vuejs.org/images/lifecycle.png](https://vuejs.org/images/lifecycle.png)。
- en: Note that it would be beneficial that you print this image out and keep it with
    you until you fully understand the information it conveys. This will be of great
    help for getting a deeper understanding of Vue in general, and its component lifecycle
    in particular.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，打印出这张图片并随身携带直到完全理解它所传达的信息将是有益的。这将对更深入地理解Vue总体以及其组件生命周期特别有帮助。
- en: As we can see, there are five distinct stages of a component's life, and each
    stage has a lifecycle hook before a specific stage begins, and another lifecycle
    hook for after it is completed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，组件的生命周期有五个不同的阶段，每个阶段在特定阶段开始之前有一个生命周期钩子，以及在完成后有另一个生命周期钩子。
- en: It is important to note that a component can be mounted several times, based
    on the changes in the data model. This is verifiable in the lifecycle diagram
    referenced in the previous tip box. However, it is also crucial to understand
    that the DOM re-rendering that takes place when the underlying data is changed
    can result in a component being effectively *unmounted,* even though this is not
    explicitly mentioned anywhere in the lifecycle diagram.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，一个组件可以根据数据模型的变化被多次挂载。这在之前的提示框中引用的生命周期图中是可以验证的。然而，同样重要的是要理解，当底层数据发生变化时，DOM重新渲染可能会导致组件被有效地*卸载*，尽管这在生命周期图中没有明确提到。
- en: How do we use lifecycle hooks?
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何使用生命周期钩子？
- en: 'Let''s look at a simple example, available at this Codepen URL: [https://codepen.io/AjdinImsirovic/pen/jprmoa](https://codepen.io/AjdinImsirovic/pen/jprmoa).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，可以在这个Codepen网址找到：[https://codepen.io/AjdinImsirovic/pen/jprmoa](https://codepen.io/AjdinImsirovic/pen/jprmoa)。
- en: 'To begin with, let''s add the HTML:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加HTML：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, let''s add the CSS:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加CSS：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And finally, the JS:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，JS部分：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As can be seen in the Codepen provided, it is really easy to hook into life
    cycle methods in Vue. It's just a matter of providing the desired code (functionality)
    to the life cycle hook method name in the Vue instance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如在提供的Codepen中所示，很容易在Vue中钩入生命周期方法。只需要在Vue实例中的生命周期钩子方法名称中提供所需的代码（功能）即可。
- en: In the previous example, we are showing an alert for the `beforeCreate()` method,
    and we are showing another alert 5 seconds after the `created()` method has been
    run.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们展示了`beforeCreate()`方法的警报，并且在`created()`方法运行后5秒钟显示另一个警报。
- en: There are many more useful things to do with life cycle hooks, which will be
    covered in the chapters which follow.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子还有许多有用的用途，这将在接下来的章节中介绍。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at some basic concepts in Vue. We described why these
    concepts are important and how they can be used. We also looked at several simple
    examples of using these concepts in practice.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Vue中的一些基本概念。我们描述了为什么这些概念很重要以及它们如何被使用。我们还看了一些在实践中使用这些概念的简单例子。
- en: We learned about data-driven views in Vue and reactivity as a way to keep track
    of the changes to the data model. We looked at using computed properties and methods,
    directives, and their modifiers. We have seen some practical examples of components,
    templates, and props, as well as different approaches to building component templates
    in Vue.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了Vue中的数据驱动视图以及响应性作为跟踪数据模型变化的一种方式。我们看了使用计算属性和方法、指令及其修饰符的方法。我们已经看到了一些关于组件、模板和props的实际例子，以及在Vue中构建组件模板的不同方法。
- en: We learned how to prototype websites using Vue components and directives, and
    we wrapped up the chapter with a look at watchers and lifecycle hooks as a powerful
    way to alter the behavior of components at any point of their lifecycle.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用Vue组件和指令原型化网站，并在本章中结束时，我们看了一下watchers和生命周期钩子，作为改变组件行为的强大方式，可以在它们的生命周期的任何时刻进行。
- en: In the next chapter, we will further delve into reactive programming in Vue
    with a focus on components, props, and slots.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步深入研究Vue中的响应式编程，重点关注组件、props和插槽。
