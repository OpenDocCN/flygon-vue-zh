- en: Creating Chat and Message Vuex, Pages, and Routes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Chat和Message Vuex、页面和路由
- en: In this chapter, we will finalize the application and create the final parts.
    This chapter will finish the development of the application, making it ready to
    create a final product for deployment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将完成应用程序并创建最终部分。本章将完成应用程序的开发，使其准备好为部署创建最终产品。
- en: Here you will learn how to create GraphQL queries and fragments, create the
    Chat Vuex module and business rules, create the contacts page and components used
    in the page, and finally the messages page with the components needed for creating
    the page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将学习如何创建GraphQL查询和片段，创建Chat Vuex模块和业务规则，创建联系人页面和页面中使用的组件，最后创建消息页面和创建页面所需的组件。
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Creating GraphQL queries and fragments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建GraphQL查询和片段
- en: Creating the Chat Vuex module on your application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序上创建Chat Vuex模块
- en: Creating the Contacts page of your application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建应用程序的联系人页面
- en: Creating the Messages page of your application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建应用程序的消息页面
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be using **Node.js**, **AWS Amplify**,and **Quasar
    Framework**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Node.js，AWS Amplify和Quasar Framework。
- en: 'Attention, Windows users! You need to install an `npm` package called `windows-build-tools`
    to be able to install the required packages. To do it, open PowerShell as an administrator
    and execute the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Windows用户！您需要安装一个名为`windows-build-tools`的`npm`包，以便能够安装所需的包。要执行此操作，请以管理员身份打开PowerShell并执行以下命令：
- en: '`> npm install -g windows-build-tools`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`> npm install -g windows-build-tools`'
- en: 'To install **Quasar Framework**, you need to open Terminal (macOS or Linux)
    or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装**Quasar Framework**，您需要打开Terminal（macOS或Linux）或Command Prompt/PowerShell（Windows）并执行以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To install **AWS Amplify****,** you need to open Terminal (macOS or Linux)
    or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装**AWS Amplify**，您需要打开Terminal（macOS或Linux）或Command Prompt/PowerShell（Windows）并执行以下命令：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating GraphQL queries and fragments
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建GraphQL查询和片段
- en: In GraphQL, it is possible to create a straightforward query to fetch only the
    data you want. By doing this, your code can reduce the usage of your user network
    and processing power. This technique is also known as **fragments**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL中，可以创建一个简单的查询来获取您想要的数据。通过这样做，您的代码可以减少用户网络和处理能力的使用。这种技术也被称为**片段**。
- en: In this recipe, we will learn how to create GraphQL fragments and use them in
    our application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何创建GraphQL片段并在我们的应用程序中使用它们。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The prerequisites for this recipe are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的先决条件如下：
- en: The project from the *Creating User pages and routes for your application* recipe
    in [Chapter 5](39414f7b-02f2-400c-a1e0-0a0cbf12151a.xhtml), *Creating the User
    Vuex Module, Pages, and Routes*
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](39414f7b-02f2-400c-a1e0-0a0cbf12151a.xhtml)的食谱*为您的应用程序创建用户页面和路由*中的项目，创建用户Vuex模块、页面和路由
- en: Node.js 12+
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Node.js全局对象如下：
- en: '`@aws-amplify/cli`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@aws-amplify/cli`'
- en: '`@quasar/cli`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@quasar/cli`'
- en: To start our GraphQL fragments that will be used on the application, we will
    continue with the project that we created in [Chapter 5](39414f7b-02f2-400c-a1e0-0a0cbf12151a.xhtml)*,
    Creating the User Vuex Module, Pages, and Routes*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们将在应用程序中使用的GraphQL片段，我们将继续使用我们在[第5章](39414f7b-02f2-400c-a1e0-0a0cbf12151a.xhtml)中创建的项目，创建用户Vuex模块、页面和路由。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will create the fragments needed in our application, and
    replace some of the code that we wrote in the last recipes with the fragments
    created here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建应用程序中所需的片段，并用这里创建的片段替换我们在上一个配方中编写的一些代码。
- en: Creating the GraphQL fragments
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建GraphQL片段
- en: 'Here we will create all the fragments that we will use in our application:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建我们在应用程序中将使用的所有片段：
- en: Create a file named `fragments.js` in the `src/graphql` folder and open it.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/graphql`文件夹中创建一个名为`fragments.js`的文件并打开它。
- en: 'Then, we need to import the `graphql` language interpreter:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要导入`graphql`语言解释器：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s create the `getUser` fragment to fetch the user information. This fragment
    will get basic information about the user. First, we need to start the `graphql` interpreter,
    and then pass the template literal string with our query. Using the `getUser` query
    as the base query, we will create a query schema with only the data that we want
    to fetch from the server:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建`getUser`片段来获取用户信息。这个片段将获取用户的基本信息。首先，我们需要启动`graphql`解释器，然后传递带有我们查询的模板文字字符串。使用`getUser`查询作为基本查询，我们将创建一个只包含我们想要从服务器获取的数据的查询模式：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The template literal in the ES2015 specification provides a new feature called
    tagged templates or tag functions. Those are used to pre-process the string on
    the template literal before using the string that is attached to it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015规范中的模板文字提供了一个称为标记模板或标记函数的新功能。这些用于在使用附加到它的字符串之前预处理模板文字上的字符串。
- en: 'Then we will create the `listUsers` fragment to fetch all the users in our
    application. This fragment will use the `listUsers` query from the base queries
    that were created from AWS Amplify. Then it will return all the current users
    in our application with the basic information from them:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将创建`listUsers`片段来获取应用程序中的所有用户。这个片段将使用从AWS Amplify创建的基本查询中的`listUsers`查询。然后它将返回我们应用程序中所有当前用户的基本信息：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To finish the user fragments, we will create the `getUserAndConversations` fragment
    to fetch the user basic information and their last 10 conversations. This fragment
    is based on the `GetUser` query:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成用户片段，我们将创建`getUserAndConversations`片段来获取用户的基本信息和他们最近的10次对话。这个片段基于`GetUser`查询：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For fetching the user conversations, we will create a fragment named `getConversation`, based
    on the `GetConversation` query, that gets the last 1,000 messages and the conversation
    members from the user in the current conversation ID:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取用户对话，我们将创建一个名为`getConversation`的片段，基于`GetConversation`查询，从当前对话ID的用户那里获取最后1,000条消息和对话成员：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To create a new message in our API, we need to create a fragment called `createMessage`.
    This fragment is based on the `CreateMessage` mutation. The fragment will receive `id`, `authorId`, `content`, `messageConversationId`,
    and `createdAt`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在我们的API中创建新的消息，我们需要创建一个名为`createMessage`的片段。这个片段基于`CreateMessage`变异。片段将接收`id`、`authorId`、`content`、`messageConversationId`和`createdAt`：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To start a new conversation between two users, we need to create a new fragment
    called `createConversation`. This fragment is based on the `CreateConversation` mutation;
    it will receive the `name` of the conversation, and the `members` list of the
    conversation that is being created:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在两个用户之间开始新的对话，我们需要创建一个名为`createConversation`的新片段。这个片段基于`CreateConversation`变异；它将接收对话的`name`和正在创建的对话的`members`列表：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we will finish our fragments with the `createConversationLink` fragment,
    which is based on the `CreateConversationLink` mutation. This fragment will link
    the conversations created in our application and generate a unique ID. For this
    to work, this fragment needs to receive the `conversationLinkConversationId` and `conversationLinkUserId`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用基于CreateConversationLink变异的createConversationLink片段完成我们的片段。此片段将链接在我们的应用程序中创建的对话并生成唯一ID。为使其工作，此片段需要接收conversationLinkConversationId和conversationLinkUserId：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we will export all the fragments that we created to a JavaScript object:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将导出我们创建的所有片段到JavaScript对象中：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Applying fragments on the User Vuex actions
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将片段应用于User Vuex操作
- en: 'Now we can update the User Vuex actions to use the fragments that we created:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新User Vuex操作以使用我们创建的片段：
- en: Open the `actions.js` file in the `store/user` folder.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在store/user文件夹中打开actions.js文件。
- en: 'In the `import` section, we will replace `getUser` and `listUsers` from `src/graphql/queries`,
    with the newly created `src/graphql/fragments`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“import”部分，我们将从src/graphql/queries替换getUser和listUsers为新创建的src/graphql/fragments。
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the GraphQL query language, we were able to create small queries and mutations,
    called fragments, which can execute parts of the original query or mutation, and
    return the same response but with the data that we requested.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GraphQL查询语言，我们能够创建小查询和变异，称为片段，可以执行原始查询或变异的部分，并返回相同的响应，但包含我们请求的数据。
- en: By doing this, the amount of data usage in our application was reduced, and
    the processing power to iterate over the data is reduced too.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们的应用程序数据使用量减少了，遍历数据的处理能力也减少了。
- en: The GraphQL fragments work the same as the query or the mutation that is being
    used as the base. This happens because GraphQL uses the same schema, queries,
    and mutations as the base. By doing this, you can use the same variables on the
    search and mutations that were declared on the query or mutation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL片段与作为基础的查询或变异相同。这是因为GraphQL使用相同的模式、查询和变异作为基础。通过这样做，您可以在搜索和变异中使用在查询或变异中声明的相同变量。
- en: Because we used the same name as the base query when we replaced the imported
    code on the User Vuex action, we didn't have to change anything, as the result
    of the request will be the same as the old one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在替换User Vuex操作中导入的代码时使用了相同的名称作为基础查询，所以我们不需要更改任何内容，因为请求的结果将与旧的结果相同。
- en: See also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Find more information about template literal tag functions at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)找到有关模板文字标签函数的更多信息。
- en: Find more information about GraphQL queries, mutations, and fragments at [https://graphql.org/learn/queries/](https://graphql.org/learn/queries/).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://graphql.org/learn/queries/](https://graphql.org/learn/queries/)找到有关GraphQL查询、变异和片段的更多信息。
- en: Creating the Chat Vuex module on your application
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的应用程序上创建Chat Vuex模块
- en: To create a chat application, we need to create custom business rules for the
    chat part of the application. This part will hold all the logic between fetching
    new messages, sending messages, and starting new conversations between users.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建聊天应用程序，我们需要为应用程序的聊天部分创建自定义业务规则。这部分将包含获取新消息、发送消息和在用户之间开始新对话的所有逻辑。
- en: In this recipe, we will create the Chat module in the application Vuex, where
    we will store all the messages between the logged user and other users, fetch
    new messages, send new messages, and start new conversations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将在应用程序的 Vuex 中创建 Chat 模块，其中我们将存储已登录用户和其他用户之间的所有消息，获取新消息，发送新消息，并开始新对话。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The prerequisites for this recipe are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此教程的先决条件如下：
- en: The project from the previous recipe
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自上一个教程的项目
- en: Node.js 12+
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的 Node.js 全局对象如下：
- en: '`@aws-amplify/cli`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@aws-amplify/cli`'
- en: '`@quasar/cli`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@quasar/cli`'
- en: To start our Chat Vuex module, we will continue with the project that was created
    in the *Creating GraphQL queries and fragments *recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的 Chat Vuex 模块，我们将继续使用在 *创建 GraphQL 查询和片段* 教程中创建的项目。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For the creation of the Chat Vuex module, we will split our tasks into five
    parts: creating the **state**, **mutations**, **getters**, and **actions**, then
    adding the module to Vuex.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建 Chat Vuex 模块，我们将把任务分成五个部分：创建 **state**、**mutations**、**getters** 和 **actions**，然后将模块添加到
    Vuex。
- en: Creating the Chat Vuex state
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Chat Vuex 状态
- en: 'In order to store the data on a Vuex module, we need a state that will have
    the data stored. Here we will create the Chat state:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Vuex 模块上存储数据，我们需要一个具有存储数据的状态。在这里，我们将创建 Chat 状态：
- en: Create a new folder called `chat` in the `store` folder and then create a new
    file called `state.js`, and open it.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 store 文件夹中创建一个名为 `chat` 的新文件夹，然后创建一个名为 `state.js` 的新文件，并打开它。
- en: 'Create a new function called `createState`, which returns a JavaScript object
    with the properties of `conversations`, `messages`, `loading`, and `error`. The `conversations` and `messages` properties
    will be defined as an empty array, the `loading` property will be defined as `false`,
    and `error` is `undefined`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `createState` 的新函数，它返回一个具有 `conversations`、`messages`、`loading` 和 `error`
    属性的 JavaScript 对象。`conversations` 和 `messages` 属性将被定义为空数组，`loading` 属性将被定义为 `false`，`error`
    为 `undefined`：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, in order to export the state as a singleton, and make it available
    as a JavaScript object, we need to `export default` the execution of the `createState` function:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了将状态导出为单例，并将其作为 JavaScript 对象可用，我们需要将 `createState` 函数的执行导出为默认值：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating the Chat Vuex mutations
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Chat Vuex mutations
- en: 'Now to save any data on a state, Vuex needs a mutation. For this, we will create
    the Chat mutation that will manage the mutations for this module:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要在状态上保存任何数据，Vuex 需要一个 mutation。为此，我们将创建 Chat mutation，用于管理此模块的 mutations：
- en: Create a new file called `types.js` in the `store/chat` folder, and open it.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 store/chat 文件夹中创建一个名为 `types.js` 的新文件，并打开它。
- en: 'In the file, export a default JavaScript object with properties that are the
    same as the values of the strings. The properties will be `SET_CONVERSATIONS`, `SET_MESSAGES`, `LOADING`,
    and `ERROR`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中，导出一个默认的 JavaScript 对象，其属性与字符串的值相同。属性将是 `SET_CONVERSATIONS`、`SET_MESSAGES`、`LOADING`
    和 `ERROR`：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create a new file called `mutations.js` in the `store/chat` folder, and open
    it.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 store/chat 文件夹中创建一个名为 `mutations.js` 的新文件，并打开它。
- en: 'Import the newly created `types.js` file:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入新创建的 `types.js` 文件：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a new function called `setLoading` with `state` as the first argument.
    Inside we will define `state.loading` as `true`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `setLoading` 的新函数，以 `state` 作为第一个参数。在其中，我们将定义 `state.loading` 为 `true`：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a new function called `setError`, with`state` as the first argument,
    and `error` as the second with a default value of `new Error()`. Inside we will
    define the `state.error` as `error` and `state.loading` to `false`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `setError` 的新函数，以 `state` 作为第一个参数，`error` 作为第二个参数，其默认值为 `new Error()`。在其中，我们将定义
    `state.error` 为 `error`，并将 `state.loading` 定义为 `false`：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a new function called `setConversations`, with the `state` as the first
    argument, and a JavaScript object as the second, with the  `items` property. With
    that, we will define the state conversation with the received array:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`setConversations`的新函数，第一个参数是`state`，第二个参数是JavaScript对象，具有`items`属性。通过这样做，我们将使用接收到的数组定义状态对话：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a new function called `setMessages`, with `state` as the first argument
    and a JavaScript object as the second. In this function, we will try to find if
    there are any messages with the `id` equal to  `id` received on  `payload`, and
    then add the messages to the state:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`setMessages`的新函数，第一个参数是`state`，第二个参数是JavaScript对象。在这个函数中，我们将尝试查找是否有与`payload`中接收到的`id`相等的消息，并将消息添加到状态中：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, export a default JavaScript object, with the keys being the imported
    mutation types and the values as the functions that correspond to each type:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，导出一个默认的JavaScript对象，其中键是导入的mutation类型，值是对应于每种类型的函数：
- en: Define `MT.LOADING` as `setLoading`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`MT.LOADING`定义为`setLoading`。
- en: Define `MT.ERROR` as `setError`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`MT.ERROR`定义为`setError`。
- en: Define `MT.SET_CONVERSATION` as `setConversations`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`MT.SET_CONVERSATION`定义为`setConversations`。
- en: 'Define `MT.SET_MESSAGES` as `setMessages`:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`MT.SET_MESSAGES`定义为`setMessages`：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating the Chat Vuex getters
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Chat Vuex getters
- en: 'To access the data stored on the state, we need to create the `getters`. Here
    we will create the `getters` for the Chat module:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 访问存储在状态中的数据，我们需要创建`getters`。在这里，我们将为Chat模块创建`getters`：
- en: In a `getter` function, the first argument that that function will receive will
    always be the current `state` of the Vuex `store`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getter`函数中，该函数将接收的第一个参数始终是Vuex `store`的当前`state`。
- en: Create a new file called `getters.js` in the `store/chat` folder.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`store/chat`文件夹中创建一个名为`getters.js`的新文件。
- en: 'Create a new function called `getConversations`. This function starts by receiving `state`, `_getters`, `_rootState`,
    and `rootGetters` in the first part of the currying function. Finally, it will
    return a filtered list of the conversations between the user and another user
    on the application:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`getConversations`的新函数。该函数首先接收`state`，`_getters`，`_rootState`和`rootGetters`作为柯里化函数的第一部分。最后，它将返回用户和应用程序中另一个用户之间的对话的筛选列表：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`_variable` (underscore variable) is a technique used in JavaScript to indicate
    that the function created can have those arguments, but it won''t use them for
    now. In our case, the Vuex getters API always executes every getter call passing
    `state`, `getters`, `rootState`, and `rootGetters`, because with the linter rule,
    we added underscores to the unused arguments.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`_variable`（下划线变量）是JavaScript中用于指示创建的函数可以具有这些参数，但目前不会使用它们的技术。在我们的情况下，Vuex getters
    API始终执行每个getter调用，传递`state`，`getters`，`rootState`和`rootGetters`，因为根据linter规则，我们为未使用的参数添加了下划线。'
- en: 'Create a new function called `getChatMessages`, which is a getter using the
    method call. First, we pass `state`, then return a function receiving `convId`.
    Finally, it will return the list of messages from that conversation ID:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`getChatMessages`的新函数，这是一个使用方法调用的getter。首先，我们传递`state`，然后返回一个接收`convId`的函数。最后，它将返回该对话ID的消息列表：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a new function called `isLoading`, which returns `state.loading`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`isLoading`的新函数，返回`state.loading`：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a new function called `hasError`, which returns `state.error`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`hasError`的新函数，返回`state.error`：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, export a `default` JavaScript object with the created functions as
    properties: `getConversations`, `getChatMessages`, `isLoading`, and `hasError`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，导出一个默认的JavaScript对象，其中包含创建的函数作为属性：`getConversations`，`getChatMessages`，`isLoading`和`hasError`：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating the Chat Vuex actions
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Chat Vuex actions
- en: 'Here we will create the Chat module''s Vuex actions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建Chat模块的Vuex actions：
- en: Create a file called `actions.js` in the `store/chat` folder, and open it.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`store/chat`文件夹中创建一个名为`actions.js`的文件，并打开它。
- en: 'First, we need to import the functions, enums, and classes to be used in this
    part:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入在这部分中要使用的函数、枚举和类：
- en: Import `graphqlOperation` from the `aws-amplify` package.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`aws-amplify`包中导入`graphqlOperation`。
- en: Import `getUserAndConversations`, `createConversation`, `createConversationLink`, `createMessage` and `getConversation` from
    `src/graphql/fragments.js`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`src/graphql/fragments.js`导入`getUserAndConversations`，`createConversation`，`createConversationLink`，`createMessage`和`getConversation`。
- en: Import the `getCurrentAuthUser` function from `driver/auth.js`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`driver/auth.js`导入`getCurrentAuthUser`函数。
- en: Import `AuthAPI` from `driver/appsync`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`driver/appsync`导入`AuthAPI`。
- en: 'Import the Vuex mutation types from `./types.js`:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`./types.js`导入Vuex变异类型：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create an asynchronous function called `newConversation`. In the first argument,
    we will add `_vuex`, and use a JavaScript object as the second argument, receiving `authorId` and `otherUserId` as
    the properties. In this function, we will create a new conversation based on the
    received payload. Then we need to create the relationship between the conversation
    and the users in the conversation. Finally, we return the ID of the conversation
    and the name of it:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`newConversation`的异步函数。在第一个参数中，我们将添加`_vuex`，并使用一个JavaScript对象作为第二个参数，接收`authorId`和`otherUserId`作为属性。在这个函数中，我们将根据接收到的载荷创建一个新的对话。然后我们需要创建对话和对话中用户之间的关系。最后，我们返回对话的ID和名称：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For sending a new message to a user, we need to create an `asynchronous` function
    called `newMessage`. This function will receive a deconstructed JavaScript object in
    the first argument with the `commit` variable, and as the second argument, another
    deconstructed JavaScript object with the `message` and `conversationId` properties. Then,
    in the function, we need to fetch the user''s `username` and return the GraphQL `createMessage` mutation,
    passing the variables, with `id` defined as `uid()`, `authorID` as `username`, `content` as `message`, `messageConversationId` as `conversationId`,
    and `createdAt` as `Date.now()`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了向用户发送新消息，我们需要创建一个名为`newMessage`的异步函数。这个函数将在第一个参数中接收一个解构的JavaScript对象，其中包含`commit`变量，并作为第二个参数，另一个解构的JavaScript对象，其中包含`message`和`conversationId`属性。然后，在函数中，我们需要获取用户的`username`并返回GraphQL的`createMessage`变异，传递变量，其中`id`定义为`uid()`，`authorID`定义为`username`，`content`定义为`message`，`messageConversationId`定义为`conversationId`，`createdAt`定义为`Date.now()`：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To get the initial user messages, we need to create the `getMessages` asynchronous
    function. This function will receive a deconstructed JavaScript object in the
    first argument, with the `commit`variable. Inside this function, we need to get
    the `id` of the authenticated user, and then execute the GraphQL `getUserAndConversations` mutation to
    fetch all the current user `conversations`, pass them to the mutations, and return
    them:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取初始用户消息，我们需要创建一个名为`getMessages`的异步函数。这个函数将在第一个参数中接收一个解构的JavaScript对象，其中包含`commit`变量。在这个函数内部，我们需要获取经过身份验证的用户的`id`，然后执行GraphQL的`getUserAndConversations`变异来获取所有当前用户的`conversations`，将它们传递给变异，并返回它们：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then we need to finish the chat actions, creating the `fetchNewMessages` function.
    This asynchronous function will receive a deconstructed JavaScript object in the
    first argument, with the `commit` variable, and another as the second with the `conversationId` property.
    In this function, we will use the GraphQL `getConversation` query to fetch the
    messages in the conversation by passing the conversation ID. Finally, the received
    array of messages will be added to the state through the Vuex `SET_MESSAGES` mutation
    and return `true`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要完成聊天操作，创建`fetchNewMessages`函数。这个异步函数将在第一个参数中接收一个解构的JavaScript对象，其中包含`commit`变量，第二个参数包含`conversationId`属性。在这个函数中，我们将使用GraphQL的`getConversation`查询通过传递对话ID来获取对话中的消息。最后，接收到的消息数组将通过Vuex的`SET_MESSAGES`mutation添加到状态中，并返回`true`：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we will export all the created functions:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将导出所有创建的函数：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Adding the Chat module to Vuex
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Chat模块添加到Vuex
- en: 'Now we will import the created Chat module to the Vuex state management:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将Chat模块导入到Vuex状态管理中：
- en: Create a new file called `index.js` in the `store/chat` folder.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`store/chat`文件夹中创建一个名为`index.js`的新文件。
- en: 'Import the `state.js`, `actions.js`, `mutation.js`, and `getters.js` files
    that we just created:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们刚刚创建的`state.js`、`actions.js`、`mutation.js`和`getters.js`文件：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create `export default` with a JavaScript object, with the properties being `state`, `actions`, `mutations`, `getters`,
    and `namespaced` (defined as `true`):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有JavaScript对象的`export default`，其中属性为`state`、`actions`、`mutations`、`getters`和`namespaced`（定义为`true`）：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Open the `index.js` file in the `store` folder.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`store`文件夹中的`index.js`文件。
- en: 'Import the newly created `index.js` file into the `store/chat` folder:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的`index.js`文件导入到`store/chat`文件夹中：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'On the creation of the Vuex store, add a new property called `modules`, and
    define it as a JavaScript object. Then add the imported user file to this property :'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建Vuex存储时，添加一个名为`modules`的新属性，并将导入的用户文件添加到此属性中：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created the Chat Vuex module. This module includes all business
    logic that is necessary to manage the conversations and messages inside the application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了Chat Vuex模块。该模块包括了管理应用程序内对话和消息所需的所有业务逻辑。
- en: In the Vuex action, we used the **AppSync API Driver** and the GraphQL fragments
    to create new conversations and messages and fetch them on the API. After being
    fetched, all the messages and conversations are stored on the Vuex state through
    the Vuex mutations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vuex操作中，我们使用了**AppSync API Driver**和GraphQL片段来创建新的对话和消息，并在API上获取它们。在获取后，所有消息和对话都通过Vuex
    mutations存储在Vuex状态中。
- en: Finally, all the data is accessible to the user via the Vuex getter. The getters
    were developed as a currying function so it's possible to access the state and
    do a search inside of it when executing it to fetch the conversation messages,
    and using the complete API to fetch the user conversations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有数据都可以通过Vuex getter访问到。getter被开发为柯里化函数，因此在执行时可以访问状态并在其中进行搜索，以获取对话消息，并使用完整的API获取用户对话。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Find more information about the Vuex getters API at [https://vuex.vuejs.org/api/#getters](https://vuex.vuejs.org/api/#getters).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://vuex.vuejs.org/api/#getters](https://vuex.vuejs.org/api/#getters)找到有关Vuex
    getters API的更多信息。
- en: Find more information about Vuex getters method data access at [https://vuex.vuejs.org/guide/getters.html#method-style-access](https://vuex.vuejs.org/guide/getters.html#method-style-access).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://vuex.vuejs.org/guide/getters.html#method-style-access](https://vuex.vuejs.org/guide/getters.html#method-style-access)找到有关Vuex
    getters方法数据访问的更多信息。
- en: Creating the Contacts page of your application
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序的联系人页面
- en: In a chat application, it's common to have a start page where the user can select
    from old conversations to continue messaging, or start a new conversation. This
    practice can be used as the main page of the application. In our application,
    it won't be different.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在聊天应用程序中，通常会有一个起始页面，用户可以从旧对话中选择继续发送消息，或者开始新的对话。这种做法可以作为应用程序的主页面。在我们的应用程序中，也不会有所不同。
- en: In this recipe, we will create a Contacts page that the user can use to start
    a conversation or continue with an old one.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个联系人页面，用户可以使用它来开始对话或继续旧对话。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The prerequisites for this recipe are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的先决条件如下：
- en: The project from the previous recipe
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自上一个示例的项目
- en: Node.js 12+
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Node.js全局对象如下：
- en: '`@aws-amplify/cli`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@aws-amplify/cli`'
- en: '`@quasar/cli`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@quasar/cli`'
- en: To start our User contact pages, we will continue with the project that was
    created in the *Creating the Chat Vuex module on your application *recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的用户联系人页面，我们将继续使用在*在应用程序中创建Chat Vuex模块*示例中创建的项目。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'In this recipe, we will need to divide our work into two parts: first a new
    component to start a new conversation, and finally, the Contacts page itself.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们需要将我们的工作分为两部分：首先是一个新的组件来开始新的对话，最后是联系人页面本身。
- en: Creating the NewConversation component
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建NewConversation组件
- en: First, we need to create the component to start a new conversation between the
    user and another user on the application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个组件，在应用程序中的用户和另一个用户之间开始新的对话。
- en: Single file component <script> section
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单文件组件<script>部分
- en: 'Here we will create the `<script>` section of our component:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建组件的`<script>`部分：
- en: Create a new file called `NewConversation.vue` in the `src/components` folder
    and open it.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中创建一个名为`NewConversation.vue`的新文件并打开它。
- en: 'Import `mapActions` and `mapGetters` from `vuex`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`vuex`中导入`mapActions`和`mapGetters`：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Export a `default` JavaScript object with seven properties: `name`, `props`, `data`, `watch`, `computed`, and `methods`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出一个带有七个属性的`default`JavaScript对象：`name`，`props`，`data`，`watch`，`computed`和`methods`：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `components` property, import the `AvatarDisplay` component as a lazyload
    component:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`属性中，将`AvatarDisplay`组件导入为lazyload组件：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `props` property, we will add a new property called `value` of type `Boolean` and
    with the default value as `false`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`props`属性中，我们将添加一个名为`value`的新属性，类型为`Boolean`，默认值为`false`：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On the `data` property, we need to define two properties: `userList` as an array, and `pending` as
    a Boolean defined as `false`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data`属性上，我们需要定义两个属性：`userList`作为一个数组，`pending`作为一个布尔值，定义为`false`：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `methods` property, first, we will deconstruct `mapActions` from the
    user module calling the `listAllUsers` function. Then we will do the same with
    the chat module for the `newConversation` function. Now we will create an asynchronous
    function called `fetchUser` that sets the component as `pending`, fetches all
    the users, and sets`userList` as the response filtered without the current user.
    Finally, we need to create an asynchronous function called `createConversation`,
    which receives an argument of `otherUserId`, creates a new conversation, and redirects
    the user to the Messages page:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`methods`属性中，首先，我们将从用户模块中解构`mapActions`调用`listAllUsers`函数。然后我们将对聊天模块做同样的操作，调用`newConversation`函数。现在我们将创建一个名为`fetchUser`的异步函数，设置组件为`pending`，获取所有用户，并将`userList`设置为过滤掉当前用户的响应。最后，我们需要创建一个名为`createConversation`的异步函数，它接收一个`otherUserId`参数，创建一个新的对话，并将用户重定向到消息页面：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'On the `computed` property, first, we will deconstruct `mapGetters` from the
    user module calling `getUser`. Then we will do the same with the chat module for `getConversations`.
    Now we will create a function called `contactList` that returns the current `userList`, filtered
    by the users that the current user has already started a conversation with:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`computed`属性上，首先，我们将从用户模块调用`getUser`解构`mapGetters`。然后我们将对聊天模块的`getConversations`做同样的操作。现在我们将创建一个名为`contactList`的函数，它返回当前`userList`，并通过当前用户已经开始对话的用户进行筛选：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, on the `watch` property, we will add an asynchronous function called `value`,
    which receives an argument called `newVal`. This function checks if the `newVal` value
    is `true`; if so, it will fetch the users list in the API:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`watch`属性上，我们将添加一个名为`value`的异步函数，它接收一个名为`newVal`的参数。这个函数检查`newVal`的值是否为`true`；如果是，它将在API中获取用户列表：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Single-file component <template> section
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单文件组件的<template>部分
- en: 'Now let''s create the `<template>` section for the `NewConversation` component:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`NewConversation`组件创建`<template>`部分：
- en: 'Create a `QDialog` component with the `value` attribute defined as `value`.
    Also create the event listener `input` defined as the `$emit` function, sending
    the `''input''` event with `$event` as data:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`value`属性定义为`value`的`QDialog`组件。还创建一个事件监听器`input`，定义为`$emit`函数，发送带有`$event`作为数据的`'input'`事件：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Inside of the `QDialog` component, create a `QCard` component with the `style` attribute
    defined as `min-width: 400px; min-height: 100px;`. Inside the `QCard` component, create
    two `QCardSection` child components. In the first component, add the `class` attribute
    defined as `row items-center q-pb-none`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`QDialog`组件内部，创建一个带有`style`属性定义为`min-width: 400px; min-height: 100px;`的`QCard`组件。在`QCard`组件内部，创建两个`QCardSection`子组件。在第一个组件中，添加一个`class`属性定义为`row
    items-center q-pb-none`：'
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'On the first `QCardSection` component, add a `div` with the `class` attribute
    as `text-h6`, and the inner HTML as `New Conversation`. Then add a `QSpace` component.
    Finally, add `QBtn` with the `icon` attribute as `close`, the attributes of `flat`, `round`,
    and `dense` as `true`, and add the `v-close-popup` directive:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个`QCardSection`组件上，添加一个带有`class`属性定义为`text-h6`的`div`，并将内部HTML定义为`New Conversation`。然后添加一个`QSpace`组件。最后，添加一个带有`icon`属性定义为`close`的`QBtn`，并将`flat`、`round`和`dense`属性定义为`true`，并添加`v-close-popup`指令：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the second `QCardSection` component, create a `QList` component with a `QItem` child.
    In the `QItem` child component, add a `v-for` directive to iterate over `contactList`.
    Then define the `key` variable attribute as `contact.id`, the `class` attribute as `q-my-sm`,
    and `clickable` as `true`**.** Add the `v-ripple` directive. Finally, add an event
    listener on the `click` event, dispatching the `createConversation` method and
    sending `contact.id` as the parameter:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个`QCardSection`组件中，创建一个带有`QItem`子组件的`QList`组件。在`QItem`子组件中，添加一个`v-for`指令来迭代`contactList`。然后将`key`变量属性定义为`contact.id`，`class`属性定义为`q-my-sm`，并将`clickable`定义为`true`**。**添加`v-ripple`指令。最后，在`click`事件上添加一个事件监听器，调度`createConversation`方法并发送`contact.id`作为参数：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inside the `QItem` component, create a `QItemSection` component with the `avatar` attribute defined
    as `true`. Then create a `QAvatar` component as a child and an `AvatarDisplay` component
    as a child of `QAvatar`. On the `AvatarDisplay` component, add an `avatar-object` dynamic attribute
    as `contact.avatar` and a `name` dynamic attribute as `contact.name`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QItem`组件内部，创建一个带有`avatar`属性定义为`true`的`QItemSection`组件。然后创建一个`QAvatar`组件作为子组件，以及一个`AvatarDisplay`组件作为`QAvatar`的子组件。在`AvatarDisplay`组件上，添加一个`avatar-object`动态属性作为`contact.avatar`，以及一个`name`动态属性作为`contact.name`：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After the first `QItemSection` component, create another `QItemSection` as
    a sibling element. Inside this `QItemSection`, add two `QItemLabel` components.
    For the first one, add `contact.name` as the inner HTML, and on the second add
    the `caption` attribute as `true`, and `lines` as `1`, with the inner HTML as `contact.email`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个`QItemSection`组件之后，创建另一个作为同级元素的`QItemSection`。在这个`QItemSection`内，添加两个`QItemLabel`组件。对于第一个，将`contact.name`添加为内部HTML，对于第二个，将`caption`属性设置为`true`，`lines`设置为`1`，内部HTML设置为`contact.email`：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then create another `QItemSection` component as the third sibling, with the `side` attribute as `true`.
    Inside of it, add a `QIcon` component with the `name` attribute as `add_comment` and `color` as `green`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建另一个作为第三个同级元素的`QItemSection`组件，其中`side`属性设置为`true`。在其中添加一个`name`属性设置为`add_comment`，`color`设置为`green`的`QIcon`组件：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, as the sibling of the `QList` component, create a `QInnerLoading` component
    with the `showing` attribute defined as `pending`. Inside of it add a `QSpinner` component
    with the `size` attribute as `50px` and the `color` attribute defined as `primary`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，作为`QList`组件的同级元素，创建一个带有`showing`属性定义为`pending`的`QInnerLoading`组件。在其中添加一个`size`属性设置为`50px`，`color`属性定义为`primary`的`QSpinner`组件：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is the rendered version of your component:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您组件的渲染版本：
- en: '![](assets/6d55d973-123f-4f66-9d1d-f3448259fb78.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6d55d973-123f-4f66-9d1d-f3448259fb78.png)'
- en: Creating the Contacts page
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建联系人页面
- en: Now it's time to create the Contacts page. This page will be the initial page
    of the application for the authenticated user. Here the user will be able to go
    to the user update page, enter and resume an old conversation, or create a new
    conversation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建联系人页面的时候了。这个页面将是已认证用户应用程序的初始页面。在这里，用户可以转到用户更新页面，进入并恢复旧对话，或创建新对话。
- en: Single-file component <script> section
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单文件组件 <script> 部分
- en: 'Here we will create the `<script>` section of the single-file component that
    will be the Contacts page:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建单文件组件的`<script>`部分，它将成为联系人页面：
- en: 'Open the `Contacts.vue` file in the `src/pages` folder. In the `<script>` section
    of the file, import `mapActions` and `mapGetters` from `vuex`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/pages`文件夹中打开`Contacts.vue`文件。在文件的`<script>`部分中，从`vuex`中导入`mapActions`和`mapGetters`：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Export a `default` JavaScript object with these properties: `name`, `mixins`, `components`, `data`, `mounted`, and `methods`.
    Define the `name` property as `ChatContacts`, and in the `mixins` property, add
    the array to the imported `getAvatar` mixin. In the `components` property, add
    two new properties inside of it, `NewConversation` and `AvatarDisplay`, which
    will receive an anonymous function that returns an imported component. Finally,
    on the `data` property, create an object with the `dialogNewConversation` property and with
    the value of `false`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出一个带有这些属性的`default` JavaScript对象：`name`，`mixins`，`components`，`data`，`mounted`和`methods`。将`name`属性定义为`ChatContacts`，在`mixins`属性中，添加导入的`getAvatar`混合的数组。在`components`属性中，添加两个新属性，`NewConversation`和`AvatarDisplay`，它们将接收一个返回导入组件的匿名函数。最后，在`data`属性上，创建一个具有`dialogNewConversation`属性和值为`false`的对象：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `computed` property, first, we will deconstruct `mapGetters` from the
    user module by calling `getUser`. Then we will do the same with the chat module
    for `getConversations`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`computed`属性中，首先，我们将通过调用`getUser`从用户模块中解构`mapGetters`。然后我们将对聊天模块的`getConversations`做同样的操作：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the `methods` property, we will deconstruct `mapActions` from the chat module
    by calling the `getMessages` function:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`methods`属性中，我们将通过调用`getMessages`函数从聊天模块中解构`mapActions`：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, on the `mounted` life cycle hook, we need to make it asynchronous
    and add a call to the `getMessage` function:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`mounted`生命周期钩子上，我们需要将其设置为异步，并调用`getMessage`函数：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Single-file component <template> section
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单文件组件 <template> 部分
- en: 'Now, let''s create the `<template>` section for the page:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为页面创建`<template>`部分：
- en: 'Create a `QPage` component, then add as a child element a `QList` component
    with the `bordered` attribute defined as `true`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`QPage`组件，然后将一个带有`bordered`属性定义为`true`的`QList`组件作为子元素添加：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Inside of the `QList` component, create a `QItem` component with the `v-for` directive
    iterated over `getConversations`. Define the component attributes as follows: `key` as `contact.id`, `to` as
    a JavaScript object with the route destination information, `class` as `q-my-sm`, `clickable` as `true`, and
    then add the `v-ripple` directive:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QList`组件内部，创建一个带有`v-for`指令的`QItem`组件，迭代`getConversations`。将组件属性定义如下：`key`为`contact.id`，`to`为包含路由目标信息的JavaScript对象，`class`为`q-my-sm`，`clickable`为`true`，然后添加`v-ripple`指令：
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Inside the `QItem` component, create a `QItemSection` component with the `avatar` attribute defined
    as `true`. Then create a `QAvatar` component as a child and an `AvatarDisplay` component
    as a child of `QAvatar`. On the `AvatarDisplay` component, add an `avatar-object` dynamic attribute
    as `contact.avatar` and the `name` dynamic attribute as `contact.name`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QItem`组件内部，创建一个`QItemSection`组件，其中`avatar`属性定义为`true`。然后创建一个`QAvatar`组件作为子组件，以及一个`AvatarDisplay`组件作为`QAvatar`的子组件。在`AvatarDisplay`组件上，添加一个`avatar-object`动态属性作为`contact.avatar`，以及一个`name`动态属性作为`contact.name`：
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After the first `QItemSection`, create another `QItemSection` as a sibling
    element. Inside this `QItemSection`, add two `QItemLabel` components. On the first,
    add`contact.name` as the inner HTML, and on the second add the `caption` attribute as `true`,
    and `lines` as `1`, with the inner HTML as `contact.email`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个`QItemSection`之后，创建另一个`QItemSection`作为兄弟元素。在这个`QItemSection`内部，添加两个`QItemLabel`组件。在第一个组件上，将`contact.name`作为内部HTML，而在第二个组件上，将`caption`属性定义为`true`，`lines`定义为`1`，内部HTML为`contact.email`。
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then create another `QItemSection` component as the third sibling, with the
    `side` attribute as `true`. Inside of it add a`QIcon` component with the `name` attribute
    as `chat_bubble` and `color` as `green`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建另一个`QItemSection`组件作为第三个兄弟元素，其中`side`属性定义为`true`。在其中添加一个`QIcon`组件，其中`name`属性为`chat_bubble`，`color`为`green`：
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, as a sibling of the `QList` component, create a `QPageSticky` component,
    with the `position` attribute defined as `bottom-right` and `offset` as `[18,
    18]`. Inside of the component, create a new child  `QBtn` component with the `fab` attribute defined
    as `true`, `icon` as `chat`, `color` as `accent`, and the `click` event listener changing `dialogNewConversation` to
    the negation of the current `dialogNewConversation`. Then, add the `NewConversation` component as
    a sibling of `QBtn`, with the `v-model` directive defined as `dialogNewConversation`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，作为`QList`组件的兄弟元素，创建一个`QPageSticky`组件，其中`position`属性定义为`bottom-right`，`offset`为`[18,
    18]`。在组件内部，创建一个新的子`QBtn`组件，其中`fab`属性定义为`true`，`icon`为`chat`，`color`为`accent`，并且`click`事件监听器将`dialogNewConversation`更改为当前`dialogNewConversation`的否定。然后，将`NewConversation`组件作为`QBtn`的兄弟元素，其中`v-model`指令定义为`dialogNewConversation`：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here is a preview of how the page will look:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是页面预览的样子：
- en: '![](assets/123f4c54-4631-4265-ad02-afdca75ceaa9.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/123f4c54-4631-4265-ad02-afdca75ceaa9.png)'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Contacts page works as an aggregation of all the Vuex modules created, so
    the user can have a better experience on the application. This page holds all
    the information needed by the user to navigate initially and start to use it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人页面作为所有创建的Vuex模块的聚合，使用户可以更好地体验应用程序。该页面包含用户最初导航和开始使用应用程序所需的所有信息。
- en: The similarities between the `NewConversation` component's `<template>` section
    and the Contacts page's `<template>` section are on purpose, so the user has the
    same experience when creating a new conversation and viewing the current contacts
    list.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewConversation`组件的`<template>`部分与联系人页面的`<template>`部分之间的相似之处是有意为之，这样用户在创建新对话和查看当前联系人列表时有相同的体验。'
- en: The usage of mixins was crucial to make the code cleaner with less duplication
    of code and made it simpler to reuse the same code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 混合使用对于使代码更清晰，减少代码重复并使代码更简单重用至关重要。
- en: See also
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Find more information about the Quasar `QBtn` component at [https://quasar.dev/vue-components/button](https://quasar.dev/vue-components/button).
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://quasar.dev/vue-components/button](https://quasar.dev/vue-components/button)找到有关Quasar
    `QBtn`组件的更多信息。
- en: Find more information about the Quasar `QDialog` component at [https://quasar.dev/vue-components/dialog](https://quasar.dev/vue-components/dialog).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://quasar.dev/vue-components/dialog](https://quasar.dev/vue-components/dialog)找到有关Quasar
    `QDialog`组件的更多信息。
- en: Find more information about the Quasar `QInnerLoading` component at [https://quasar.dev/vue-components/inner-loading](https://quasar.dev/vue-components/inner-loading).
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://quasar.dev/vue-components/inner-loading](https://quasar.dev/vue-components/inner-loading)找到有关Quasar
    `QInnerLoading`组件的更多信息。
- en: Find more information about Quasar `QSpinners` at [https://quasar.dev/vue-components/spinners](https://quasar.dev/vue-components/spinners).
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://quasar.dev/vue-components/spinners](https://quasar.dev/vue-components/spinners)找到有关Quasar
    `QSpinners`的更多信息。
- en: Find more information about the Quasar `QPageSticky` component at [https://quasar.dev/layout/page-sticky](https://quasar.dev/layout/page-sticky).
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://quasar.dev/layout/page-sticky](https://quasar.dev/layout/page-sticky)找到有关Quasar
    `QPageSticky`组件的更多信息。
- en: Find more information about the Quasar `ClosePopup` directive at [https://quasar.dev/vue-directives/close-popup](https://quasar.dev/vue-directives/close-popup).
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://quasar.dev/vue-directives/close-popup](https://quasar.dev/vue-directives/close-popup)找到有关Quasar
    `ClosePopup`指令的更多信息。
- en: Find more information about Vue mixins at [https://vuejs.org/v2/guide/mixins.html](https://vuejs.org/v2/guide/mixins.html).
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://vuejs.org/v2/guide/mixins.html](https://vuejs.org/v2/guide/mixins.html)找到有关Vue
    mixins的更多信息。
- en: Creating the Messages page of your application
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序的消息页面
- en: What is a chat application without messages? Just a simple contact list. In
    this final recipe, we will finish the whole cycle of our application, creating
    the possibility for the user to communicate with other users directly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 没有消息的聊天应用程序只是一个简单的联系人列表。在这个最终的配方中，我们将完成应用程序的整个周期，为用户创建与其他用户直接交流的可能性。
- en: In this recipe, we will create the Chat page, the `ChatInput` component, and
    the Messages layout.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建聊天页面，`ChatInput`组件和消息布局。
- en: Getting ready
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The prerequisites for this recipe are as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的先决条件如下：
- en: The project from the previous recipe
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自上一个配方的项目
- en: Node.js 12+
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Node.js全局对象如下：
- en: '`@aws-amplify/cli`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@aws-amplify/cli`'
- en: '`@quasar/cli`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@quasar/cli`'
- en: To start our user messages pages, we will continue with the project that was
    created in the *Creating the Contacts page of your application *recipe.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的用户消息页面，我们将继续使用在*创建应用程序的联系人页面*中创建的项目。
- en: How to do it...
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we need to split it into three parts: the creation of the `ChatInput`
    component, the creation of the Messages layout, and finally, the creation of the
    Chat page.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们需要将其分为三个部分：创建`ChatInput`组件，创建消息布局，最后创建聊天页面。
- en: Creating the ChatInput component
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建ChatInput组件
- en: Here we will create the `ChatInput` component. This component's responsibility
    is to receive the new messages inputs from the users and send them to the server.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建`ChatInput`组件。该组件的责任是接收用户的新消息输入并将其发送到服务器。
- en: Single-file component <script> section
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单文件组件<script>部分
- en: 'In this part, we will create the `<script>` section for the page:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将为页面创建`<script>`部分：
- en: Create a new file called `ChatInput.vue` in the `src/components` folder, and
    open it.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中创建一个名为`ChatInput.vue`的新文件，并打开它。
- en: 'Import `mapActions` from the `vuex` package:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`vuex`包中导入`mapActions`：
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Export a `default` JavaScript object with the properties of `name`, `data`,
    and `methods`. Define the `name` property as `ChatInput`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出一个具有`name`、`data`和`methods`属性的`default` JavaScript对象。将`name`属性定义为`ChatInput`：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'On the `data` property, add a new property called `text`, with an empty string as
    the default value:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data`属性上，添加一个名为`text`的新属性，其默认值为空字符串：
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the `methods` property, we will deconstruct `mapActions` from the chat module,
    calling the `newMessage` and `fetchNewMessages` functions. Then we need to create
    a new function called `sendMessage`, which will create a new message on the server
    and fetch new messages from the server:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`methods`属性中，我们将从聊天模块中解构`mapActions`，调用`newMessage`和`fetchNewMessages`函数。然后我们需要创建一个名为`sendMessage`的新函数，该函数将在服务器上创建新消息并从服务器获取新消息。
- en: '[PRE66]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Single-file component <template> section
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单文件组件<template>部分
- en: 'It''s time to create the `<template>` component section of the single-file
    component:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建单文件组件的`<template>`组件部分了：
- en: 'Create a `QInput` component with the `v-model` directive bounded to `text`.
    Then define the `bottom-slots` attribute as `true`, and the `label` attribute defined
    as `"Message"`. Finally, define the `keypress` event listener on the `enter` button,
    executing the `sendMessage` function:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`QInput`组件，其`v-model`指令绑定到`text`。然后将`bottom-slots`属性定义为`true`，`label`属性定义为`"Message"`。最后，在`enter`按钮上定义`keypress`事件监听器，执行`sendMessage`函数。
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Inside the `QInput` component, create a `Template` component with the `v-slot` directive
    with `after` as the name. Then create a child `QBtn` component with the attributes of `round` and `flat` defined
    as `true`, then `icon` defined as `"send"`. Finally, add an event listener on
    the `@click` event, executing the `sendMessage` function:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QInput`组件内部，创建一个带有`v-slot`指令的`Template`组件，名称为`after`。然后创建一个子`QBtn`组件，属性为`round`和`flat`定义为`true`，然后`icon`定义为`"send"`。最后，在`@click`事件上添加事件监听器，执行`sendMessage`函数：
- en: '[PRE68]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here is the render of your component:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您组件的渲染：
- en: '![](assets/e5c54eab-bf8c-4b50-8655-8310886bef1f.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e5c54eab-bf8c-4b50-8655-8310886bef1f.png)'
- en: Creating the Messages layout
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建消息布局
- en: In the Chat page, we will need to have a footer component for the user to type
    their messages into, and this will require a lot of modifications to the Chat
    layout we created in the previous recipes. To make it simple and easier to maintain,
    we will create a new layout exclusive to the Chat page and call it the Messages
    layout.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在聊天页面中，我们需要一个页脚组件，让用户输入他们的消息，并且这将需要对我们在之前的示例中创建的聊天布局进行大量修改。为了简化和更容易维护，我们将创建一个专门用于聊天页面的新布局，并将其称为消息布局。
- en: Single-file component <script> section
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单文件组件<script>部分
- en: 'Now let''s create the `<script>` section of the Messages layout:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建消息布局的`<script>`部分：
- en: Create a new file called `Messages.vue` in the `layouts` folder.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`layouts`文件夹中创建一个名为`Messages.vue`的新文件。
- en: 'Import the `signOut` function from the `src/driver/auth.js` file and the `ChatInput` component
    from `components/ChatInput`:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`src/driver/auth.js`文件中导入`signOut`函数和`components/ChatInput`中的`ChatInput`组件：
- en: '[PRE69]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Export a `default` JavaScript object with the `name` property defined as `"ChatLayout"`,
    the `components` property, and another property called `methods`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出一个`name`属性定义为`"ChatLayout"`的`default` JavaScript对象，具有`components`属性和另一个名为`methods`的属性：
- en: '[PRE70]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the `components` property, add the imported `ChatInput` component:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`属性中，添加导入的`ChatInput`组件：
- en: '[PRE71]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the `methods` property, add a new asynchronous function called `logOff`.
    In this function we will execute the `signOut` function and reload the browser
    after it:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`methods`属性中，添加一个名为`logOff`的新的异步函数。在这个函数中，我们将执行`signOut`函数，并在其后重新加载浏览器：
- en: '[PRE72]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Single-file component <template> section
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单文件组件`<template>`部分
- en: 'Here we will create the `<template>` section of the Chat layout:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建Chat布局的`<template>`部分：
- en: 'Create a `QLayout` component with the `view` attribute defined as `"hHh lpR
    fFf"`:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`view`属性定义为`"hHh lpR fFf"`的`QLayout`组件：
- en: '[PRE73]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Inside the `QLayout` component, we need to add a `QHeader` component with an `elevated` attribute:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QLayout`组件内部，我们需要添加一个带有`elevated`属性的`QHeader`组件：
- en: '[PRE74]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'On the `QHeader` component, we will add a `QToolbar` component with a `QToolbarTitle` component
    as a child element, with a text as a slot place holder:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QHeader`组件上，我们将添加一个`QToolbar`组件，其中包含一个`QToolbarTitle`组件作为子元素，具有文本作为插槽占位符：
- en: '[PRE75]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'On the `QToolbar` component, before the `QToolbarTitle` component, we will
    add a `QBtn` component with the attributes of `dense`, `flat`, and `round` defined
    as `true`. The `icon` attribute will show a `back` icon, and the `v-go-back` directive
    is defined as `$route.meta.goBack`, so the destination is defined on the router
    file:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QToolbar`组件上，在`QToolbarTitle`组件之前，我们将添加一个`dense`，`flat`和`round`属性被定义为`true`的`QBtn`组件。`icon`属性将显示一个`back`图标，并且`v-go-back`指令被定义为`$route.meta.goBack`，因此目的地在路由文件中被定义：
- en: '[PRE76]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'After the `QToolbarTitle` component, we will add a `QBtn` component with the
    attributes of `dense`, `flat`, and `round` defined as `true`. The `icon` attribute
    we will define as `exit_to_app`, and on the `@click` directive we will pass the `logOff` method:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QToolbarTitle`组件之后，我们将添加一个`QBtn`组件，其中`dense`，`flat`和`round`属性被定义为`true`。我们将`icon`属性定义为`exit_to_app`，并在`@click`指令上传递`logOff`方法：
- en: '[PRE77]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As a sibling of the `QHeader` component, create a `QPageContainer` component
    with a `RouterView` component as a direct child:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为`QHeader`组件的同级，创建一个带有`RouterView`组件作为直接子元素的`QPageContainer`组件：
- en: '[PRE78]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Finally, create a `QFooter` component with the `class` attribute defined as `bg-white`.
    Add a child `QToolbar` component with a child `QToolbarTitle` component. Inside
    of the `QToolbarTitle`  component, add the `ChatInput` component:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个`class`属性定义为`bg-white`的`QFooter`组件。添加一个子`QToolbar`组件，其中包含一个子`QToolbarTitle`组件。在`QToolbarTitle`组件内部，添加`ChatInput`组件：
- en: '[PRE79]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Changing the application routes
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改应用程序路由
- en: 'After the creation of the Messages layout, we need to change how the chat page
    route is mounted, so it can use the newly created Messages layout:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Messages布局之后，我们需要更改聊天页面路由的挂载方式，以便可以使用新创建的Messages布局：
- en: Open the `routes.js` file in the `router` folder.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`router`文件夹中的`routes.js`文件。
- en: 'Find the `/chat` route and extract the `Messages` route object. After the `/chat` route,
    create a new JavaScript object with the `path`, `component`, and `children` properties. Define
    the `path` property as `/chat/messages`, then on the `component` property, we
    need to lazy load the newly created `Messages` layout. Finally, put the extracted
    route object on the `children` property, and change the `path` property on the
    newly added object on the `children` array to `:id/name`:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`/chat`路由并提取`Messages`路由对象。在`/chat`路由之后，创建一个新的JavaScript对象，具有`path`，`component`和`children`属性。将`path`属性定义为`/chat/messages`，然后在`component`属性上，我们需要延迟加载新创建的`Messages`布局。最后，将提取的路由对象放在`children`属性上，并将`children`数组中新添加的对象的`path`属性更改为`:id/name`：
- en: '[PRE80]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Creating the Messages page
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建消息页面
- en: In this final part of the recipe, we will create the Messages page. Here, the
    user will be sending messages to their contacts and receiving them.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱的最后部分，我们将创建消息页面。在这里，用户将向他们的联系人发送消息并接收消息。
- en: Single-file component <script> section
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单文件组件<script>部分
- en: 'Let''s create the `<script>` section of the single-file component:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建单文件组件的<script>部分：
- en: 'Open the `Messages.vue` file in the `src/pages` folder. On the `<script>` section
    of the file, import `mapActions` and `mapGetters` from `vuex`, and `date` from `quasar`:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/pages`文件夹中打开`Messages.vue`文件。在文件的`<script>`部分，从`vuex`中导入`mapActions`和`mapGetters`，以及从`quasar`中导入`date`：
- en: '[PRE81]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Export a `default` JavaScript object with the properties of `name`, `components`,  `data`, `beforeMount`, `beforeDestroy`, `watch`, `computed`, and`methods`.
    Define the `name` property as `MessagesPage`. In the `components` property, add
    a new property inside of it, `AvatarDisplay`, which will receive an anonymous
    function that returns an imported component. Finally, on the `data` property,
    create an object with the `interval` property with the value of `null`:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出一个默认的JavaScript对象，其中包含`name`、`components`、`data`、`beforeMount`、`beforeDestroy`、`watch`、`computed`和`methods`属性。将`name`属性定义为`MessagesPage`。在`components`属性中，添加一个新的属性，`AvatarDisplay`，它将接收一个返回导入组件的匿名函数。最后，在`data`属性上，创建一个带有值为`null`的`interval`属性的对象：
- en: '[PRE82]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'On the `computed` property, first, we will deconstruct the `mapGetters` function,
    passing the `user` module as the first argument, and `getUser` as the second.
    Then we will do the same with the chat module for `getChatMessages`. Finally,
    create a `currentMessages` function, which gets the messages for the current conversation,
    and return the messages with the `createdAt` date formatted:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`computed`属性上，首先，我们将解构`mapGetters`函数，将`user`模块作为第一个参数传递，`getUser`作为第二个参数。然后我们将对chat模块做同样的操作，获取`getChatMessages`。最后，创建一个`currentMessages`函数，用于获取当前对话的消息，并返回带有`createdAt`日期格式的消息：
- en: '[PRE83]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'At the `methods` property, deconstruct `mapActions` from the `chat` module
    by calling `fetchNewMessages`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`methods`属性中，通过调用`fetchNewMessages`从`chat`模块中解构`mapActions`：
- en: '[PRE84]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the `watch` property, create a property called `currentMessages`, which
    is a JavaScript object, with three properties, `handler`, `deep`, and `immediate`.
    Define the `handler` property as a function with the `newValue` and `oldValue` parameters. This
    function will check if `newValue` is larger than `oldValue`. Then create a timeout,
    that will scroll the screen to the last visible element. The `deep` property is
    defined as `true`, and the `immediate` property as `false`:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`watch`属性中，创建一个名为`currentMessages`的属性，它是一个JavaScript对象，有三个属性，`handler`、`deep`和`immediate`。将`handler`属性定义为一个带有`newValue`和`oldValue`参数的函数。这个函数将检查`newValue`是否大于`oldValue`。然后创建一个超时，将屏幕滚动到最后可见的元素。将`deep`属性定义为`true`，将`immediate`属性定义为`false`：
- en: '[PRE85]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We need to make the `beforeMount` life cycle hook asynchronous. Then we need
    to assign `interval` to a new `setInterval`, which will fetch new messages every
    1 second:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`beforeMount`生命周期钩子设置为异步。然后我们需要将`interval`分配给一个新的`setInterval`，它将每1秒获取新消息：
- en: '[PRE86]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, on the `beforeDestroy` life cycle hook, we will clear the `interval` loop
    and define `interval` as `null`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`beforeDestroy`生命周期钩子上，我们将清除`interval`循环，并将`interval`定义为`null`：
- en: '[PRE87]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Single-file component <template> section
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单文件组件<template>部分
- en: Now let's create the `<template>` section of the single-file component
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建单文件组件的<template>部分
- en: Create a `QPage` component with the `class` attribute defined as `q-pa-md row
    justify-center`, and add a `QChatMessage` component as a child.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`class`属性定义为`q-pa-md row justify-center`的`QPage`组件，并将`QChatMessage`组件作为子组件添加。
- en: In the `QChatMessage` child component, first, iterate on the `v-for` directive
    over `currentMessages`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QChatMessage`子组件中，首先在`v-for`指令上对`currentMessages`进行迭代。
- en: Define the `ref` and `key` component attributes as `message.id`, `stamp` as `message.createdAt`,
    and `text` as `[message.content]`.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ref`和`key`组件属性定义为`message.id`，`stamp`定义为`message.createdAt`，`text`定义为`[message.content]`。
- en: Then define the `sent` attribute as an evaluation of whether `message.authorId` is
    the same as `getUser.id`, `name` as `message.author.name`, `avatar` as the `getAvatar` method
    passing in `message.author.avatar` and `message.author.name` as arguments.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将`sent`属性定义为评估`message.authorId`是否与`getUser.id`相同，`name`定义为`message.author.name`，`avatar`定义为传入`message.author.avatar`和`message.author.name`作为参数的`getAvatar`方法。
- en: Then, define the `class` attribute as `col-12`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`class`属性定义为`col-12`。
- en: 'Finally, inside the `QChatMessage` component, create a `template` component
    on the `avatar` slot and add the `AvatarDisplay` component. Define the `avatar-object`
    dynamic attribute as `message.author.avatar`, the `name` dynamic attribute as`message.author.name`,
    the `tag` attribute as `''img''`, the `class` attribute as `''q-message-avatar''`,
    and the class dynamic attribute as a ternary operator checking whether `getUser.id`
    is different from `message.authorId`, so it returns `''q-message-avatar--received''`,
    or returns `''q-message-avatar--sent''` if the message is from the sender:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`QChatMessage`组件内，在`avatar`插槽上创建一个`template`组件，并添加`AvatarDisplay`组件。将`avatar-object`动态属性定义为`message.author.avatar`，将`name`动态属性定义为`message.author.name`，将`tag`属性定义为`'img'`，将`class`属性定义为`'q-message-avatar'`，将类动态属性定义为三元运算符，检查`getUser.id`是否与`message.authorId`不同，如果是，则返回`'q-message-avatar--received'`，如果消息来自发送者，则返回`'q-message-avatar--sent'`。
- en: '[PRE88]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Here is a preview of how the page will look:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这是页面的预览：
- en: '![](assets/311932f4-95f8-4f1a-98fc-801cbbc2b0d4.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/311932f4-95f8-4f1a-98fc-801cbbc2b0d4.png)'
- en: How it works...
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Messages page is a combination of three parts: the layout, the `ChatInput` component,
    and the page. Using this combination, we were able to split our code into different
    responsibilities to increase the ease of maintaining our code.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 消息页面由三个部分组成：布局、`ChatInput`组件和页面。使用这种组合，我们能够将代码分割为不同的责任，以增加代码的可维护性。
- en: In the `ChatInput` component, we used the Chat Vuex module to send messages
    directly, without the need to pass through a container like a page or a layout,
    making the component stateful.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ChatInput`组件中，我们使用Chat Vuex模块直接发送消息，无需通过页面或布局等容器，使组件具有状态。
- en: We needed to add the new layout and the router modification because the layout
    of the application needed a component fixed on the footer of the application.
    This footer is the message input, which needs to always be visible to the user.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加新的布局和路由修改，因为应用程序的布局需要一个固定在应用程序底部的组件。这个底部是消息输入，需要始终对用户可见。
- en: Finally, the Messages page is an auto-refreshing page that fetches new content
    every second, and always displays the new messages for the user.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，消息页面是一个自动刷新页面，每秒获取新内容，并始终为用户显示新消息。
- en: See also
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Find more information about Quasar Framework's `QChatMessage` component at [https://quasar.dev/vue-components/chat](https://quasar.dev/vue-components/chat).
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://quasar.dev/vue-components/chat](https://quasar.dev/vue-components/chat)找到有关Quasar
    Framework的`QChatMessage`组件的更多信息。
- en: Find more information about Quasar Framework's `date` utils at [https://quasar.dev/quasar-utils/date-utils](https://quasar.dev/quasar-utils/date-utils).
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://quasar.dev/quasar-utils/date-utils](https://quasar.dev/quasar-utils/date-utils)找到有关Quasar
    Framework的`date`工具的更多信息。
