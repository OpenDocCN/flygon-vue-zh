- en: Navigating through the File Tree and Loading Folders from the URL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过文件树导航并从URL加载文件夹
- en: In [Chapter 4](part0076.html#28FAO0-985bf4ae118d4f62b18ae64204cb251c), *Getting
    a List of Files Using the Dropbox API*,  we created an app that listed the file
    and folder contents of a specified Dropbox folder. We now need to make our app
    easy to navigate. This means the user will be able to click the folder names to
    navigate into and list the contents of, and also give the user the ability to
    download the file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0076.html#28FAO0-985bf4ae118d4f62b18ae64204cb251c)中，我们创建了一个应用程序，列出了指定Dropbox文件夹的文件和文件夹内容。现在我们需要使我们的应用程序易于导航。这意味着用户将能够点击文件夹名称以导航到并列出其内容，并且还能够下载文件。
- en: Before you proceed, ensure you have the Vue and Dropbox JavaScript files included
    in your HTML.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保在HTML中包含了Vue和Dropbox的JavaScript文件。
- en: 'In this chapter, we are going to be:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Creating a component for both files and folders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为文件和文件夹分别创建一个组件
- en: Adding links to the folder component to update the directory listing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为文件夹组件添加链接以更新目录列表
- en: Adding a download button to the file component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为文件组件添加下载按钮
- en: Creating a breadcrumb component, so the user can easily navigate back up the
    tree
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个面包屑组件，以便用户可以轻松地返回上一级目录
- en: Dynamically updating the browser URL, so if a folder is bookmarked or a link
    shared, the correct folder loads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态更新浏览器的URL，以便如果文件夹被收藏夹或链接共享，正确的文件夹加载
- en: Separating out files and folders
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件和文件夹分开
- en: Before we create the components, we need to separate our files and folders in
    our structure, so we can easily identify and display our different types. Thanks
    to the `.tag` attribute on each item, we can split up our folders and files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建组件之前，我们需要在结构中分离文件和文件夹，以便我们可以轻松地识别和显示不同类型。由于每个项目上都有`.tag`属性，我们可以将文件夹和文件分开。
- en: 'First, we need to update our `structure` data property to be an object containing
    both the `files` and the `folders` array:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更新我们的`structure`数据属性，使其成为一个包含`files`和`folders`数组的对象：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This gives us the ability to append our files and folders to different arrays,
    meaning we can display them differently in our view.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够将文件和文件夹追加到不同的数组中，从而可以在视图中以不同的方式显示它们。
- en: The next step is to populate these arrays with the data of the current folder.
    All the following code takes place in the first `then()` function of the `getFolderStructure` method.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用当前文件夹的数据填充这些数组。以下所有代码都在`getFolderStructure`方法的第一个`then()`函数中执行。
- en: 'Create a JavaScript loop to cycle through the entries and check the `.tag`
    property of the item. If it is equal to `folder`, append it to the `structure.folder`
    array, otherwise, add it to the `structure.files` array:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个JavaScript循环来遍历条目并检查项目的`.tag`属性。如果它等于`folder`，则将其追加到`structure.folder`数组中，否则将其添加到`structure.files`数组中：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code loops through the entries, as we were in the view and checks the `.tag`
    attribute. As the attribute itself begins with a `.`, we are unable to use the
    object style notation to access the property like we would, for example, do for
    the name -  `entry.name`. We then append the entry to either the `files` or `folders`
    array using JavaScript push, depending on the type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过循环遍历条目，就像我们在视图中一样，并检查`.tag`属性。由于属性本身以`.`开头，我们无法像访问`entry.name`属性那样使用对象样式的表示法来访问该属性。然后，根据类型，我们使用JavaScript的push方法将条目追加到`files`或`folders`数组中。
- en: To display this new data, we need to update the view to loop through both types
    of array. This is a perfect use case for using the `<template>` tag as we want
    to append both arrays to the same unordered list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示这些新数据，我们需要更新视图，循环遍历两种类型的数组。这是使用`<template>`标签的一个完美用例，因为我们希望将两个数组都追加到同一个无序列表中。
- en: 'Update the view to list the two arrays separately. We can remove the size option
    from the folder display section, as it will never feature a `size` property:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 更新视图以单独列出这两个数组。我们可以从文件夹显示部分中删除大小选项，因为它永远不会包含`size`属性：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This now gives us the opportunity to create components for both types.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有机会为两种类型创建组件。
- en: Making file and folder components
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件和文件夹组件
- en: 'With our data types separated out, we can create individual components to compartmentalize
    the data and methods. Create a `folder` component that accepts a single property,
    allowing the `folder` object variable to be passed through. As the template is
    so small, there is no need for a view or `<script>` block-based template; instead,
    we can pass it in as a string on the component:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的数据类型分开后，我们可以创建单独的组件来分隔数据和方法。创建一个`folder`组件，接受一个属性，允许通过`folder`对象变量传递。由于模板非常小，不需要基于视图或`<script>`块的模板；相反，我们可以将其作为字符串传递给组件：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To make our code smaller and less repetitive, the prop is called `f`. This tidies
    up the view and lets the component name determine the display type without repeating
    the word `folder` several times.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码更小、更少重复，属性被称为`f`。这样可以整理视图，并让组件名称决定显示类型，而不需要多次重复单词`folder`。
- en: 'Update the view to use the folder component, and pass in the `entry` variable
    to the `f` property:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更新视图以使用文件夹组件，并将`entry`变量传递给`f`属性：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Repeat the process with files by creating a `file` component. When creating
    the `file` component, we can move both the `bytesToSize` method and `byteSizes`
    data property from the parent `dropbox-viewer` component as it would only ever
    be used when displaying files:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个`file`组件来重复这个过程。在创建`file`组件时，我们可以将`bytesToSize`方法和`byteSizes`数据属性从父级`dropbox-viewer`组件中移动，因为它们只会在显示文件时使用：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once again, we can use `f` for the prop name to reduce repetition (and the
    file size of our app). Update the view once again to use this new component:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以使用`f`作为属性名称来减少重复（和应用程序的文件大小）。再次更新视图以使用这个新组件。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Linking folders and updating the structure
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接文件夹并更新结构
- en: Now that we have our folders and files separated, we can transform our folder
    names into links. These links will then update the structure to show the contents
    of the selected folder. For this, we are going to use the `path_lower` property
    in each folder to build the link target.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将文件夹和文件分开后，我们可以将文件夹名称转换为链接。这些链接将更新结构以显示所选文件夹的内容。为此，我们将使用每个文件夹中的`path_lower`属性来构建链接目标。
- en: 'Create a dynamic link to each folder `name`, linking to the folder''s `path_lower`.
    As we are getting more familiar with Vue, the `v-bind` property has been shortened
    to just the colon notation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个文件夹的`name`创建一个动态链接，链接到文件夹的`path_lower`。由于我们对Vue越来越熟悉，`v-bind`属性已经缩短为冒号表示法：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now need to add a `click` listener for this link. When clicked, we need to
    trigger the `getFolderStructure` method on the `dropbox-viewer` component. Although
    the click method will use the `f` variable on each instance to get the data, it's
    good practice to have the `href` attribute set to the folder URL.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为此链接添加一个`click`监听器。当点击时，我们需要在`dropbox-viewer`组件上触发`getFolderStructure`方法。虽然点击方法将使用每个实例上的`f`变量来获取数据，但将`href`属性设置为文件夹URL是一个好的做法。
- en: Using what we learned in the early chapters of the book, create a method on
    the `folder` component that, when triggered, emits the folder path to the parent
    component. The `dropbox-viewer` component also needs a new method to update the
    structure with the given parameter when fired.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在本书早期章节中学到的知识，在`folder`组件上创建一个方法，当触发时将文件夹路径发送到父组件。当触发时，`dropbox-viewer`组件还需要一个新的方法来使用给定的参数更新结构。
- en: 'Create the new method on the `folder` component and add the `click` event to
    the folder link. As with the `v-bind` directive, we are now using the shorthand
    notation for `v-on`, represented by an `@` symbol:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`folder`组件上创建新的方法，并将`click`事件添加到文件夹链接上。与`v-bind`指令一样，我们现在使用`v-on`的简写表示法，表示为`@`符号：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Along with defining the `click` event, an event modifier has also been added.
    Using `.prevent` after the click event adds `preventDefault` to the link action,
    this stops the link from actually going to the specified URL and instead lets
    the `click` method handle everything. More event modifiers and details about them
    can be found in the Vue documentation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义`click`事件之外，还添加了一个事件修饰符。在点击事件之后使用`.prevent`将`preventDefault`添加到链接操作中，这样可以阻止链接实际上转到指定的URL，而是让`click`方法处理一切。有关更多事件修饰符和详细信息，请参阅Vue文档。
- en: When clicked, the navigate method is fired, which emits the folder's lower path
    using the `path` variable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击时，将触发导航方法，该方法使用`path`变量发出文件夹的较低路径。
- en: 'Now that we have our `click` handler and the variable being emitted, we need
    to update the view to trigger a method on the parent `dropbox-viewer` component:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`click`处理程序和被发出的变量，我们需要更新视图以触发父组件`dropbox-viewer`上的一个方法：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new method on the Dropbox component with the same name as the value
    of the `v-on` attribute, in this case `updateStructure`. This method will have
    one parameter, which is the path we emitted earlier. From here, we can trigger
    our original `getFolderStructure` method using the path variable:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dropbox组件上创建一个与`v-on`属性的值相同的新方法，这里是`updateStructure`。这个方法将有一个参数，即我们之前发出的路径。从这里开始，我们可以使用路径变量触发我们原来的`getFolderStructure`方法：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Viewing our app in the browser should now list the folders and links and, when
    clicked, show the contents of the new folder.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看我们的应用程序，现在应该列出文件夹和链接，并且在点击时显示新文件夹的内容。
- en: When doing so, however, there are a couple of issues that are raised. Firstly,
    the files and folders are appended to the existing list rather than replacing
    it. Secondly, there is no feedback to the user that the app is loading the next
    folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这样做时，会引发一些问题。首先，文件和文件夹被追加到现有列表中，而不是替换它。其次，用户没有任何反馈，表明应用正在加载下一个文件夹。
- en: The first issue can be resolved by clearing the folder and file arrays before
    appending the new structure. The second can be addressed by utilizing the loading
    screen we used at the beginning of the app - this will give the user some feedback.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题可以通过在追加新结构之前清除文件夹和文件数组来解决。第二个问题可以通过使用我们在应用程序开始时使用的加载屏幕来解决-这将给用户一些反馈。
- en: 'To address the first issue, create a new `structure` object inside the success
    promise function for the `getFolderStructure` method. This object should replicate
    that of the `structure` object in the `data` object. This should set blank arrays
    for both files and folders. Update the `for` loop to use the local structure arrays
    rather than the component ones. Lastly, update the component `structure` object
    with the new version, including the updated files and folders:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第一个问题，在`getFolderStructure`方法的成功promise函数中创建一个新的`structure`对象。这个对象应该复制`data`对象中的`structure`对象。这应该为文件和文件夹设置空数组。更新`for`循环以使用本地结构数组而不是组件数组。最后，使用新版本更新组件`structure`对象，包括更新后的文件和文件夹：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As this method gets called when the app gets mounted and creates its own version
    of the structure object, there is no need to declare the arrays in the `data`
    function. Update the data object to just initialize the `structure` property as
    an object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此方法在应用程序挂载时调用并创建自己的结构对象，所以不需要在`data`函数中声明数组。将数据对象更新为只初始化`structure`属性为对象：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running the app now will render the file list, which will be cleared and updated
    when a new folder is clicked into. To give the user some feedback and let them
    know the app is working, let's toggle the loading screen after each click.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序将呈现文件列表，当点击进入新文件夹时，文件列表将被清除并更新。为了给用户一些反馈并让他们知道应用程序正在工作，让我们在每次点击后切换加载屏幕。
- en: Before we do this, however, let's fully understand where the delay comes from
    and where is best to trigger the loading screen.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们这样做之前，让我们充分了解延迟来自何处以及何时最好触发加载屏幕。
- en: 'The click on the link is instantaneous, which triggers the navigate method
    on the folder component, which in turn fires the `updateStructure` method on the
    Dropbox component. The delay comes when the app gets to the `filesListFolder`
    function on the Dropbox instance, inside the `getFolderStructure` method. As we
    may want to fire the `getFolderStucture` method at a later date without triggering
    the loading screen, set the `isLoading` variable to `true` inside the `updateStructure`
    method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 点击链接是瞬时的，它触发文件夹组件上的导航方法，进而触发Dropbox组件上的`updateStructure`方法。当应用程序到达Dropbox实例上的`filesListFolder`函数时，延迟就会出现在`getFolderStructure`方法内部。由于我们可能希望在以后的某个日期触发`getFolderStucture`方法而不触发加载屏幕，所以在`updateStructure`方法内将`isLoading`变量设置为`true`：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With the animations in place, the app fades between both the loading screen
    and folder structure when navigating through folders.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过动画，应用程序在导航文件夹时在加载屏幕和文件夹结构之间淡入淡出。
- en: Creating a breadcrumb from the current path
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从当前路径创建面包屑
- en: When navigating through folders or a nested structure of any kind, it's always
    nice to have a breadcrumb available so the user knows where they are, how far
    they've gone, and also so they can get back to a previous folder easily. We are
    going to make a component for the breadcrumb as it is going to feature various
    properties, computed functions, and methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航文件夹或任何嵌套结构时，始终有一个可用的面包屑对用户来说是很好的，这样他们就知道自己在哪里，走了多远，还可以轻松返回到以前的文件夹。我们将为面包屑制作一个组件，因为它将具有各种属性、计算函数和方法。
- en: The breadcrumb component is going to list each folder depth as a link to a folder
    icon. Clicking the link will take the user directly to that folder - even if it
    is several layers up. To achieve this, we will need to have a list of links we
    can loop through, each with two properties - one being the full path to the folder
    and the other just being the folder name.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 面包屑组件将以链接的形式列出每个文件夹的深度，链接将直接将用户带到该文件夹 - 即使它是几层上面的。为了实现这一点，我们需要一个链接列表，我们可以循环遍历，每个链接都有两个属性
    - 一个是文件夹的完整路径，另一个只是文件夹的名称。
- en: For example, if we had the folder structure ofimg/holiday/summer/iphone`, we
    would want to be able to click on `Holiday` and for the app to navigate toimg/holiday`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有文件夹结构`img/holiday/summer/iphone`，我们希望能够点击`Holiday`并使应用程序导航到`img/holiday`。
- en: 'Create your breadcrumb component — for now, add an empty `<div>` to the template
    property:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建您的面包屑组件 - 现在，在模板属性中添加一个空的`<div>`：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the component to your view. We''re going to want the breadcrumb to fade
    in and out with the structure list, so we need to tweak the HTML to wrap both
    the list and breadcrumb component in a container that has the `v-if` declaration:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件添加到您的视图中。我们希望面包屑能够与结构列表一起淡入淡出，因此我们需要调整HTML，将列表和面包屑组件都包裹在一个具有`v-if`声明的容器中：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We now need to make a variable available to us that stores the current folder
    path. We can then manipulate this variable within the breadcrumb component. This
    will be stored and updated on the Dropbox component and passed down to the breadcrumb
    component.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个变量来存储当前文件夹路径。然后我们可以在面包屑组件中操作这个变量。这个变量将被存储和更新在Dropbox组件中，并传递给面包屑组件。
- en: 'Create a new property called `path` on the `dropbox-viewer` component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dropbox-viewer`组件上创建一个名为`path`的新属性：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We now need to ensure this path gets updated whenever the structure is retrieved
    from the Dropbox API. Do this within the `getFolderStructure` method, just before
    the `isLoading` variable is disabled. This ensures it only gets updated once the
    structure has been loaded, but before the files and folders are displayed:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要确保当从Dropbox API检索到结构时，该路径会得到更新。在`getFolderStructure`方法中进行此操作，就在`isLoading`变量被禁用之前。这样可以确保它只在结构加载完成之后但在文件和文件夹显示之前更新：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have a variable populated with the current path, we can pass it
    through to the breadcrumb component as a prop. Add a new attribute to the breadcrumb
    with the path variable as the value:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个填充了当前路径的变量，我们可以将其作为属性传递给面包屑组件。在面包屑中添加一个新的属性，将路径变量作为值：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Update the component to accept the prop as a string:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 更新组件以接受字符串作为属性：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `p` attribute now contains the full path of where we are (for exampleimg/holiday/summer`).
    We want to break up this string so we can identify the folder name and build the
    breadcrumb for the component to render.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`p`属性现在包含我们所在位置的完整路径（例如img/holiday/summer）。我们想要将这个字符串分解，以便我们可以识别文件夹名称并构建面包屑供组件渲染。'
- en: 'Create a `computed` object on the component and create a new function titled
    `folders()`. This is going to create the breadcrumb array for us to loop through
    in the template:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件上创建一个`computed`对象，并创建一个名为`folders()`的新函数。这将为我们创建面包屑数组，供我们在模板中循环使用：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We now need to set up some variables for us to use. Create a new, empty array
    called `output`. This is where we are going to build up our breadcrumb. We also
    need an empty variable titled `slug` as a string. The `slug` variable refers to
    a part of a URL and its use was made popular by WordPress. The last variable is
    the path created as an array. As we know, each folder is separated by a `/`, we
    can use this to explode or split the string into various parts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要设置一些变量供我们使用。创建一个新的空数组`output`，这是我们要构建面包屑的地方。我们还需要一个空的字符串变量`titled slug`。`slug`变量是URL的一部分，它的使用在WordPress中很流行。最后一个变量是作为数组创建的路径。我们知道，每个文件夹都是由`/`分隔的，我们可以使用这个来将字符串分解成各个部分：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we were to look at the parts variable for our `Summer`folder, it would look
    like the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`Summer`文件夹的`parts`变量，它将如下所示：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can now loop through the array to create the breadcrumb. Each breadcrumb
    item is going to be an object with the `name` of the individual folder, for example,
    `holiday` or `summer`, and the `slug`, which would beimg/holiday` for the former
    andimg/holiday/summer` for the latter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以循环遍历数组来创建面包屑。每个面包屑项将是一个对象，包含个别文件夹的`name`，例如`holiday`或`summer`，以及`slug`，前者为img/holiday，后者为img/holiday/summer。
- en: 'Each object will be constructed and then added to the `output` array. We can
    then return the output for our template to use:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象将被构建，然后添加到`output`数组中。然后我们可以返回输出供我们的模板使用：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This loop creates our breadcrumb by taking the following steps. For this example,
    we''ll assume we are in theimg/holiday`folder:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环通过以下步骤创建我们的面包屑。以img/holiday文件夹为例：
- en: '`parts` will now be an array containing three items, `['''', ''images'', holiday'']`.
    If the string you split on begins with the item you''re splitting, an empty item
    will be made as the first item.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`parts`现在是一个包含三个项目的数组，`['''', ''images'', holiday'']`。如果你分割的字符串以你要分割的项目开头，那么一个空项目将作为第一个项目。'
- en: At the beginning of the loop, the first slug variable will be equal to `''`,
    as it is the first item.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环开始时，第一个slug变量将等于`''`，因为它是第一个项目。
- en: 'The `output` array will have a new item appended to it with the object of `{''name'':
    '''', ''path'': ''''}`.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`output`数组将附加一个新项，对象为`{''name'': '''', ''path'': ''''}`。'
- en: The `slug` variable then has a `/` added to the end.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`slug`变量的末尾添加一个`/`。
- en: Looping through the next item, the `slug` variable gets the name of the item
    (`images`) added to it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历下一个项目时，`slug`变量将其名称（`images`）添加到其中。
- en: '`output` now has a new object added, with the value of `{''name'': ''images'',
    ''path'': ''/images''}`.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`output`现在添加了一个新的对象，值为`{''name'': ''images'', ''path'': ''/images''}`。'
- en: For the last item, another `/` is added along with the next name, `holiday`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后一个项目，还会添加另一个`/`以及下一个名称`holiday`。
- en: '`output` gets the last object added, the value being `{''name'': ''holiday'',
    ''path'':img/holiday''}` - note the path is building up whereas the name remains
    the singular folder name.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`output`获取最后一个添加的对象，其值为`{''name'': ''holiday'', ''path'':img/holiday''}` -
    注意路径正在构建，而名称保持为单个文件夹名称。'
- en: We now have our breadcrumb output array that we can loop through in the view.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以在视图中循环遍历的面包屑输出数组。
- en: The reason we add the slash after we've appended to the output array is that
    the API states that to get the root of the Dropbox we pass in an empty string,
    whereas all other paths must begin with a `/`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在将输出数组附加后添加斜杠的原因是API规定要获取Dropbox的根目录，我们传入一个空字符串，而所有其他路径必须以`/`开头。
- en: 'The next step is to output the breadcrumb into our view. As this template is
    small, we are going to use the multiline JavaScript notation. Loop through the
    items within the `folders` computed variable, outputting a link for each of the
    items. Don''t forget to keep a containing element around all the links:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将面包屑输出到我们的视图中。由于这个模板很小，我们将使用多行JavaScript表示法。循环遍历`folders`计算变量中的项目，为每个项目输出一个链接。不要忘记在所有链接周围保留一个包含元素：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Rendering this app in the browser should reveal a breadcrumb - albeit a bit
    squished together and missing a home link (as the first item didn''t have a name).
    Head back to the `folders` function and add an `if` statement - checking whether
    the item has a name and, if it doesn''t, adding a hard-coded value:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中渲染此应用程序应该会显示一个面包屑 - 尽管有点挤在一起并且缺少一个主页链接（因为第一个项目没有名称）。返回到`folders`函数并添加一个`if`语句
    - 检查项目是否有名称，如果没有，则添加一个硬编码的值：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The other option is to add the `if` statement in the template itself:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是在模板本身中添加`if`语句：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we wanted to display a divider between the folder names, such as a slash
    or chevron, this can be easily added. However, a slight hurdle arises when we
    want to display the separator between the links, but not at the beginning or end.
    To resolve this, we are going to utilize the `index` keyword available when doing
    a loop. We are then going to compare this against the length of the array and
    operate a `v-if` declaration on an element.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在文件夹名称之间显示一个分隔符，比如斜杠或箭头，这可以很容易地添加。然而，当我们想要在链接之间显示分隔符，但不在开头或结尾时，会出现一个小障碍。为了解决这个问题，我们将利用循环时可用的`index`关键字。然后，我们将将其与数组的长度进行比较，并在元素上操作`v-if`声明。
- en: 'When looping through an array, Vue allows you to utilize another variable.
    This, by default, is the index (the position of the item in the array); however,
    the index may be set to a value if your array is constructed in a key/value fashion.
    If this is the case, you can still access the index by adding a third variable.
    As our array is a simple list, we can easily use this variable:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环数组时，Vue允许您利用另一个变量。默认情况下，这是索引（数组中项目的位置）；然而，如果您的数组以键/值方式构建，则可以将索引设置为一个值。如果是这种情况，您仍然可以通过添加第三个变量来访问索引。由于我们的数组是一个简单的列表，我们可以轻松使用这个变量：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Update the `f` variable to a pair of brackets containing an `f` and an `i`, comma
    separated. The `f` variable is the current folder in the loop, while the `i` variable
    that has been created is the index of the item. Bear in mind that the array indexes
    start at `0` instead of `1`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将“f”变量更新为包含“f”和“i”的一对括号，用逗号分隔。变量“f”是循环中的当前文件夹，而已创建的变量“i”是项目的索引。请记住，数组索引从0开始，而不是从1开始。
- en: The separator we've added is contained in a span tag with a `v-if` attribute,
    the contents of which could look confusing. This is confusing the current index
    with the length of the `folders` array (how many items it has) minus 1\. The `-
    1` is because of the index starting at 0 and not 1, as you would expect. If the
    numbers do not match, then the `span` element is displayed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的分隔符包含在一个带有“v-if”属性的span标签中，其内容可能看起来很困惑。这是将当前索引与“folders”数组的长度（它有多少项）减1混淆在一起。减1是因为索引从0开始，而不是从1开始，这是您所期望的。如果数字不匹配，则显示“span”元素。
- en: The last thing we need to do is make our breadcrumb navigate to the selected
    folder. We can do this by adapting the navigate function we wrote for the `folder`
    component. However, because our whole component is the breadcrumb and not each
    individual link, we need to alter it so it accepts a parameter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是使面包屑导航到选定的文件夹。我们可以通过调整我们为“文件夹”组件编写的导航函数来实现这一点。然而，由于我们的整个组件是面包屑，而不是每个单独的链接，我们需要修改它以接受一个参数。
- en: 'Start off by adding the `click` event to the link, passing in the `folder`
    object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为链接添加“click”事件，传入“folder”对象：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, create the `navigate` method on your breadcrumb component, making sure
    you accept the `folder` parameter and emit the path:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在面包屑组件上创建“navigate”方法，确保接受“folder”参数并发出路径：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last step is to trigger the parent method when the path gets emitted. For
    this, we can utilize the same `updateStructure` method on the `dropbox-viewer`
    component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在路径发出时触发父方法。为此，我们可以利用“dropbox-viewer”组件上的相同“updateStructure”方法：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We now have a fully operational breadcrumb that allows the user to navigate
    down the folder structure using the folder links and back up via breadcrumb links.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个完全可操作的面包屑，允许用户使用文件夹链接导航到文件夹结构下方，并通过面包屑链接返回上级。
- en: 'Our full breadcrumb component looks like is:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完整的面包屑组件如下所示：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Adding the ability to download files
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加下载文件的功能
- en: Now that our users can navigate through the folder structure, we need to add
    the ability to download the files. Unfortunately, this isn't as simple as accessing
    a link attribute on the file. To get the download link, we have to query the Dropbox
    API for each file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的用户可以通过文件夹结构导航，我们需要添加下载文件的功能。不幸的是，这并不像访问文件上的链接属性那样简单。要获取下载链接，我们必须为每个文件查询Dropbox
    API。
- en: We will query the API on the creation of the file component, this will asynchronously
    get the download link and show it once available. Before we can do this, we need
    to make the Dropbox instance available to the file component.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建文件组件时，我们将查询API，这将异步获取下载链接并在可用时显示它。在此之前，我们需要将Dropbox实例提供给文件组件。
- en: 'Add a new attribute to the file component in the view, and pass the Dropbox
    method through as the value:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中为文件组件添加一个新属性，并将Dropbox方法作为值传递：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the `d` variable to the `props` object of your component accepting an Object:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将`d`变量添加到接受对象的组件的`props`对象中：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We are now going to add a data attribute of `link`. This should be set to `false`
    by default, so we can hide the link, and we'll populate it with the download link
    once the API has returned with the value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个名为`link`的数据属性。默认情况下，它应该设置为`false`，这样我们就可以隐藏链接，并在API返回值后填充它。
- en: 'Add the `created()` function to the file component, and inside add the API
    call:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件组件中添加`created()`函数，并在其中添加API调用：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This API method accepts an object, similar to the `filesListFolder` function.
    We're passing the path of the current file. Once the data is returned, we can
    set the component's `link` attribute to the download link.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API方法接受一个对象，类似于`filesListFolder`函数。我们传递当前文件的路径。一旦数据返回，我们就可以将组件的`link`属性设置为下载链接。
- en: 'We can now add a download link to the template of the component. Add a `v-if`
    to only show the `<a>` once the download link has been retrieved:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在组件的模板中添加一个下载链接。添加一个`v-if`，只有在获取到下载链接后才显示`<a>`：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Browsing through the files, we can now see a download link appearing next to
    each file, the speed of which will depend on your internet connection and the
    API speed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览文件时，我们现在可以看到每个文件旁边出现了一个下载链接，其速度取决于您的互联网连接和API速度。
- en: 'The full file component, with the download link added, now looks like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文件组件，添加了下载链接后，现在看起来是这样的：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Updating the URL hash and using it to navigate through the folders
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新URL哈希并使用它浏览文件夹
- en: 'With our Dropbox web app now fully navigable via both the structure list and
    breadcrumb, we can now add and update the browser URL for quick folder access
    and sharing. We can do this in two ways: we can either update the hash, for example,
    `www.domain.comimg/holiday/summer`, or we can redirect all the paths to the single
    page and handle the routing without the hash in the URL.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结构列表和面包屑，我们的Dropbox Web应用程序现在可以完全导航，现在我们可以添加和更新浏览器URL以快速访问和共享文件夹。我们可以通过两种方式实现这一点：我们可以更新哈希，例如`www.domain.comimg/holiday/summer`，或者我们可以将所有路径重定向到单个页面，并处理URL中的路由而不使用哈希。
- en: For this app, we will use the `#` method in the URL. We'll cover the URL routing
    technique in the third section of the book when we introduce `vue-router`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们将在URL中使用`#`方法。当我们介绍`vue-router`时，我们将在本书的第三部分介绍URL路由技术。
- en: Before we get the app to show the corresponding folder of the URL, we first
    need to get the URL to update when navigating to a new folder. We can do this
    using the native `window.location.hash` JavaScript object. We want to update the
    URL as soon as the user clicks a link, rather than waiting for the data to load
    to update.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们让应用程序显示与URL对应的文件夹之前，我们首先需要在导航到新文件夹时获取URL。我们可以使用原生的`window.location.hash`
    JavaScript对象来实现这一点。我们希望在用户点击链接时立即更新URL，而不是等待数据加载完成后再更新。
- en: 'As the `getFolderStructure` method gets fired whenever we update the structure,
    add the code to the top of this function. This would mean the URL gets updated
    and then the Dropbox API is called to update the structure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`getFolderStructure`方法在更新结构时被触发，所以将代码添加到该函数的顶部。这意味着URL会被更新，然后调用Dropbox API来更新结构：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you navigate through your app, it should be updating the URL to include the
    current folder path.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当您浏览应用程序时，它应该会更新URL以包括当前文件夹路径。
- en: However, what you will find when you press refresh with a folder; is that the
    URL resets to just having a hash with no folder afterward as it is being reset
    by the empty path passed in via the method in the `created()` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你按下刷新按钮时，你会发现一个问题：URL会重置，只剩下一个哈希，后面没有文件夹，因为它是通过`created()`函数中传入的空路径重置的。
- en: We can remedy this by passing in the current hash to the `getFolderStructure`
    within the `created` function, however, there will be a few checks and error catching
    we will need to do if we do this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`created`函数中将当前哈希传递给`getFolderStructure`来解决这个问题，但是如果这样做，我们需要进行一些检查和错误捕获。
- en: First, when calling `window.location.hash`, you also get the hash returned as
    part of the string, so we will need to remove that. Second, we need to handle
    the instance of an incorrect URL, should the user enter an incorrect path or the
    folder gets moved. Lastly, we need to let the user use the back and forward buttons
    (or keyboard shortcuts) in their browsers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当调用`window.location.hash`时，你也会得到哈希作为字符串的一部分返回，所以我们需要将其删除。其次，我们需要处理URL不正确的情况，如果用户输入了不正确的路径或者文件夹被移动了。最后，我们需要让用户在浏览器中使用后退和前进按钮（或键盘快捷键）。
- en: Showing the folder based on the URL
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据URL显示文件夹
- en: When our app mounts, it already calls a function to request the structure for
    the base folder. We wrote this function to allow the path to be passed in and,
    within the `created()` function, we have fixed the value to be the root folder
    of `''`. This gives us the flexibility to adapt this function to pass in the hash
    from the URL, instead of a fixed string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用挂载时，它已经调用了一个函数来请求基本文件夹的结构。我们编写了这个函数，允许传入路径，并且在`created()`函数中，我们已经将值固定为根文件夹`''`。这使我们能够灵活地调整这个函数，以传入URL的哈希，而不是固定的字符串。
- en: 'Update the function to accept the hash of the URL and, if it doesn''t have
    one, the original fixed string:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更新函数以接受URL的哈希，如果没有哈希，则使用原始的固定字符串：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Create a new variable called `hash` and assign `window.location.hash` to it.
    Becuase the variable starts with `#`, which is not needed for our app, use the
    `substring` function to remove the first character from the string. We can then
    use a logical operator to use either the hash variable, or if that equates to
    nothing, the original fixed string.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`hash`的新变量，并将`window.location.hash`赋值给它。因为变量以`#`开头，对于我们的应用来说是不需要的，所以使用`substring`函数从字符串中删除第一个字符。然后，我们可以使用逻辑运算符来使用hash变量，或者如果它等于空，使用原始的固定字符串。
- en: You should now be able to still navigate through your app with the URL updating.
    If you press refresh at any time or copy and paste the URL into a different browser
    window, the folder you were in should load.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够通过更新URL来浏览你的应用。如果你随时按下刷新按钮或将URL复制粘贴到另一个浏览器窗口中，你所在的文件夹应该会加载。
- en: Displaying an error message
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示错误消息
- en: With our app accepting URLs, we need to handle a case where someone is entering
    a URL and makes a mistake, or a folder is shared that has since been moved.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用接受URL，我们需要处理一种情况，即有人输入了一个URL并犯了一个错误，或者共享的文件夹已经被移动了。
- en: 'As this error is an edge case, we are going to hijack the `isLoading` parameter
    if there is an error in loading the data. In the `getFolderStructure` function,
    we have a `catch` function returned as a promise that gets fired if there is an
    error with the API call. In this function, set the `isLoading` variable to `''error''`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个错误是一个边缘情况，如果加载数据时出现错误，我们将劫持`isLoading`参数。在`getFolderStructure`函数中，我们返回一个作为promise的`catch`函数，如果API调用出错，就会触发这个函数。在这个函数中，将`isLoading`变量设置为`'error'`：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `console.log` has been left in, should we need to diagnose a problem beyond
    a wrong file path. Although the API can throw several different errors, we are
    going to assume for this app that the error is due to a wrong path. If you wanted
    to cater for other errors in the app, you can identify the error type by its `status_code`
    attribute. More details on this can be found in the Dropbox API documentation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log`已经保留下来，以防需要诊断除了错误文件路径之外的问题。虽然API可能会抛出多种不同的错误，但我们将假设这个应用程序的错误是由于错误的路径。如果您想在应用程序中处理其他错误，可以通过其`status_code`属性识别错误类型。有关此的更多详细信息可以在Dropbox
    API文档中找到。'
- en: 'Update your view to handle this new `isLoading` variable property. When set
    to error, the `isLoading` variable is still "true," so within your loading element,
    add a new `v-if` to check whether the loading variable is set to `error`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更新视图以处理这个新的`isLoading`变量属性。当设置为错误时，`isLoading`变量仍然为“true”，所以在加载元素中，添加一个新的`v-if`来检查加载变量是否设置为`error`：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is set to display the first element of the `isLoading` variable is set
    to `error`; otherwise, show the loading text. In the error text, a link is included
    to send the user back to the current URL without any URL hash. This will "reset"
    them back to the top of the document tree so they can navigate back down. An improvement
    could be to break the current URL down and suggest the same URL with the last
    folder removed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置为显示`isLoading`变量的第一个元素设置为`error`；否则，显示加载文本。在错误文本中，包含一个链接，将用户发送回当前URL，不带任何URL哈希。这将使他们“重置”回到文档树的顶部，以便他们可以返回。一个改进是将当前URL拆分，并建议删除最后一个文件夹后相同的URL。
- en: Verify the error code is loading by adding a nonexistent path to the end of
    your URL and ensuring the error message is displayed. Bear in mind your user may
    experience a false positive on this error message in the sense that if the Dropbox
    API throws any kind of error, this message will be displayed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在URL末尾添加一个不存在的路径并确保显示错误消息来验证错误代码是否正在加载。请记住，您的用户可能会在某种意义上对此错误消息产生误报，即如果Dropbox
    API抛出任何类型的错误，将显示此消息。
- en: Using the back and forward buttons in your browser
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用浏览器的后退和前进按钮
- en: To use the back and forward buttons in our browser, we are going to need to
    update our code significantly. Currently, when the user clicks on a folder from
    either the structure or breadcrumb, we prevent the default behavior of the browser
    by using `.prevent` on our `click` handlers. We then immediately update the URL
    before we process the folder.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用浏览器的后退和前进按钮，我们需要大幅更新我们的代码。目前，当用户从结构或面包屑中点击一个文件夹时，我们通过在`click`处理程序上使用`.prevent`来阻止浏览器的默认行为。然后，我们立即更新URL，然后处理文件夹。
- en: However, if we allow the app to update the URL using native behavior, we can
    then watch for a hash URL update and use this to retrieve our new structure. Using
    this methodology, the back and forward buttons would work without any further
    intervention, as they would be updating the URL hash.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们允许应用程序使用本机行为更新URL，我们可以监听哈希URL的更新，并使用它来检索我们的新结构。使用这种方法，后退和前进按钮将无需任何进一步的干预，因为它们将更新URL哈希。
- en: This would also improve the readability of our app, and reduce code weight as
    we would be able to remove the `navigate` methods and `click` handlers on the
    links.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将改善我们应用程序的可读性，并减少代码量，因为我们将能够删除链接上的`navigate`方法和`click`处理程序。
- en: Removing unneeded code
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除不需要的代码
- en: The first step, before we add more code, is to remove the unnecessary code from
    our components. Starting with the breadcrumb, remove the `navigate` method from
    the component and the `@click.prevent` attribute from the link in the template.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加更多代码之前，第一步是从我们的组件中删除不必要的代码。从面包屑开始，从组件中删除`navigate`方法，并从模板中的链接中删除`@click.prevent`属性。
- en: 'We also need to update the `slug` of each of the items to prepend a `#` - this
    ensures the app doesn''t try and navigate to a brand new page when clicked. As
    we are looping through our breadcrumb items in the folders `computed` function,
    add a hash to each `slug` when pushing the object to the `output` array:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新每个项目的`slug`，在前面添加一个`#`，这样可以确保应用程序在单击时不会尝试导航到一个全新的页面。当我们在文件夹的`computed`函数中循环遍历面包屑项时，在将对象推送到`output`数组时，为每个`slug`添加一个哈希：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also remove the `v-on` declaration on the breadcrumb component in the
    `dropbox-viewer-template`. It should only have the path being passed in as a prop:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从`dropbox-viewer-template`中的面包屑组件中删除`v-on`声明。它只应该作为属性传递路径：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can now repeat the same pattern for the folder component. Remove the `@click.prevent`
    declaration from the link and delete the `navigate` method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为文件夹组件重复相同的模式。从链接中删除`@click.prevent`声明并删除`navigate`方法。
- en: As we are not looping through or editing the folder object before displaying
    it, we can prepend the `#` in the template. As we are telling Vue the `href` is
    bound to a JavaScript object (with the colon), we need to encapsulate the hash
    in quotes and concatenate it with the folder path using the JavaScript `+` notation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在显示之前不会循环遍历或编辑文件夹对象，所以我们可以在模板中添加`#`。由于我们告诉Vue`href`绑定到一个JavaScript对象（使用冒号），我们需要将哈希封装在引号中，并使用JavaScript的`+`符号将其与文件夹路径连接起来。
- en: 'We are already inside both single and double quotes, so we need to inform JavaScript
    we *literally* mean a single quote and this is done by using a backslash in front
    of the single quote character:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在单引号和双引号内部，所以我们需要告诉JavaScript我们是*字面上*意味着一个单引号，这可以通过在单引号字符前面使用反斜杠来实现：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can also remove the `@path` attribute from the `<folder>` component in the
    view:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从视图中的`<folder>`组件中删除`@path`属性：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Already our code is looking cleaner, less cluttered, and smaller in file size.
    Viewing the app in the browser will render the structure of the folder you are
    in; however, clicking links will update the URL but not change what is displayed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码看起来更整洁、更简洁，文件大小更小。在浏览器中查看应用程序将呈现所在文件夹的结构；但是，点击链接将更新URL但不会更改显示内容。
- en: Updating the structure with a URL change and setting Vue data outside of the
    instance
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过URL更改更新结构并在实例外部设置Vue数据
- en: Now that we have our URL updating correctly, we can get the new structure whenever
    the hash changes. This can be done natively with JavaScript with the `onhashchange`
    function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的URL已经正确更新，我们可以在哈希更改时获取新的结构。这可以使用JavaScript的`onhashchange`函数来实现。
- en: We are going to create a function that fires whenever the hash of the URL updates,
    which, in turn, will update a path variable on the parent Vue instance. This variable
    will be passed to the child `dropbox-viewer` component as a prop. This component
    will be watching for a change in the variable and, upon update, it will retrieve
    the new structure.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个函数，每当URL的哈希更新时触发，然后将更新父Vue实例上的路径变量。这个变量将作为属性传递给子组件`dropbox-viewer`。该组件将监听变量的变化，并在更新时检索新的结构。
- en: 'To begin with, update the parent Vue instance to have a data object with a
    path key - set to the empty string property. We are also going to assign our Vue
    instance to a constant variable of `app`—this allows us to set data and call methods
    outside of the instance:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新父Vue实例，使其具有一个数据对象，其中包含一个路径键-设置为空字符串属性。我们还将将Vue实例分配给一个名为`app`的常量变量-这允许我们在实例外部设置数据和调用方法：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The next step is to update this data property every time the URL gets updated.
    This is done using `window.onhashchange`, which is a native JavaScript function
    that fires every time the hash changes in the URL.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在URL更新时每次更新这个数据属性。这是使用`window.onhashchange`完成的，它是一个原生JavaScript函数，每当URL中的哈希发生变化时触发。
- en: 'Copy and paste the hash modifier from the `created` function on the Dropbox
    component, and use that to modify the hash and store the value on the Vue instance.
    If the hash doesn''t exist, we will pass an empty string to the path variable:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从Dropbox组件的`created`函数中复制并粘贴哈希修改器，并使用它来修改哈希并将值存储在Vue实例上。如果哈希不存在，我们将传递一个空字符串给路径变量：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We now need to pass this path variable through to the Dropbox component. Add
    a prop of `p` with the `path` variable as the value in your view:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将这个路径变量传递给Dropbox组件。在视图中添加一个名为`p`的prop，将`path`变量作为值：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add the `props` object to the Dropbox component to accept a string:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dropbox组件中添加`props`对象以接受一个字符串：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We are now going to add a watch function to the `dropbox-viewer` component.
    This function will watch the `p` prop and, when updated, call the `updateStructure()`
    method with the modified path:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`dropbox-viewer`组件中添加一个`watch`函数。这个函数将监视`p` prop，并在更新时使用修改后的路径调用`updateStructure()`方法：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Heading back to the browser we should now be able to navigate through our Dropbox
    structure, as before, using both the folder links and breadcrumb as navigation.
    We should now be able to use the back and forward browser buttons, plus any keyboard
    shortcuts, to also navigate back through the folders.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 回到浏览器，我们现在应该能够像以前一样通过文件夹链接和面包屑导航浏览我们的Dropbox结构。我们现在还可以使用浏览器的后退和前进按钮，以及任何键盘快捷键，通过文件夹进行导航。
- en: Before we head to [Chapter 6](part0103.html#3279U0-985bf4ae118d4f62b18ae64204cb251c), *Caching
    the Current Folder Structure Using Vuex*, and introduce folder caching to our
    app using `vuex`, there are a few optimizations we can make to our Dropbox component.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前往[第6章](part0103.html#3279U0-985bf4ae118d4f62b18ae64204cb251c)之前，*使用Vuex缓存当前文件夹结构*，并在我们的应用程序中引入文件夹缓存，我们可以对Dropbox组件进行一些优化。
- en: 'First, in the `getFolderStructure` function, we can remove the first line where
    the URL hash gets set to the path. This is because the URL has already been updated
    when the link is used. Remove this line from your code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`getFolderStructure`函数中，我们可以删除第一行，其中URL哈希被设置为路径。这是因为当链接被使用时，URL已经被更新。从代码中删除这行：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Second, there is now repetition in the Dropbox component with the `this.path` variable
    and the `p` prop. Eliminating this requires some slight reworking, as you are
    not allowed to modify a prop directly as you are with the path; however, it needs
    to be kept in sync so the breadcrumb can be correctly rendered.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在Dropbox组件中，`this.path`变量和`p` prop中现在存在重复。消除这种重复需要进行一些轻微的改动，因为你不能像处理路径那样直接修改prop；然而，它需要保持同步，以便正确渲染面包屑。
- en: Remove the `path` property from the data object in the Dropbox component, and
    also delete the  `this.path` = path line from the `getFolderStructure` function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从Dropbox组件的数据对象中删除`path`属性，并从`getFolderStructure`函数中删除`this.path = path`这一行。
- en: Next, update the prop to be equal to `path`, not `p`. This will also require
    the `watch` function to be updated to watch the `path` variable and not `p()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将prop更新为等于`path`，而不是`p`。这还需要更新`watch`函数，以监视`path`变量而不是`p()`。
- en: 'Update the created method to just use `this.path` as the parameter to the function.
    The Dropbox component should now look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将`created`方法更新为只使用`this.path`作为函数的参数。Dropbox组件现在应该是这样的：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Update the view to accept the `prop` as `path`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将视图更新为接受`prop`作为`path`：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We now need to ensure the parent `Vue` instance has the correct path on both
    page load and hash change. To avoid repetition, we are going to extend our `Vue`
    instance with both a method and a `created` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保父`Vue`实例在页面加载和哈希变化时具有正确的路径。为了避免重复，我们将使用一个方法和一个`created`函数来扩展我们的`Vue`实例。
- en: Keep the path variable set to an empty string. Create a new method titled `updateHash()` that
    removes the first character from the window hash and then sets the `path` variable
    either to the hash or an empty string. Next, create a `created()` function that
    runs the `updateHash` method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将路径变量设置为空字符串。创建一个名为`updateHash()`的新方法，它会从窗口哈希中删除第一个字符，然后将`path`变量设置为哈希或空字符串。接下来，创建一个`created()`函数，运行`updateHash`方法。
- en: 'The `Vue` instance now looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vue`实例现在看起来像这样：'
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Lastly, to remove repetition, we can fire the `updateHash` method when the
    hash changes in the address bar:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了避免重复，当地址栏中的哈希发生变化时，我们可以触发`updateHash`方法：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Final Code
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终代码
- en: 'With our code now complete your view and JavaScript file should look like the
    following. Firstly, the view should look like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码已经完成，你的视图和JavaScript文件应该如下所示。首先，视图应该是这样的：
- en: '[PRE55]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The accompanying JavaScript app should look like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的JavaScript应用程序应该是这样的：
- en: '[PRE56]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have a fully functioning Dropbox viewer app featuring navigation for
    folders and download links for files. We can use either the folder links or breadcrumb
    for navigation and use the back and/or forward buttons. We can also share or bookmark
    a link and load the contents of that folder.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有一个完全功能的Dropbox查看器应用程序，具有文件夹导航和文件下载链接。我们可以使用文件夹链接或面包屑进行导航，并使用后退和/或前进按钮。我们还可以共享或书签一个链接，并加载该文件夹的内容。
- en: In [Chapter 6](part0103.html#3279U0-985bf4ae118d4f62b18ae64204cb251c), *Caching
    the Current Folder Structure Using Vuex*, we are going to speed up the navigation
    process by caching the current folder contents using Vuex.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](part0103.html#3279U0-985bf4ae118d4f62b18ae64204cb251c)中，*使用Vuex缓存当前文件夹结构*，我们将通过使用Vuex缓存当前文件夹内容来加快导航过程。
