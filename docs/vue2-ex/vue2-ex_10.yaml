- en: Building an E-Commerce Store – Browsing Products
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建电子商务商店-浏览产品
- en: In [Chapter 9](part0156.html#4KONO0-985bf4ae118d4f62b18ae64204cb251c), *Using
    Vue-Router Dynamic Routes to Load Data*, we loaded our product data into the Vuex
    store and created a product detail page where a user could view the product and
    its variations. When viewing the product detail page, a user could change the
    variation from the drop-down and the price and other details would update.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](part0156.html#4KONO0-985bf4ae118d4f62b18ae64204cb251c)中，*使用Vue-Router动态路由加载数据*，我们将产品数据加载到Vuex存储中，并创建了一个产品详细页面，用户可以在该页面查看产品及其变体。在查看产品详细页面时，用户可以从下拉菜单中更改变体，价格和其他详细信息将更新。
- en: 'In this chapter, we are going to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Create a home page listing page with specific products
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有特定产品的主页列表页面
- en: Create a category page with a reusable component
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有可重用组件的类别页面
- en: Create an ordering mechanism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个排序机制
- en: Create filters dynamically and allow the user to filter the products
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态创建过滤器并允许用户过滤产品
- en: Listing the products
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出产品
- en: Before we create any filtering, curated lists, ordering components, and functionality,
    we need to create a basic product list – showing all the products first, and then
    we can create a paginated component that we can then reuse throughout the app.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建任何过滤、精选列表、排序组件和功能之前，我们需要创建一个基本的产品列表-首先显示所有产品，然后我们可以创建一个分页组件，然后在整个应用程序中重复使用。
- en: Adding a new route
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个新的路由
- en: 'Let us add a new route to our `routes` array. For now, we''ll work on the `HomePage`
    component, which will have the `/` route. Make sure you add it to the top of the
    `routes` array, so it doesn''t get overridden by any of the other components:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向`routes`数组中添加一个新的路由。现在，我们将在`HomePage`组件上工作，它将具有`/`路由。确保将其添加到`routes`数组的顶部，以免被其他组件覆盖。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Within the `HomePage` component, create a new `computed` property and gather
    all the products from the `store`. Ensure the products have loaded before displaying
    anything in the template. Populate the `HomePage` component with the following
    code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HomePage`组件中，创建一个新的`computed`属性并从`store`中收集所有产品。在显示模板中的任何内容之前，确保产品已加载。使用以下代码填充`HomePage`组件：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looping through products
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历产品
- en: When looking at a category listing for any shop, the data displayed tends to
    have a recurring theme. It normally consists of an image, title, price, and manufacturer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看任何商店的类别列表时，显示的数据往往具有重复的主题。通常包括图像、标题、价格和制造商。
- en: 'Add an ordered list to your template – as the products are going to have an
    order to them, it makes semantic sense to place them in an ordered list. Within
    the `<ol>`, add a `v-for` looping through the products and displaying a title
    for each one, as shown here. It''s also good practice to ensure the `product`
    variable exists before proceeding with displaying it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中添加一个有序列表-由于产品将按顺序排列，将它们放在有序列表中在语义上是有意义的。在`<ol>`中，通过`v-for`循环遍历产品并显示每个产品的标题，如下所示。在显示之前，确保`product`变量存在是一个好的实践：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When viewing the page in your browser, you may notice that the product list
    is very long. Loading images for every one of these products would be a huge load
    on the user's computer, along with overwhelming the user with that many products
    on display. Before we add more information, such as price and images, to our template,
    we'll look at paginating the products, allowing the data to be accessed in more
    manageable chunks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看页面时，您可能会注意到产品列表非常长。为每个产品加载图像将对用户的计算机造成巨大的负担，并且在显示这么多产品时会使用户不知所措。在向模板添加更多信息（如价格和图像）之前，我们将查看对产品进行分页，以便以更可管理的方式访问数据。
- en: Creating pagination
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建分页
- en: Creating pagination, initially, seems quite simple – as you only need to return
    a fixed number of products. However, if we wish to make our pagination interactive
    and reactive to the product list – it needs to be a bit more advanced. We need
    to build our pagination to be able to handle different lengths of products – in
    the case where our product list has been filtered into fewer products.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分页，最初似乎很简单 - 因为您只需要返回固定数量的产品。然而，如果我们希望使我们的分页与产品列表交互和响应 - 它需要更加先进。我们需要构建我们的分页能够处理不同长度的产品
    - 在我们的产品列表被过滤为较少的产品的情况下。
- en: Calculating the values
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算值
- en: 'The arithmetic behind creating a pagination component and displaying the correct
    products relies on four main variables:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分页组件并显示正确的产品的算术依赖于四个主要变量：
- en: '**Items per page**: This is usually set by the user; however, we''ll use a
    fixed number of 12, to begin with'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每页项目数**：这通常由用户设置; 但是，我们将首先使用固定的12个数字'
- en: '**Total items**: This is the total number of products to display'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总项目数**：这是要显示的产品总数'
- en: '**Number of pages**: This can be calculated by dividing the number of products
    by the items per page'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页数**：这可以通过将产品数量除以每页项目数来计算'
- en: '**Current page number**: This, combined with the others, will allow us to return
    exactly which products we need'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前页码**：这个与其他信息结合起来，将允许我们返回我们需要的产品'
- en: From these numbers, we can calculate everything needed for our pagination. This
    includes what products to display, whether to show next/previous links and, if
    desired, a component to skip to different links.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些数字，我们可以计算出我们的分页所需的一切。这包括要显示的产品，是否显示下一个/上一个链接，以及如果需要，跳转到不同链接的组件。
- en: Before we proceed, we are going to convert our `products` object into an array.
    This allows us to use the split method on it, which will allow us to return a
    specific list of products. It also means we can easily count the total number
    of items.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将把我们的“products”对象转换为数组。这使我们能够在其上使用split方法，从而返回特定的产品列表。这也意味着我们可以轻松计算出总项目数。
- en: 'Update your `products` computed function to return an `array` instead of an
    `object`. This is done by using the `map()` function – which is an ES2015 replacement
    for a simple `for` loop. This function now returns an array containing the product
    objects:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 更新您的“products”计算函数，以返回一个数组而不是一个对象。这可以通过使用“map()”函数来完成 - 这是一个简单的“for”循环的ES2015替代品。此函数现在返回一个包含产品对象的数组：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a new function in the computed object titled `pagination`. This function
    will return an object with various figures about our pagination, for example,
    the total number of pages. This will allow us to create a product list and update
    the navigation components. We need to only return the object if our `products`
    variable has data. The function is shown in the following code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算对象中创建一个名为“pagination”的新函数。此函数将返回一个包含有关我们的分页的各种数字的对象，例如总页数。这将允许我们创建一个产品列表并更新导航组件。我们只需要在我们的“products”变量有数据时返回对象。以下代码片段显示了该函数：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now need to keep track of two variables – items `perPage` and the `currentPage`.
    Create a `data` function on your `HomePage` component and store these two variables.
    We''ll give the user the ability to update the `perPage` variable later on. The
    highlighted code portion shows our `data` function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要跟踪两个变量 - 每页项目数和当前页码。在您的“HomePage”组件上创建一个“data”函数并存储这两个变量。我们将在以后给用户更新“perPage”变量的能力。下面的代码部分显示了我们的“data”函数：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You may be wondering when to use local data on a component and when to store
    the information in the Vuex store. This all depends on where you are going to
    be using the data and what is going to manipulating it. As a general rule, if
    only one component uses the data and manipulate it, then use the local `data()`
    function. However, if more than one component is going to be interacting with
    the variable, save it in the central store.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道何时在组件上使用本地数据，何时将信息存储在Vuex存储中。这完全取决于您将在何处使用数据以及将对其进行何种操作。一般规则是，如果只有一个组件使用数据并对其进行操作，则使用本地的`data()`函数。但是，如果有多个组件将与该变量进行交互，请将其保存在中央存储中。
- en: 'Back to the `pagination()` computed function, store a variable with the length
    of the `products` array. With this as a variable, we can now calculate the total
    pages. To do this, we are going to do the following equation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`pagination()`计算函数，用`products`数组的长度存储一个变量。有了这个变量，我们现在可以计算总页数。为此，我们将执行以下等式：
- en: '*total number of products / items per page*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*产品总数 / 每页显示的项数*'
- en: Once we have this result, we need to round it up to the nearest integer. This
    is because if there is any hangover, we need to create a new page for it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个结果，我们需要将其四舍五入到最近的整数。这是因为如果有任何余数，我们需要为其创建一个新的页面。
- en: 'For example, if you were showing 12 items per page and you had 14 products,
    that would yield a result of 1.1666 pages – which is not a valid page number.
    Rounding this up ensures we have two pages to display our products. To do this,
    use the `Math.ceil()` JavaScript function. We can also add the total number of
    products to our output. Check the following code for using the `Math.ceil()` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果每页显示12个项目，而您有14个产品，那么结果将为1.1666页 - 这不是一个有效的页码。将其四舍五入确保我们有两页来显示我们的产品。要做到这一点，使用`Math.ceil()`
    JavaScript函数。我们还可以将产品的总数添加到输出中。请查看以下代码以了解如何使用`Math.ceil()`函数：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next calculation we need to do is work out what the current range of products
    for the current page is. This is a little more complicated, as not only do we
    need to work out what we need from the page number, but the array slicing is based
    on the item index – which means the first item is `0`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一个计算是确定当前页的产品范围。这有点复杂，因为我们不仅需要确定我们从页码中需要什么，而且数组切片是基于项索引的 - 这意味着第一项是`0`。
- en: 'To work out where to take our slice from, we can use the following calculation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定从哪里进行切片，我们可以使用以下计算：
- en: '*(current page number * items per page) – items per page*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*(当前页码 * 每页显示的项数) - 每页显示的项数*'
- en: The final subtraction may seem odd, but it means on page `1`, the result is
    `0`. This allows us to work out at which index we need to slice the `products`
    array.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的减法可能看起来奇怪，但它意味着在第`1`页，结果是`0`。这样我们就可以确定我们需要在哪个索引处切片`products`数组。
- en: As another example, if we were on page three, the result would be 24, which
    is where the third page would start. The end of the slice is then this result
    *plus* the number of items per page. The advantage of this means we can update
    the items per page and all of our calculations will update.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子，如果我们在第三页，结果将是24，这是第三页的起始位置。切片的结束位置是这个结果*加上*每页显示的项数。这样做的好处是，我们可以更新每页显示的项数，所有的计算都会更新。
- en: 'Create an object inside the `pagination` result with these two results – this
    will allow us to access them later easily:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pagination`结果中创建一个对象，包含这两个结果 - 这样我们以后可以轻松地访问它们：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Displaying a paginated list
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示分页列表
- en: With our pagination properties calculated, we are now able to manipulate our
    `products` array using the start and end points. Rather than use a hardcoded value,
    or use another computed function, we are going to use a method to truncate the
    product list. This has the advantage of being able to pass on any list of products
    while also meaning Vue does not cache the result.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算我们的分页属性，我们现在可以使用起始点和结束点来操作我们的`products`数组。我们将使用一个方法来截断产品列表，而不是使用硬编码的值或使用另一个计算函数。这样做的好处是可以传递任何产品列表，同时也意味着Vue不会缓存结果。
- en: 'Create a new method object inside your component with a new method of `paginate`.
    This should accept a parameter that will be the array of `products` for us to
    slice. Within the function, we can use the two variables we calculated previously
    to return the right number of products:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部创建一个新的方法对象，方法名为`paginate`。该方法应该接受一个参数，这个参数将是我们要切片的`products`数组。在函数内部，我们可以使用之前计算的两个变量来返回正确数量的产品：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Update the template to use this method when looping through the products:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模板以在循环遍历产品时使用这个方法：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can now view this in our browser and note it returns the first 12 products
    from our object. Updating the `currentPage` variable within the `data` object
    to two or three will reveal different lists of products, depending on the number.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在浏览器中查看它，并注意它返回我们对象中的前12个产品。将`data`对象中的`currentPage`变量更新为2或3将显示不同的产品列表，具体取决于数量。
- en: To continue our semantic approach to listing our products, we should update
    the start position of our ordered list when not on page one. This can be done
    using the HTML attribute of `start` – this allows you to specify with which number
    you should start an ordered list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续我们对产品列表的语义化方法，当不在第一页时，我们应该更新有序列表的起始位置。这可以使用HTML属性`start`来完成 - 这允许您指定有序列表应该从哪个数字开始。
- en: 'Use the `pagination.range.from` variable to set the starting point of our ordered
    list – remembering to add `1` as on the first page it will be `0`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pagination.range.from`变量来设置有序列表的起始点 - 记得加上`1`，因为在第一页上它将是`0`：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When incrementing the page numbers in the code now, you will notice the ordered
    list starts at the appropriate place for each page.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在代码中递增页面数字时，你会注意到有序列表从每个页面的适当位置开始。
- en: Creating paginating buttons
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建分页按钮
- en: Updating the page number via the code isn't user-friendly – so we should add
    some pages to increment and decrement the page number variable. To do this, we'll
    create a function that changes the `currentPage` variable to its value. This allows
    us to use it for both the Next page and Previous page buttons, plus a numbered
    page list if desired.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过代码更新页面编号对用户不友好 - 所以我们应该添加一些页面来递增和递减页面编号变量。为此，我们将创建一个函数，将`currentPage`变量更改为其值。这样我们就可以同时用于下一页和上一页按钮，以及一个希望的编号页面列表。
- en: Begin by creating two buttons within your `pagination` container. We want to
    disable these buttons if we are at the extremities of the navigations – for example,
    you don't want to be able to go below `1` when going back, and past the maximum
    number of pages when going forward. We can do this by setting the `disabled` attribute
    on the button – like we did on the product detail page and comparing the current
    page against these limits.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的`pagination`容器中创建两个按钮。如果我们处于导航的极限位置，我们希望禁用这些按钮 - 例如，当返回时，您不希望能够低于`1`，当向前时，超过最大页面数。我们可以通过在按钮上设置`disabled`属性来实现这一点
    - 就像我们在产品详细页面上所做的，并将当前页面与这些限制进行比较。
- en: 'Add a `disabled` attribute and, on the Previous page, the button checks if
    the current page is one. On the Next page button, compare it to the `totalPages`
    value of our `pagination` method. The code for implementing the previously mentioned
    attributes is shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一页按钮上添加一个`disabled`属性，并检查当前页面是否为1。在下一页按钮上，将其与我们的`pagination`方法的`totalPages`值进行比较。实现前面提到的属性的代码如下所示：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Set the `currentPage` variable back to `1` and load the home page up in the
    browser. You should notice the Previous page button is disabled. If you change
    the `currentPage` variable, you will notice the buttons become active and inactive
    as desired.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将`currentPage`变量设置回`1`，并在浏览器中加载主页。您会注意到上一页按钮被禁用。如果您更改`currentPage`变量，您会注意到按钮按预期变为活动或非活动状态。
- en: 'We now need to create a click method for the buttons to update the `currentPage`.
    Create a new function titled `toPage()`. This should accept a single variable
    – this will directly update the `currentPage` variable:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为按钮创建一个点击方法来更新`currentPage`。创建一个名为`toPage()`的新函数。这个函数应该接受一个变量 - 这将直接更新`currentPage`变量：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the click handlers to the buttons, passing through `currentPage + 1` for
    the Next page button, and `currentPage - 1` for the Previous page button:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将点击处理程序添加到按钮上，对于下一页按钮，传递`currentPage + 1`，对于上一页按钮，传递`currentPage - 1`：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now navigate back and forth through the products. As a nice addition
    to the user interface, we could give an indication of the page number and how
    many pages remain, using the variables available to us by using the code mentioned
    here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过产品进行前后导航。作为用户界面的一个很好的补充，我们可以使用此处提到的代码中可用的变量来指示页面编号和剩余页面数量：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Updating the URL on navigation
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新导航的URL
- en: Another improvement to the user experience would be to update the URL on page
    navigation – this would allow the user to share the URL, bookmark it, and return
    to it later. When paginating, the pages are a *temporary* state and should not
    be the main endpoint of a URL. Instead, we can take advantage of the query parameters
    with Vue router.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 改善用户体验的另一个方法是在页面导航时更新URL - 这将允许用户分享URL，将其加为书签，并在以后返回。在分页时，页面是一个*临时*状态，不应该是URL的主要终点。相反，我们可以利用Vue路由的查询参数。
- en: 'Update the `toPage` method to add the parameter to the URL on page change.
    This can be achieved using `$router.push`, however, we need to be careful not
    to remove any existing parameters that may be in use for filtering in the future.
    This can be achieved by combining the current query object from the route with
    a new one containing the `page` variable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`toPage`方法，在页面更改时将参数添加到URL中。这可以通过`$router.push`实现，但是我们需要小心，不要删除将来可能用于过滤的任何现有参数。这可以通过将路由的当前查询对象与包含`page`变量的新对象组合来实现：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While navigating from page to page, you will notice the URL obtaining a new
    parameter of `?page=` equal to the current page name. However, pressing refresh
    will not yield the correct page results but, instead, page one again. This is
    because we need to pass the current `page` query parameter to the `currentPage`
    variable on our `HomePage` component.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在从一页导航到另一页时，您会注意到URL获取一个新的参数`?page=`，其值等于当前页面名称。然而，按下刷新按钮将不会产生正确的页面结果，而是再次显示第一页。这是因为我们需要将当前的`page`查询参数传递给我们的`HomePage`组件的`currentPage`变量。
- en: 'This can be done using the `created()` function – updating the variables –
    ensuring we''ve checked for its existence first. The `created` function is part
    of the Vue life cycle and was covered in [Chapter 4](part0076.html#28FAO0-985bf4ae118d4f62b18ae64204cb251c),
    *Getting a List of Files Using the Dropbox API*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用`created()`函数来完成 - 更新变量 - 确保我们首先检查其是否存在。`created`函数是Vue生命周期的一部分，并在[第4章](part0076.html#28FAO0-985bf4ae118d4f62b18ae64204cb251c)中介绍过，*使用Dropbox
    API获取文件列表*：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We need to ensure the `currentPage` variable is an integer, to help us with
    any arithmetic we need to do later on as a `string` is not a fan of calculations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保`currentPage`变量是一个整数，以帮助我们进行后续的算术运算，因为`string`不喜欢计算。
- en: Creating pagination links
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建分页链接
- en: When viewing paginated products, it's often good practice to have a truncated
    list of page numbers, allowing the user to jump several pages. We already have
    the mechanism for navigating between pages – this can extend that.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看分页产品时，通常最好的做法是有一个截断的页面数字列表，允许用户跳转多个页面。我们已经有了在页面之间导航的机制 - 这可以扩展它。
- en: 'As a simple entry point, we can create a link to every page by looping through
    until we reach the `totalPages` value. Vue allows us to do this without any JavaScript.
    Create a `nav` element at the bottom of the component with a list inside. Using
    a `v-for`, and create a variable of `page` for *every item* in the `totalPages`
    variable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的入口点，我们可以通过循环遍历直到达到`totalPages`值来创建到每个页面的链接。Vue允许我们在没有任何JavaScript的情况下做到这一点。在组件底部创建一个带有列表的`nav`元素。使用`v-for`，并为`totalPages`变量中的*每个项目*创建一个名为`page`的变量：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will create a button for every page – for example, if there are 24 pages
    in total, this will create 24 links. This is not the desired effect, as we want
    a few pages before and after the current page. An example of this would be, if
    the current page is 15, the page links should be 12, 13, 14, 15, 16, 17 and 18\.
    This means there are fewer links and it is less overwhelming for the user.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为每个页面创建一个按钮 - 例如，如果总共有24个页面，这将创建24个链接。这不是期望的效果，因为我们希望在当前页面之前和之后有几个页面。例如，如果当前页面是15，页面链接应该是12、13、14、15、16、17和18。这意味着链接较少，对用户来说不那么压倒性。
- en: 'To begin with, create a new variable in the `data` object, which will note
    how many pages to show either side of the selected page – a good value to start
    with is three:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`data`对象中创建一个新变量，用于记录所选页面两侧要显示的页面数量 - 一个好的起始值是三：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, create a new computed function titled `pageLinks`. This function will
    need to take the current page and work out what page numbers are three less and
    three more than that. From there, we need to check that the lower range is not
    less than one, and the upper is not more than the total number of pages. Check
    that the products array has items before proceeding:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`pageLinks`的新计算函数。这个函数需要获取当前页面，并计算出比它小三个和比它大三个的页面数字。从那里，我们需要检查较低范围是否不小于1，较高范围是否不大于总页数。在继续之前，检查产品数组是否有项目：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The last step is to create an array and a `for` loop that loops from the lower
    range to the higher range. This will create an array containing, at most, seven
    numbers with the page range:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建一个数组和一个`for`循环，循环从较低范围到较高范围。这将创建一个包含最多七个数字的页面范围数组：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can now replace the `pagination.totalPages` variable in our navigation component
    with the new `pageLinks` variable and the correct number of links will be created,
    as shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用新的`pageLinks`变量替换导航组件中的`pagination.totalPages`变量，将创建正确数量的链接，如下所示：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Viewing this in the browser, however, will render some odd behavior. Although
    the correct number of links will be generated, clicking on them or using the next/previous
    buttons will cause the buttons to remain the same – even if you navigate out of
    the range of the buttons. This is because the computed value is cached. We can
    combat this in two ways – either move the function into the `method` object or,
    alternatively, add a `watch` function to watch the route and update the current
    page.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在浏览器中查看时，会出现一些奇怪的行为。虽然会生成正确数量的链接，但点击它们或使用上一页/下一页按钮会导致按钮保持不变-即使您导航到超出按钮范围的位置。这是因为计算值被缓存了。我们可以通过两种方式解决这个问题-将函数移到`method`对象中，或者通过添加一个`watch`函数来监听路由并更新当前页面。
- en: 'Opting for the second option means we can ensure no other results and outputs
    get cached and are updated accordingly. Add a `watch` object to your component
    and update the `currentPage` variable to that of the page query variable. Ensure
    it exists, otherwise default to one. The `watch` method is as shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 选择第二个选项意味着我们可以确保没有其他结果和输出被缓存，并且会相应地更新。在你的组件中添加一个`watch`对象，并将`currentPage`变量更新为页面查询变量的值。确保它存在，否则默认为1。`watch`方法如下所示：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This ensures all the computed variables update when a different page is navigated
    to. Open your `HomePage` component and ensure all your pagination components work
    accordingly and update the list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以确保在导航到不同页面时，所有计算的变量都会更新。打开你的`HomePage`组件，确保所有的分页组件都能正常工作并更新列表。
- en: Updating the items per page
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新每页显示的项目数
- en: 'The last user interface addition we need to create is allowing the user to
    update the number of products per page. To initially set this up, we can create
    a `<select>` box with a `v-model` attribute that updates the value directly. This
    works as expected and updates the product list accordingly, as shown:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的最后一个用户界面添加是允许用户更新每页显示的产品数量。为了最初设置这个，我们可以创建一个带有`v-model`属性的`<select>`框，直接更新值。这按预期工作，并相应地更新产品列表，如下所示：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The issue with this is if the user is on a page higher than is possible once
    the value has changed. For example, if there are 30 products with 12 products
    per page, this would create three pages. If the user navigates to page three and
    then selects 24 products per page, there would only be two pages needed and page
    three would be empty.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是，如果用户在值改变后所在的页面高于可能的页面，就会出现问题。例如，如果有30个产品，每页显示12个产品，那么会创建三个页面。如果用户导航到第三页，然后选择每页显示24个产品，那么只需要两个页面，第三页将为空。
- en: 'This can be resolved, once again, with a watch function. When the `perPage`
    variable updates, we can check if the current page is higher than the `totalPages`
    variable. If it is, we can redirect it to the last page:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以再次通过watch函数解决这个问题。当`perPage`变量更新时，我们可以检查当前页面是否高于`totalPages`变量。如果是，我们可以将其重定向到最后一页：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating the ListProducts component
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ListProducts组件
- en: Before we proceed with creating the filtering and ordering, we need to extract
    our product listing logic and template it into our component – allowing us to
    easily reuse it. This component should accept a prop of `products`, which it should
    be able to list and paginate.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续创建过滤和排序之前，我们需要提取我们的产品列表逻辑并将其模板化到我们的组件中-以便我们可以轻松地重用它。该组件应该接受一个名为`products`的prop，它应该能够列出和分页。
- en: Open up the `ListProducts.js` file and copy the code from the `HomePage.js`
    file into the component. Move the data object and copy the `pagination` and `pageLinks`
    computed functions. Move the watch and methods objects, as well as the `created()`
    function, from the `HomePage` to the `ListProducts` file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`ListProducts.js`文件，并将代码从`HomePage.js`文件复制到组件中。将数据对象移动并复制`pagination`和`pageLinks`计算函数。将watch和methods对象以及`created()`函数从`HomePage`移动到`ListProducts`文件中。
- en: 'Update the `HomePage` template to use the `<list-products>` components with
    a `products` prop, passing in the `products` computed value. In comparison, the
    `HomePage` component should now be significantly smaller:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`HomePage`模板，使用带有`products`属性的`<list-products>`组件，传入`products`计算值。相比之下，`HomePage`组件现在应该更小：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Within the `ListProducts` component, we need to add a props object, to let
    the component know what to expect. This component is now significant. There are
    a few more things we need to add to this component to make it more versatile.
    They include:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ListProducts`组件内部，我们需要添加一个props对象，以让组件知道要期望什么。这个组件现在很重要。我们还需要添加一些东西到这个组件中，使其更加通用。它们包括：
- en: Showing the next/previous links if there is more than one page
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有多个页面，则显示下一页/上一页链接
- en: Showing the "products per page" component if there are more than 12 products,
    and only showing each step if there are more products than in the preceding step
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有超过12个产品，则显示“每页产品”组件，并且只在比前一步骤中有更多产品时显示每个步骤
- en: Only showing the `pageLinks` component if it's more than our `pageLinksCount`
    variable
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在`pageLinksCount`变量大于我们的`pageLinks`组件时才显示
- en: 'All of these additions have been added to the following component code as follows.
    We have also removed the unnecessary `products` computed value:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些添加都已添加到以下组件代码中。我们还删除了不必要的`products`计算值：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can verify your conditional rendering tags are working by temporarily truncating
    the products array in the `HomePage` template – don''t forget to remove it once
    you''re done:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`HomePage`模板中临时截断产品数组来验证您的条件渲染标签是否起作用 - 完成后不要忘记将其删除：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Creating a curated list for the home page
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个首页的精选列表
- en: With our product listing component in place, we can proceed with making a curated
    list of products for our home page, and add more information to the product listing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的产品列表组件，我们可以继续为我们的首页创建一个精选产品列表，并为产品列表添加更多信息。
- en: In this example, we are going to hardcode an array of product handles on our
    home page component that we want to display. If this were in development, you
    would expect this list to be controlled via a content management system or similar.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将在首页组件上硬编码一个产品句柄数组，我们希望显示。如果这是在开发中，您可以期望通过内容管理系统或类似方式来控制此列表。
- en: 'Create a `data` function on your `HomePage` component, that which includes
    an array titled `selectedProducts`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`HomePage`组件上创建一个`data`函数，其中包含一个名为`selectedProducts`的数组：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Populate the array with several `handles` from the product list. Try and get
    about six, but if you go over 12, remember it will paginate with our component.
    Add your selected handles to the `selectedProducts` array:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用产品列表中的几个`handles`填充数组。尽量获得六个，但如果超过12个，请记住它将与我们的组件分页。将您选择的句柄添加到`selectedProducts`数组中：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With our selected handles, we can now filter the product list to only include
    a list of products included in our `selectedProducts` array. The initial instinct
    might be to use the JavaScript `filter()` function on the products array combined
    with `includes()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用我们选择的句柄，我们现在可以过滤产品列表，只包括在我们的`selectedProducts`数组中的产品列表。最初的直觉可能是在产品数组上结合使用JavaScript的`filter()`函数和`includes()`函数：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The issue with this is that, although it appears to work, it does not respect
    the ordering of the selected products. The filter function simply removes any
    items that do not match and leaves the remaining products in the order they are
    loaded.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于，尽管它似乎工作正常，但它不尊重所选产品的顺序。过滤函数只是删除不匹配的任何项目，并按加载顺序保留剩余的产品。
- en: Fortunately, our products are saved in a key/value pair with the handle as the
    key. Using this, we can utilize the products object and return an array using
    a `for` loop.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们的产品以键/值对的形式保存，键是句柄。利用这一点，我们可以利用产品对象并使用`for`循环返回一个数组。
- en: 'Create an empty array, `output`, within the computed function. Looping through
    the `selectedProducts` array, find each required product and add to the `output`
    array:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算函数中创建一个空数组`output`。遍历`selectedProducts`数组，找到每个所需的产品并添加到`output`数组中：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This creates the same product list but, this time, in the correct order. Try
    re-ordering, adding, and deleting items to ensure your list reacts accordingly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建相同的产品列表，但这次是按正确的顺序。尝试重新排序、添加和删除项目，以确保您的列表能够相应地做出反应。
- en: Showing more information
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示更多信息
- en: 'We can now work on showing more product information in our `ListProduct` component.
    As mentioned near the beginning of the chapter, we should display:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`ListProduct`组件中显示更多的产品信息了。正如在本章开头提到的，我们应该显示：
- en: Image
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: Title
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题
- en: Price
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格
- en: Manufacturer
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制造商
- en: 'We''re already displaying the title, and the image and manufacturer can easily
    be pulled out from the product information. Don''t forget to always retrieve the
    first image from the `images` array. Open up the `ListProducts.js` file and update
    the product to display this information – making sure you check whether the image
    exists before displaying it. The manufacturer title is listed under the `vendor`
    object in the product data:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经显示了标题，图片和制造商可以很容易地从产品信息中提取出来。不要忘记始终从`images`数组中获取第一张图片。打开`ListProducts.js`文件并更新产品以显示这些信息-确保在显示之前检查图片是否存在。制造商标题在产品数据的`vendor`对象下列出：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The price is going to be a little more complicated to work out. This is because
    each variation on the product can have a different price, however, these are often
    the same. If there are different prices we should display the cheapest one with
    a *from* prepended.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 价格会更复杂一些。这是因为产品上的每个变体都可以有不同的价格，但通常是相同的。如果有不同的价格，我们应该显示最便宜的价格，并在前面加上*from*。
- en: We need to create a function that loops through the variations and works out
    the cheapest price and, if there is a price range, add the word *from*. To achieve
    this, we are going to loop through the variations and build up an array of unique
    prices – if the price does not already exist in the array. Once complete, we can
    check the length – if there is more than one price, we can add the prefix, if
    not, it means all variations are the same price.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个函数，遍历变体并计算出最便宜的价格，如果有价格范围，则添加*from*这个词。为了实现这一点，我们将遍历变体并建立一个唯一价格的数组-如果价格在数组中不存在的话。完成后，我们可以检查数组的长度-如果有多个价格，我们可以添加前缀，如果没有，这意味着所有的变体都是相同的价格。
- en: 'Create a new method on the `ListProducts` component called `productPrice`.
    This accepts one parameter, which will be the variations. Inside, create an empty
    array, `prices`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ListProducts`组件上创建一个名为`productPrice`的新方法。这个方法接受一个参数，即变体。在方法内部，创建一个空数组`prices`：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Loop through the variations and append the price to the `prices` array if it
    does not exist already. Create a `for` loop that uses the `includes()` function
    to check if the price exists in the array:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历变体，并将价格添加到`prices`数组中，如果价格在数组中不存在的话。使用`includes()`函数创建一个`for`循环来检查价格是否存在于数组中：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With our array of prices, we can now extract the lowest number and check whether
    there is more than one item.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有了价格数组，我们现在可以提取最小的数字，并检查是否有多个项目。
- en: 'To extract the lowest number from an array, we can use the JavaScript `Math.min()`
    function. Use the `.length` property to check the length of the array. Lastly,
    return the `price` variable:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数组中提取最小的数字，我们可以使用JavaScript的`Math.min()`函数。使用`.length`属性来检查数组的长度。最后，返回`price`变量：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add your `productPrice` method to your template, remembering to pass `product.variationProducts`
    into it. The last thing we need to add to our template is a link to the product:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的`productPrice`方法添加到模板中，记得将`product.variationProducts`传递给它。我们需要在模板中添加的最后一件事是一个指向产品的链接：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Ideally, the product links should use a named route and not a hardcoded link,
    in case the route changes. Add a name to the product route and update the `to`
    attribute to use the name instead:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，产品链接应该使用命名路由而不是硬编码的链接，以防路由发生变化。为产品路由添加一个名称，并更新`to`属性以使用该名称：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Update the template to now use the route name, with the `params` object:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模板以使用路由名称和`params`对象：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Creating categories
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建分类
- en: A shop is not really a usable shop if it does not have categories to navigate
    by. Fortunately, each of our products has a `type` key that indicates a category
    for it to be shown in. We can now create a category page that lists products from
    that particular category.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果商店没有可导航的类别，那么它实际上不是一个可用的商店。幸运的是，我们的每个产品都有一个`type`键，指示它所属的类别。现在我们可以创建一个类别页面，列出该特定类别的产品。
- en: Creating a category list
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类别列表
- en: 'Before we can display the products in a particular category, we first need
    to generate a list of available categories. To help with the performance of our
    app, we will also store the handles of the products in each category. The categories
    structure will look like the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够显示特定类别的产品之前，我们首先需要生成一个可用类别列表。为了提高应用程序的性能，我们还将在每个类别中存储产品的句柄。类别结构将如下所示：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Creating the category list like this means we readily have available the list
    of products within the category while being able to loop through the categories
    and output the `title` and `handle` to create a list of links to categories. As
    we already have this information, we will create the category list once we've
    retrieved the product list.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式创建类别列表意味着我们可以方便地获得类别中的产品列表，同时可以循环遍历类别并输出`title`和`handle`以创建类别链接列表。由于我们已经拥有这些信息，所以我们将在检索到产品列表后创建类别列表。
- en: Open up `app.js` and navigate to the `created()` method on the `Vue` instance.
    Rather than creating a second `$store.commit` underneath the `products` storing
    method, we are going to utilize a different functionality of Vuex – `actions`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app.js`并导航到`Vue`实例上的`created()`方法。我们将不再在`products`存储方法下面创建第二个`$store.commit`，而是利用Vuex的另一个功能
    - `actions`。
- en: Actions allow you to create functions in the store itself. Actions are unable
    to mutate the state directly – that is still down to mutations, but it allows
    you to group several mutations together, which in this instance, suits us perfectly.
    Actions are also perfect if you want to run an asynchronous operation before mutating
    the state – for example with a `setTimeout` JavaScript function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 操作允许您在存储本身中创建函数。操作无法直接改变状态 - 这仍然是突变的工作，但它允许您将多个突变组合在一起，这在这种情况下非常适合我们。如果您想在改变状态之前运行异步操作，操作也非常适合
    - 例如使用`setTimeout` JavaScript函数。
- en: 'Navigate to your `Vuex.Store` instance and, after the mutations, add a new
    object of `actions`. Inside, create a new function titled `initializeShop`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您的`Vuex.Store`实例，并在突变之后添加一个新的`actions`对象。在内部，创建一个名为`initializeShop`的新函数：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With action parameters, the first parameter is the store itself, which we need
    to use in order to utilize the mutations. There are two ways of doing this, the
    first is to use a single variable and access its properties within the function.
    For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在action参数中，第一个参数是store本身，我们需要使用它来使用mutations。有两种方法可以做到这一点，第一种是使用一个变量并在函数内部访问其属性。例如：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, with ES2015, we are able to use argument destructuring and utilize
    the properties we need. For this action, we only need the `commit` function, like
    so:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用ES2015，我们可以使用参数解构并利用我们需要的属性。对于这个action，我们只需要`commit`函数，像这样：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we wanted the state from the store as well, we could add it to the curly
    brackets:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想要来自store的state，我们可以将其添加到花括号中：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Using this "exploded" method of accessing the properties makes our code cleaner
    and less repetitive. Remove the `state` property and add a second parameter after
    the curly brackets labeled `products`. This will be our formatted product''s data.
    Pass that variable directly to the product''s `commit` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种"爆炸式"访问属性的方法使我们的代码更清晰、更简洁。删除`state`属性，并在花括号后面添加一个名为`products`的第二个参数。这将是我们格式化后的产品数据。将该变量直接传递给产品的`commit`函数：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Using actions is as simple as using `mutations`, except instead of using `$store.commit`,
    you use `$store.dispatch`. Update your `created` method – not forgetting to change
    the function name too, and check your app still works:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mutations`一样简单，只是不再使用`$store.commit`，而是使用`$store.dispatch`。更新你的`created`方法
    - 不要忘记同时更改函数名，并检查你的应用是否仍然正常工作：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The next step is to create a mutation for our categories. As we may want to
    update our categories independently of our products – we should create a second
    function within the `mutations`. It should also be this function that loops through
    the products and creates the list of categories.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为我们的categories创建一个mutation。由于我们可能希望独立于产品更新我们的categories - 我们应该在`mutations`中创建一个第二个函数。它也应该是这个函数循环遍历产品并创建类别列表。
- en: 'First, make a new property in the state object titled `categories`. This should
    be an object by default:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在state对象中创建一个名为`categories`的新属性。默认情况下，它应该是一个对象：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, create a new mutation called `categories`. Along with the state, this
    should take a second parameter. To be consistent, title it `payload` – as this
    is what Vuex refers to it as:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`categories`的新mutation。除了state之外，它还应该接受第二个参数。为了保持一致，将其命名为`payload`
    - 因为这是Vuex所指的：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now for the functionality. This mutation needs to loop through the products.
    For every product, it needs to isolate the `type`. Once it has the title and slug,
    it needs to check if an entry exists with that slug; if it does, append the product
    handle to the `products` array, if not – it needs to create a new array and details.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是功能的时间了。这个mutation需要循环遍历产品。对于每个产品，它需要隔离`type`。一旦它有了标题和slug，它需要检查是否存在具有该slug的条目；如果存在，将产品handle附加到`products`数组中，如果不存在
    - 它需要创建一个新的数组和详细信息。
- en: 'Create an empty `categories` object and loop through the payload, setting a
    variable for both the product and type:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空的`categories`对象，并循环遍历`payload`，为产品和类型设置一个变量：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We now need to check if an entry exists with the key of the current `type.handle`.
    If it does not, we need to create a new entry with it. The entry needs to have
    the title, handle, and an empty products array:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要检查是否存在一个具有当前`type.handle`键的条目。如果不存在，我们需要创建一个新的条目。该条目需要具有标题、handle和一个空的产品数组：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Lastly, we need to append the current product handle onto the products array
    of the entry:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将当前产品handle附加到条目的products数组中：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can view the `categories` output by adding  `console.log` to the end of
    the function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在函数末尾添加`console.log`来查看`categories`的输出：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add the mutation to the `initializeShop` action:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将mutation添加到`initializeShop` action中：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Viewing the app in the browser, you will be faced with a JavaScript error. This
    is because some products do not contain a "type" for us to use to categorize them.
    Even with the JavaScript error resolved, there are still a lot of categories that
    get listed out.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看应用程序，您将面临一个JavaScript错误。这是因为一些产品不包含我们用于对其进行分类的“type”。即使解决了JavaScript错误，仍然有很多类别被列出。
- en: To help with the number of categories, and to group the uncategorized products,
    we should make an "Miscellaneous" category. This will collate all the categories
    with two or fewer products and group the products into their own group.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助处理类别的数量，并将未分类的产品分组，我们应该创建一个“杂项”类别。这将汇总所有只有两个或更少产品的类别，并将产品分组到它们自己的组中。
- en: Creating an "miscellaneous" category
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个“杂项”类别
- en: The first issue we need to negate is the nameless category. When looping through
    our products, if no type is found, we should insert a category, so everything
    is categorized.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的第一个问题是无名称的类别。在循环遍历产品时，如果找不到类型，则应插入一个类别，以便对所有内容进行分类。
- en: Create a new object in the `categories` method that contains the title and handle
    for a new category. For the handle and variable call it other. Make the title
    a bit more user-friendly by calling it <q class="calibre31">Miscellaneous</q>.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`categories`方法中创建一个新对象，其中包含一个新类别的标题和句柄。对于句柄和变量，将其命名为`other`。通过将标题称为<q class="calibre31">杂项</q>，使其更加用户友好。
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When looping through products, we can then check to see whether the `type`
    key exists, if not, create an `other` category and append to it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环遍历产品时，我们可以检查`type`键是否存在，如果不存在，则创建一个`other`类别并将其附加到其中：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Viewing the app now will reveal all the categories in the JavaScript console
    – allowing you to see the magnitude of how many categories there are.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看应用程序将在JavaScript控制台中显示所有类别 - 让您可以看到有多少类别。
- en: 'Let''s combine any categories with two or fewer products into the "other" category
    – not forgetting to remove the category afterward. After the product loop, loop
    through the categories, checking the count of the products available. If fewer
    than three, add them to the "other" category:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将任何只有两个或更少产品的类别合并到“其他”类别中 - 不要忘记在之后删除该类别。在产品循环之后，循环遍历类别，检查可用产品的数量。如果少于三个，将它们添加到“其他”类别中：
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can then delete the category we''ve just stolen the products from:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以删除刚刚从中窃取产品的类别：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And with that, we have a much more manageable list of categories. One more
    improvement we can make is to ensure the categories are in alphabetical order.
    This helps users find their desired category much quicker. In JavaScript, arrays
    can be sorted a lot more easily than objects, so once again, we need to loop through
    an array of the object keys and sort them. Create a new object and add the categories
    as they are sorted to it. Afterward, store this on the `state` object so we have
    the categories available to us:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们有了一个更易管理的类别列表。我们可以做的另一个改进是确保类别按字母顺序排列。这有助于用户更快地找到他们想要的类别。在JavaScript中，数组比对象更容易排序，因此我们需要再次循环遍历对象键的数组并对其进行排序。创建一个新对象，并将排序后的类别添加到其中。之后，将其存储在`state`对象上，以便我们可以使用这些类别：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: With that, we can now add a list of categories to our `HomePage` template. For
    this, we'll create named `router-view` components – allowing us to put things
    in the sidebar of the shop on selected pages.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以在我们的`HomePage`模板中添加一个类别列表。为此，我们将创建命名的`router-view`组件 - 允许我们将东西放在选定页面的商店侧边栏中。
- en: Displaying the categories
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示类别
- en: With our categories stored, we can now proceed with creating our `ListCategories`
    component. We want to display our category navigation in a sidebar on the home
    page, and also on a shop category page. As we want to show it in several places,
    we have a couple of options as to how we display it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有了存储的类别，我们现在可以继续创建我们的`ListCategories`组件。我们希望在主页上的侧边栏显示类别导航，也希望在商店类别页面上显示。由于我们希望在多个地方显示它，我们有几个选项来显示它。
- en: We can use the component in the template as we have with the `<list-products>` component.
    The issue with this is that if we want to display our list in a sidebar and our
    sidebar needs to be consistent across the site, we would have to copy and paste
    a lot of HTML between views.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使用`<list-products>`组件一样在模板中使用该组件。问题是，如果我们想在侧边栏中显示我们的列表，并且我们的侧边栏需要在整个站点上保持一致，我们将不得不在视图之间复制和粘贴大量的HTML。
- en: A better approach would be to use named routes and set the template once in
    our `index.html`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用命名路由，并在我们的`index.html`中设置模板一次。
- en: 'Update the app template to contain a `<main>` and an `<aside>` element. Within
    these, create a `router-view`, leaving the one inside `main` unnamed, while giving
    the one inside the `aside` element a name of `sidebar`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 更新应用程序模板，包含一个`<main>`和一个`<aside>`元素。在其中创建一个`router-view`，将`main`内部的一个未命名，而将`aside`元素内部的一个命名为`sidebar`：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Within our routes object, we can now add different components to different
    named views. On the `Home` route, change the `component` key to `components`,
    and add an object - specifying each component and its view:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的路由对象中，我们现在可以为不同的命名视图添加不同的组件。在`Home`路由上，将`component`键改为`components`，并添加一个对象
    - 指定每个组件及其视图：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The default indicates that the component will go into the unnamed `router-view`.
    This allows us to still use the singular `component` key if required. For the
    component to be correctly loaded into the sidebar view, we need to alter how the
    `ListCategories` component is initialized. Instead of using `Vue.component`, initialize
    it as you would a `view` component:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，组件将进入未命名的`router-view`。这使我们仍然可以使用单数的`component`键（如果需要的话）。为了正确加载组件到侧边栏视图中，我们需要修改`ListCategories`组件的初始化方式。不要使用`Vue.component`，而是像初始化`view`组件一样初始化它：
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We can now proceed with making the template for the category list. As our categories
    are saved in the store, loading and displaying them should be familiar by now.
    It is advised you load the categories from the state into a computed function
    - for cleaner template code and easier adaptation should you need to manipulate
    it in any way.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续制作类别列表的模板了。由于我们的类别保存在store中，加载和显示它们应该是熟悉的。建议将类别从状态加载到计算函数中-以获得更清晰的模板代码，并在需要时更容易进行适应。
- en: Before we create the template, we need to create a route for the category. Referring
    back to our plan in [Chapter 9](part0156.html#4KONO0-985bf4ae118d4f62b18ae64204cb251c), *Using
    Vue-Router Dynamic Routes to Load Data*, we can see the route is going to be `/category/:slug`
    – add this route with a `name` and enable props, as we'll utilize them for the
    `slug`. Ensure you have made the `CategoryPage` file and initialized the component.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模板之前，我们需要为类别创建一个路由。回顾一下我们在[第9章](part0156.html#4KONO0-985bf4ae118d4f62b18ae64204cb251c)中的计划，*使用Vue-Router动态路由加载数据*，我们可以看到路由将是`/category/:slug`
    - 添加这个带有`name`和启用props的路由，因为我们将在`slug`中使用它们。确保你已经创建了`CategoryPage`文件并初始化了组件。
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Back to our `ListCategories` component; loop through the stored categories
    and create a link for each one. Show the product count in brackets after each
    name:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`ListCategories`组件；循环遍历存储的类别，并为每个类别创建一个链接。在每个名称后面用括号显示产品数量：
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With the links to our categories now showing on the home page, we can head on
    to make a category page.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的主页上显示了类别链接，我们可以继续创建一个类别页面。
- en: Displaying products in a category
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类别中显示产品
- en: Clicking one of the category links (that is, `/#/category/grips`) will navigate
    to a blank page – thanks to our route. We need to create a template and set up
    the category page to show the products. As a starting base, create the `CategoryPage`
    component in a similar vein to the product page.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 点击其中一个类别链接（即`/#/category/grips`）将导航到一个空白页面 - 这要归功于我们的路由。我们需要创建一个模板并设置类别页面以显示产品。作为起始基础，创建一个类似于产品页面的`CategoryPage`组件。
- en: Create a template with an empty container and the `PageNotFound` component inside.
    Create a data variable titled `categoryNotFound`, and ensure the `PageNotFound`
    component displays if this is set to `true`. Create a `props` object, which allows
    the `slug` property to be passed and, lastly, create a `category` computed function.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有空容器和`PageNotFound`组件的模板。创建一个名为`categoryNotFound`的数据变量，并确保如果设置为`true`，则显示`PageNotFound`组件。创建一个`props`对象，允许传递`slug`属性，并最后创建一个`category`计算函数。
- en: 'The `CategoryPage` component should look like the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoryPage`组件应该如下所示：'
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Inside the `category` computed function, load the correct category from the
    store based on the slug. If it is not on the list, mark the `categoryNotFound`
    variable to true - similar to what we did in the `ProductPage` component:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`category`计算函数内，根据slug从存储中加载正确的类别。如果它不在列表中，则将`categoryNotFound`变量标记为true -
    类似于我们在`ProductPage`组件中所做的：
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'With our category loaded, we can output the title in the template:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 加载了我们的类别后，我们可以在模板中输出标题：
- en: '[PRE65]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We can now proceed with displaying the products on our category page. To do
    this, we can use the code from the `HomePage` component as we have exactly the
    same scenario – an array of product handles.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续在我们的分类页面上显示产品了。为了做到这一点，我们可以使用`HomePage`组件中的代码，因为我们有完全相同的情况 - 一个产品句柄数组。
- en: 'Create a new `computed` function that takes the current category products and
    processes them as we did on the home page:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`computed`函数，它接受当前类别产品并像在主页上那样处理它们：
- en: '[PRE66]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We don''t need to check whether the products exist in this function as we are
    checking whether the category exists, and that would only return true if the data
    had been loaded. Add the component to the HTML and pass in the `products` variable:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们不需要检查产品是否存在，因为我们正在检查类别是否存在，只有在数据加载完成后才会返回true。将组件添加到HTML中并传入`products`变量：
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: With that, we have our category products listed out for each category.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以为每个类别列出我们的类别产品了。
- en: Code optimization
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码优化
- en: With our `CategoryPage` component complete, we can see a lot of similarities
    between that and the home page – the only difference being the home page has a
    fixed product array. To save repetition, we can combine these two components –
    meaning we only have to ever update one if we need to.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了我们的`CategoryPage`组件后，我们可以看到它与主页之间有很多相似之处 - 唯一的区别是主页有一个固定的产品数组。为了避免重复，我们可以将这两个组件合并在一起
    - 这意味着我们只需要更新一个组件即可。
- en: We can address the fixed array issue by displaying it when we identify that
    we are on the home page. The way of doing that is to check if the slug prop has
    a value. If not, we can assume we are on the home page.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在识别出我们在主页上时显示它来解决固定数组问题。这样做的方法是检查slug属性是否有值。如果没有，我们可以假设我们在主页上。
- en: 'First, update the `Home` route to point to the `CategoryPage` component and
    enable props. When using named views, you have to enable props for each of the
    views. Update the props value to be an object with each of the named views, enabling
    the props for each:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`Home`路由更新为指向`CategoryPage`组件并启用props。当使用命名视图时，您必须为每个视图启用props。将props值更新为一个对象，其中包含每个命名视图，为每个视图启用props。
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, create a new variable in the `data` function of the `CategoryPage`, titled
    `categoryHome`. This is going to be an object that follows the same structure
    as the category objects, containing a `products` array, title, and handle. Although
    the handle won''t be used, it is good practice to follow conventions:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`CategoryPage`的`data`函数中创建一个名为`categoryHome`的新变量。这将是一个遵循类别对象相同结构的对象，包含一个`products`数组，标题和句柄。虽然句柄不会被使用，但遵循惯例是一个好习惯：
- en: '[PRE69]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The last thing we need to do is check whether the slug exists. If not, assign
    our new object to the category variable within the computed function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是检查slug是否存在。如果不存在，则将我们的新对象分配给计算函数中的类别变量：
- en: '[PRE70]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Head to the home page and verify your new component is working. If it is, you
    can delete `HomePage.js` and remove it from `index.html`. Update the category
    route to also include the category list in the sidebar and use the `props` object:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 前往主页并验证您的新组件是否正常工作。如果是，请删除`HomePage.js`并从`index.html`中删除它。在类别路由中更新侧边栏中的类别列表，并使用`props`对象：
- en: '[PRE71]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Ordering products in a category
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对类别中的产品进行排序
- en: 'With our category pages displaying the right products, it''s time to add some
    ordering options within our `ListProducts` component. When viewing a shop online,
    you can normally order the products by the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的类别页面显示正确的产品时，现在是在`ListProducts`组件中添加一些排序选项的时候了。在在线商店中查看产品时，通常可以按以下方式对产品进行排序：
- en: 'Title: Ascending (A - Z)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题：升序（A - Z）
- en: 'Title: Descending (Z - A)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题：降序（Z - A）
- en: 'Price: Ascending ($1 - $999)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格：升序（$1 - $999）
- en: 'Price: Descending ($999 - $1)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格：降序（$999 - $1）
- en: However, once we have the mechanism in place, you can add any ordering criteria
    you want.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们建立了机制，您可以添加任何您想要的排序标准。
- en: 'Start off by creating a select box in your `ListProducts` component with each
    of the preceding values. Add an extra first one of Sort products by...:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`ListProducts`组件中创建一个选择框，其中包含上述每个值。添加一个额外的第一个选项：按产品排序...
- en: '[PRE72]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We now need to create a variable for the select box to update in the `data`
    function. Add a new key titled `ordering` and add a value to each option, so interpreting
    the value is easier. Construct the value by using the field and order, separated
    by a hyphen. For example, `Title - ascending (`A - Z`)` would become `title-asc`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在`data`函数中创建一个变量来更新选择框。添加一个名为`ordering`的新键，并为每个选项添加一个值，以便更容易解释该值。通过使用字段和顺序，用连字符分隔构造值。例如，`Title
    - ascending (`A - Z`)`将变为`title-asc`：
- en: '[PRE73]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And the updated `data` function becomes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的`data`函数如下：
- en: '[PRE74]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: To update the order of the products we now need to manipulate the product list.
    This needs to be done before the list gets split for pagination - as the user
    would expect the whole list to be sorted, not just the current page.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新产品的顺序，我们现在需要操作产品列表。这需要在列表被分割为分页之前完成 - 因为用户希望整个列表都被排序，而不仅仅是当前页面。
- en: Store the product price
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储产品价格
- en: Before we proceed, there is an issue we need to address. To sort by price, the
    price needs to ideally be available on the product itself, not calculated specifically
    for the template, which it currently is. To combat this, we are going to calculate
    the price before the products get added to the store. This means it will be available
    as a property on the product itself, rather than being dynamically created.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要解决一个问题。要按价格排序，价格理想情况下应该在产品本身上可用，而不是专门为模板计算的，而目前它是这样的。为了解决这个问题，我们将在将产品添加到商店之前计算价格。这意味着它将作为产品本身的属性可用，而不是动态创建的。
- en: The details we need to know are the cheapest price and whether the product has
    many prices within its variations. The latter means we know whether we need to
    display the `"From:"` when listing the products out. We will create two new properties
    for each product: `price` and `hasManyPrices`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道的详细信息是最便宜的价格以及产品的变体中是否有多个价格。后者意味着我们知道在列出产品时是否需要显示“From:”。我们将为每个产品创建两个新属性：`price`和`hasManyPrices`。
- en: 'Navigate to the `products` mutation in the store and create a new object and
    a loop of the products:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到存储中的`products`mutation，并创建一个新对象和产品的循环：
- en: '[PRE75]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Copy the code from the `productPrice` method on the `ListProducts` component
    and place it within the loop. Update the second `for` loop so it loops through `product.variationProducts`.
    Once this `for` loop has completed, we can add the new properties to the product.
    Lastly, update the state with the new products object:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ListProducts`组件上的`productPrice`方法的代码复制并放置在循环内。更新第二个`for`循环，使其循环遍历`product.variationProducts`。完成此`for`循环后，我们可以向产品添加新属性。最后，使用新的产品对象更新状态：
- en: '[PRE76]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can now update the `productPrice` method on the `ListProducts` component.
    Update the function so it accepts the product, instead of variations. Remove the
    `for` loop from the function, and update the variables so they use the `price`
    and `hasManyPrices` properties of the product instead:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新`ListProducts`组件上的`productPrice`方法。更新函数，使其接受产品而不是变体。从函数中删除`for`循环，并更新变量，使其使用产品的`price`和`hasManyPrices`属性：
- en: '[PRE77]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Update the template so the product is passed to the function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模板，以便将产品传递给函数：
- en: '[PRE78]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Wiring up the ordering
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接排序
- en: 'With our price readily available, we can proceed with wiring up the ordering.
    Create a new `computed` function titled `orderProducts` that returns `this.products`.
    We want to ensure we are always sorting from the source and not ordering something
    that has previously been ordered. Call this new function from within the `paginate`
    function and remove the parameter from this method and from the template:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的价格，我们可以继续连接排序。创建一个名为`orderProducts`的新的`computed`函数，返回`this.products`。我们希望确保我们始终从源头排序，而不是对之前已经排序过的东西进行排序。从`paginate`函数中调用这个新函数，并从该方法和模板中删除参数：
- en: '[PRE79]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To determine how we need to sort the products, we can use the `this.ordering`
    value. If it exists, we can split the string on the hyphen, meaning we have an
    array containing the field and order type. If it does not exist, we need to simply
    return the existing product array:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 确定我们需要如何对产品进行排序，我们可以使用`this.ordering`的值。如果存在，我们可以在连字符上拆分字符串，这意味着我们有一个包含字段和排序类型的数组。如果不存在，我们只需要返回现有的产品数组：
- en: '[PRE80]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Sort the `products` array based on the value of the first item of the ordering
    array. If it is a string, we will use `localCompare`, which ignores cases when
    comparing. Otherwise, we will simply subtract one value from the other – this
    is what the `sort` function expects:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 根据排序数组的第一个项的值对`products`数组进行排序。如果它是一个字符串，我们将使用`localCompare`进行比较，它在比较时忽略大小写。否则，我们将简单地从另一个值中减去一个值
    - 这是`sort`函数所期望的：
- en: '[PRE81]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Lastly, we need to check if the second item in the `orders` array is `asc`
    or `desc`. By default, the current sort function will return the items sorted
    in an `ascending` order, so if the value is `desc`, we can reverse the array:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要检查`orders`数组中的第二个项是`asc`还是`desc`。默认情况下，当前排序函数将以升序返回排序的项目，因此如果值为`desc`，我们可以反转数组：
- en: '[PRE82]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Head to your browser and check out the ordering of products!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 转到浏览器并查看产品的排序！
- en: Creating Vuex getters
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Vuex getters
- en: The last step to making our category page just like any other shop is the introduction
    of filtering. Filtering allows you to find products that have particular sizes,
    colors, tags, or manufacturers. Our filtering options are going to be built from
    the products on the page. For example, if none of the products have an XL size
    or a blue color, there is no point showing that as a filter.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的类别页面与任何其他商店一样的最后一步是引入过滤。过滤允许您查找具有特定尺寸、颜色、标签或制造商的产品。我们的过滤选项将从页面上的产品构建。例如，如果没有产品具有XL尺寸或蓝色，那么将其显示为过滤器就没有意义。
- en: To achieve this, we are going to need to pass the products of the current category
    to the filtering component as well. However, the products get processed on the
    `CategoryPage` component. Instead of repeating this processing, we can move the
    functionality to a Vuex store `getter`. Getters allow you to retrieve data from
    the store and manipulate it like you would in a function on a component. Because
    it is a central place, however, it means several components can benefit from the
    processing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们还需要将当前类别的产品传递给过滤组件。但是，产品在`CategoryPage`组件上进行处理。我们可以将功能移动到Vuex存储的获取器中，而不是重复此处理。获取器允许您从存储中检索数据并像在组件的函数中一样操作它。但是，由于它是一个中心位置，这意味着多个组件可以从处理中受益。
- en: Getters are the Vuex equivalent of computed functions. They are declared as
    functions but called as variables. However, they can be manipulated to accept
    parameters by returning a function inside them.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器是Vuex中计算函数的等效物。它们被声明为函数，但作为变量进行调用。但是，可以通过在其中返回一个函数来操作它们以接受参数。
- en: We are going to move both the `category` and `products` functions from the `CategoryPage`
    component into the getter. The `getter` function will then return an object with
    the category and products.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把`CategoryPage`组件中的`category`和`products`函数都移到获取器中。然后，`getter`函数将返回一个包含类别和产品的对象。
- en: 'Create a new object in your store titled `getters`. Inside, create a new function
    called `categoryProducts`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储中创建一个名为`getters`的新对象。在其中，创建一个名为`categoryProducts`的新函数：
- en: '[PRE83]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Getters themselves receive two parameters, the state as the first, and any other
    getters as the second. To pass a parameter to a getter, you have to return a function
    inside of the getter that receives the parameter. Fortunately, in ES2015, this
    can be achieved with the double arrow (`=>`) syntax. As we are not going to be
    using any other getters in this function, we do not need to call the second parameter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器本身接收两个参数，第一个是状态，第二个是任何其他获取器。要将参数传递给获取器，必须在获取器内部返回一个接收参数的函数。幸运的是，在ES2015中，可以使用双箭头（`=>`）语法实现这一点。由于在此函数中不会使用任何其他获取器，因此不需要调用第二个参数。
- en: 'As we are abstracting all of the logic out, pass in the `slug` variable as
    the parameter of the second function:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在将所有逻辑抽象出来，因此将`slug`变量作为第二个函数的参数传入：
- en: '[PRE84]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'As we are transferring the logic for selecting and retrieving the categories
    and products into the store, it makes sense to store the `HomePage` category content
    in the `state` itself:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在将选择和检索类别和产品的逻辑转移到存储中，因此将`HomePage`类别内容存储在`state`中是有意义的：
- en: '[PRE85]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Move category-selecting logic from the `category` computed function in the `CategoryPage`
    component into the getter. Update the `slug` and `categoryHome` variables to use
    the content from the relevant places:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CategoryPage`组件中的`category`计算函数中的逻辑移动到获取器中。更新`slug`和`categoryHome`变量以使用相关位置的内容：
- en: '[PRE86]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'With a category assigned, we can now load the products based on the handles
    stored in the category. Move the code from the `products` computed function into
    the getter. Combine the variable assignments together and remove the store product
    retrieval variable, as we have the state readily available. Ensure the code that
    checks to see whether the category exists is still in place:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个分配的类别，我们现在可以根据类别中存储的句柄加载产品。将代码从`products`计算函数移动到getter中。将变量赋值合并在一起，并删除存储产品检索变量，因为我们已经有了可用的状态。确保检查类别是否存在的代码仍然存在：
- en: '[PRE87]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Lastly, we can add a new `productDetails` array on the `category` with the
    fleshed-out product data. Return the `category` at the end of the function. If
    the `slug` variable input exists as a category, we will get all of the data back.
    If not, it will return `false` – from which we can display our `PageNotFound`
    component:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`category`上添加一个新的`productDetails`数组，其中包含详细的产品数据。在函数末尾返回`category`。如果`slug`变量输入存在作为一个类别，我们将得到所有的数据。如果不存在，它将返回`false`
    - 我们可以显示我们的`PageNotFound`组件：
- en: '[PRE88]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In our `CategoryPage` component, we can remove the `products()` computed function
    and update the `category()` function. To call a `getter` function, you refer to
    `this.$store.getters`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`CategoryPage`组件中，我们可以删除`products()`计算函数并更新`category()`函数。要调用一个`getter`函数，你可以引用`this.$store.getters`：
- en: '[PRE89]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Unfortunately, we are still having to check whether the categories exist before
    proceeding. This is so we can tell that there is no category with the name, rather
    than an unloaded one.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们仍然需要在继续之前检查类别是否存在。这样我们可以知道没有这个名称的类别，而不是一个未加载的类别。
- en: To make this neater, we can extract this check into another getter and utilize
    it in both our other getter and the component.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更整洁，我们可以将此检查提取到另一个getter中，并在其他getter和组件中使用它。
- en: 'Create a new getter titled `categoriesExist`, and return the contents of the
    `if` statement:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`categoriesExist`的新getter，并返回`if`语句的内容：
- en: '[PRE90]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Update the `categoryProducts` getter to accept getters in the arguments of
    the first function and to use this new getter to indicate its output:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`categoryProducts` getter以接受第一个函数的getter参数，并使用这个新的getter来指示它的输出：
- en: '[PRE91]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In our `CategoryPage` component, we can now call on the new getter with `this.$store.getters.categoriesExist()`.
    To save having `this.$store.getters` repeated twice in this function, we can map
    the getters to be locally accessed. This allows us to call `this.categoriesExist()` as
    a more readable function name.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`CategoryPage`组件中，我们现在可以使用`this.$store.getters.categoriesExist()`调用新的getter。为了避免在此函数中重复使用`this.$store.getters`，我们可以将getter映射为本地访问。这样我们就可以调用`this.categoriesExist()`作为一个更可读的函数名。
- en: At the beginning of the `computed` object, add a new function titled `...Vuex.mapGetters()`.
    This function accepts an array or an object as a parameter and the three dots
    at the beginning ensure the contents are expanded to be merged with the `computed`
    object.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在`computed`对象的开头，添加一个名为`...Vuex.mapGetters()`的新函数。这个函数接受一个数组或一个对象作为参数，而开头的三个点确保内容被展开以与`computed`对象合并。
- en: 'Pass in an array containing the names of the two getters:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 传入一个包含两个getter名称的数组：
- en: '[PRE92]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This now means we have `this.categoriesExist` and `this.categoryProducts` at
    our disposal. Update the category function to use these new functions:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了`this.categoriesExist`和`this.categoryProducts`。更新category函数以使用这些新函数：
- en: '[PRE93]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Update the template to reflect the changes in the computed data:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模板以反映计算数据的更改：
- en: '[PRE94]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Building the filtering component based on products
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于产品构建过滤组件
- en: As mentioned, all our filters are going to be created from the products in the
    current category. This means if there are no products made by *IceToolz*, it won't
    appear as an available filter.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们所有的过滤器都将根据当前类别中的产品创建。这意味着如果没有由*IceToolz*制造的产品，它将不会显示为可用的过滤器。
- en: 'To begin with, open the `ProductFiltering.js` component file. Our product filtering
    is going to go in our sidebar, so change the component definition from `Vue.component`
    to an object. We still want our categories to display after the filtering, so
    add the `ListCategories` component as a declared component within `ProductFiltering`.
    Add a template key and include the `<list-categories>` component:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`ProductFiltering.js`组件文件。我们的产品过滤将放在侧边栏中，所以将组件定义从`Vue.component`更改为对象。我们仍然希望在过滤之后显示我们的类别，所以将`ListCategories`组件添加为`ProductFiltering`中的一个声明组件。添加一个模板键并包含`<list-categories>`组件：
- en: '[PRE95]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Update the category route to include the `ProductFiltering` component in the
    sidebar instead of `ListCategories`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 更新类别路由，将侧边栏中的组件从`ListCategories`更改为`ProductFiltering`：
- en: '[PRE96]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: You should now have the `Home` route, which includes the `CategoryPage` and `ListCategories`
    components, and the `Category` route, which includes the `ProductFiltering` component
    instead.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该有包含`CategoryPage`和`ListCategories`组件的`Home`路由，以及包含`ProductFiltering`组件的`Category`路由。
- en: 'From the `CategoryPage` component, copy the props and computed objects - as
    we are going to be utilizing a lot of the existing code. Rename the `category`
    computed function to `filters`. Remove both the return and the `componentNotFound`
    if statement. Your component should now look like the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从`CategoryPage`组件中复制props和computed对象-因为我们将使用大量现有代码。将`category`计算函数重命名为`filters`。删除返回语句和`componentNotFound`的if语句。您的组件现在应该如下所示：
- en: '[PRE97]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We now need to construct our filters, based on the products in the category.
    We will be doing this by looping through the products, collecting information
    from preselected values, and displaying them.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要根据该类别中的产品构建我们的过滤器。我们将通过循环遍历产品，收集预选值的信息并显示它们来完成这个过程。
- en: 'Create a `data` object that contains a key of `topics`. This will be an object
    containing child objects with a, now familiar, pattern of `''handle'': {}` for
    each of the properties we want to filter on.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '创建一个包含`topics`键的`data`对象。这将是一个包含子对象的对象，每个子对象都有一个现在熟悉的模式`''handle'': {}`，用于我们想要过滤的每个属性。'
- en: Each child object will contain a `handle`, which is the value of the product
    of which to filter (for example, vendor), a `title`, which is the user-friendly
    version of the key, and an array of values, which will be populated.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子对象将包含一个`handle`，它是要过滤的产品的值（例如，供应商），一个`title`，它是键的用户友好版本，以及一个将被填充的值数组。
- en: 'We''ll start off with two, `vendor` and `tags`; however, more will be dynamically
    added as we process the products:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从两个开始，`vendor`和`tags`；然而，随着我们处理产品，将会动态添加更多：
- en: '[PRE98]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We will now begin looping through the products. Along with the values, we are
    going to keep track of how many products have the same value, allowing us to indicate
    to the user how many products will be revealed.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始循环遍历产品。除了值之外，我们还将跟踪具有相同值的产品数量，以便向用户指示将显示多少产品。
- en: Loop through the `products` on the category within the `filters` method and,
    to begin with, find the `vendor` of each product. For every one encountered, check
    whether it exists within the `values` array.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在`filters`方法中循环遍历类别中的`products`，并首先找到每个产品的`vendor`。对于每个遇到的产品，检查它是否存在于`values`数组中。
- en: If it does not, add a new object with the `name`, `handle`, and a `count`, which
    is an array of product handles. We store an array of handles so that we can verify
    that the product has already been seen. If we were keeping a raw numerical count,
    we could encounter a scenario where the filters get triggered twice, doubling
    the count. By checking whether the product handle exists already, we can check
    it's only been seen once.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，则添加一个新对象，其中包含`name`、`handle`和`count`，`count`是一个产品句柄的数组。我们存储一个句柄数组，以便我们可以验证该产品是否已经被看到。如果我们保持原始的数值计数，可能会遇到过滤器触发两次的情况，从而使计数加倍。通过检查产品句柄是否已经存在，我们可以确保它只被看到一次。
- en: 'If a filter of that name does exist, add the handle to the array after checking
    it does not exist:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在该名称的过滤器，则在检查它不存在后将句柄添加到数组中：
- en: '[PRE99]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This utilizes the previously-used object-expanding ellipsis (`...`), which
    saves us from having to write:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了先前使用的对象展开省略号（`...`），这样我们就不必编写：
- en: '[PRE100]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Although, feel free to use this if you are more comfortable with it.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您更习惯使用它，请随意使用。
- en: 'Duplicate the code to work with `tags`, however as `tags` are an array themselves,
    we need to loop through each tag and add accordingly:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 复制代码以处理`tags`，但是由于`tags`本身是一个数组，我们需要循环遍历每个标签并相应地添加：
- en: '[PRE101]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Our code is already getting repetitive and complex, let's simplify it by creating
    a method to handle the repetitive code.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码已经变得重复和复杂，让我们通过创建一个处理重复代码的方法来简化它。
- en: 'Create a `methods` object with a function of `addTopic`. This will take two
    parameters: the object to append to and the singular item. For example, its usage
    would be:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`methods`对象，其中包含一个名为`addTopic`的函数。该函数接受两个参数：要附加到的对象和单个项。例如，使用方法如下：
- en: '[PRE102]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Create the function and abstract out the logic from inside the `hasOwnProperty`
    if declaration. Name the two parameters `category` and `item`, and update the
    code accordingly:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 创建函数并从`hasOwnProperty`的if声明中提取逻辑。将这两个参数命名为`category`和`item`，并相应地更新代码：
- en: '[PRE103]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Update the `filters` computed function to use the new `addTopic` method. Remove
    the variable declarations at the top of the function, as they are being passed
    directly into the method:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`filters`计算函数以使用新的`addTopic`方法。删除函数顶部的变量声明，因为它们直接传递给方法：
- en: '[PRE104]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'At the end of this function, return `this.topics`. Although we could reference
    `topics` directly in the template, we need to ensure the `filters` computed property
    gets triggered:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数的末尾，返回`this.topics`。虽然我们可以直接在模板中引用`topics`，但我们需要确保`filters`计算属性被触发：
- en: '[PRE105]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Before we proceed to create our dynamic filters based on the various types,
    let's display the current filters.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续创建基于不同类型的动态过滤器之前，让我们显示当前的过滤器。
- en: 'Due to how the `topics` object is set up, we can loop through each of the child
    objects and then through the `values` of each one. We are going to make our filters
    out of checkboxes, with the value of the input being the handle of each of the
    filters:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`topics`对象的设置方式，我们可以循环遍历每个子对象，然后遍历每个对象的`values`。我们将使用复选框创建我们的过滤器，输入的值将是每个过滤器的句柄：
- en: '[PRE106]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: In order to keep track of what is checked, we can use a `v-model` attribute.
    If there are checkboxes with the same `v-model`, Vue creates an array with each
    item.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪选中的内容，我们可以使用`v-model`属性。如果有多个具有相同`v-model`的复选框，Vue会创建一个包含每个项的数组。
- en: 'Add an array of `checked` to each of the `topic` objects in the data object:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据对象的每个`topic`对象中添加一个`checked`数组：
- en: '[PRE107]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Next, add a `v-model` attribute to each checkbox, referencing this array on
    the `filter` object along with a click binder, referencing an `updateFilters`
    method:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为每个复选框添加一个`v-model`属性，引用`filter`对象上的该数组，并添加一个点击绑定器，引用一个`updateFilters`方法：
- en: '[PRE108]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Create an empty method for now - we''ll configure it later:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先创建一个空的方法，稍后再进行配置：
- en: '[PRE109]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Dynamically creating filters
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态创建过滤器
- en: With our fixed filters created and being watched, we can take the opportunity
    to create dynamic filters. These filters will observe the `variationTypes` on
    the products (for example, color, and size) and list out the options – again with
    the count of each one.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建和监视我们的固定过滤器，我们可以利用机会创建动态过滤器。这些过滤器将观察产品上的`variationTypes`（例如颜色和尺寸），并列出选项
    - 同时显示每个选项的计数。
- en: 'To achieve this, we need to first loop through the `variationTypes` on the
    products. Before adding anything, we need to check to see if that variation type
    exists on the `topics` object, if not – we need to add a skeleton object. This
    expands the variation (which contains the `title` and `handle`) and also includes
    empty `checked` and `value` properties:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们首先需要遍历产品上的`variationTypes`。在添加任何内容之前，我们需要检查`topics`对象上是否存在该变体类型，如果不存在，则需要添加一个骨架对象。这会展开变体（其中包含`title`和`handle`），并且还包括空的`checked`和`value`属性：
- en: '[PRE110]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'With our empty object created, we can now loop through the `variationProducts`
    on the product object. For each one, we can access the variant with the handle
    of the current variation. From there, we can use our `addTopic` method to include
    the value (for example, Blue or XL) within the filters:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 创建空对象后，我们现在可以遍历产品对象上的`variationProducts`。对于每个产品，我们可以使用当前变体的句柄访问变体。从那里，我们可以使用我们的`addTopic`方法在过滤器中包含值（例如蓝色或XL）：
- en: '[PRE111]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: We do need to update our `addTopic` method, however. This is because the dynamic
    properties have a `value`, instead of a title.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们确实需要更新我们的`addTopic`方法。这是因为动态属性具有`value`，而不是标题。
- en: 'Add an `if` statement to your `addTopic` method to check whether a `value`
    exists, if it does – set it to the `title`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addTopic`方法中添加一个`if`语句，检查是否存在`value`，如果存在 - 将其设置为`title`：
- en: '[PRE112]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Viewing the app in the browser should reveal your dynamically-added filters,
    along with the original ones we had added.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看应用程序应该显示出动态添加的过滤器，以及我们添加的原始过滤器。
- en: Resetting filters
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置过滤器
- en: When navigating between categories you will notice that, currently, the filters
    do not reset. This is because we are not clearing the filters between each navigation,
    and the arrays are persisting. This is not ideal, as it means they get longer
    as you navigate around and do not apply to the products listed.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航到不同类别之间，您会注意到，当前过滤器不会重置。这是因为我们没有在每次导航之间清除过滤器，数组仍然存在。这并不理想，因为它意味着随着您的导航而变得越来越长，并且不适用于列出的产品。
- en: 'To remedy this, we can create a method that returns our default topic object
    and, when the slug updates, call the method to reset the `topics` object.  Move
    the `topics` object to a new method titled `defaultTopics`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以创建一个方法来返回我们的默认主题对象，并在slug更新时调用该方法来重置`topics`对象。将`topics`对象移到一个名为`defaultTopics`的新方法中：
- en: '[PRE113]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Within the `data` function, change the value of topics to be `this.defaultTopics()`
    to call the method:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data`函数中，将topics的值更改为`this.defaultTopics()`来调用该方法：
- en: '[PRE114]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Lastly, add a watch function to reset the topics key when the `slug` gets updated:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`slug`更新时添加一个watch函数来重置topics键：
- en: '[PRE115]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Updating the URL on checkbox filter change
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在复选框过滤器更改时更新URL
- en: Our filtering component, when interacted with, is going to update the URL query
    parameters. This allows the user to see the filters in effect, bookmark them,
    and share the URL if needed. We already used query parameters for our pagination,
    and it makes sense to put the user back on page one when filtering – as there
    may only be one page.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当与我们的过滤组件交互时，它将更新URL查询参数。这允许用户查看过滤器的效果，将其加为书签，并在需要时共享URL。我们已经在分页中使用了查询参数，将用户放回第一页进行过滤是有意义的，因为可能只有一页。
- en: To construct our query parameters of filters, we need to loop through each filter
    type and add a new parameter for each one that has items in the `checked` array.
    We can then call a `router.push()` to update the URL and, in turn, change the
    products displayed.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的过滤器的查询参数，我们需要循环遍历每个过滤器类型，并为每个在`checked`数组中有项目的过滤器添加一个新参数。然后，我们可以调用`router.push()`来更新URL，并相应地更改显示的产品。
- en: 'Create an empty object in your `updateFilters` method. Loop through the topics
    and populate the `filters` object with the items checked. Set the `query` parameters
    in the router to the `filters` object:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在`updateFilters`方法中创建一个空对象。循环遍历主题并使用选中的项目填充`filters`对象。将`filters`对象设置为路由器中的`query`参数：
- en: '[PRE116]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Checking and unchecking the filters on the right should update the URL with
    the items checked.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧选中和取消选中过滤器应该更新URL并选中项目。
- en: Preselecting filters on page load
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在页面加载时预选过滤器。
- en: 'When loading a category with filters already in the URL, we need to ensure
    the checkboxes are checked on the right-hand side. This can be done by looping
    through the existing query parameters and adding any matching keys and arrays
    to the topics parameter. As the `query` can either be an array or a string, we
    need to ensure the checked property is an array no matter what. We also need to
    ensure the query key is, indeed, a filter and not a page parameter:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL中加载具有已经存在的过滤器的类别时，我们需要确保右侧的复选框被选中。这可以通过循环遍历现有的查询参数，并将任何匹配的键和数组添加到主题参数中来完成。由于`query`可以是数组或字符串，我们需要确保`checked`属性无论如何都是一个数组。我们还需要确保查询键确实是一个过滤器，而不是一个页面参数：
- en: '[PRE117]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: On page load, the filters in the URL will be checked.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面加载时，将检查URL中的过滤器。
- en: Filtering the products
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤产品
- en: Our filters are now being created and appended to dynamically, and activating
    a filter updates the query parameter in the URL. We can now proceed with showing
    and hiding products based on the URL parameters. We are going to be doing this
    by filtering the products before being passed into the `ListProducts` component.
    This ensures the pagination works correctly.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在动态创建和附加过滤器，并且激活过滤器会更新URL中的查询参数。现在我们可以根据URL参数显示和隐藏产品。我们将通过在传递给`ListProducts`组件之前对产品进行过滤来实现这一点。这样可以确保分页功能正常工作。
- en: 'As we are filtering, open up `ListProducts.js` and add a `:key` attribute to
    each list item, with the value of the `handle`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行过滤时，打开`ListProducts.js`并为每个列表项添加一个`：key`属性，其值为`handle`：
- en: '[PRE118]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Open up the `CategoryPage` view and create a method within the `methods` object
    titled `filtering()` and add a  `return true` to begin with. The method should
    accept two parameters, a `product` and `query` object:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`CategoryPage`视图，并在`methods`对象中创建一个名为`filtering()`的方法，并添加`return true`以开始。该方法应接受两个参数，一个`product`和一个`query`对象：
- en: '[PRE119]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Next, within the `category` computed function, we need to filter the products
    if there is a query parameter. However, we need to be careful that we don't trigger
    the filters if the page number is present – as that is also a query.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`category`计算函数中，如果有查询参数，我们需要对产品进行过滤。但是，我们需要小心，如果页面号存在，不要触发过滤器，因为那也是一个查询参数。
- en: 'Create a new variable called `filters`, which is a copy of the query object
    from the route. Next, if the page parameter is present, `delete` it from our new
    object. From there, we can check whether the query object has any other contents
    and if so, run the native JavaScript `filter()` function on our product array
    – passing in the product and new query/filters object to our method:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`filters`的新变量，它是路由中查询对象的副本。接下来，如果页面参数存在，从我们的新对象中`删除`它。从那里，我们可以检查查询对象是否有其他内容，如果有的话，就在我们的产品数组上运行原生的JavaScript
    `filter()`函数 - 将产品和新的查询/过滤对象传递给我们的方法：
- en: '[PRE120]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Refresh your app to ensure the products still show.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新您的应用程序以确保产品仍然显示。
- en: To filter products, there is quite a complex process involved. We want to check
    whether an attribute is in the query parameters; if it is, we set a placeholder
    value of `false`. If the attribute on the product matches that of the query parameter,
    we set the placeholder to `true`. We then repeat this for each of the query parameters.
    Once complete, we then only show products that have all of the criteria.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要过滤产品，涉及到一个相当复杂的过程。我们想要检查一个属性是否在查询参数中，如果是，我们将设置一个占位值为`false`。如果产品上的属性与查询参数相匹配，我们将将占位符设置为`true`。然后我们对每个查询参数重复这个过程。完成后，我们只显示具有所有条件的产品。
- en: The way we are going to construct this allows products to be `OR` within the
    categories, but `AND` with different sections. For example, if the user were to
    pick many colors (red and green) and one tag (accessories), it will show all products
    that are red or green accessories.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的方式允许产品在类别内为`OR`，但在不同的部分为`AND`。例如，如果用户选择了多种颜色（红色和绿色）和一个标签（配件），它将显示所有红色或绿色的配件产品。
- en: Our filtering is created with the tags, vendor, and then dynamic filters. As
    two of the properties are fixed, we will have to check these first. The dynamic
    filters will be verified by reconstructing the way they were built.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过滤器是通过标签、供应商和动态过滤器创建的。由于其中两个属性是固定的，我们需要首先检查它们。动态过滤器将通过重建它们构建的方式进行验证。
- en: Create a `hasProperty` object, which will be our placeholder object for keeping
    track of the query parameters the product has. We'll begin with the `vendor` –
    as this is the simplest property.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`hasProperty`对象，它将是我们用来跟踪产品具有的查询参数的占位符对象。我们将从`vendor`开始 - 因为这是最简单的属性。
- en: 'We start by looping through the query attributes – in case there is more than
    one (for example, red and green). Next, we need to confirm that the  `vendor`
    exists in the `query` – if it does, we then set a vendor attribute in the `hasProperty`
    object to `false`. We then check whether the vendor handle is the same as the
    query attribute. If this matches, we change our `hasProperty.vendor` property
    to `true`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过循环遍历查询属性 - 如果有多个属性（例如红色和绿色），接下来，我们需要确认`query`中是否存在`vendor` - 如果存在，我们将在`hasProperty`对象中将`vendor`属性设置为`false`，然后我们检查`vendor`句柄是否与查询属性相同，如果匹配，我们将更改`hasProperty.vendor`属性为`true`。
- en: '[PRE121]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This will update the `hasProperty` object with whether the vendor matches the
    selected filter. We can row replicate the functionality with the `tags` – remembering
    that tags on a product are an object we need to filter.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据供应商是否与所选过滤器匹配来更新`hasProperty`对象。我们可以使用标签来复制该功能 - 记住产品上的标签是我们需要过滤的对象。
- en: 'The dynamic properties constructed by the filters will also need to be checked.
    This is done by checking the variant object on each `variationProduct`, and updating
    the `hasProperty` object if it matches:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要检查过滤器构建的动态属性。这是通过检查每个`variationProduct`上的变体对象，并在匹配时更新`hasProperty`对象来完成的。
- en: '[PRE122]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Lastly, we need to check each of the properties of the `hasProperty` object.
    If all the values are set to `true`, we can set the display of the product to
    `true` – meaning it will show. If one of them is `false`, the product will not
    show as it does not match all of the criteria:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要检查`hasProperty`对象的每个属性。如果所有值都设置为`true`，我们可以将产品的显示设置为`true` - 这意味着它将显示出来。如果其中一个值为`false`，则产品将不会显示，因为它不符合所有的条件。
- en: '[PRE123]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We now have a successful filtering product list. View your app in the browser
    and update the filters – noting how products show and hide with each click. Note
    how even when you press refresh, only the filtered products display.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个成功的过滤产品列表。在浏览器中查看您的应用程序并更新过滤器 - 注意每次单击时产品的显示和隐藏。请注意，即使您按下刷新，只有过滤后的产品会显示。
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we created a category listing page, allowing the user the view
    all the products in a category. This list is able to be paginated, along with
    the order changing. We also created a filtering component, allowing the user to
    narrow down the results.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个分类列表页面，允许用户查看某个类别中的所有产品。该列表可以进行分页，并且可以改变排序方式。我们还创建了一个筛选组件，允许用户缩小结果范围。
- en: With our products now browseable, filterable, and viewable, we can proceed on
    to making a Cart and Checkout page.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的产品可以浏览、筛选和查看了，我们可以继续制作购物车和结账页面。
