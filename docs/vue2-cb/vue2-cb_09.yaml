- en: Advanced Vue.js – Directives, Plugins, and Render Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Vue.js - 指令、插件和渲染函数
- en: 'In this chapter, we will talk about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Creating a new directive
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的指令
- en: Using WebSockets in Vue
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue中使用WebSockets
- en: Writing a plugin for Vue
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Vue编写插件
- en: Rendering a simple component manually
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动渲染一个简单的组件
- en: Rendering a component with children
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染带有子元素的组件
- en: Using JSX to render a component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSX渲染组件
- en: Creating a functional component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个功能性组件
- en: Building a responsive table with higher-order components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高阶组件构建响应式表格
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Directives and plugins are ways to package functionality in a reusable way and
    also make it easily shareable across apps and teams; you will build a few of them
    in this chapter. Render functions are how Vue really works under the hood to turn
    templates into the Vue language and then into HTML and JavaScript again; they become
    useful if you need to optimize the performance of your apps and work in some corner
    cases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 指令和插件是以可重用的方式打包功能并使其在应用程序和团队之间易于共享的方法；在本章中，您将构建其中的一些。渲染函数是Vue在幕后实际工作的方式，将模板转换为Vue语言，然后再次转换为HTML和JavaScript；如果您需要优化应用程序的性能并处理一些特殊情况，它们将非常有用。
- en: In general, you should avoid using these advanced functions when possible as
    they have been a little overused in the past. Usually, many problems can be solved
    by simply writing a good component and distributing the component itself; you
    should look at advanced features only when this is not true.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，应尽量避免在可能的情况下使用这些高级功能，因为它们在过去有点被滥用。通常，许多问题可以通过编写一个良好的组件并分发组件本身来解决；只有在这种情况不成立时，您才应该考虑使用高级功能。
- en: This chapter is for the slightly more experienced, and you probably won't find
    the level of step-by-step detail found in other recipes, but I have strived to
    make them complete nonetheless.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章面向稍有经验的开发者，您可能不会在其他示例中找到逐步详细说明的水平，但我努力使它们完整。
- en: Creating a new directive
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的指令
- en: Directives are like mini functions that you can use to quickly drop in to your
    code, mainly to improve the user experience, and to add new low-level features
    to your graphic interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 指令类似于小型函数，您可以使用它们快速地插入到您的代码中，主要是为了改善用户体验，并向您的图形界面添加新的低级功能。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe, although found in the advanced chapter, is really easy to complete.
    The main reason directives are *advanced* is because you should usually prefer
    composition to add functionality and style to your apps. When components won't
    cut it, use directives.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个示例在高级章节中，但它非常容易完成。指令之所以被称为“高级”是因为通常应该优先选择组合来为应用程序添加功能和样式。当组件无法满足需求时，可以使用指令。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will build a `v-pony` directive that will turn any element into a pony element.
    A pony element is created with a pink background and changes color when you click
    on it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个`v-pony`指令，将任何元素转换为小马元素。小马元素具有粉色背景，并在单击时更改颜色。
- en: 'The HTML code for the pony element is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 小马元素的HTML代码如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Just to show the difference, I''ve included a normal `blockquote` element.
    In our JavaScript section, write the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示差异，我包含了一个普通的`blockquote`元素。在我们的JavaScript部分，写入以下内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is how you declare a new directive. The `bind` hook is called when the
    directive is bound to the element. The only thing we are doing now is setting
    the background color. We also want to make it change color after each click. To
    do this, you have to add this code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何声明新指令的。当指令绑定到元素时，将调用`bind`钩子。现在我们只是设置背景颜色。我们还希望在每次点击后更改颜色。要做到这一点，您必须添加以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are creating an `onclick` listener that will generate a random color
    with a bias toward red and assign it as a new background color.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个`onclick`监听器，它将生成一个偏向红色的随机颜色，并将其分配为新的背景颜色。
- en: 'At the end of our JavaScript, remember to create a `Vue` instance:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JavaScript末尾，不要忘记创建一个`Vue`实例：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can launch your application to see your directive in action:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以启动应用程序以查看指令的效果：
- en: '![](img/Image00159.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00159.jpg)'
- en: Don't forget to click on the text to change the background color!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记点击文本以更改背景颜色！
- en: How it works…
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The syntax to declare a new directive is as illustrated:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 声明新指令的语法如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will register a new global directive. Inside the hooks object, you can
    define two important functions: `bind` , which you used in this recipe, and `update`
    , which is triggered every time a component contained in it is updated.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将注册一个新的全局指令。在hooks对象内部，您可以定义两个重要的函数：`bind`，您在本示例中使用的函数，以及`update`，它在其中包含的组件每次更新时触发。
- en: 'Every hook function is called with at least three arguments:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个钩子函数至少被调用三个参数：
- en: '`el` : The HTML element'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`el`：HTML元素'
- en: '`binding` : Directives can receive an argument; binding is an object that will
    contain the value of the argument'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding`：指令可以接收一个参数；binding是一个包含参数值的对象'
- en: '`vnode` : the Vue internal representation of this element'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vnode`：此元素的Vue内部表示'
- en: We used the `el`  parameter to edit the appearance of our element, manipulating
    it directly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`el`参数直接编辑元素的外观。
- en: Using WebSockets in Vue
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Vue中使用WebSockets
- en: WebSockets are a new technology that enables two-way communication between the
    user and the server where the app is hosted. Before this technology, only the
    browser could initiate a request and, thus, a connection. If some update on the
    page was expected, the browser had to continuously poll the server. With WebSockets,
    this is no longer necessary; after the connection is established, the server can
    send updates only when there is a need.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets是一种新技术，它使用户和托管应用程序的服务器之间可以进行双向通信。在这项技术出现之前，只有浏览器可以发起请求和连接。如果页面上有更新，浏览器必须不断地轮询服务器。使用WebSockets，这不再是必需的；在建立连接后，服务器只有在需要时才能发送更新。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You don't need any preparation for this recipe, just the basics of Vue. If you
    don't know what WebSockets are, you don't really need to, just think about them
    as a channel of continuous two-way communication between a server and browser.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要为此示例做任何准备，只需要了解Vue的基础知识。如果您不知道什么是WebSockets，您实际上不需要知道，只需将其视为服务器和浏览器之间连续双向通信的通道。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: For this recipe, we need a server and a browser that will act a client. We will not
    build a server; instead, we'll use an already existing server that just echoes
    whatever you send to it via WebSockets. So, if we were to send the `Hello` message,
    the server would respond with `Hello` .
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要一个充当客户端的服务器和浏览器。我们不会构建一个服务器；相反，我们将使用一个已经存在的服务器，通过WebSockets将您发送的任何内容回显。因此，如果我们发送`Hello`消息，服务器将回复`Hello`。
- en: 'You will build a chat app that will talk to this server. Write the following
    HTML code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您将构建一个聊天应用程序，该应用程序将与此服务器进行通信。编写以下HTML代码：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `<pre>` tag will help us render a chat. As we don't need the `<br/>` element
    to break a line, we can just use the `n` special character that means a new line.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`<pre>`标签将帮助我们渲染聊天记录。由于我们不需要`<br/>`元素来换行，我们可以使用特殊字符`n`表示换行。'
- en: 'For our chat to work, we first have to declare our WebSocket in the JavaScript:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的聊天工作，我们首先必须在JavaScript中声明我们的WebSocket：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, we declare our `Vue` instance that will contain a `chat` string
    (to contain the chat so far) and a `message` string (to contain the message we
    are currently writing):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们声明我们的`Vue`实例，其中包含一个`chat`字符串（用于保存到目前为止的聊天记录）和一个`message`字符串（用于保存我们当前正在编写的消息）：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We still need to define the `send` method, which is called upon pressing *Enter*
    in the textbox:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要定义`send`方法，该方法在文本框中按下*Enter*时调用：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We factored out the `appendToChat`  method because we will use it to append
    all the messages we''ll receive. To do this, we must wait for the component to
    be instantiated. The `created`  hook is a safe place for that:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`appendToChat`方法分解出来，因为我们将使用它来附加我们收到的所有消息。为此，我们必须等待组件被实例化。`created`钩子是一个安全的地方：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now launch the application to chat with your personal echo chamber:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动应用程序与您的个人回声室聊天：
- en: '![](img/Image00160.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00160.jpg)'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To see the internals of what you have built, open the Chrome developer tools
    (![](img/Image00161.jpg)  |  More tools  |  Developer tools or *Opt* + *Cmd* +
    *I* ):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您构建的内容的内部，请打开Chrome开发者工具（！[](img/Image00161.jpg) | 更多工具 | 开发者工具或*Opt* + *Cmd*
    + *I*）：
- en: '![](img/Image00162.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00162.jpg)'
- en: 'Go to the Network tab and reload the page; you should see the `echo.websocket.orl`
     WebSocket, as seen in the screenshot. Write something and messages will appear
    in the frame tab, like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 转到网络选项卡并重新加载页面；您应该看到`echo.websocket.orl` WebSocket，如屏幕截图所示。输入一些内容，消息将出现在帧选项卡中，如下所示：
- en: '![](img/Image00163.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00163.jpg)'
- en: The green messages are sent from you while the white messages are the ones you
    receive. You can also examine the message length (in bytes) and the exact time
    they were sent or received.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色消息是您发送的消息，而白色消息是您接收的消息。您还可以检查消息的长度（以字节为单位）以及发送或接收的确切时间。
- en: Writing a plugin for Vue
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Vue编写一个插件
- en: A plugin is a collection of utilities or a global new behavior that we want
    in our application. Vuex and vue-router are two famous examples of Vue plugins.
    A plugin can really be anything, since writing one means acting at a very low
    level. There are different kinds of plugins you can write. For this recipe, we
    will concentrate on building a directive with global properties.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是我们想要在应用程序中拥有的一组实用工具或全局新行为。Vuex和vue-router是Vue插件的两个著名例子。插件可以是任何东西，因为编写插件意味着在非常低的层次上进行操作。你可以编写不同类型的插件。对于这个示例，我们将专注于构建具有全局属性的指令。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will be based on *Creating a new directive* , except that we will
    add some features for global coordination.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将基于*创建一个新的指令*，只是我们将添加一些用于全局协调的功能。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, we will build a website for a kangaroo appreciation club.
    The layout of the home page HTML looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将为一个袋鼠欣赏俱乐部建立一个网站。主页HTML的布局如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can change the link to the images of kangaroos with the one you prefer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将袋鼠图片的链接更改为你喜欢的链接。
- en: 'In the JavaScript part, we instantiate an empty `Vue` instance for now:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript部分，我们暂时实例化一个空的`Vue`实例：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we open the page now, we get this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打开页面，会得到这个结果：
- en: '![](img/Image00164.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00164.jpg)'
- en: Now we want to add a fun note to our website. We want the elements of the page,
    except the title, to jump at random intervals.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想在网站上添加一个有趣的注释。我们希望页面上的元素（除了标题）以随机的时间间隔跳动。
- en: To do this, the strategy you will implement is to register all the elements
    that will need to jump in an array, and then, periodically take a random element
    and make it jump.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，你将实现的策略是将所有需要跳动的元素注册到一个数组中，然后定期选择一个随机元素并使其跳动。
- en: 'The first thing we need to define is the jump animation in CSS:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要定义CSS中的跳动动画：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What this does is create a class named `kangaroo` that, when applied to an element,
    makes it jump twice by translating it along the y axis.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的效果是创建一个名为`kangaroo`的类，当应用于一个元素时，它会沿着y轴跳动两次。
- en: 'Next, write a function that adds this class to a specified element in the JavaScript:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编写一个函数，在JavaScript中将这个类添加到指定的元素上：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `jump` function adds the `kangaroo` class and then removes it when the animation
    is finished.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`jump`函数会添加`kangaroo`类，并在动画完成后将其移除。'
- en: 'We want to perform this action on a random element picked from the ones registered:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在注册的元素中随机选择一个执行此操作：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `doOnRandomElement`  function takes an action and a collection and applies
    the action to a drawn element. We then need to schedule it at random intervals:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`doOnRandomElement`函数接受一个动作和一个集合，并将该动作应用于一个随机选择的元素。然后，我们需要在随机的时间间隔内调度它：'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `atRandomIntervals`  function takes the specified function and calls it
    at random intervals shorter than 6 seconds.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`atRandomIntervals`函数接受指定的函数，并在小于6秒的随机时间间隔内调用它。'
- en: 'We now have all the functions we need to actually build a plugin that will
    make our element jump:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了构建使元素跳跃的插件所需的所有函数：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Kangaroo plugin, when installed, creates an empty array; it declares a new
    directive, `kangaroo`  which will register all the elements with it inside the
    array.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Kangaroo插件在安装时创建一个空数组；它声明了一个新的指令`kangaroo`，该指令将所有包含在其中的元素注册到数组中。
- en: Then at random intervals, one random element is drawn from the array and the
    jump function is called on it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在随机的时间间隔内，从数组中随机选择一个元素，并调用跳跃函数。
- en: 'To activate the plugin, we need one line before declaring the `Vue` instance
    (but after declaring `Kangaroo` ):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活插件，在声明`Vue`实例之前（但在声明`Kangaroo`之后）需要添加一行代码：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have to choose the elements that jump, that is, everything except the title:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须选择跳动的元素，也就是除了标题以外的所有元素：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you run your app now, you will see that an image or the text jumps just like
    a kangaroo every few seconds.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行您的应用程序，您将看到图像或文本每隔几秒钟像袋鼠一样跳动。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In its essence, a Vue plugin is just a way to group some functionalities. There
    are not many restrictions and all you have to do to create a plugin is to declare
    an install function. The general syntax to do that is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，Vue插件只是一种将一些功能组合在一起的方式。没有太多限制，创建插件的唯一要做的就是声明一个安装函数。一般的语法如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To use the plugin you just made, write the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用您刚刚创建的插件，编写以下代码：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the second parameter is the optional object that gets passed to the `install`
    function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第二个参数是传递给`install`函数的可选对象。
- en: Since plugins are global entities, you should use them sparsely and only for
    features that you foresee will affect your app throughout.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于插件是全局实体，您应该尽量少使用它们，只用于您预见会影响整个应用程序的功能。
- en: Rendering a simple component manually
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动渲染一个简单的组件
- en: Vue turns your HTML templates into render functions. Usually, you should stick
    to templates because they are much simpler. There are a couple of cases in which
    render functions become in handy. Here, we show a simple example in which render
    functions are useful.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Vue将您的HTML模板转换为渲染函数。通常，您应该坚持使用模板，因为它们更简单。有几种情况下，渲染函数变得非常有用。在这里，我们展示了一个简单的例子，其中渲染函数很有用。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This is the first recipe on render functions. If you already understand the
    basics of Vue, you will understand everything.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有关渲染函数的第一个示例。如果您已经了解Vue的基础知识，您将理解其中的一切。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The first use case for render functions is whenever you just want a `Vue` instance
    that displays another component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染函数的第一个用例是当您只想要一个显示另一个组件的`Vue`实例时。
- en: 'Write an empty HTML layout, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个空的HTML布局，如下所示：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have a Greeter component somewhere that we want to show as the main `Vue`
    instance. In the JavaScript part, add the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为Greeter的组件，我们希望将其显示为主要的`Vue`实例。在JavaScript部分，添加以下代码：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we have to imagine that we are taking the `Greeter` component from somewhere
    else and, since the component is nicely packaged, we don''t want to modify it.
    Instead, we will pass it to the `Vue` main instance:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须想象我们从其他地方获取了`Greeter`组件，并且由于组件已经很好地打包，我们不想修改它。相反，我们将它传递给`Vue`主实例：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we launch the application now, we will only see the `Greeter` component.
    The main `Vue` instance will only act as a wrapper.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在启动应用程序，我们只会看到`Greeter`组件。主`Vue`实例只充当包装器。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The render function replaces the template in the `Vue` instance. When render
    is called, the passed argument is the so-called `createElement` function. We named
    it `h` for brevity. This function accepts three arguments, but for now, just note
    how the first argument we are passing (the only one we are passing) is the `Greeter`
    component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染函数替换了`Vue`实例中的模板。当调用渲染函数时，传递的参数是所谓的`createElement`函数。为了简洁起见，我们将其命名为`h`。这个函数接受三个参数，但现在只需要注意我们传递的第一个参数（也是唯一一个参数）是`Greeter`组件。
- en: In theory, you can write the component inline, inside the `h` function. In a
    real project, this is not always possible depending on the presence of the Vue
    template compiler at runtime. When you use the official Webpack template, one
    of the questions you are asked is whether you want to include the Vue template
    compiler when distributing your software.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，您可以在`h`函数内联编写组件。在实际项目中，这并不总是可能的，这取决于运行时是否存在Vue模板编译器。当您使用官方的Webpack模板时，您会被问到是否要在分发软件时包含Vue模板编译器。
- en: 'The arguments for the `createElement` function are listed here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`createElement`函数的参数在这里列出：'
- en: 'As the first argument, the only required one, you have the option to pass three
    different things:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一个参数，唯一必需的参数，您可以选择传递三种不同的内容：
- en: The options of a Vue component, like in our recipe
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue组件的选项，就像我们的示例中一样
- en: A string representing an HTML tag (such as `div` , `h1` , and `p` )
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示HTML标签的字符串（例如`div`、`h1`和`p`）
- en: A function that returns an options object for a Vue component or a string representing
    an HTML tag
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个返回Vue组件的选项对象或表示HTML标签的字符串的函数
- en: The second argument must be an object called **Data Object** . This object is
    explained in the next recipe.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数必须是一个名为**Data Object**的对象。这个对象将在下一个示例中解释。
- en: 'The third argument is an array or a string:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个参数是一个数组或字符串：
- en: The array represents a list of elements, text, or components to put inside the
    component
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组表示要放在组件内部的元素、文本或组件的列表
- en: You can write a string that will be rendered to text
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以编写一个将被渲染为文本的字符串
- en: Rendering a component with children
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染带有子元素的组件
- en: In this recipe, you will build a simple web page with a few elements and components
    completely using render functions. This will give you a close-up view of  how
    Vue compiles your templates and components. It may be useful if you want to build
    an advanced component and you want a full example to kick start.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将使用渲染函数完全构建一个简单的网页，其中包含一些元素和组件。这将让您近距离观察Vue如何编译您的模板和组件。如果您想构建一个高级组件，并且想要一个完整的示例来启动，这可能会很有用。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This is a complete recipe on how to build components through render functions.
    Usually, you don't need to do this in practice; it's recommended only for advanced
    readers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完整的构建组件的渲染函数的示例。通常情况下，您不需要在实践中这样做；这只推荐给高级读者。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You will build a page for a plumber club. The page will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您将为一个水管工俱乐部构建一个页面。页面将如下所示：
- en: '![](img/Image00165.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00165.jpg)'
- en: Whenever we write a name inside the name textbox, it will be written in the
    greeting exactly like the `v-model` directive.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在名称文本框中写入一个名称时，它将被写入问候中，就像`v-model`指令一样。
- en: For this recipe, we are starting from the end instead of the beginning because
    usually when you have to resort to the `render` function, you have a pretty clear
    idea of what you are trying to get.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们从末尾开始而不是从开头开始，因为通常当您不得不使用`render`函数时，您对您想要的结果有一个非常清晰的想法。
- en: 'In the HTML side of our app, let''s start with an empty tag:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序的HTML部分，让我们从一个空标签开始：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the JavaScript, write an empty `<div>` element in the `render` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，在`render`函数中写入一个空的`<div>`元素：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first thing we''ll put inside is the title, like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先放入的是标题，如下所示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All the other elements and components will fit inside the array we have just
    created for the title.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他的元素和组件都将适应我们刚刚为标题创建的数组。
- en: We need an `<input>` element that will take the value and display a greeting.
    For this, we can build a `Vue` component.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`<input>`元素，它将接收值并显示问候语。为此，我们可以构建一个`Vue`组件。
- en: In the following code, we are using a regular JavaScript function instead of
    an arrow function; this is because we want a reference to the component itself.
    Arrow functions don't allow you to modify the scope of `this` , while `this` depends
    on how the function is called and can be optionally bound to any variable in regular
    functions. In our case, it will be bound to the instance component.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用的是一个常规的JavaScript函数，而不是箭头函数；这是因为我们想要一个对组件本身的引用。箭头函数不允许您修改`this`的作用域，而`this`取决于函数的调用方式，并且可以选择地绑定到常规函数中的任何变量。在我们的情况下，它将绑定到实例组件。
- en: 'After the title of the page, we add the following component in the same array:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面标题之后，我们在同一个数组中添加以下组件：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The component has three options: the `render` , `data` , and `props`  functions.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件有三个选项：`render`，`data`和`props`函数。
- en: 'The second parameter of the `createElement` function is to actually assign
    values to our props:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`createElement`函数的第二个参数是为我们的props实际分配值：'
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will be equivalent to writing `:exclamation="true"` when declaring the
    component.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将等同于在声明组件时写`：exclamation="true"`。
- en: You can easily understand the `data` and `props` options of the component. Let's
    examine what we wrote in the `render` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松理解组件的`data`和`props`选项。让我们来看看我们在`render`函数中写了什么。
- en: 'In the first line of the function, we set `self = this` as a convenient way
    to refer to the component were we to add any nested functions. Then, we return
    the result of a `createElement` function (`h` ) that, inside a div tag, places
    three things in the DOM. The first is the raw text `Your name is`  and then two
    elements: an input and a paragraph.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的第一行，我们将`self = this`设置为一种方便的方式，以便在添加任何嵌套函数时引用组件。然后，我们返回一个`createElement`函数（`h`）的结果，该函数在一个div标签内将三个元素放置在DOM中。第一个是原始文本`Your
    name is`，然后是两个元素：一个输入框和一个段落。
- en: We don't have a direct equivalent of the `v-model` directive when working with
    render functions. Instead, we implement it manually. We bind the value to the
    name, and then we add a listener to the input event that will set the value of
    the state variable, `name` , to whatever is inside the textbox.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用渲染函数时，我们没有`v-model`指令的直接等价物。相反，我们手动实现它。我们将值绑定到名称，然后添加一个监听器到输入事件，该事件将把状态变量`name`的值设置为文本框中的内容。
- en: We then insert a paragraph element that will compose the greeting phrase, adding
    an exclamation point based on the value of the `exclamation` prop.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们插入一个段落元素，根据`exclamation`属性的值添加一个感叹号，组成问候语。
- en: 'After the component, we can add the following, as illustrated, in the same
    array:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件之后，我们可以在同一个数组中添加以下内容，如图所示：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you have done things right, you should be able to run the application and
    see the whole page.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您做得正确，您应该能够运行应用程序并看到整个页面。
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we've seen a glimpse of what happens behind the curtains when
    Vue compiles our templates; again, you are not advised to do this with regular
    components. Most of the time, the result will be just more verbose with little
    or no gain. On the other hand, there are a couple of cases in which writing the
    render function may actually result in better or more robust code and cover some
    functionality that is difficult to express with templates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了Vue在编译我们的模板时发生的一瞥；再次强调，您不建议在常规组件中这样做。大多数情况下，结果将更冗长，几乎没有收益。另一方面，有几种情况下编写渲染函数实际上可能会产生更好或更健壮的代码，并涵盖一些难以用模板表达的功能。
- en: Using JSX to render a component
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSX渲染组件
- en: JSX is very popular in the React community. In Vue, you don't have to use JSX
    to build templates for your components; you can use the much more familiar HTML. JSX,
    however, is the next best thing you can do if you are forced to write a lot of
    render functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: JSX在React社区非常流行。在Vue中，您不必使用JSX来构建组件的模板；您可以使用更熟悉的HTML。然而，如果您被迫编写大量的渲染函数，JSX是您可以做的下一件最好的事情。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before venturing into this recipe, you better play a little with the render
    function. The previous recipes provide some exercises.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试这个示例之前，最好先玩一下渲染函数。之前的示例提供了一些练习。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: JSX needs a Babel plugin to work. For this recipe, I will assume that you are
    working within the webpack template.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: JSX需要一个Babel插件才能工作。在这个示例中，我假设你是在webpack模板中工作。
- en: 'To install the babel plugin, you can run the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Babel插件，可以运行以下命令：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inside the `.babelrc` file, add the following in the `plugins` array:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.babelrc`文件中，在`plugins`数组中添加以下内容：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run `npm install`  as usual to actually install all the dependencies.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样运行`npm install`来安装所有依赖项。
- en: 'Now, open the `main.js` and delete everything inside. Replace it with the following
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`main.js`并删除其中的所有内容。用以下代码替换它：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The highlighted line is the weird bit if you have never seen JSX. Just note
    that we didn't use the arrow function in the `render` option in the preceding code.
    That's because we are using `this` inside and we want it to be bound to the component.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未见过JSX，那么这一行是有点奇怪的。只要注意我们在前面的代码中没有在`render`选项中使用箭头函数。这是因为我们在内部使用了`this`，我们希望它绑定到组件上。
- en: You can already see your page working using the `npm run dev` command.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`npm run dev`命令看到你的页面已经工作了。
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The babel plugin will turn the JSX code into a JavaScript `render` function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Babel插件将把JSX代码转换为JavaScript的`render`函数。
- en: I wouldn't recommend using JSX with Vue. The only time I can see it being useful
    is whenever you need to intermix `render` functions with JavaScript and you need
    a quick and readable way of defining templates. Other than that, there are not
    many advantages to using JSX.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议在Vue中使用JSX。我唯一能想到它有用的时候是当你需要将`render`函数与JavaScript混合使用，并且需要一种快速和可读的方式来定义模板。除此之外，使用JSX没有太多优势。
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Let's complicate the code a little bit to at least have a flavor of how JSX
    plays with props.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微复杂一点的代码，至少让我们了解JSX如何与props配合使用。
- en: 'Define a new component before the main `Vue` instance:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`Vue`实例之前定义一个新的组件：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s use this component in our `Vue` instance and pass the `msg` variable
    via props:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`Vue`实例中使用这个组件，并通过props传递`msg`变量：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The syntax is slightly different from an HTML template. In particular, note
    how props are passed and how we can use camelCase and self-closing tags.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 语法与HTML模板略有不同。特别要注意如何传递props以及如何使用驼峰命名和自闭合标签。
- en: Creating a functional component
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个功能组件
- en: A lighter version of a component is a functional component. The functional component
    doesn't have instance variables (so no `this` ) and has no state. In this recipe,
    we will write a simple functional component that takes some instructions via HTML
    and turns them into a drawing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的一个轻量级版本是功能组件。功能组件没有实例变量（因此没有`this`）并且没有状态。在这个示例中，我们将编写一个简单的功能组件，它通过HTML接收一些指令并将它们转换为绘图。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before attempting this recipe, you should at least become familiar with the
    render function in Vue. You can use the previous recipes to do that.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试这个示例之前，你至少应该熟悉Vue中的渲染函数。你可以使用之前的示例来做到这一点。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'When you are writing an `<svg>`  element, you usually have to put data in the
    attributes of elements inside it to actually draw shapes. For example, if you
    want to draw a triangle, you have to write the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个`<svg>`元素时，通常需要将数据放在其中的元素的属性中才能真正绘制形状。例如，如果你想绘制一个三角形，你需要写以下内容：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The text inside the `d` attribute is a series of instructions that make a virtual
    cursor move to draw: `M` moves the cursor to the (100, 30) coordinate inside the
    `<svg>` , then `L` traces a line up until (200, 30) and then again to the (150,
    120) coordinate. Finally, `z` closes the path we are drawing, and the result is
    always a triangle.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`d`属性内的文本是一系列指令，用于移动虚拟光标进行绘制：`M`将光标移动到`<svg>`内的坐标(100, 30)，然后`L`绘制一条线直到(200,
    30)，然后再次绘制到坐标(150, 120)。最后，`z`关闭我们正在绘制的路径，结果始终是一个三角形。'
- en: 'We would like to write a triangle with a component, but we don''t like attributes
    and we want to write in our own language, so we would write the following to get
    the same result:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要用一个组件来绘制一个三角形，但我们不喜欢属性，而且我们想用我们自己的语言来编写，所以我们会写以下内容以获得相同的结果：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a perfect job for a functional component because there is no state to
    manage, only a translation from one component to one element.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完美的功能组件的工作，因为没有需要管理的状态，只是从一个组件到一个元素的转换。
- en: 'Your HTML layout will simply look like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你的HTML布局将简单地如下所示：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, lay out your functional component in your JavaScript:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在JavaScript中布局你的功能性组件：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You have to specify that the component will be functional with `functional:
    true` ; then the render function is slightly different than usual. The first argument
    is still the `createElement` function, but the second passed is the context of
    our component.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '你必须指定组件将是功能性的，使用`functional: true`；然后渲染函数与通常略有不同。第一个参数仍然是`createElement`函数，但传递的第二个参数是我们组件的上下文。'
- en: We can access the text written inside the HTML of our component (the commands
    to draw) through `context.children` .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`context.children`访问组件HTML中写的文本（绘制命令）。
- en: 'You can see that I already added an empty `<svg>` element. Inside this, there
    is an empty array of children; we will put only the `<path>` element there, which
    is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我已经添加了一个空的`<svg>`元素。在其中，有一个空的子元素数组；我们将只把`<path>`元素放在那里，如下所示：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The highlighted code creates a path element and then sets some attributes, such
    as `fill` and `stroke` . The `d` attribute takes the text from inside the component,
    makes some substitutions, and then returns it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个路径元素，然后设置了一些属性，比如`fill`和`stroke`。`d`属性从组件内部获取文本，进行一些替换，然后返回它。
- en: 'We just need to create the `Vue` instance in the JavaScript:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在JavaScript中创建`Vue`实例：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, loading the app, we should see a triangle, which is shown in the following
    screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，加载应用程序，我们应该看到一个三角形，如下面的截图所示：
- en: '![](img/Image00166.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00166.jpg)'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Vue lets you create components that are very lightweight as they don't have
    any internal state. With this come some limitations, for example, the only place
    where we can put some logic to process user input (in the form of children of
    the element or props) is in the render function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Vue允许您创建非常轻量级的组件，因为它们没有任何内部状态。但是这也带来了一些限制，例如，我们可以将一些逻辑放在哪里来处理用户输入（以元素的子元素或props的形式）只能在渲染函数中。
- en: 'The context we passed contains the following properties:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的上下文包含以下属性：
- en: '`props` : This is passed by the user.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`props`：这是由用户传递的。'
- en: '`children` : This is really an array of virtual nodes, children of our component
    in the template. We don''t have the actual HTML element here but only a representation
    of it by Vue.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`children`：这实际上是一个虚拟节点数组，是我们组件在模板中的子元素。在这里我们没有实际的HTML元素，只有Vue的表示。'
- en: '`slots` : This is a function returning the slots (can be used instead of children
    in some cases).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slots`：这是一个返回插槽的函数（在某些情况下可以替代children）。'
- en: '`data` : This is the entire data object passed to the component.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是传递给组件的整个数据对象。'
- en: '`parent` : This is a reference to the parent component.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`：这是对父组件的引用。'
- en: 'In our code, we extracted the text inside the component by doing the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们通过以下方式提取了组件内部的文本：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We are taking the array of virtual nodes contained in children and mapping
    each node to its text. Since we put only some text in our HTML, the array of nodes
    will be a singleton, with only one node: the text we entered. Therefore, in this
    particular case, doing `var a = children.map(c => someFunction(c))` is then equivalent
    of doing `var a = [someFunction(children[0])]` .'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在获取包含在children中的虚拟节点数组，并将每个节点映射到其文本。由于我们只在HTML中放置了一些文本，节点数组将是一个单例，只有一个节点：我们输入的文本。因此，在这种特殊情况下，执行`var
    a = children.map(c => someFunction(c))`等同于执行`var a = [someFunction(children[0])]`。
- en: We are not only extracting the text though, we are replacing some terms I invented
    to describe `svg` commands, with the real commands. The `join` function will sew
    together all the strings in the array (just one in our case) and `trim` will remove
    all the white spaces and line breaks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅提取文本，还替换了一些我发明的用于描述`svg`命令的术语，用真实的命令替换。`join`函数将把数组中的所有字符串（在我们的情况下只有一个）拼接在一起，`trim`函数将删除所有的空格和换行符。
- en: Building a responsive table with higher-order components
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高阶组件构建响应式表格
- en: Functional components are very good wrappers when we have to decide which component
    to actually wrap. In this recipe, you'll write a responsive table that will display
    different columns depending on the browser width.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要决定要实际包装哪个组件时，功能组件是非常好的包装器。在这个示例中，您将编写一个响应式表格，根据浏览器宽度显示不同的列。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is about functional components. If you want to warm up, you can
    try and complete the previous recipe.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是关于功能组件的。如果您想热身一下，可以尝试完成前一个示例。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'For this recipe, we will use the excellent semantic UI CSS framework. To use
    it, you have to include the CSS library as a dependency or as a `<link>` tag.
    For example, you can put the following code in the `<head>` of your HTML:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用优秀的语义UI CSS框架。要使用它，您必须将CSS库作为依赖项或`<link>`标签包含进来。例如，您可以将以下代码放在HTML的`<head>`中：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you are using JSFiddle, the link inside should be sufficient.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是JSFiddle，内部的链接就足够了。
- en: 'Another tag you have to add to your page for it to look good on mobile is this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在页面中添加另一个标签，以便在移动设备上显示良好：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This tells the mobile browser that the width of the page is equal to the width
    of the device. If you don't put this, the mobile may assume that the page is much
    larger than the phone and, trying to display all of it, show a miniaturized version
    of your app.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉移动浏览器页面的宽度等于设备的宽度。如果您不添加这个，移动设备可能会认为页面比手机大得多，并试图显示全部内容，从而显示您的应用的缩小版本。
- en: 'We will design a table of cat breeds. You can see all the data in the Vue instance
    status. Write it in your JavaScript:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一个猫品种的表格。您可以在Vue实例状态中看到所有的数据。在您的JavaScript中编写如下代码：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We are declaring the `width` variable to change the layout of the page and since
    the width of the page is not reactive by nature, we're also installing a listener
    on `window.onresize` . For a real project, you'll probably want something a bit
    more sophisticated, but for this recipe, this will suffice.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了`width`变量来改变页面的布局，由于页面的宽度本质上不是响应式的，我们还在`window.onresize`上安装了一个监听器。对于一个真实的项目，您可能需要更复杂的东西，但对于这个示例，这就足够了。
- en: 'Also, note how we are using the `BreedTable` component, which we write like
    this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意我们如何使用`BreedTable`组件，代码如下：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What our component is doing is just passing all the `context.data` and `context.children`
    to another component, which will be `DesktopTable` or `MobileTable` , depending
    on the resolution.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件所做的就是将所有的`context.data`和`context.children`传递给另一个组件，这个组件将是`DesktopTable`或`MobileTable`，具体取决于分辨率。
- en: 'Our HTML layout is the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML布局如下：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `breeds` props will be passed on to the selected component in the `context.data`
    .
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`breeds`属性将传递给`context.data`中的选定组件。'
- en: 'Our desktop table will look pretty regular for a table:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的桌面表格看起来很普通：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The classes at the top are part of semantic UI and they will make our table
    look much better. The `unstackable` class, in particular, disables the automatic
    stacking performed by CSS. We will cover more on this in the next section.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的类是语义UI的一部分，它们将使我们的表格看起来更好。特别是`unstackable`类，它禁用了CSS执行的自动堆叠。我们将在下一节中详细介绍这个。
- en: 'For the mobile table, we''d like to edit not only the styling, but we''d also
    like to group the columns themselves. The breed will go along with the color and
    the affection with the shedding. Also, we want to express them in a compact style.
    The table head will look like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动端的表格，我们不仅希望编辑样式，还希望对列进行分组。品种将与颜色一起显示，情感与脱毛程度一起显示。此外，我们希望以紧凑的样式来表达它们。表头将如下所示：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Instead of just spelling the coat color, we draw a little circle of that color:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅仅是拼写外套的颜色，还会画一个小圆圈来表示颜色：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Also, instead of using numbers like in the desktop table for the affection
    and shedding level, we put a heart and star rating:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在移动端表格中使用心形和星级评分代替了情感和脱毛程度的数字：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Also, don't forget to declare the `breeds` prop like in the `DesktopTable` component.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，不要忘记像`DesktopTable`组件中那样声明`breeds`属性。
- en: 'Now launch your application in a browser. You can see how the table groups
    the column when squished enough:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中启动你的应用程序。你可以看到当表格被压缩到足够小的时候，它会将列进行分组：
- en: '![](img/Image00167.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00167.jpg)'
- en: 'The following screenshot shows that numbers are replaced by hearts and star
    rating:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了数字被心形和星级评分所替代：
- en: '![](img/Image00168.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00168.jpg)'
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: A responsive page changes its layout according to the width of the browser and
    this is very important when the user is using a tablet or smartphone to browse
    the website.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式页面根据浏览器的宽度来改变布局，在用户使用平板电脑或智能手机浏览网站时非常重要。
- en: Most of the components have to be developed only once for a responsive page,
    and only the styling is done multiple times according to different sizes. This
    can save a lot of development time if compared to having a separate site optimized
    for mobile.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组件只需要开发一次，响应式页面只需要根据不同的尺寸多次进行样式设计。与为移动端优化的独立网站相比，这样可以节省很多开发时间。
- en: 'Normally, in a responsive page table, go from columnar to stacked, as shown in
    the following illustration:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在响应式页面中，表格从列式布局变为堆叠式布局，如下图所示：
- en: '![](img/Image00169.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00169.jpg)'
- en: I never liked this approach, but the objective disadvantage is that if you make
    your table look good on one side, it will look not so good on the other. This
    is because you have to style the cells in the same way and what the responsiveness
    does is that it stacks them up.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我从来不喜欢这种方法，但它的一个明显缺点是，如果你让表格在一侧看起来很好，那么在另一侧看起来就不那么好。这是因为你必须以相同的方式设计单元格，而响应式布局会将它们堆叠起来。
- en: What our `BreedTable` component does is to dynamically switch between the two
    components instead of simply relying on the CSS. Since it's a functional component,
    it has the advantage of being very lightweight compared to a full-fledged component.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`BreedTable`组件会动态地在两个组件之间切换，而不仅仅依赖于CSS。由于它是一个功能性组件，与完整组件相比非常轻量级。
- en: In a real application, using the `onresize` event is questionable, mainly because
    of the performance hit. In a production system, the solutions for responsiveness via
    JavaScript need to be more structured. For example, consider using a timer or
    using `matchMedia` .
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，使用`onresize`事件是有问题的，主要是因为性能受损。在生产系统中，通过JavaScript实现响应性的解决方案需要更加结构化。例如，考虑使用定时器或使用`matchMedia`。
- en: As a last thing, note how the Vue instance never registers the two subcomponents;
    this is because they never appear in a template but are referenced directly in
    the code as objects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是，Vue实例从未注册这两个子组件；这是因为它们从未出现在模板中，而是直接在代码中作为对象引用。
