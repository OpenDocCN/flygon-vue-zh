- en: Unit Testing and End-to-End Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和端到端测试
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Using Jasmine for testing Vue
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jasmine进行Vue测试
- en: Adding some Karma to your workflow
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Karma添加到工作流程中
- en: Testing your application state and methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应用程序的状态和方法
- en: Testing the DOM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试DOM
- en: Testing DOM asynchronous updates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试DOM异步更新
- en: End-to-end testing with nightwatch
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用nightwatch进行端到端测试
- en: Simulating a double-click in nightwatch
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在nightwatch中模拟双击
- en: Different styles of unit testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同风格的单元测试
- en: Stubbing external API calls with Sinon.JS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Sinon.JS对外部API调用进行存根
- en: Measuring the coverage of your code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量代码的覆盖率
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Testing is what really differentiates professional software from amateur software.
    From industry experience and studies, it has been discovered that much of the
    cost of software lies in correcting bugs while the software is in production.
    Testing software reduces bugs in production and makes correcting those bugs much
    less expensive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是真正区分专业软件和业余软件的关键。根据行业经验和研究，发现软件成本的很大一部分在于在软件投入生产时纠正错误。测试软件可以减少生产中的错误，并使纠正这些错误的成本大大降低。
- en: In this chapter, you will learn how to set up your test harness and how to write
    unit tests and integration tests that will help speed up your app development
    and help it grow in complexity without leaving bugs behind.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何设置测试工具和编写单元测试和集成测试，以加快应用程序开发速度，并使其在复杂性增加时不留下错误。
- en: You will gain familiarity with the most popular testing framework and slang;
    after completing the recipes, you will be able to confidently ship software that
    works just as expected.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些示例后，您将熟悉最流行的测试框架和术语；您将能够自信地发布按预期工作的软件。
- en: Using Jasmine for testing Vue
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jasmine进行Vue测试
- en: Jasmine is a library for testing, it's very easy to use and it's capable of
    displaying the results of the tests directly in the browser. In this recipe, you
    will build a simple Vue application and you will test it with Jasmine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是一个用于测试的库，非常易于使用，并且能够直接在浏览器中显示测试结果。在这个示例中，您将构建一个简单的Vue应用程序，并使用Jasmine进行测试。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I hope you don't start learning Vue with this recipe because I'm going to assume,
    as I will with the rest of the chapter, that you already know the basics of building
    simple applications in Vue.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您不是从这个示例开始学习Vue，因为我将假设，就像本章的其他部分一样，您已经了解了在Vue中构建简单应用程序的基础知识。
- en: 'You should also be able to find four files on the Internet. I will write the
    link as I found them at writing time but, of course, they may change:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该能够在互联网上找到四个文件。我将在写作时提供链接，但是当然，它们可能会发生变化：
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.css](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.css)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.css](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.css)'
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.js](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.js)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.js
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine-html.js](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine-html.js)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine-html.js](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine-html.js)
    的中文翻译如下：'
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/boot.js](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/boot.js)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/boot.js
- en: You can conveniently copy-paste all the links from the [https://cdnjs.com/libraries/jasmine](https://cdnjs.com/libraries/jasmine)
     page.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以方便地从[https://cdnjs.com/libraries/jasmine](https://cdnjs.com/libraries/jasmine)页面复制粘贴所有链接。
- en: The files are dependent on each other, so the order in which you add them matters!
    In particular, `boot.js` is dependent on `jasmine-html.js` , which is dependent
    on `jasmine.js` .
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件彼此依赖，因此添加它们的顺序很重要！特别是，`boot.js` 依赖于 `jasmine-html.js`，而 `jasmine-html.js`
    又依赖于 `jasmine.js`。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Jasmine is a library composed of various modules. To make it work, you need
    to install a few dependencies related to Jasmine. I will assume that you are using
    JSFiddle to follow along. If you are using npm or other methods instead, you should
    be able to derive what you need to change as the code will be simple in principle.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是一个由各种模块组成的库。为了使其工作，您需要安装一些与Jasmine相关的依赖项。我假设您正在使用JSFiddle进行操作。如果您使用的是npm或其他方法，您应该能够根据原则简单地推导出需要更改的内容。
- en: To install Jasmine in your app, you will need four different dependencies, of
    which one is just for CSS styling.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的应用程序中安装Jasmine，您将需要四个不同的依赖项，其中一个仅用于CSS样式。
- en: 'The four files are (*in order of dependence* ):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个文件的顺序（按依赖关系排序）是：
- en: '`jasmine.css`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jasmine.css`'
- en: '`jasmine.js`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jasmine.js` 是一个用于 JavaScript 测试的开源框架。它提供了一套简洁的语法和功能，用于编写和执行单元测试和集成测试。`jasmine.js`
    可以帮助开发人员轻松地编写可靠的测试用例，以确保代码的质量和稳定性。无论是在前端还是后端开发中，`jasmine.js` 都是一个非常有用的工具。'
- en: '`jasmine-html.js` (which depends on the preceding js)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jasmine-html.js`（依赖于前面的js文件）'
- en: '`boot.js` (which depends on the preceding js)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boot.js`（依赖于前面的js文件）'
- en: You should be able to find all these files on CDNJS or other CDNs. Install them
    in the order shown, or they won't work properly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够在CDNJS或其他CDN上找到所有这些文件。按照显示的顺序安装它们，否则它们将无法正常工作。
- en: 'When you have all the files in place, write the following HTML code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把所有文件放好后，写下以下HTML代码：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, add the following script as the JavaScript part:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下脚本添加为JavaScript部分：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can launch the application now and, as expected, the `Hello World`  message
    should appear on the screen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以启动应用程序了，正如预期的那样，屏幕上会出现“Hello World”的消息。
- en: We would like to be 100% sure that our application always displays this message
    when we make modifications to it and add new features.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在对应用程序进行修改和添加新功能时，能够确保我们的应用程序始终显示这条消息。
- en: 'Jasmine will help us in this regard. Just after the Vue instance, we write
    the following JavaScript:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，Jasmine将帮助我们。在Vue实例之后，我们编写以下JavaScript代码：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In order for this to work in JSFiddle, Load Type needs to be set to No wrap
    - in <body> . If you keep the default Load Type onLoad , it will load Jasmine
    before Vue has a chance to start.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其在JSFiddle中工作，需要将Load Type设置为No wrap - in <body>。如果保持默认的Load Type onLoad，它将在Vue有机会启动之前加载Jasmine。
- en: Now try and launch the application. You will see a detailed report by Jasmine
    at the end of the page that tells you weather there is something wrong with your
    app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试启动应用程序。您将在页面末尾看到Jasmine的详细报告，告诉您应用程序是否有问题。
- en: 'If everything goes as expected, you should see a happy green bar, like the
    following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切如预期，您应该会看到一个快乐的绿色条，如下所示：
- en: '![](img/Image00131.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00131.jpg)'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You wrote your very first unit test for a Vue application. If you write unit
    tests already, everything should be quite clear since we have not used any feature
    unique to Vue to write the test.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您为Vue应用程序编写了第一个单元测试。如果您已经编写了单元测试，那么一切都应该很清楚，因为我们没有使用任何Vue特有的功能来编写测试。
- en: In any case, let's spend a little time analyzing the code we have written; after
    that, I'll provide some considerations about when you should write similar tests
    when writing a real application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，让我们花点时间分析我们编写的代码；之后，我将提供一些关于在编写真实应用程序时何时编写类似测试的考虑事项。
- en: The test we wrote displays `my app should say Hello World` when you read it
    as a sentence on the web page.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的测试在网页上读作“我的应用程序应该说Hello World”。
- en: 'This is a fairly generic message; however, let''s look at the code closely:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一条相当通用的消息；然而，让我们仔细看一下代码：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Read it as an English phrase--we expect the `<p>` element inside the document
    to contain the text `Hello World` .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将其作为一个英语短语来阅读-我们期望文档中的`<p>`元素包含文本`Hello World`。
- en: The `document.querySelector('p')` code selects the first `p` element inside
    the page, to be precise. `innerText` looks inside the HTML element and returns
    the readable text that's inside. We then verify that this text contains `Hello
    World` .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.querySelector(''p'')`代码选择页面内的第一个`p`元素，确切地说。`innerText`查找HTML元素内部并返回可读的文本。然后，我们验证该文本是否包含`Hello
    World`。'
- en: In a real application, you wouldn't write the tests just under your web pages.
    Tests are of great importance to a developer to check whether everything is working
    correctly without manually verifying every single feature after every code change.
    On the other hand, you don't want your users to see the results of your tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你不会将测试代码直接写在网页下方。测试对于开发者来说非常重要，可以在每次代码更改后自动验证每个功能是否正常工作，而无需手动验证。另一方面，你不希望用户看到测试结果。
- en: In general, you will have a dedicated page, accessible only by developers, that
    runs all the tests for you.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您将拥有一个专门的页面，只有开发人员可以访问，该页面会为您运行所有的测试。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is a widespread practice in software called **TDD** or **Test-Driven Development**
    . It encourages you to think about the features of your software as tests. This,
    in turn, enables you to ensure that the features in your software work because
    the tests themselves work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中有一种广泛的实践叫做**TDD**或者**测试驱动开发**。它鼓励你将软件的功能视为测试。这样一来，你可以通过测试本身的工作来确保软件中的功能正常运行。
- en: In this bit, we will add a feature to our recipe using TDD. We want the page
    to have a header that says `Welcome` .
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将使用TDD为我们的食谱添加一个功能。我们希望页面上有一个标题，上面写着“欢迎”。
- en: 'First, we will write a (failing) test for the feature inside the `describe`
     function after the hello world test:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在hello world测试之后，我们将为`describe`函数内的功能编写一个（失败的）测试。
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we launch the test, we should see it fail:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动测试时，我们应该看到它失败：
- en: '![](img/Image00132.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00132.jpg)'
- en: Now, don't pay too much attention to the stack trace. The important thing you
    should note is that we have the name of the test that is failing (the other test
    is still working.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不要太关注堆栈跟踪。你应该注意的重要事情是，我们有一个测试失败的名称（另一个测试仍然有效）。
- en: It's important to write the test and see that it fails before implementing the
    feature itself. To understand why, try to imagine that we write the test before
    implementing the feature, then we launch it, and then it succeeds. It would mean
    that the test is not really working because we never implemented the feature in
    the first place.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现功能本身之前，编写测试并确保它失败是很重要的。要理解为什么，试着想象一下，我们在实现功能之前编写了测试，然后我们启动它，然后它成功了。这意味着测试实际上并没有起作用，因为我们从一开始就没有实现功能。
- en: If you think this is just strange and impossible, think again. In practice,
    it often happens that a test that seems perfectly okay is not testing anything
    in reality and will always succeed, even if the feature is broken.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这只是奇怪和不可能的，请再次思考。在实践中，经常发生这样的情况，一个看起来完全正常的测试实际上并没有测试任何东西，并且无论功能是否损坏，它总是成功的。
- en: 'At this point, we are ready to actually implement the feature. We edit the
    HTML layout, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经准备好实际实现功能了。我们编辑HTML布局，像这样：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we launch the page, the result should be similar to this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动页面时，结果应该类似于这样：
- en: '![](img/Image00133.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00133.jpg)'
- en: Adding some Karma to your workflow
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的工作流添加一些Karma
- en: Karma is a JavaScript test runner. This means that it will run your tests for
    you. Software often grows quickly and Karma gives you a way to run all your unit
    tests at once. It also gives you the power to add tools that monitor for test
    coverage and code quality.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Karma是一个JavaScript测试运行器。这意味着它将为您运行测试。软件往往会迅速增长，Karma为您提供了一种同时运行所有单元测试的方法。它还为您提供了添加监视测试覆盖率和代码质量的工具的能力。
- en: Karma is used traditionally in Vue projects and is present in the official Vue
    templates as a tool. Learning Karma is a great addition for your JavaScript toolbelt
    even if you are not working with Vue.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Karma在Vue项目中传统上被使用，并且作为一个工具存在于官方Vue模板中。学习Karma是您JavaScript工具箱的一个很好的补充，即使您不使用Vue也是如此。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I would consider having completed the *Using Jasmine for testing Vue*  recipe
    a prerequisite. Since Karma is a test runner, you should first be able to write
    a test.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为已经完成了“使用Jasmine测试Vue”的先决条件。由于Karma是一个测试运行器，所以您应该首先能够编写测试。
- en: We will use npm in this recipe, so you should first read the basics on how to
    use it in the *Choosing a development environment*  recipe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用npm，所以在继续之前，请确保已经安装了它，并阅读有关如何使用它的基础知识。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: For this recipe, we will need the command line and npm, so be sure to have it
    installed before moving ahead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将需要命令行和npm，所以在继续之前，请确保已经安装了它。
- en: 'In a new folder, create a file named `package.json` and write the following
    inside it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的文件夹中，创建一个名为`package.json`的文件，并在其中写入以下内容：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just having this file in your folder creates a new npm project. We will edit
    this file later.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 只要将此文件放在您的文件夹中，就会创建一个新的npm项目。我们稍后会编辑这个文件。
- en: 'In your command line, go to the directory where your project is and type the
    following command inside it to install the necessary dependencies:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，进入项目所在的目录，并在其中输入以下命令来安装必要的依赖项：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will install Vue along with Karma, Jasmine, and a couple of plugins of
    Karma as dependencies of our project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Vue以及Karma、Jasmine和Karma的一些插件作为我们项目的依赖项。
- en: If you take a look at the `package.json` now, you will see that it has changed
    accordingly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在查看`package.json`，您会看到它已相应地更改。
- en: 'The next command will create a file named `karma.conf.js` that will contain
    the configuration for Karma:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令将创建一个名为`karma.conf.js`的文件，其中包含Karma的配置：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will ask you some questions, just leave the default for all the questions
    except when it asks you the location of your source and test files. For that question,
    just write `*.js` . After this, you should be able to see the `karma.conf.js`
     file in your directory. Open it and take a quick look at all the settings you
    just set by answering the questions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将询问您一些问题，除了询问源文件和测试文件的位置时，其他问题都选择默认值。对于该问题，只需写入`*.js`。完成后，您应该能够在目录中看到`karma.conf.js`文件。打开它并快速查看您通过回答问题设置的所有设置。
- en: 'Since Karma doesn''t know about Vue natively, you''ll need to perform a small
    modification to add Vue as a dependency to Karma. There are a couple of ways to
    do this; the quickest is probably to add a line to the list of the files you want
    to load. In the `karma.conf.js`  file, add the following line in the `files` array:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Karma不知道Vue，您需要进行一些小的修改，将Vue添加为Karma的依赖项。有几种方法可以做到这一点；最快的方法可能是在要加载的文件列表中添加一行。在`karma.conf.js`文件中，在`files`数组中添加以下行：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that when you answered the question, you could have also added the line
    directly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您回答问题时，您也可以直接添加该行。
- en: The next step is to write the application we want to test.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写我们要测试的应用程序。
- en: 'In your folder, create a file named `myApp.js` ; inside it, write the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的文件夹中，创建一个名为`myApp.js`的文件；在其中写入以下内容：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The object we are assigning to `myApp` is just a simple Vue instance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配给`myApp`的对象只是一个简单的Vue实例。
- en: Next, we will create a test for it. Specifically, we will check weather the
    `Hello World`  text is contained somewhere in the component.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为其创建一个测试。具体来说，我们将检查组件中是否包含`Hello World`文本。
- en: 'Create a file named `test.js` and write the following inside it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`test.js`的文件，并在其中写入以下内容：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `beforeEach` block will run before each test (now we have only one), resetting
    the state of our Vue app before checking additional features.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach`块将在每个测试之前运行（现在我们只有一个测试），在检查其他功能之前重置我们的Vue应用程序的状态。'
- en: 'We are now in a position to run our test. Write the following command in your
    terminal:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的测试了。在终端中输入以下命令：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should see Chrome starting and if you go back to your command line, you
    should receive a message similar to this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到Chrome启动，如果你回到命令行，你应该收到类似于以下消息：
- en: '![](img/Image00134.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00134.jpg)'
- en: This means that your tests worked successfully.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你的测试成功了。
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: After your recipe is complete, you should note the general structure of your
    application. You have the application itself in `myApp.js` , and then you have
    your tests in `test.js` . You have some configuration files, such as `karma.conf.js`
    and `package.json` , and you have your libraries inside the `node_modules`  directory.
    All these files work together to make your application testable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的配方完成后，你应该注意你的应用程序的一般结构。你有应用程序本身在`myApp.js`中，然后你有你的测试在`test.js`中。你有一些配置文件，如`karma.conf.js`和`package.json`，你的库在`node_modules`目录中。所有这些文件一起工作，使你的应用程序可测试。
- en: In a real application, you will probably have more files for the source code
    and for the test, while the configuration files usually grow much slower.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实的应用程序中，你可能会有更多的源代码和测试文件，而配置文件通常增长得更慢。
- en: In this whole setup, you may be wondering how you launch the application itself.
    After all, there is no HTML and the only thing we launched are tests; we've never
    seen this `Hello World`  program.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个设置中，你可能会想知道如何启动应用程序本身。毕竟，没有HTML，我们只启动了测试；我们从来没有见过这个“Hello World”程序。
- en: 'Actually, you are right; there is no program to launch here. As a matter of
    fact, we had to write a fixture for the HTML layout inside the `beforeEach` of
    the tests:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你是对的；这里没有要启动的程序。事实上，我们必须在测试的`beforeEach`中为HTML布局编写一个固定装置：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we are injecting the HTML, which consists only of a `<div>`
    element (the rest of the layout is inside `myApp.js` ) in the page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们注入了HTML，它只包含一个`<div>`元素（其余的布局在`myApp.js`中）在页面中。
- en: We then create a new Vue instance, passing the option object contained in the
    `myApp` variable that was defined in `myApp.js` ; we then use the `$mount('#app')`
    Vue API that effectively materializes the application in the `<div>` element we
    just injected.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的Vue实例，传递在`myApp.js`中定义的`myApp`变量中包含的选项对象；然后我们使用`$mount('#app')` Vue
    API，在我们刚刚注入的`<div>`元素中实际地实现应用程序。
- en: There's more...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Calling Karma from inside the `node_modules` directory every time can be annoying.
    There are two ways to make this more pleasant: we can install Karma globally or we
    can add Karma to our npm scripts; we''ll do both.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每次从`node_modules`目录中调用Karma可能会很烦人。有两种方法可以使这更愉快：我们可以全局安装Karma，或者我们可以将Karma添加到我们的npm脚本中；我们将两者都做。
- en: 'First, let''s add Karma to our npm scripts. Go inside the `package.json` file
    and add the following block:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将Karma添加到我们的npm脚本中。进入`package.json`文件，并添加以下代码块：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, you can type `npm run test` and Karma will automatically launch. The next
    thing we can do is install Karma globally with the following line:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以输入`npm run test`，Karma将自动启动。接下来，我们可以使用以下命令全局安装Karma：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can write commands such as `karma init` and `karma start` , and they
    will be recognized. We can also edit our `package.json` , like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写诸如`karma init`和`karma start`之类的命令，并且它们将被识别。我们还可以编辑我们的`package.json`，像这样：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing your application state and methods
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用程序的状态和方法
- en: In this recipe, we will write a unit test to touch and check the state of our
    Vue instance directly. The advantage of testing the state of our components instead
    of looking for something in our web page is that we don't have to wait for the
    DOM to be updated and that, even if something changes in the HTML layout, the
    state changes much more slowly, reducing the amount of maintenance required for
    our tests.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个单元测试来直接触摸和检查我们的Vue实例的状态。测试组件状态的优势是我们不必等待DOM更新，即使HTML布局发生变化，状态变化也会慢得多，从而减少了测试所需的维护量。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before trying this recipe, you should complete *Adding some Karma to your workflow*
     as we will describe how to write the test but we won't mention much about the
    setup of the testing environment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试这个示例之前，您应该完成*将一些Karma添加到您的工作流程*，因为我们将描述如何编写测试，但我们不会提及测试环境的设置。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's suppose that we have an application that greets you with `Hello World!`
    , but it also has a button to translate the greeting to Italian, as `Ciao Mondo!`
    .
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个应用程序，它用`Hello World!`来问候您，但它还有一个按钮可以将问候语翻译成意大利语，即`Ciao Mondo!`。
- en: 'For this, you need to create a new npm project in a new folder. There, you
    can install the dependencies required for this recipe with the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您需要在一个新文件夹中创建一个新的npm项目。在那里，您可以使用以下命令安装此示例所需的依赖项：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To set up Karma like in the previous recipe, run the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Karma，就像在前一个示例中一样，运行以下命令：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Leave the default answers, except for the question `What is the location of
    your source and test files ?` ; for that, you should answer with the following
    two lines:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了问题`您的源文件和测试文件的位置是什么？`，保留默认答案；对于这个问题，您应该用以下两行回答：
- en: '`node_modules/vue/dist/vue.js`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules/vue/dist/vue.js`'
- en: '`*.js`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.js`'
- en: 'Create a file called `test.js` and write a `beforeEach` that will bring the
    application back to it''s starting state inside it so that it can be tested independently
    of other tests:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`test.js`的文件，并在其中编写一个`beforeEach`，以便将应用程序恢复到其起始状态，以便可以独立于其他测试进行测试：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note how you are declaring the `vm` variable at the beginning to reference our
    Vue instance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您在开始时声明了`vm`变量来引用我们的Vue实例。
- en: 'Just after the `beforeEach`  (but inside the `describe` ), add the following
    (empty for now) test:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`beforeEach`之后（但在`describe`内部），添加以下（目前为空）测试：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the first part of the test, you will bring the component to the desired
    state (after `toItalian` is called):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的第一部分中，您将使组件达到所需的状态（在调用`toItalian`之后）：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we want to check whether the greeting has changed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要检查问候语是否已更改：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, to prove to yourself that the state is reset before each test, add the
    following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了证明每个测试之前状态都被重置了，添加以下内容：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the state is really reset, it should contain the English greeting, and if
    you launch the tests (with the `./node_modules/karma/bin/karma start`  command),
    you'll find that (if there are no errors) indeed it does.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态真的被重置了，它应该包含英文问候语，如果你启动测试（使用`./node_modules/karma/bin/karma start`命令），你会发现（如果没有错误的话）确实是这样的。
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Since we have the reference to the Vue instance itself, we can access methods
    and status variables directly in our tests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有Vue实例本身的引用，我们可以直接在测试中访问方法和状态变量。
- en: I would like you to spend some time appreciating the name of the tests. The
    first is titled `should greet in Italian after toItalian is called` . It doesn't
    make any reference to the page or the graphics, and it doesn't make any assumption
    on preconditions. Note that the button is never clicked on and, as a matter of
    fact, the button is not mentioned in the test title.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你花一些时间欣赏测试的名称。第一个标题为`should greet in Italian after toItalian is called`。它没有提到页面或图形，并且没有对前提条件做任何假设。请注意，按钮从未被点击过，事实上，在测试标题中也没有提到按钮。
- en: Had we titled the test `should display 'Ciao Mondo' when Translate button is
    clicked on` , we would have lied because we never check whether the greeting is
    actually displayed and we never click on the button in our test.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将测试标题命名为`should display 'Ciao Mondo' when Translate button is clicked on`，那么我们就会撒谎，因为我们从未检查问候语是否实际显示，并且我们在测试中从未点击按钮。
- en: Naming the test the right way is very important in real applications because
    when you have thousands of tests and one breaks, the first thing you read about
    it is the title or what the test should check. If the title is misleading, you
    are in for a lot of time spent chasing after a red herring.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实应用程序中，正确命名测试非常重要，因为当你有成千上万个测试时，如果有一个测试失败，你首先读到的是标题或测试应该检查的内容。如果标题误导了，你将花费很多时间追逐一个错误的线索。
- en: Testing the DOM
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试DOM
- en: In this recipe, you will learn a technique to quickly test weather the DOM or
    the web page itself is what it is supposed to be, even when the Vue component
    is not present in the page.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习一种技术，可以快速测试DOM或网页本身是否符合预期，即使Vue组件不在页面中。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should have a test setup already up and working; complete
    the *Using* * Jasmine for testing Vue*  recipe if you don't know what that means.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您应该已经有一个已经设置好并且工作正常的测试环境；如果您不知道这是什么意思，请完成*使用Jasmine进行Vue测试*示例。
- en: I will assume that you have Jasmine installed and you can perform tests.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您已经安装了Jasmine并且可以执行测试。
- en: 'Basically, all you need is a web page (JSFiddle is okay) and these four dependencies
    installed:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，您只需要一个网页（JSFiddle可以）和这四个已安装的依赖项：
- en: '`jasmine.css`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jasmine.css`'
- en: '`jasmine.js`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jasmine.js`'
- en: '`jasmine-html.js`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jasmine-html.js`'
- en: '`boot.js`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boot.js`'
- en: If you are using JSFiddle or adding them manually, remember to add them in the
    specified order.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用JSFiddle或手动添加它们，请记住按指定的顺序添加它们。
- en: Find the link to these files in the *Using Jasmine for testing Vue*  recipe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在“使用Jasmine进行Vue测试”配方中找到这些文件的链接。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: Let's suppose that you are writing a component that displays the `Hello World!`
    greeting; you want to test that the greeting is actually displayed, but the web
    page you are testing is already complex enough and you want to test your component
    in isolation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在编写一个显示“Hello World！”问候语的组件；您希望测试该问候语是否实际显示，但您正在测试的网页已经足够复杂，您希望在隔离环境中测试您的组件。
- en: Turns out you don't have to actually display the component to prove that it
    works. You can display and test your component outside the document.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，您不必实际显示组件来证明它的工作。您可以在文档之外显示和测试您的组件。
- en: 'Write the following setup for your greeting in your test file or test part
    of your page:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的测试文件或页面的测试部分中，编写以下设置来显示问候语：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To materialize our Vue instance as an off-document element, we just need to
    add the `$mount()`  API call:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的Vue实例实现为一个文档之外的元素，我们只需要添加`$mount()` API调用：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we have the reference to `vm` , we can now test our component to access
    the element rendered off-document:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有对`vm`的引用，我们现在可以测试我们的组件以访问在文档之外渲染的元素：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `vm.$el`  element represents our component, but it's not reachable from
    the normal DOM.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`vm.$el`元素代表我们的组件，但无法从正常的DOM中访问。'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理如下：
- en: 'On initialization, the `Vue` instance checks whether there is an `el` option.
    In our recipes, we usually include an `el` option, but this time we have a template
    instead:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化时，Vue实例会检查是否有`el`选项。在我们的示例中，我们通常包含一个`el`选项，但这次我们有一个模板：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the `Vue` instance has the `el` option, it automatically mounts to that
    element (if found); in our case, the Vue instances waits for the `$mount` call
    instead. We don't provide any arguments to the function and so the component gets
    rendered off-document.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当Vue实例具有`el`选项时，它会自动挂载到该元素（如果找到）；在我们的情况下，Vue实例等待`$mount`调用。我们不提供任何参数给函数，因此组件会在文档之外渲染。
- en: At this point, the only way to retrieve it in the DOM is through the `$el` property.
    The `$el` property is always present once the component is mounted, irrespective
    of whether the component was mounted manually or automatically.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，从DOM中检索它的唯一方法是通过`$el`属性。一旦组件被挂载，`$el`属性始终存在，无论组件是手动挂载还是自动挂载。
- en: From there, we can access it as we would access any normal component and test
    whether everything is as we expect.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以像访问任何普通组件一样访问它，并测试一切是否符合我们的预期。
- en: Testing DOM asynchronous updates
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试DOM的异步更新。
- en: In Vue, when the status of your component changes, the DOM is changed accordingly;
    that's why we call the status reactive. The only gotcha here is that the update
    is not synchronous; it happens that we have to wait additional time for the changes
    to actually propagate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue中，当组件的状态发生变化时，DOM会相应地发生变化；这就是为什么我们称之为响应式状态的原因。唯一需要注意的是，更新不是同步的；我们必须等待额外的时间来实际传播这些变化。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: For this recipe, I will assume that you have already completed the *Using* * Jasmine
    for testing Vue*  recipe, and you know how to write a basic test.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我假设你已经完成了“使用Jasmine进行Vue测试”的配方，并且知道如何编写基本测试。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The test we will write is an illustration of how Vue's update mechanism works.
    From there, you will then be able to write asynchronous tests on your own.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写的测试是Vue更新机制工作原理的示例。从那里，您将能够自己编写异步测试。
- en: 'In the `beforeEach` function of our test suite, write the following Vue instance:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试套件的`beforeEach`函数中，编写以下Vue实例：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will create a component with a text box and a span element that will contain
    the `Hello from ...`  phrase and whatever is written in the text box.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个组件，其中包含一个文本框和一个 span 元素，该 span 元素将包含“Hello from ...”短语以及文本框中输入的任何内容。
- en: What we will do to test this component is write `Herman`  in the text box (programmatically,
    not manually), and then wait for the DOM to update. When the DOM has updated,
    we check whether the `Hello from Herman`  phrase appears.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何测试这个组件是，在文本框中编写`Herman`（通过编程方式，而不是手动），然后等待DOM更新。当DOM更新后，我们检查是否出现了`Hello
    from Herman`这个短语。
- en: 'Let''s start with an empty test just after the `beforeEach` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`beforeEach`函数之后的一个空测试开始：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding test passes already. Note that we are taking the done argument
    and then we are calling it as a function. The test will not pass until `done()`
    is called.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试已经通过了。请注意，我们正在接收`done`参数，然后将其作为函数调用。只有在调用`done()`之后，测试才会通过。
- en: 'Assign the `<span>` element to a variable for convenience and then insert the
    text `Herman`  in to the text box:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将`<span>`元素分配给一个变量以方便操作，然后将文本`Herman`插入到文本框中。
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'While we have to wait for the DOM to update when we modify the state, the opposite
    is not true; when we have modified the DOM, we can already check whether the `name`
    variable has changed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们修改状态时，我们必须等待DOM更新，但反之则不然；当我们修改了DOM时，我们可以立即检查`name`变量是否已更改。
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Launch the test while you edit it to check whether it works.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在您编辑测试时，启动它以检查是否正常工作。
- en: 'Next, we will install a listener for the next update cycle of the `Vue` component,
    called a tick:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为`Vue`组件的下一个更新周期安装一个监听器，称为tick。
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Everything inside the `$nextTick` block is run only after the DOM is updated.
    We will check that the content of the `<span>` element has changed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`$nextTick`块中的所有内容只有在DOM更新后才会运行。我们将检查`<span>`元素的内容是否已更改。'
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note how we also verify that the DOM is unchanged before the tick.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在进行下一次操作之前，我们还会验证DOM是否未更改。
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理如下...
- en: 'The official documentation states the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档中指出：
- en: <q>Vue performs DOM updates **asynchronously** . Whenever a data change is observed,
    it will open a queue and buffer all the data changes that happen in the same event
    loop.</q>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <q>Vue以**异步**方式执行DOM更新。每当观察到数据变化时，它将打开一个队列并缓冲在同一事件循环中发生的所有数据变化。</q>
- en: For this reason, many tests require the `$nextTick` helper. There is, however,
    an ongoing effort to create better tools to deal with testing and synchronicity
    so, while this recipe illustrates the problem, it might not be the most up-to-date
    method to deal with the test.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，许多测试需要使用`$nextTick`辅助函数。然而，目前正在努力创建更好的工具来处理测试和同步性，因此，尽管本文档说明了问题，但可能不是处理测试的最新方法。
- en: End-to-end testing with nightwatch
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nightwatch进行端到端测试
- en: Sometimes unit tests just don't cut it. We may need to integrate two features
    developed independently and, while each works and is unit tested, there is no
    easy way to test them along with a unit test. Also, it defeats the purpose of
    unit tests--testing atomic units of the software. Integration testing and e2e
    (end-to-end) testing can be performed in these cases. Nightwatch is software that
    basically mimics a user clicking and typing around in a website. This is probably
    what we want as an ultimate verification that the whole system works.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有时单元测试并不能满足需求。我们可能需要集成两个独立开发的功能，并且尽管每个功能都经过了单元测试并且可以正常工作，但没有简单的方法来同时测试它们。此外，这也违背了单元测试的目的-测试软件的原子单元。在这种情况下，可以进行集成测试和端到端（end-to-end）测试。Nightwatch是一种模拟用户在网站上点击和输入的软件。这可能是我们想要的最终验证整个系统是否正常工作的方式。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before beginning your journey in this somewhat advanced recipe, you should already
    be familiar with the command line and npm. Check the *Choosing a development environment*
     recipe if you are not familiar with them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始进行这个稍微高级的示例之前，您应该已经熟悉命令行和npm。如果您对它们不熟悉，请查看*选择开发环境*示例。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a new folder for this recipe and create a new file inside it, named `index.html`
    .
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个示例创建一个新文件夹，并在其中创建一个名为`index.html`的新文件。
- en: 'This file will contain our Vue application and it is what we will test. Write
    the following in this file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件将包含我们的Vue应用程序，也是我们要测试的内容。在这个文件中写入以下内容：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, this is just the usual boilerplate for a small Vue application.
    Inside the `<div>` , put a header and a button; when we click on the button, the
    text `Hello Nightwatch!` will be displayed:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这只是一个小型Vue应用程序的常规样板。在`<div>`标签内放置一个标题和一个按钮；当我们点击按钮时，将显示文本`Hello Nightwatch!`：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Inside the script tag, write the following JavaScript to make it work:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<script>`标签内，写入以下JavaScript代码使其工作：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Our application is complete; now we move into the test part of the recipe.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经完成；现在我们进入了示例的测试部分。
- en: 'Launch these commands to install what would be your dependencies:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来安装您的依赖项：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will install the Selenium server, which is necessary to automate browser
    actions, and it is what really makes nightwatch work. The `http-server` command
    will be useful to serve our working website without having to memorize a long
    file path. Finally, it will install nightwatch itself which, for the most part,
    is a wrapper and JavaScript API for Selenium.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Selenium服务器，这是自动化浏览器操作所必需的，也是使nightwatch工作的真正原因。`http-server`命令将有助于在不必记住长文件路径的情况下提供我们的工作网站。最后，它将安装nightwatch本身，它在很大程度上是Selenium的包装器和JavaScript
    API。
- en: 'When npm finishes installing all these tools, create a new file, named `nightwatch.json`
    , that will contain the nightwatch configuration and write this inside it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当npm完成安装所有这些工具后，创建一个名为`nightwatch.json`的新文件，其中包含nightwatch的配置，并在其中写入以下内容：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first setting says that you will write all your tests inside a folder called
    tests (which we will create); the second setting just sets Chrome as our default
    browser to run tests into.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个设置表示您将在名为tests的文件夹中编写所有测试（我们将创建该文件夹）；第二个设置只是将Chrome设置为我们运行测试的默认浏览器。
- en: Now, create, `test` directory and a `test.js` file inside it. In the file, we
    will test the app. We will verify that when the app launches, the `<p>` tag is
    not visible and that when we click on the button it should appear.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`test`目录下创建一个`test.js`文件。在该文件中，我们将测试应用程序。我们将验证当应用程序启动时，`<p>`标签是不可见的，并且当我们点击按钮时，它应该出现。
- en: 'An empty test will look like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空的测试看起来像这样：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, the client is the browser (Chrome in this case).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，客户端是浏览器（在本例中为Chrome）。
- en: 'We will serve our application at the `http://localhost:8080`  address, so first
    we want the browser to go to this address. For this we would write the following
    code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`http://localhost:8080`地址上提供我们的应用程序，所以首先我们希望浏览器转到这个地址。为此，我们将编写以下代码：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we wait for the page to load; we do this indirectly by waiting for the
    `<div>` with `id="app"` to appear:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们等待页面加载；我们通过等待具有`id="app"`的`<div>`出现来间接实现这一点：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The second argument is the number of milliseconds we are willing to wait before
    considering the test failed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是在考虑测试失败之前愿意等待的毫秒数。
- en: 'Next, we want to ensure that the header is also displayed correctly and there
    is no `<p>` element visible:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望确保标题也正确显示，并且没有可见的`<p>`元素：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We then click on the button and assert that the `<p>` element is visible and
    contains the word `Nightwatch` :'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们点击按钮并断言`<p>`元素是可见的并且包含单词`Nightwatch`：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `end()` function will mark the test as having succeeded, as there are no
    more things to check for.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`end()`函数将标记测试已成功，因为没有更多需要检查的内容。'
- en: 'To actually launch this test, you will need to launch the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际运行此测试，您需要运行以下命令：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will install Selenium, then open three different command lines. In the
    first, launch the Selenium server with the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Selenium，然后打开三个不同的命令行。在第一个命令行中，使用以下命令启动Selenium服务器：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the second command line, go to the root of your recipe folder, where `index.html`
    is, and launch `http-server` :'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个命令行中，进入你的食谱文件夹的根目录，即`index.html`所在的位置，并启动`http-server`：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will tell you after it''s launched that your website is served at `http://localhost:8080`
    . This is just like the address we wrote in our test. You can navigate to it right
    now to see the application running:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，它会告诉你你的网站在`http://localhost:8080`上提供服务。这就像我们在测试中写的地址一样。你现在可以导航到该地址查看应用程序的运行情况：
- en: '![](img/Image00135.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00135.jpg)'
- en: 'Lastly, in the third command line, again go inside your recipe folder and type
    the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第三个命令行中，再次进入你的食谱文件夹，并输入以下命令：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If everything goes well, you will see the browser flashing before your eyes
    and displaying the application for a fraction of a second (depending on the speed
    of your computer), and in the console, you should see something like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你会看到浏览器在你眼前闪烁，并在一瞬间（取决于你的计算机速度）显示应用程序，在控制台中，你应该看到类似于这样的内容：
- en: '![](img/Image00136.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00136.jpg)'
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: If this recipe looked like a lot of effort, don't despair, Vue templates already
    have this setup all sorted out inside them. You know how all this machinery works
    but when, in the later recipes, we use Webpack, you will only need one command
    to run e2e tests because everything is already set up.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个食谱看起来很费劲，不要灰心，Vue模板已经在其中解决了所有的设置。你知道所有这些机制是如何工作的，但是当我们在后面的食谱中使用Webpack时，你只需要一个命令来运行端到端测试，因为一切都已经设置好了。
- en: Note how the title of the end-to-end test is rather generic, and it refers to
    a particular action flow rather than detailing the context and what is expected.
    This is common for e2e tests as you are usually better off building user stories
    and then branching them and naming each branch after a particular scenario. So,
    just to give an example, if we were expecting a response from the server and it
    didn't come back, we could test a scenario in which we give an error and call
    the test *Server error scenario* .
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意端到端测试的标题是相当通用的，它指的是一个特定的操作流程，而不是详细描述上下文和期望的内容。这在端到端测试中很常见，因为通常最好先构建用户故事，然后将它们分支，并为每个分支命名一个特定的场景。所以，举个例子，如果我们期望从服务器得到一个响应，但没有返回，我们可以测试一个场景，在这个场景中我们会出现一个错误，并将测试称为*服务器错误场景*。
- en: Simulating a double-click in nightwatch
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在nightwatch中模拟双击
- en: This recipe is candy for all those who have struggled to simulate a double-click
    in nightwatch. Being one of them in the first place, I'm sympathetic. As it turns
    out, there is a `doubleClick` function in nightwatch but, at least in the opinion
    of the author, it doesn't work as expected.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱对于那些在nightwatch中模拟双击而苦苦挣扎的人来说是一种享受。作为其中之一，我对此表示同情。事实证明，在nightwatch中有一个`doubleClick`函数，但至少在作者的意见中，它并不像预期的那样工作。
- en: Getting ready
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe is for developers who are starting out in nightwatch and struggle
    with this particular problem. You want to learn how to simulate a double-click
    for testing and you don't know nightwatch? Go back one recipe.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方适用于刚开始使用nightwatch并且在这个特定问题上遇到困难的开发人员。你想学习如何模拟双击进行测试，但你不了解nightwatch吗？回到上一个配方。
- en: I will assume that your setup with nightwatch is working and you can launch
    tests. I will also assume that you have all the commands installed from the preceding recipe.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经设置好了nightwatch，并且可以启动测试。我还假设你已经安装了前面配方中的所有命令。
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Let''s assume that you have the following Vue application in an `index.html`
    file:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个Vue应用程序，它在一个`index.html`文件中：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Just after the `<div>` element, add this script:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<div>`元素之后，添加以下脚本：
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can serve your app with `http-server` . Go to `http://localhost:8080` with
    your browser, and you can try double-clicking on the button to make the text appear.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`http-server`来提供你的应用程序。在浏览器中打开`http://localhost:8080`，然后尝试双击按钮以使文本出现。
- en: Now, if we want to test that, we look at nightwatch's API and discover that
    it has a function call named `doubleClick()` .
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要测试这个，我们查看nightwatch的API，发现它有一个名为`doubleClick()`的函数调用。
- en: 'We can then write a test similar to the one in the preceding recipe:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以编写一个类似于前面配方中的测试：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Except that this won''t work as expected. The right way to do it is the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个不会按预期工作。正确的方法是：
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Double-click only works if you first *move* to the element you want to double-click
    on; only then you can call `doubleClick` without any argument.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你首先*移动*到你想要双击的元素上时，双击才起作用；只有这样，你才能调用`doubleClick`而不带任何参数。
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The arguments for the `moveToElement` function are the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveToElement`函数的参数如下：'
- en: '`selector` : We used `tag name` as a selector'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector`：我们使用`tag name`作为选择器'
- en: '`tag` /`selector` : We looked for the `button`  tag; had we used another selector
    here, we would have put a different format'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag` / `selector`：我们寻找`button`标签；如果我们在这里使用了另一个选择器，我们会使用不同的格式'
- en: '`xoffset` : This is where the virtual mouse will be positioned in x coordinates;
    for us, 0 was okay as, even on the edge of a button, clicking is valid'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xoffset`：这是虚拟鼠标在x坐标上的位置；对我们来说，0是可以的，因为即使在按钮的边缘，点击也是有效的'
- en: '`yoffset` : This is similar to the preceding argument, but on the y-axis'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yoffset`：这与前面的参数类似，但在y轴上'
- en: There is a range of commands that, after having been brought to the right position,
    can release events. We used `doubleClick` , but there are others as well.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确位置后，有一系列的命令可以释放事件。我们使用了`doubleClick`，但还有其他命令。
- en: Different styles of unit testing
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同风格的单元测试
- en: We've discovered and used Jasmine in the previous recipes. In this recipe, we
    will explore and compare different styles of unit testing. This is particularly
    relevant because Vue templates come with Mocha and Chai preinstalled. Chai enables
    you to write your tests in three different styles.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的示例中发现并使用了Jasmine。在这个示例中，我们将探索和比较不同的单元测试风格。这是特别相关的，因为Vue模板预装了Mocha和Chai。Chai使您能够以三种不同的风格编写测试。
- en: Getting ready
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe doesn't require any particular previous knowledge, but I highly
    suggest that you complete the *Using* * Jasmine for testing Vue* recipe.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例不需要任何特定的先前知识，但我强烈建议您完成“使用Jasmine进行Vue测试”的示例。
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'For this recipe to work, you will need two dependencies: Mocha and Chai. You
    will find them in no time with Google; just remember that Mocha comes in two different
    files: `mocha.js` and `mocha.css` . You will have to add them both if you want
    it to display nicely.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个示例工作，您需要两个依赖项：Mocha和Chai。您可以在Google上很快找到它们；只需记住，Mocha有两个不同的文件：`mocha.js`和`mocha.css`。如果您希望显示得漂亮，您必须同时添加它们。
- en: If you are using JSFiddle, continue as usual; otherwise, just make sure to have
    Vue as well in the dependencies.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用JSFiddle，请按照通常的方式继续；否则，请确保依赖项中也有Vue。
- en: 'Our HTML layout will look like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML布局将如下所示：
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The mocha bit is where all the results will be presented.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: mocha部分是显示所有结果的地方。
- en: 'In the JavaScript part, write the simplest `Vue` application and assign it
    to a variable:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript部分，编写最简单的`Vue`应用程序并将其分配给一个变量：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We will write a test to see whether the `Hello world`  text really gets displayed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个测试来查看“Hello world”文本是否真的被显示出来。
- en: 'Just after the `Vue` application is finished, write the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Vue`应用程序完成后，写入以下内容：
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding code is preparing `mocha` and `chai` (by installing the `describe`
    , `it` and `should`  functions) and then asserting that the inner text of our
    component should contain `Hello World` . Pretty readable, don't you think?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码准备了`mocha`和`chai`（通过安装`describe`，`it`和`should`函数），然后断言我们组件的内部文本应该包含`Hello
    World`。相当易读，不是吗？
- en: 'You can launch your application and you will see this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以启动应用程序，然后您将看到这个：
- en: '![](img/Image00137.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00137.jpg)'
- en: 'There are two other ways `chai` lets us write the very same test. The first
    one is as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: chai还允许我们以另外两种方式编写完全相同的测试。第一种方式如下所示：
- en: '[PRE55]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To use the second one, you have to add `const  expect = chai . expect`  before
    it:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用第二种方式，您必须在之前添加`const expect = chai.expect`：
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, add the `const assert = chai.assert` line before:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在之前添加`const assert = chai.assert`行：
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It's idiomatic for the assert style to add a message as an additional argument
    to make a test more verbose when something goes wrong.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在assert风格中，将消息作为附加参数添加是惯用的做法，以使测试在出现问题时更加详细。
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Chai is a simple library that implements some functions and throws exceptions
    when some conditions are not satisfied. Mocha, on the other hand, runs certain
    bits of code, collects the exceptions, and tries to display them to the user in
    a nice way.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Chai是一个简单的库，它实现了一些函数，并在某些条件不满足时抛出异常。另一方面，Mocha运行某些代码片段，收集异常，并尝试以友好的方式向用户显示它们。
- en: While it's largely a matter of taste as to what style to use, there are some
    subtle differences between the three styles.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用哪种风格主要是品味问题，但这三种风格之间存在一些细微的差别。
- en: '`Should`  has the added value of being more eloquent and readable. Unfortunately,
    it extends `Object` , adding the `should` function to everything. You shouldn''t
    mind if you don''t know how to react to the last phrase, but the correct way to
    behave is run and scream in pain; never extend `Object` .'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Should`更加雄辩和可读。不幸的是，它扩展了`Object`，将`should`函数添加到了所有对象上。如果你不知道如何对待最后一句话，你不应该介意，但正确的行为方式是奔跑并尖叫痛苦；永远不要扩展`Object`。'
- en: '`Assert`  means writing a detailed description of every assertion, and this
    is usually good if you write multiple assertions for each test. Personally, I
    consider it a good practice to write at most one assertion per test and concentrate
    on the title for description.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert`意味着对每个断言编写详细的描述，如果你为每个测试编写多个断言，这通常是很好的。就个人而言，我认为每个测试最多只应该有一个断言，并且应该集中在标题上进行描述。'
- en: '`Expect`  does not extend `Object` and is very readable with a good balance,
    and normally I prefer to use it over the other alternatives.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Expect`不扩展`Object`，非常可读且平衡良好，通常我更喜欢使用它而不是其他替代方案。'
- en: Stubbing external API calls with Sinon.JS
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sinon.JS进行外部API调用的存根化
- en: Normally, when you do end-to-end testing and integration testing, you will have
    the backend server running and ready to respond to you. I think there are many
    situations in which this is not desirable. As a frontend developer, you take every
    opportunity to blame the backend guys.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在进行端到端测试和集成测试时，您将运行并准备好后端服务器以响应您的请求。我认为有很多情况下这是不可取的。作为前端开发人员，您会抓住每一个机会责怪后端人员。
- en: Getting ready
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: No particular skills are required to complete this recipe, but you should install
    Jasmine as a dependency; this is explained in detail in the *Using* * Jasmine
    for testing Vue*  recipe.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个示例不需要特殊的技能，但您应该将Jasmine安装为依赖项；这在*使用Jasmine进行Vue测试*示例中有详细说明。
- en: How to do it...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: First of all, let's install some dependencies. For this recipe, we will use
    Jasmine to run the whole thing; you can find detailed instructions in the *Using Jasmine
    for testing Vue*  recipe (the four files you'll need are `jasmine.css` , `jasmine.js`
    , `jasmine-html.js` , and `boot.js` , in this order)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装一些依赖项。对于这个示例，我们将使用Jasmine来运行整个测试；您可以在*使用Jasmine进行Vue测试*示例中找到详细的说明（这四个文件分别是`jasmine.css`，`jasmine.js`，`jasmine-html.js`和`boot.js`，按照这个顺序）。
- en: Also, install Sinon.JS and Axios before continuing; you just need to add the
    `js` files relative to them.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，还要安装Sinon.JS和Axios；您只需要添加与它们相关的`js`文件。
- en: 'We will build an application that retrieves a post at the click of a button.
    In the HTML part, write the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个在点击按钮时检索帖子的应用程序。在HTML部分中，编写以下内容：
- en: '[PRE58]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Instead, the JavaScript part will look like the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，JavaScript部分将如下所示：
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you launch your application now, you should be able to see it working:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在启动应用程序，应该能够看到它正在工作：
- en: '![](img/Image00138.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00138.jpg)'
- en: Now we want to test the application, but we don't want to connect to the real
    server. This will take additional time and it will not be reliable; instead, we
    will take a sample correct response from the server and use that instead.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要测试应用程序，但我们不想连接到真实的服务器。这将需要额外的时间，并且不可靠；相反，我们将从服务器获取一个正确的样本响应并使用它。
- en: Sinon.JS has the concept of a sandbox. It means that whenever a test starts,
    some dependencies, such as Axios are overwritten. After each test, we can discard
    the sandbox and everything returns to normal.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS有一个沙盒的概念。这意味着每当一个测试开始时，一些依赖项（如Axios）都会被覆盖。每个测试结束后，我们可以丢弃沙盒，一切都恢复正常。
- en: 'An empty test with Sinon.JS looks like the following (add it after the `Vue`
    instance):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sinon.JS的空测试如下所示（在`Vue`实例之后添加）：
- en: '[PRE60]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We want to stub the call to the `get` function for axios:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要为axios的`get`函数存根调用：
- en: '[PRE61]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We are overwriting axios here. We are saying that now the `get` method should
    return the `resolved` promise:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里覆盖了axios。我们说现在`get`方法应该返回`resolved`的promise：
- en: '[PRE62]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since we are returning a promise (and we need to return a promise because the
    `retrieve` method is calling `then` on it), we need to wait until it resolves.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们返回了一个promise（我们需要返回一个promise，因为`retrieve`方法正在调用它的`then`方法），所以我们需要等待它解析。
- en: 'We can launch the page and see whether it works:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以启动页面并查看它是否工作：
- en: '![](img/Image00139.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00139.jpg)'
- en: If you are using JSFiddle, remember to set Load Type to No wrap - in `<body>`
     or Vue won't get a chance to start.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用JSFiddle，请记住将加载类型设置为No wrap - in `<body>`，否则Vue将没有机会启动。
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our case, we used the sandbox to stub a method of one of our dependencies.
    This way, the `get` method of axios never gets fired and we receive an object
    that is similar to what the backend will give us.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们使用沙盒来存根其中一个依赖项的方法。这样，axios的`get`方法就不会被触发，我们会收到一个类似于后端将给我们的对象。
- en: Stubbing the API responses will get you isolated from the backend and its quirks.
    If something goes wrong, you won't mind and, moreover, you can run your test without
    relying on the backend running correctly.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 存根API响应将使您与后端及其怪癖隔离开来。如果出现问题，您不会在意，而且您可以在不依赖于后端正确运行的情况下运行测试。
- en: There are many libraries and techniques to stub API calls in general, not only
    related to HTTP. Hopefully, this recipe has given you a head start.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多库和技术可以存根API调用，不仅与HTTP相关。希望这个示例为您提供了一个起步。
- en: Measuring the coverage of your code
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量代码的覆盖率
- en: Code coverage is one of the most used and understandable metrics to evaluate
    the quality of a piece of software. If a test exercises a particular portion of
    code, the code is said to be covered. This suggests that that particular portion
    of code is working correctly and has less chance of containing bugs.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是评估软件质量最常用和易于理解的指标之一。如果一个测试执行了特定的代码部分，那么该代码被认为是被覆盖的。这意味着该特定代码部分正常工作且包含错误的可能性较小。
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before measuring your code coverage, ensure that you complete the  *Adding some
    Karma to your workflow*  recipe as we will be using Karma to help us.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在测量代码覆盖率之前，请确保完成“将一些Karma添加到你的工作流程”这个步骤，因为我们将使用Karma来帮助我们。
- en: How to do it...
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new directory and place a file named `package.json`  in it. Inside
    it, write the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新目录，并在其中放置一个名为`package.json`的文件。在其中写入以下内容：
- en: '[PRE63]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This creates an npm project. In the same directory, run the following command
    to install our dependencies:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个npm项目。在同一目录中，运行以下命令来安装我们的依赖项：
- en: '[PRE64]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `package.json` file changes accordingly.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件会相应地更改。'
- en: The `karma-coverage` plugin uses the underlying software, Istanbul, to measure
    and display the coverage of our tests.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`karma-coverage`插件使用底层软件Istanbul来测量和显示我们的测试覆盖率。'
- en: 'To make the next step a little easier, we will install Karma globally (if you
    have not already done it). Run the following command:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使下一步更容易一些，我们将全局安装Karma（如果你还没有安装）。运行以下命令：
- en: '[PRE65]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When Karma is installed, run the following command in your directory; it will
    create a Karma configuration file:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装了Karma后，在你的目录中运行以下命令；它将创建一个Karma配置文件：
- en: '[PRE66]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Answer the default value for all questions except when it asks you the files
    to load; in that case, write the following two lines:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 除非它要求你加载文件，否则回答所有问题的默认值；在这种情况下，写下以下两行：
- en: '`node_modules/vue/dist/vue.js`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules/vue/dist/vue.js`'
- en: '`*.js`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.js`'
- en: Leave a blank line after that to confirm.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后留一个空行以确认。
- en: This will load Vue and all the files that end with the `js` extension in the
    root of the directory.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载Vue和以`js`扩展名结尾的所有文件到目录的根目录中。
- en: Open the file that Karma created; it should be called `karma.conf.js` and it
    should be in your directory along with the other files.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Karma创建的文件；它应该被称为`karma.conf.js`，并且应该与其他文件一起在你的目录中。
- en: 'There should be a part like the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一个类似以下的部分：
- en: '[PRE67]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Inside the preprocessors object, insert coverage, as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在preprocessors对象中，插入coverage，如下所示：
- en: '[PRE68]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This means that we want to preprocess the `myApp.js` file with the coverage
    preprocessor. The `myApp.js` file will contain our application to test.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们想要使用coverage预处理器对`myApp.js`文件进行预处理。`myApp.js`文件将包含我们要测试的应用程序。
- en: 'Just after that, in the `reporters` array, add coverage:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，在`reporters`数组中添加coverage：
- en: '[PRE69]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This will make the coverage reporter print a web page with the coverage measurements.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使coverage报告生成一个包含覆盖率测量的网页。
- en: 'In order for the setup to work properly, you need to set another property,
    called `plugins` , between `frameworks`  and `files` :'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使设置正常工作，您需要在`frameworks`和`files`之间设置另一个属性，称为`plugins`：
- en: '[PRE70]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Next, we will write a simple Vue application that we want to test.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个简单的Vue应用程序进行测试。
- en: Create a file named `myApp.js` ; we will create a number guessing game.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`myApp.js`的文件；我们将创建一个猜数字游戏。
- en: 'Write the following inside the file:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中写入以下内容：
- en: '[PRE71]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The user will input a number and the output will display a hint or a text to
    celebrate victory if the number is right. Add the following status to the `myApp`
    object:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将输入一个数字，输出将显示一个提示或者一个文本来庆祝胜利，如果数字正确。将以下状态添加到`myApp`对象中：
- en: '[PRE72]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'At the top of the file, you can add a `getRandomInt` function, as illustrated:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的顶部，您可以添加一个名为`getRandomInt`的函数，如下所示：
- en: '[PRE73]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We also need a computed property to display the hints:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个计算属性来显示提示：
- en: '[PRE74]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Our application is complete. Let's test weather it works as expected.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经完成。让我们测试一下它是否按预期工作。
- en: 'Create a file named `test.js` at the root of the directory and write the following
    test:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录的根目录下创建一个名为`test.js`的文件，并编写以下测试：
- en: '[PRE75]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To run the tests, use the following command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，请使用以下命令：
- en: '[PRE76]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If the preceding command fails to ask for the `karma-coverage`  plugin to be
    installed when it's already installed, you can either install the plugin globally
    or use the locally installed Karma to run the tests from `./node-modules/karma/bin/karma
    start` .
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的命令在已经安装了`karma-coverage`插件的情况下没有要求安装该插件，您可以全局安装插件，或者使用本地安装的Karma从`./node-modules/karma/bin/karma
    start`运行测试。
- en: If your browser opens, go back to the console and, when the test finishes, hit
    *Ctrl* + *C* to stop Karma.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的浏览器打开了，请返回控制台，当测试完成时，按下*Ctrl* + *C*停止Karma。
- en: 'If everything went well, you should have a new folder named coverage with a
    directory named Chrome inside it. You should also find a file named `index.html`
    inside it. Open it, and you will see a page like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该会看到一个名为coverage的新文件夹，其中包含一个名为Chrome的目录。您还应该在其中找到一个名为`index.html`的文件。打开它，您会看到一个类似于这样的页面：
- en: '![](img/Image00140.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00140.jpg)'
- en: Right from the start, we can see that yellow indicates that something is wrong.
    We tested 100% of the functions but only 50% of the if branches.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们就可以看到黄色表示出现了问题。我们测试了100％的函数，但只测试了50％的if分支。
- en: 'If you navigate through and open the details of the `myApp.js` file, you will
    see that we are not testing two branches of the `if` statement:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览并打开`myApp.js`文件的详细信息，您会发现我们没有测试`if`语句的两个分支：
- en: '![](img/Image00141.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00141.jpg)'
- en: We can have errors inside those branches and we may not even know it!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分支内部可能会出现错误，我们甚至可能不知道！
- en: 'Try adding these two tests inside the test file:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在测试文件中添加以下两个测试：
- en: '[PRE77]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now if you run the test and open the report, it looks much greener:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行测试并打开报告，它看起来会更加绿色：
- en: '![](img/Image00142.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00142.jpg)'
- en: How it works...
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理如下...
- en: We never even opened the application, but we are already pretty sure that it
    works correctly, thanks to our tests.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至没有打开应用程序，但我们已经非常确定它能正常工作，这要归功于我们的测试。
- en: Furthermore, we have a report that shows us that we covered 100% of the code.
    Although we have only tested the guessing game for three numbers, we covered all
    the possible branches.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有一份报告显示我们覆盖了100%的代码。尽管我们只测试了猜数字游戏的三个数字，但我们覆盖了所有可能的分支。
- en: We will never be sure that our software is free of bugs, but these kinds of
    tool help us developers a great deal in adding features to our software without
    having nightmares that we might have broken something.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远无法确定我们的软件没有错误，但这些工具对我们开发人员在添加功能到我们的软件时非常有帮助，而不必担心可能会出现问题。
