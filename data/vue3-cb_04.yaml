- en: Components, Mixins, and Functional Components
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 组件，混合和功能组件
- en: Building a Vue application is like putting a puzzle together. Each piece of
    the puzzle is a component, and each piece has a slot to fill.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Vue应用程序就像拼图一样。拼图的每一块都是一个组件，每一块都有一个插槽要填充。
- en: Components play a big part in Vue development. In Vue, each part of your code
    will be a component—it could be a layout, page, container, or button, but ultimately,
    it's a component. Learning how to interact with them and reuse them is the key
    to cleaning up code and performance in your Vue application. Components are the
    code that will, in the end, render something on the screen, whatever the size
    might be.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 组件在Vue开发中扮演着重要的角色。在Vue中，您的代码的每一部分都将是一个组件——它可以是布局，页面，容器或按钮，但最终，它都是一个组件。学习如何与它们交互并重用它们是清理代码和提高Vue应用性能的关键。组件是最终会在屏幕上呈现出某些东西的代码，无论大小如何。
- en: In this chapter, we will learn about how we can make a visual component that
    can be reused in many places. We'll use slots to place data inside our components,
    create functional components for seriously fast rendering, implement direct communication
    between parent and child components, and finally, look at loading your components
    asynchronously.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何制作一个可视化组件，可以在许多地方重复使用。我们将使用插槽将数据放入我们的组件中，为了严格快速的渲染，创建功能性组件，实现父子组件之间的直接通信，最后，看看如何异步加载您的组件。
- en: Let's put these all those pieces together and create the beautiful puzzle that
    is a Vue application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些部分放在一起，创建一个美丽的拼图，即Vue应用程序。
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Creating a visual template component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可视化模板组件
- en: Using slots and named slots to place data inside your components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插槽和命名插槽将数据放入您的组件中
- en: Passing data to your component and validating the data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据传递给您的组件并验证数据
- en: Creating functional components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建功能性组件
- en: Accessing your children components data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问您的子组件数据
- en: Creating a dynamic injected component
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个动态注入的组件
- en: Creating a dependency injection component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个依赖注入组件
- en: Creating a component `mixin`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个组件`mixin`
- en: Lazy loading your components
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟加载您的组件
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be using **Node.js** and **Vue-CLI****.**
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**Node.js**和**Vue-CLI**。
- en: 'Attention Windows users: you need to install an NPM package called `windows-build-tools` to
    be able to install the following required packages. To do so, open PowerShell
    as an administrator and execute the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Windows用户：您需要安装一个名为`windows-build-tools`的NPM包，以便能够安装以下所需的包。为此，请以管理员身份打开PowerShell并执行以下命令：
- en: '`> npm install -g windows-build-tools`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '> npm install -g windows-build-tools'
- en: 'To install **Vue-CLI**, you need to open Terminal (macOS or Linux) or the Command
    Prompt*/*PowerShell (Windows) and execute the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装**Vue-CLI**，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating a visual template component
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可视化模板组件
- en: 'Components can be data-driven, stateless, stateful, or a simple visual component.
    But what is a visual component? A visual component is a component that has only
    one purpose: visual manipulation.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以是数据驱动的，无状态的，有状态的，或者是一个简单的可视化组件。但是什么是可视化组件？可视化组件是一个只有一个目的的组件：可视化操作。
- en: A visual component could have a simple Scoped CSS with some `div` HTML elements,
    or it could be a more complex component that can calculate the position of the
    element on the screen in real-time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可视化组件可以有一个简单的带有一些`div` HTML元素的作用域CSS，或者它可以是一个更复杂的组件，可以实时计算元素在屏幕上的位置。
- en: We will create a card wrapper component that follows the Material Design guide.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个遵循Material Design指南的卡片包装组件。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The pre-requisite for this recipe is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的先决条件如下：
- en: Node.js 12+
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To start our component, we can use the Vue project with Vue-CLI, as we did in
    the 'Creating Your first project with Vue CLI' recipe in [Chapter 2](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml), *Introducing
    TypeScript and the Vue Ecosystem***,** or we can start a new one.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的组件，我们可以使用带有Vue-CLI的Vue项目，就像我们在[第2章](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml)中的“使用Vue
    CLI创建您的第一个项目”食谱中所做的那样，*介绍TypeScript和Vue生态系统***，或者我们可以开始一个新的项目。
- en: 'To start a new project, open Terminal (macOS or Linux) or the Command Prompt/PowerShell (Windows)
    and execute the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个新项目，打开终端（macOS或Linux）或命令提示符/PowerShell（Windows），并执行以下命令：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The CLI will ask some questions that will help with the creation of the project.
    You can use the arrow keys to navigate, the *Enter* key to continue, and the *spacebar*
    to select an option. Choose the `default` option:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: CLI将询问一些问题，这些问题将有助于创建项目。您可以使用箭头键导航，*Enter*键继续，*空格键*选择选项。选择`default`选项：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s follow these steps and create a visual template component:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照这些步骤创建一个可视化模板组件：
- en: Let's create a new file called `MaterialCardBox.vue` in the `src/components`
    folder.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`src/components`文件夹中创建一个名为`MaterialCardBox.vue`的新文件。
- en: 'In this file, we will start with the template of our component. We need to
    create the box for the card. By using the Material Design guide, this box will
    have a shadow and rounded corners:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们将从组件的模板开始。我们需要为卡片创建一个框。通过使用Material Design指南，这个框将有阴影和圆角：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `<script>` part of our component, we will add just our basic name:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们组件的`<script>`部分中，我们将只添加我们的基本名称：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to create our elevation CSS stylesheet rules. To do this, create a
    file named `elevation.css` in the `style` folder. There, we will create the elevations
    from `0` to `24`, to follow all the elevations on the Material Design guide:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建我们的高程CSS样式表规则。为此，请在`style`文件夹中创建一个名为`elevation.css`的文件。在那里，我们将创建从`0`到`24`的高程，以遵循Material
    Design指南上的所有高程：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For styling our card in the `<style>` part of the component, we need to set
    the `scoped` attribute inside the `<style>` tag to make sure that the visual style
    won''t interfere with any other components within our application. We will make
    this card follow the Material Design guide. We need to import the `Roboto` font
    family and apply it to all elements that will be wrapped inside this component:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在组件的`<style>`部分中设置样式，我们需要在`<style>`标签内设置`scoped`属性，以确保视觉样式不会干扰应用程序中的任何其他组件。我们将使这张卡遵循Material
    Design指南。我们需要导入`Roboto`字体系列并将其应用于将包装在此组件内的所有元素：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To run the server and see your component, you need to open Terminal (macOS
    or Linux) or the Command Prompt/PowerShell (Windows) and execute the following
    command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行服务器并查看您的组件，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is your component rendered and running:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的组件呈现并运行的方式：
- en: '![](assets/5f9be750-4b22-4898-a28a-c02bba7912d9.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5f9be750-4b22-4898-a28a-c02bba7912d9.png)'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A visual component is a component that will wrap any component and place the
    wrapped data with custom styles. As this component mixes with others, it can form
    a new component without the need to reapply or rewrite any style in your code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化组件是一个将包装任何组件并使用自定义样式放置包装数据的组件。由于此组件与其他组件混合，它可以形成一个新的组件，而无需在代码中重新应用或重写任何样式。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can find more information about Scoped CSS at [https://vue-loader.vuejs.org/guide/scoped-css.html#child-component-root-elements](https://vue-loader.vuejs.org/guide/scoped-css.html#child-component-root-elements).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://vue-loader.vuejs.org/guide/scoped-css.html#child-component-root-elements](https://vue-loader.vuejs.org/guide/scoped-css.html#child-component-root-elements)找到有关作用域CSS的更多信息。
- en: You can find more information about Material Design cards at [https://material.io/components/cards/](https://material.io/components/cards/).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://material.io/components/cards/](https://material.io/components/cards/)找到有关Material
    Design卡片的更多信息。
- en: Check out the Roboto font family at [https://fonts.google.com/specimen/Roboto](https://fonts.google.com/specimen/Roboto).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://fonts.google.com/specimen/Roboto](https://fonts.google.com/specimen/Roboto)上查看Roboto字体系列。
- en: Using slots and named slots to place data inside your components
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插槽和命名插槽在组件中放置数据
- en: Sometimes the pieces of the puzzle go missing, and you find yourself with a
    blank spot. Imagine that you could fill that empty spot with a piece that you
    crafted yourself, not the original one that came with the puzzle box. That's a
    rough analogy for what a Vue slot is.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，拼图的一些部分会丢失，你会发现自己有一个空白的地方。想象一下，你可以用自己制作的一块填充那个空白的地方，而不是原来随拼图盒子一起的那块。这是Vue插槽的一个粗略类比。
- en: Vue slots are like open spaces in your component that other components can fill
    with text, HTML elements, or other Vue components. You can declare where the slot
    will be and how it will behave in your component.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Vue插槽就像是组件中的开放空间，其他组件可以用文本、HTML元素或其他Vue组件填充。您可以在组件中声明插槽的位置和行为方式。
- en: With this technique, you can create a component and, when needed, customize
    it without any effort at all.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，您可以创建一个组件，并在需要时轻松自定义它。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The pre-requisite for this recipe is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的先决条件如下：
- en: Node.js 12+
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To start our component, we can create our Vue project with Vue-CLI, as we did
    in the *Creating Your first project with Vue CLI* recipe in [Chapter 2](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml), *Introducing
    TypeScript and the Vue Ecosystem***,** or use the project from the *Creating a
    visual template component* recipe.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的组件，我们可以像在[第2章](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml)的*使用Vue CLI创建您的第一个项目*中那样使用Vue-CLI创建我们的Vue项目，或者使用*创建可视化模板组件*中的项目。
- en: 'Follow these instructions to create slots and named slots in components:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明在组件中创建插槽和命名插槽：
- en: Let's open the file called `MaterialCardBox.vue` in the components folder.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开组件文件夹中的名为`MaterialCardBox.vue`的文件。
- en: 'In the `<template>` part of the component, we will need to add four main sections
    on the card. Those sections are based on the Material Design card anatomy and
    are the `header`, `media`, `main section`, and `action` areas. We will use the
    default slot for the `main section`, and the rest will all be named scopes. For
    some named slots, we will add a fallback configuration that will be displayed
    if the user doesn''t choose any setting on the slot:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<template>`部分，我们需要在卡片上添加四个主要部分。这些部分基于Material Design卡片解剖学，分别是`header`、`media`、`main
    section`和`action`区域。我们将使用默认插槽来放置`main section`，其余部分都将是命名作用域。对于一些命名插槽，我们将添加一个备用配置，如果用户没有在插槽上选择任何设置，将显示该配置：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we need to create our text CSS stylesheet rules for the component. In
    the `style` folder, create a new file called `cardStyles.css`, and there we will
    add the rules for the card text and headers:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为组件创建文本CSS样式表规则。在`style`文件夹中，创建一个名为`cardStyles.css`的新文件，在那里我们将添加卡片文本和标题的规则：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `<style>` part of the component, we need to create some CSS stylesheets
    to follow the rules of our design guide:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<style>`部分，我们需要创建一些CSS样式表来遵循我们的设计指南的规则：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `App.vue` file, in the `src` folder, we need to add elements to those
    slots. Those elements will be added to each one of the named slots, and for the
    default slot. We will change the component in the `<template>` part of the file.
    To add a named slot, we need to use a directive called `v-slot:` and then the
    name of the slot we want to use:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中的`App.vue`文件中，我们需要向这些插槽添加元素。这些元素将被添加到每个命名插槽和默认插槽中。我们将更改文件的`<template>`部分中的组件。要添加命名插槽，我们需要使用一个名为`v-slot:`的指令，然后是我们想要使用的插槽的名称：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For the default slot, we don't need to use a directive; it just needs to be
    wrapped in the component to be placed in the `<slot />` part of the component.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于默认插槽，我们不需要使用指令；它只需要包装在组件中，以放置在组件的`<slot />`部分中。
- en: 'To run the server and see your component, you need to open Terminal (macOS
    or Linux) or the Command Prompt/PowerShell (Windows) and execute the following
    command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行服务器并查看您的组件，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is your component rendered and running:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的组件渲染并运行的方式：
- en: '![](assets/82443046-abca-438a-9a1a-0be3390fecda.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/82443046-abca-438a-9a1a-0be3390fecda.png)'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Slots are places where you can put anything that can be rendered into the DOM.
    We choose the position of our slot and tell the component where to render when
    it receives any information.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽是可以放置任何可以呈现到DOM中的地方。我们选择插槽的位置，并告诉组件在接收到任何信息时在何处呈现。
- en: In this recipe, we used named slots, which are designed to work with a component
    that requires more than one slot. To place any information in that component within
    the Vue single file (`.vue`) `<template>` part, you need to add the `v-slot:`
    directive so that Vue is able to know where to place the information that was
    passed down.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们使用了命名插槽，它们旨在与需要多个插槽的组件一起使用。要在Vue单文件（`.vue`）的`<template>`部分中向该组件放置任何信息，您需要添加`v-slot:`指令，以便Vue能够知道在何处放置传递下来的信息。
- en: See also
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about Vue slots at [https://vuejs.org/v2/guide/components-slots.html](https://vuejs.org/v2/guide/components-slots.html).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://vuejs.org/v2/guide/components-slots.html](https://vuejs.org/v2/guide/components-slots.html)找到有关Vue插槽的更多信息。
- en: You can find more information about the Material Design card anatomy at [https://material.io/components/cards/#anatomy](https://material.io/components/cards/#anatomy).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://material.io/components/cards/#anatomy](https://material.io/components/cards/#anatomy)找到有关Material
    Design卡片解剖的更多信息。
- en: Passing data to your component and validating the data
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向您的组件传递数据并验证数据
- en: You now know how to place data inside your component through slots, but those
    slots were made for HTML DOM elements or Vue components. Sometimes, you need to
    pass data such as strings, arrays, Booleans, or even objects.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道如何通过插槽将数据放入组件中，但这些插槽是为HTML DOM元素或Vue组件而设计的。有时，您需要传递诸如字符串、数组、布尔值甚至对象之类的数据。
- en: The whole application is like a puzzle, where each piece is a component. Communication
    between components is an important part of it. The possibility to pass data to
    a component is the first step to connect the puzzle, and then validating the data
    is the final step to connect the pieces.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序就像一个拼图，其中每个部分都是一个组件。组件之间的通信是其中的重要部分。向组件传递数据的可能性是连接拼图的第一步，然后验证数据是连接这些部分的最后一步。
- en: In this recipe, we will learn how to pass data to a component and validate the
    data that was passed to the component.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何向组件传递数据并验证传递给组件的数据。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The pre-requisite is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件如下：
- en: Node.js 12+
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js所需的全局对象如下：
- en: '`@vue/cli`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To start our component, we can create our Vue project with Vue-CLI, as we did
    in the recipe *Creating Your first project with Vue CLI* in [Chapter 2](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml),* Introducing
    TypeScript and the Vue Ecosystem*, or use the project from the *Using slots and
    name slots to place data inside your components* recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的组件，我们可以像在第2章“介绍TypeScript和Vue生态系统”中的*使用Vue CLI创建您的第一个项目*食谱中那样，使用Vue-CLI创建我们的Vue项目，或者使用*使用插槽和命名插槽将数据放入组件*食谱中的项目。
- en: 'Follow these instructions to pass data to the component and validate it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些说明将数据传递给组件并进行验证：
- en: Let's open the file called `MaterialCardBox.vue` in the `src/components` folder.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`src/components`文件夹中打开名为`MaterialCardBox.vue`的文件。
- en: 'In the `<script>` part of the component, we create a new property, called `props`.
    This property receives the component data, and that data can be used for visual
    manipulation, variables inside your code, or a function that needs to be executed.
    In this property, we need to declare the name of the attribute, the type, if it''s
    required, and the validation function. This function will be executed at runtime
    to validate whether the passed attribute is a valid one:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们创建一个名为`props`的新属性。该属性接收组件数据，该数据可以用于视觉操作、代码内的变量或需要执行的函数。在此属性中，我们需要声明属性的名称、类型、是否必需以及验证函数。此函数将在运行时执行，以验证传递的属性是否有效：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `computed` property, in the `<script>` part of the component, we need
    to create a set of visual manipulation rules that will be used for rendering the
    card. Those rules will be `showMediaContent`, `showActionsButtons`, `showHeader`,
    and `cardElevation`. Each rule will check the received `props` and the `$slots` objects
    to see whether the relevant card part needs to be rendered:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分的`computed`属性中，我们需要创建一组用于呈现卡片的视觉操作规则。这些规则将是`showMediaContent`、`showActionsButtons`、`showHeader`和`cardElevation`。每个规则将检查接收到的`props`和`$slots`对象，以查看是否需要呈现相关的卡片部分：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After adding the visual manipulation rules, we need to add the created rules
    to the `<template>` part of our component. They will affect the appearance and
    behavior of our card. For example, if there is no header slot defined, and there
    is a header property defined, we show the fallback header. That header is the
    data that was passed down via `props`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了视觉操作规则之后，我们需要将创建的规则添加到组件的`<template>`部分。它们将影响我们卡片的外观和行为。例如，如果没有定义头部插槽，并且定义了头部属性，我们将显示备用头部。该头部是通过`props`传递下来的数据：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To run the server and see your component, you need to open Terminal (macOS
    or Linux) or the Command Prompt/PowerShell (Windows) and execute the following
    command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行服务器并查看您的组件，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is your component rendered and running:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的组件呈现并运行：
- en: '![](assets/ab464f57-6b57-4caa-b845-afec0d64684c.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ab464f57-6b57-4caa-b845-afec0d64684c.png)'
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Each Vue component is a JavaScript object that has a render function. This render
    function is called when it is time to render it in the HTML DOM. A single file
    component is an abstraction of this object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Vue组件都是一个具有渲染函数的JavaScript对象。当需要在HTML DOM中呈现它时，将调用此渲染函数。单文件组件是该对象的抽象。
- en: When we are declaring that our component has unique props that can be passed,
    it opens a tiny door for other components or JavaScript to place information inside
    our component. We are then able to use those values inside our component to render
    data, do some calculations, or make visual rules.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明我们的组件具有可以传递的唯一 props 时，它为其他组件或 JavaScript 打开了一个小门，以便将信息放入我们的组件中。然后，我们可以在组件内使用这些值来渲染数据，进行一些计算或制定可视规则。
- en: In our case, using the single file component, we are passing those rules as
    HTML attributes because `vue-template-compiler` will take those attributes and
    transform them into JavaScript objects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，使用单文件组件，我们将这些规则作为 HTML 属性传递，因为 `vue-template-compiler` 将获取这些属性并将它们转换为
    JavaScript 对象。
- en: When those values are passed to our component, Vue first checks whether the
    passed attribute matches the correct type, and then we execute our validation
    function on top of each value to see whether it matches what we'd expect.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些值传递给我们的组件时，Vue 首先检查传递的属性是否与正确的类型匹配，然后我们在每个值上执行我们的验证函数，以查看它是否与我们期望的匹配。
- en: After all of this is done, the component life cycle continues, and we can render
    our component.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，组件的生命周期将继续，我们可以渲染我们的组件。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about `props` at [https://vuejs.org/v2/guide/components-props.html](https://vuejs.org/v2/guide/components-props.html).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://vuejs.org/v2/guide/components-props.html](https://vuejs.org/v2/guide/components-props.html)
    找到有关 `props` 的更多信息。
- en: You can find more information about `vue-template-compiler` at [https://vue-loader.vuejs.org/guide/](https://vue-loader.vuejs.org/guide/).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://vue-loader.vuejs.org/guide/](https://vue-loader.vuejs.org/guide/)
    找到有关 `vue-template-compiler` 的更多信息。
- en: Creating functional components
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建功能组件
- en: The beauty of functional components is their simplicity. They're a stateless
    component, without any data, computed property, or even a life cycle. They're
    just a render function that is called when the data that is passed changed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件的美妙之处在于它们的简单性。它们是无状态组件，没有任何数据、计算属性，甚至没有生命周期。它们只是在传递的数据发生变化时调用的渲染函数。
- en: You may be wondering how this can be useful. Well, a functional component is
    a perfect companion for UI components that don't need to keep any data inside
    them, or visual components that are just rendered components that don't require
    any data manipulation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道这有什么用。嗯，功能组件是 UI 组件的完美伴侣，这些组件不需要在内部保留任何数据，或者只是渲染组件，不需要任何数据操作的可视组件。
- en: As the name implies, they are simple function components, and they have nothing
    more than the render function. They are a stripped-down version of a component
    used exclusively for performance rendering and visual elements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，它们是简单的函数组件，除了渲染函数外没有其他内容。它们是组件的精简版本，专门用于性能渲染和可视元素。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The pre-requisite is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件如下：
- en: Node.js 12+
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的 Node.js 全局对象如下：
- en: '`@vue/cli`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To start our component, create your Vue project with Vue-CLI, as we did in the
    recipe '*Creating Your first project with Vue CLI*' in [Chapter 2](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml), *Introducing
    TypeScript and the Vue Ecosystem***, **or use the project from the '*Passing data
    to your component and validating the data*'recipe.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的组件，请使用 Vue-CLI 创建您的 Vue 项目，就像我们在第 2 章“引入 TypeScript 和 Vue 生态系统”中的食谱“*使用
    Vue CLI 创建您的第一个项目*”中所做的那样，或者使用“将数据传递给您的组件并验证数据”的食谱中的项目。
- en: 'Now, follow these instructions to create a Vue functional component:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下说明创建一个 Vue 功能组件：
- en: Create a new file called `MaterialButton.vue` in the `src/components` folder.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中创建一个名为`MaterialButton.vue`的新文件。
- en: 'In this component, we need to validate whether the prop we''ll receive is a
    valid color. To do this, install in the project the `is-color` module. You''ll
    need to open Terminal (macOS or Linux) or the Command Prompt/PowerShell (Windows) and
    execute the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个组件中，我们需要验证我们将接收的prop是否是有效的颜色。为此，在项目中安装`is-color`模块。您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `<script>` part of our component, we need to create the `props` object
    that the functional component will receive. As a functional component is just
    a render function with no state – it''s stateless – the `<script>` part of the
    component is trimmed down to `props`, `injections`, and `slots`. There will be
    four `props` objects: `backgroundColor`, `textColor`, `isRound`, and `isFlat`.
    These won''t be required when installing the component, as we will have a default
    value defined in `props`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们组件的`<script>`部分，我们需要创建功能组件将接收的`props`对象。由于功能组件只是一个没有状态的渲染函数，`<script>`部分被简化为`props`、`injections`和`slots`。将有四个`props`对象：`backgroundColor`、`textColor`、`isRound`和`isFlat`。在安装组件时，这些不是必需的，因为我们在`props`中定义了默认值：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `<template>` part of our component, we first need to add the `functional` attribute to
    the `<template>` tag to indicate to the `vue-template-compiler` that this component
    is a functional component. We need to create a button HTML element, with a basic
    `class` attribute button and a dynamic `class` attribute based on the `props` object
    received. Different from the normal component, we need to specify the `props` property in
    order to use the functional component. For the style of the button, we need to
    create a dynamic `style` attribute, also based on `props`. To emit all the event
    listeners directly to the parent, we can call the `v-on` directive and pass the `listeners`
    property. This will bind all the event listeners without needing to declare each
    one. Inside the button, we will add a `div` HTML element for visual enhancement,
    and add `<slot>` where the text will be placed:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们组件的`<template>`部分，我们首先需要向`<template>`标签添加`functional`属性，以指示`vue-template-compiler`这个组件是一个功能组件。我们需要创建一个按钮HTML元素，带有基本的`class`属性按钮和一个基于`props`对象接收的动态`class`属性。与普通组件不同，我们需要指定`props`属性以使用功能组件。对于按钮的样式，我们需要创建一个基于`props`的动态`style`属性。为了直接将所有事件监听器传递给父组件，我们可以调用`v-on`指令并传递`listeners`属性。这将绑定所有事件监听器，而无需声明每一个。在按钮内部，我们将添加一个用于视觉增强的`div`
    HTML元素，并添加`<slot>`，文本将放置在其中：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s make it pretty. In the `<style>` part of the component, we need
    to create all the CSS stylesheet rules for this button. We need to add the `scoped`
    attribute to `<style>` so that all the CSS stylesheet rules won''t affect any
    other elements in our application:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们把它弄得漂亮一点。在组件的`<style>`部分，我们需要为这个按钮创建所有的CSS样式表规则。我们需要向`<style>`添加`scoped`属性，以便所有的CSS样式表规则不会影响我们应用程序中的任何其他元素：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To run the server and see your component, you need to open Terminal (macOS
    or Linux) or the Command Prompt/PowerShell (Windows) and execute the following
    command:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行服务器并查看您的组件，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is your component rendered and running:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的组件渲染并运行的地方：
- en: '![](assets/da07bacd-c897-42be-9dc2-536e8ae144c6.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/da07bacd-c897-42be-9dc2-536e8ae144c6.png)'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Functional components are as simple as a render function. They don't have any
    sort of data, function, or access to the outside world.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件就像一个渲染函数一样简单。它们没有任何类型的数据、函数或者对外部世界的访问。
- en: They were first introduced in Vue as a JavaScript object `render()` function
    only; later, they were added to `vue-template-compiler` for the Vue single file
    application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它们最初作为JavaScript对象`render()`函数在Vue中引入；后来，它们被添加到了`vue-template-compiler`中，用于Vue单文件应用程序。
- en: 'A functional component works by receiving two arguments: `createElement` and
    `context`. As we saw in the single file, we only had access to the elements as
    they weren''t in the `this` property of the JavaScript object. This occurs because
    as the context is passed to the render function, there is no `this` property.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件通过接收两个参数来工作：`createElement`和`context`。正如我们在单文件中看到的，我们只能访问元素，因为它们不在JavaScript对象的`this`属性中。这是因为当上下文传递给渲染函数时，就没有`this`属性。
- en: A functional component provides the fastest rendering possible on Vue, as it
    doesn't depend on the life cycle of a component to check for the rendering; it
    just renders each time data is changed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件在Vue上提供了最快的渲染速度，因为它不依赖于组件的生命周期来检查渲染；它只是在数据更改时每次渲染。
- en: See also
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about functional components at [https://vuejs.org/v2/guide/render-function.html#Functional-Components](https://vuejs.org/v2/guide/render-function.html#Functional-Components).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://vuejs.org/v2/guide/render-function.html#Functional-Components](https://vuejs.org/v2/guide/render-function.html#Functional-Components)找到有关功能组件的更多信息。
- en: You can find more information about the `is-color` module at [https://www.npmjs.com/package/is-color](https://www.npmjs.com/package/is-color).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.npmjs.com/package/is-color](https://www.npmjs.com/package/is-color)找到有关`is-color`模块的更多信息。
- en: Accessing your children components data
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问您的子组件数据
- en: Normally, parent-child communications are done via events or props. But sometimes,
    you need to access data, functions, or computed properties that exist in the child
    or the parent function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，父子通信是通过事件或props来完成的。但有时，您需要访问存在于子组件或父组件函数中的数据、函数或计算属性。
- en: Vue provides a way to interact in both ways, opening doors to communications
    and events, such as props and event listeners.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Vue提供了一种双向交互的方式，打开了通信和事件的大门，例如props和事件监听器。
- en: There is another way to access the data between the components: by using direct
    access. This can be done with the help of a special attribute in the template
    when using the single file component or a direct call of the object inside the
    JavaScript. This method is seen by some as a little lazy, but there are times
    when there really is no other way to do it than this.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种访问组件之间数据的方式：通过直接访问。这可以通过在单文件组件中使用模板时使用特殊属性，或者在JavaScript中直接调用对象来完成。这种方法被一些人认为有点懒惰，但有时确实没有其他方法可以做到这一点。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The pre-requisite is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件如下：
- en: Node.js 12+
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To start your component, create your Vue project with Vue-CLI, as we did in
    the '*Creating Your first project with Vue CLI*' recipe in [Chapter 2](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml), *Introducing
    TypeScript and the Vue Ecosystem*, or use the project from the '*Creating functional
    components*' recipe.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动您的组件，请使用Vue-CLI创建您的Vue项目，就像我们在[第2章](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml)的'*使用Vue
    CLI创建您的第一个项目*'食谱中所做的那样，*介绍TypeScript和Vue生态系统*，或者使用'*创建功能组件*'食谱中的项目。
- en: We're going to separate the recipe into four parts. The first three parts will
    cover the creation of new components –  `StarRatingInput`, `StarRatingDisplay`,
    and `StarRating`–and the last part will cover the parent-child direct manipulation
    of the data and function access.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个教程分成四个部分。前三部分将涵盖新组件的创建——`StarRatingInput`、`StarRatingDisplay`和`StarRating`——最后一部分将涵盖数据和函数访问的父子直接操作。
- en: Creating the star rating input
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建星级评分输入
- en: We are going to create a star rating input, based on a five-star ranking system.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个基于五星级评分系统的星级评分输入。
- en: 'Follow these steps to create a custom star rating input:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建自定义星级评分输入：
- en: Create a new file called `StarRatingInput.vue` in the `src/components` folder.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中创建一个名为`StarRatingInput.vue`的新文件。
- en: 'In the `<script>` part of the component, create a `maxRating` property in the
    `props` property that is a number, non-required, and has a default value of `5`.
    In the `data` property, we need to create our `rating` property, with the default
    value of `0`. In the `methods` property, we need to create three methods: `updateRating`,
    `emitFinalVoting`, and `getStarName`. The `updateRating` method will save the
    rating to the data, `emitFinalVoting` will call `updateRating` and emit the rating
    to the parent component through a `final-vote` event, and `getStarName` will receive
    a value and return the icon name of the star:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，在`props`属性中创建一个`maxRating`属性，它是一个数字，非必需，并且默认值为`5`。在`data`属性中，我们需要创建我们的`rating`属性，其默认值为`0`。在`methods`属性中，我们需要创建三个方法：`updateRating`、`emitFinalVoting`和`getStarName`。`updateRating`方法将保存评分到数据中，`emitFinalVoting`将调用`updateRating`并通过`final-vote`事件将评分传递给父组件，`getStarName`将接收一个值并返回星级的图标名称。
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `<template>` part of the component, we need to create a `<slot>` component
    to place the text before the star rating. We''ll create a dynamic list of stars
    based on the `maxRating` value that we received via the `props` property. Each
    star that is created will have a listener attached to it in the `mouseenter`,
    `focus`, and `click` events. `mouseenter` and `focus`, when fired, will call the
    `updateRating` method, and `click` will call `emitFinalVote`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<template>`部分，我们需要创建一个`<slot>`组件来放置星级评分之前的文本。我们将根据通过`props`属性接收到的`maxRating`值创建一个动态星级列表。创建的每个星级都将在`mouseenter`、`focus`和`click`事件上附加一个监听器。当触发`mouseenter`和`focus`时，将调用`updateRating`方法，而`click`将调用`emitFinalVote`方法。
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to import the Material Design icons into our application. Create a
    new styling file in the `styles` folder called `materialIcons.css`, and add the
    CSS stylesheet rules for `font-family`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将Material Design图标导入我们的应用程序。在`styles`文件夹中创建一个名为`materialIcons.css`的新样式文件，并添加`font-family`的CSS样式规则。
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Open the `main.js` file and import the created stylesheet into it. The `css-loader` webpack will
    handle the processing of imported `.css` files in JavaScript files. This will
    help development because you don''t need to re-import the file elsewhere:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`main.js`文件，并将创建的样式表导入其中。`css-loader`将处理JavaScript文件中导入的`.css`文件的处理。这将有助于开发，因为您不需要在其他地方重新导入文件。
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To style our component, we will create a common styling file in the `src/style` folder
    called `starRating.css`. There we will add the common styles that will be shared
    between the `StarRatingDisplay` and `StarRatingInput` components:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给我们的组件添加样式，我们将在`src/style`文件夹中创建一个名为`starRating.css`的通用样式文件。在那里，我们将添加`StarRatingDisplay`和`StarRatingInput`组件之间共享的通用样式。
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `<style>` part of the component, we need to create all the CSS stylesheet
    rules. Then, on the `StarRatingInput.vue` component file located in the `src/components`
    folder we need to add the `scoped` attribute to `<style>` so that all the CSS
    stylesheet rules won''t affect any other elements in our application. Here, we
    will import the common styles that we created and add new ones for the input:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<style>`部分，我们需要创建所有的CSS样式表规则。然后，在位于`src/components`文件夹中的`StarRatingInput.vue`组件文件上，我们需要向`<style>`添加`scoped`属性，以便所有的CSS样式表规则不会影响应用程序中的任何其他元素。在这里，我们将导入我们创建的通用样式，并为输入添加新样式：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To run the server and see your component, you need to open Terminal (macOS
    or Linux) or the Command Prompt/PowerShell (Windows) and execute the following
    command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行服务器并查看您的组件，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here is your component rendered and running:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的组件呈现并运行的样子：
- en: '![](assets/18715858-a5b0-4fa7-97db-d68268fd190d.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/18715858-a5b0-4fa7-97db-d68268fd190d.png)'
- en: Creating the StarRatingDisplay component
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建StarRatingDisplay组件
- en: 'Now that we have our input, we need a way to display the selected choice to
    the user. Follow these steps to create a `StarRatingDisplay` component:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了输入，我们需要一种方法来向用户显示所选的选择。按照以下步骤创建`StarRatingDisplay`组件：
- en: Create a new component called `StarRatingDisplay.vue` in the `src/components`
    folder.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中创建一个名为`StarRatingDisplay.vue`的新组件。
- en: 'In the `<script>` part of the component, in the `props` property, we need to
    create three new properties: `maxRating`, `rating`, and `votes`. All three of
    them will be numbers and non-required and have a default value. In the `methods`
    property, we need to create a new method called `getStarName`, which will receive
    a value and return the icon name of the star:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，在`props`属性中，我们需要创建三个新属性：`maxRating`，`rating`和`votes`。它们三个都将是数字，非必需的，并且有默认值。在`methods`属性中，我们需要创建一个名为`getStarName`的新方法，它将接收一个值并返回星星的图标名称：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In `<template>`, we need to create a dynamic list of stars based on the `maxRating` value
    that we received via the `props`property. After the list, we need to display that
    we received votes, and if we receive any votes, we will display them too:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<template>`中，我们需要根据通过`props`属性接收到的`maxRating`值创建一个动态星星列表。在列表之后，我们需要显示我们收到的投票数，如果我们收到任何投票，我们也会显示它们：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `<style>` part of the component, we need to create all the CSS stylesheet
    rules. We need to add the `scoped` attribute to `<style>`so that all the CSS stylesheet
    rules won''t affect any other elements in our application. Here, we will import
    the common styles that we created and add new ones for the display:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<style>`部分，我们需要创建所有的CSS样式表规则。我们需要向`<style>`添加`scoped`属性，以便所有的CSS样式表规则不会影响应用程序中的任何其他元素。在这里，我们将导入我们创建的通用样式，并为显示添加新样式：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To run the server and see your component, you need to open Terminal (macOS
    or Linux) or the Command Prompt/PowerShell (Windows) and execute the following
    command:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行服务器并查看您的组件，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is your component rendered and running:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的组件呈现并运行的样子：
- en: '![](assets/b65b034f-a304-4975-8858-2bd46e378bce.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b65b034f-a304-4975-8858-2bd46e378bce.png)'
- en: Creating the StarRating component
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建StarRating组件
- en: After creating the input and the display, we need to join both together in a
    single component. This component will be the final component that we'll use in
    the application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 创建输入和显示后，我们需要将两者合并到一个单独的组件中。这个组件将是我们在应用程序中使用的最终组件。
- en: 'Follow these steps to create the final `StarRating` component:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建最终的`StarRating`组件：
- en: Create a new file called `StarRating.vue` in the `src/components` folder.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中创建一个名为`StarRating.vue`的新文件。
- en: 'In the `<script>` part of the component, we need to import the `StarRatingDisplay`
    and `StarRatingInput` components. In the `props` property, we need to create three
    new properties: `maxRating`, `rating`, and `votes`. All three of them will be
    numbers and non-required, with a default value. In the `data` property, we need
    to create our `rating` property, with a default value of `0`, and a property called
    `voted`, with a default value of `false`. In the `methods` property, we need to
    add a new method called `vote`, which will receive `rank` as an argument. It will
    define `rating` as the received value and define the inside variable of the `voted` component
    as `true`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们需要导入`StarRatingDisplay`和`StarRatingInput`组件。在`props`属性中，我们需要创建三个新属性：`maxRating`，`rating`和`votes`。它们三个都将是数字，非必需的，并且有一个默认值。在`data`属性中，我们需要创建我们的`rating`属性，其默认值为`0`，并且一个名为`voted`的属性，其默认值为`false`。在`methods`属性中，我们需要添加一个名为`vote`的新方法，它将接收`rank`作为参数。它将把`rating`定义为接收到的值，并将`voted`组件的内部变量定义为`true`：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `<template>` part, we will place both the components, displaying the
    input of the rating:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<template>`部分，我们将放置两个组件，显示评分的输入：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Data manipulation on child components
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子组件上的数据操作
- en: Now that all of our components are ready, we need to add them to our application.
    The base application will access the child component, and it will set the rating
    to 5 stars.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的组件都准备好了，我们需要将它们添加到我们的应用程序中。基本应用程序将访问子组件，并将评分设置为5星。
- en: 'Now, follow these steps to understand and manipulate the data in the child
    components:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤来理解和操作子组件中的数据：
- en: In the `App.vue` file, in the `<template>` part of the component, remove the
    `main-text` attribute of the `MaterialCardBox` component and place it as the default
    slot of the component.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.vue`文件中，在组件的`<template>`部分，删除`MaterialCardBox`组件的`main-text`属性，并将其放置为组件的默认插槽。
- en: 'Before the placed text, we will add the `StarRating` component. We will add
    a `ref` attribute to it. This attribute will indicate to Vue to link this component
    directly to a special property in the `this` object of the component. In the action
    buttons, we will add the listeners for the click event—one for `resetVote` and
    another for `forceVote`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在放置的文本之前，我们将添加`StarRating`组件。我们将为其添加一个`ref`属性。此属性将指示Vue将此组件直接链接到组件的`this`对象中的一个特殊属性。在操作按钮中，我们将为点击事件添加监听器——一个用于`resetVote`，另一个用于`forceVote`。
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `<script>` part of the component, we will create a `methods` property,
    and add two new methods: `resetVote` and `forceVote`. Those methods will access
    the `StarRating` component and reset the data or set the data to a 5-star vote,
    respectively:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们将创建一个`methods`属性，并添加两个新方法：`resetVote`和`forceVote`。这些方法将访问`StarRating`组件并重置数据或将数据设置为5星投票：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the `ref` property is added to the component, Vue adds a link to the referenced
    element to the `$refs` property inside the `this` property object of JavaScript.
    From there, you have full access to the component.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ref`属性添加到组件时，Vue会将对所引用元素的链接添加到JavaScript的`this`属性对象内的`$refs`属性中。从那里，您可以完全访问组件。
- en: This method is commonly used to manipulate HTML DOM elements without the need
    to call for document query selector functions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常用于操作HTML DOM元素，而无需调用文档查询选择器函数。
- en: However, the main function of this property is to give access to the Vue component
    directly, enabling you the ability to execute functions and see the computed properties,
    variables, and changed variables of the component—like full access to the component
    from the outside.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此属性的主要功能是直接访问Vue组件，使您能够执行函数并查看组件的计算属性、变量和更改的变量，就像从外部完全访问组件一样。
- en: There's more...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the same way that a parent can access a child component, a child can access
    a parent component by calling `$parent` on the `this` object. An event can access
    the root element of the Vue application by calling the `$root` property.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与父组件可以访问子组件的方式相同，子组件可以通过在`this`对象上调用`$parent`来访问父组件。事件可以通过调用`$root`属性来访问Vue应用程序的根元素。
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about parent-child communication at [https://vuejs.org/v2/guide/components-edge-cases.html#Accessing-the-Parent-Component-Instance](https://vuejs.org/v2/guide/components-edge-cases.html#Accessing-the-Parent-Component-Instance).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://vuejs.org/v2/guide/components-edge-cases.html#Accessing-the-Parent-Component-Instance](https://vuejs.org/v2/guide/components-edge-cases.html#Accessing-the-Parent-Component-Instance)找到有关父子通信的更多信息。
- en: Creating a dynamic injected component
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动态注入组件
- en: There are some cases where your component can be defined by the kind of variable
    you are receiving or the type of data that you have; then, you need to change
    the component on the fly, without the need to set a lot of Vue `v-if`, `v-else-if`,
    and `v-else` directives.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，您的组件可以由您收到的变量类型或数据类型来定义；然后，您需要在不需要设置大量Vue `v-if`、`v-else-if`和`v-else`指令的情况下即时更改组件。
- en: In those cases, the best thing to do is to use dynamic components, when a computed
    property or a function can define the component that will be used to be rendered,
    and the decision is taken in real time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，最好的做法是使用动态组件，当计算属性或函数可以定义要呈现的组件时，并且决定是实时进行的。
- en: These decisions sometimes can be simple if there are two responses, but they
    can be more complex with a long switch case, where you may have a long list of
    possible components to be used.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个响应，这些决策有时可能很简单，但在长的switch case中可能会更复杂，其中可能有一长串可能要使用的组件。
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The pre-requisite is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件如下：
- en: Node.js 12+
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '``@vue/cli-service-global``'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``@vue/cli-service-global``'
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To start our component, we can create our Vue project with Vue-CLI, as we did
    in the '*Creating Your first project with Vue CLI*' recipe in [Chapter 2](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml), *Introducing
    TypeScript and the Vue Ecosystem*, or use the project from the '*Accessing* *your
    children components data*' recipe.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的组件，我们可以使用Vue-CLI创建我们的Vue项目，就像我们在[第2章](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml)中的'*使用Vue
    CLI创建您的第一个项目*'配方中所做的那样，*介绍TypeScript和Vue生态系统*，或者使用'*访问您的子组件数据*'配方中的项目。
- en: 'Follow these steps to create a dynamic injected component:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建动态注入组件：
- en: Open the `StarRating.vue` component.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRating.vue`组件。
- en: 'In the `<script>` part of the component, we need to create a `computed` property
    with a new computed value called `starComponent`. This value will check whether
    the user has voted. If they haven''t, it will return the `StarRatingInput` component;
    otherwise, it will return the `StarRatingDisplay` component:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们需要创建一个带有名为`starComponent`的新计算值的`computed`属性。此值将检查用户是否已投票。如果他们没有，它将返回`StarRatingInput`组件；否则，它将返回`StarRatingDisplay`组件：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `<template>` part of the component, we will remove both of the existing
    components and replace them with a special component called `<component>`. This
    special component has a named attribute that you can point to anywhere that returns
    a valid Vue component. In our case, we will point to the computed `starComponent` property.
    We will take all the bind props that were defined from both of the other components
    and put them inside this new component, including the text that is placed in `<slot>`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<template>`部分，我们将删除现有组件，并用一个名为`<component>`的特殊组件替换它们。这个特殊组件有一个命名属性，您可以指向任何返回有效Vue组件的地方。在我们的例子中，我们将指向计算属性`starComponent`。我们将把从这两个组件中定义的所有绑定props放在这个新组件中，包括放在`<slot>`中的文本：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Using the Vue special `<component>` component, we declared what the component
    should render according to the rules set on the computed property.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue特殊的`<component>`组件，我们声明了根据计算属性设置的规则应该呈现什么组件。
- en: Being a generic component, you always need to guarantee that everything will
    be there for each of the components that can be rendered. The best way to do this
    is by using the `v-bind` directive with the props and rules that need to be defined,
    but it's possible to define it directly on the component also, as it will be passed
    down as a prop.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 作为通用组件，您总是需要确保每个可以呈现的组件都存在。最好的方法是使用`v-bind`指令与需要定义的props和规则，但也可以直接在组件上定义，因为它将作为prop传递下去。
- en: See also
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about dynamic components at [https://vuejs.org/v2/guide/components.html#Dynamic-Components](https://vuejs.org/v2/guide/components.html#Dynamic-Components).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://vuejs.org/v2/guide/components.html#Dynamic-Components](https://vuejs.org/v2/guide/components.html#Dynamic-Components)找到有关动态组件的更多信息。
- en: Creating a dependency injection component
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建依赖注入组件
- en: Accessing data directly from a child or a parent component without knowing whether
    they exist can be very dangerous.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从子组件或父组件访问数据而不知道它们是否存在可能非常危险。
- en: In Vue, it's possible to make your component behavior like an interface and
    have a common and abstract function that won't change in the development process.
    The process of dependency injection is a common paradigm in the developing world
    and has been implemented in Vue also.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue中，可以使您的组件的行为像一个接口，并拥有一个在开发过程中不会改变的常见和抽象函数。依赖注入的过程是开发世界中的一个常见范例，并且也已经在Vue中实现。
- en: There are some pros and cons to using the internal Vue dependency injection,
    but it is always a good way to make sure that your children's components know
    what to expect from the parent component when developing it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内部Vue依赖注入有一些利弊，但在开发时，确保子组件知道父组件的期望总是一个好方法。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The pre-requisite is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件如下：
- en: Node.js 12+
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: How to do it...
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To start our component, we can create our Vue project with Vue-CLI, as we did
    in the '*Creating Your first project with Vue CLI*' recipe in [Chapter 2](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml), *Introducing
    TypeScript and the Vue Ecosystem***, **or use the project from the '*Creating
    a dynamic injected component*' recipe.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的组件，我们可以像在[第2章](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml)中的“使用Vue CLI创建您的第一个项目”中那样使用Vue-CLI创建我们的Vue项目，或者使用“创建动态注入组件”中的项目。
- en: 'Now, follow these steps to create a dependency injection component:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤创建一个依赖注入组件：
- en: Open the `StarRating.vue` component.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRating.vue`组件。
- en: 'In the `<script>` part of the component, add a new property called `provide`.
    In our case, we will just be adding a key-value to check whether the component
    is a child of the specific component. Create an object in the property with the
    `starRating` key and the `true` value:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，添加一个名为`provide`的新属性。在我们的情况下，我们将只添加一个键值来检查组件是否是特定组件的子级。在属性中创建一个对象，其中包含`starRating`键和`true`值：
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Open the `StarRatingDisplay.vue` file.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRatingDisplay.vue`文件。
- en: 'In the `<script>` part of the component, we will add a new property called `inject`.
    This property will receive an object with a key named `starRating`, and the value
    will be an object that will have a `default()` function. This function will log
    an error if this component is not a child of the `StarRating` component:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们将添加一个名为`inject`的新属性。此属性将接收一个名为`starRating`的键的对象，值将是一个具有`default()`函数的对象。如果此组件不是`StarRating`组件的子级，则此函数将记录错误：
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Open the `StarRatingInput.vue` file.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRatingInput.vue`文件。
- en: 'In the `<script>` part of the component, we will add a new property called `inject`.
    This property will receive an object with a key named `starRating`, and the value
    will be an object that will have a `default()` function. This function will log
    an error if this component is not a child of the `StarRating` component:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们将添加一个名为`inject`的新属性。此属性将接收一个名为`starRating`的键的对象，值将是一个具有`default()`函数的对象。如果此组件不是`StarRating`组件的子级，则此函数将记录错误：
- en: '[PRE41]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At runtime, Vue will check for the injected property of `starRating` in the
    `StarRatingDisplay` and `StarRatingInput` components, and if the parent component
    does not provide this value, it will log an error on the console.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，Vue将检查`StarRatingDisplay`和`StarRatingInput`组件中的`starRating`的注入属性，如果父组件未提供此值，则将在控制台上记录错误。
- en: Using component injection is commonly used to maintain a way of a common interface
    between bounded components, such as a menu and an item. An item may need some
    function or data that is stored in the menu, or we may need to check whether it's
    a child of the menu.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件注入通常用于在绑定组件之间保持共同接口的方式，例如菜单和项目。项目可能需要存储在菜单中的某些功能或数据，或者我们可能需要检查它是否是菜单的子级。
- en: The main downside of dependency injection is that there is no more reactivity
    on the shared element. Because of that, it's mostly used to share functions or
    check component links.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的主要缺点是共享元素上不再具有响应性。因此，它主要用于共享功能或检查组件链接。
- en: See also
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about component dependency injection at [https://vuejs.org/v2/guide/components-edge-cases.html#Dependency-Injection](https://vuejs.org/v2/guide/components-edge-cases.html#Dependency-Injection).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://vuejs.org/v2/guide/components-edge-cases.html#Dependency-Injection](https://vuejs.org/v2/guide/components-edge-cases.html#Dependency-Injection)找到有关组件依赖注入的更多信息。
- en: Creating a component mixin
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个组件混合
- en: There are times where you find yourself rewriting the same code over and over.
    However, there is a way to prevent this and make yourself far more productive.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您会发现自己一遍又一遍地重写相同的代码。但是，有一种方法可以防止这种情况，并使自己更加高效。
- en: You can use what is called a `mixin`, a special code import in Vue that joins
    code parts from outside your component to your current component.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用所谓的“mixin”，这是Vue中的一个特殊代码导入，它将外部代码部分连接到当前组件。
- en: Getting ready
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The pre-requisite is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件如下：
- en: Node.js 12+
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: How to do it...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To start our component, we can create our Vue project with Vue-CLI, as we did
    in the recipe '*Creating Your First Project with Vue CLI*' in [Chapter 2](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml), *Introducing
    TypeScript and the Vue Ecosystem*, or use the project from the '*Creating a dependency
    injection component*' recipe.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的组件，我们可以使用Vue-CLI创建我们的Vue项目，就像我们在[第2章](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml)中的'*使用Vue
    CLI创建您的第一个项目*'中所做的那样，或者使用'*创建依赖注入组件*'食谱中的项目。
- en: 'Let''s follow these steps to create a component mixin:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建一个组件`mixin`：
- en: Open the `StarRating.vue` component.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRating.vue`组件。
- en: 'In the `<script>` part, we need to extract the `props` property into a new
    file called `starRatingDisplay.js` that we need to create in the `mixins` folder.
    This new file will be our first `mixin`, and will look like this:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<script>`部分，我们需要将`props`属性提取到一个名为`starRatingDisplay.js`的新文件中，我们需要在`mixins`文件夹中创建这个新文件。这个新文件将是我们的第一个`mixin`，并且看起来像这样：
- en: '[PRE42]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Back in the `StarRating.vue` component, we need to import this newly created
    file and add it to a new property called `mixin`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`StarRating.vue`组件，我们需要导入这个新创建的文件，并将其添加到一个名为`mixin`的新属性中：
- en: '[PRE43]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, we will open the `StarRatingDisplay.vue` file.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将打开`StarRatingDisplay.vue`文件。
- en: 'In the `<script>` part, we will extract the `inject` property into a new file
    called `starRatingChild.js`, which will be created in the `mixins` folder. This
    will be our `mixin` for the `inject` property:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<script>`部分，我们将`inject`属性提取到一个名为`starRatingChild.js`的新文件中，该文件将被创建在`mixins`文件夹中。这将是我们`inject`属性的`mixin`：
- en: '[PRE44]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Back in the `StarRatingDisplay.vue` file, in the `<script>` part, we will extract
    the `methods` property into a new file called `starRatingName.js`, which will
    be created in the `mixins` folder. This will be our `mixin` for the `getStarName` method:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StarRatingDisplay.vue`文件中，在`<script>`部分，我们将提取`methods`属性到一个名为`starRatingName.js`的新文件中，该文件将被创建在`mixins`文件夹中。这将是我们`getStarName`方法的`mixin`：
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Back in the `StarRatingDisplay.vue` file, we need to import those newly created
    files and add them to a new property called `mixin`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`StarRatingDisplay.vue`文件，我们需要导入这些新创建的文件，并将它们添加到一个名为`mixin`的新属性中：
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Open the `StarRatingInput.vue` file.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRatingInput.vue`文件。
- en: 'In the `<script>` part, we remove the `inject` properties and extract the `props`property
    into a new file called `starRatingBase.js`, which will be created in the `mixins` folder.
    This will be our `mixin` for the `props` property:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<script>`部分，我们移除`inject`属性，并将`props`属性提取到一个名为`starRatingBase.js`的新文件中，该文件将被创建在`mixins`文件夹中。这将是我们`props`属性的`mixin`：
- en: '[PRE47]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Back in the `StarRatingInput.vue` file, we need to rename the `rating` data property to
    `rank`, and in the `getStarName` method, we need to add a new constant that will
    receive either the `rating` props or the `rank` data. Finally, we need to import
    the `starRatingChild` `mixin` and the `starRatingBase` `mixin`:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`StarRatingInput.vue`文件，我们需要将`rating`数据属性重命名为`rank`，并且在`getStarName`方法中，我们需要添加一个新的常量，该常量将接收`rating`属性或`rank`数据。最后，我们需要导入`starRatingChild`
    `mixin`和`starRatingBase` `mixin`：
- en: '[PRE48]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Mixins work as an object merge, but do make sure you don't replace an already-existing
    property in your component with an imported one.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`mixins`的工作原理就像对象合并一样，但确保不要用导入的属性替换组件中已经存在的属性。'
- en: The order of the `mixins` properties is important as well, as they will be checked
    and imported as a `for` loop, so the last `mixin` won't change any properties
    from any of their ancestors.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`mixins`属性的顺序也很重要，因为它们将被检查并作为`for`循环导入，所以最后一个`mixin`不会改变任何祖先的属性。'
- en: Here, we took a lot of repeated parts of our code and split them into four different
    small JavaScript files that are easier to maintain and improve productivity without
    needing to rewrite code.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的代码中的许多重复部分拆分成了四个不同的小JavaScript文件，这样更容易维护并提高了生产力，而无需重写代码。
- en: See also
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about mixins at [https://vuejs.org/v2/guide/mixins.html](https://vuejs.org/v2/guide/mixins.html).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://vuejs.org/v2/guide/mixins.html](https://vuejs.org/v2/guide/mixins.html)找到有关mixins的更多信息。
- en: Lazy loading your components
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惰性加载您的组件
- en: '`webpack` and Vue were born to be together. When using `webpack` as the bundler
    for your Vue project, it''s possible to make your components load when they are
    needed or asynchronously. This is commonly known as lazy loading.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack`和Vue天生就是一对。当使用`webpack`作为Vue项目的打包工具时，可以使组件在需要时或异步加载。这通常被称为惰性加载。'
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The pre-requisite is as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件如下：
- en: Node.js 12+
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: How to do it...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To start our component, we can create our Vue project with Vue-CLI, as we did
    in the '*Creating Your first project with Vue CLI*' recipe in [Chapter 2](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml), *Introducing
    TypeScript and the Vue Ecosystem*, or use the project from the '*Creating a component
    mixin*' recipe.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的组件，我们可以像在[第2章](fef91898-2101-4746-b1eb-8df0af8ac6fc.xhtml)中的'*使用Vue CLI创建您的第一个项目*'配方中那样使用Vue-CLI创建我们的Vue项目，或者使用'*创建组件mixin*'配方中的项目。
- en: 'Now, follow these steps to import your component with a lazy loading technique:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤使用惰性加载技术导入您的组件：
- en: Open the `App.vue` file.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.vue`文件。
- en: 'In the `<script>` part of the component, we will take the imports at the top
    of the script and transform them into lazy load functions for each component:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们将在脚本顶部获取导入并将它们转换为每个组件的惰性加载函数：
- en: '[PRE49]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we declare a function that returns an `import()` function for each component,
    `webpack` knows that this import function will be code-splitting, and it will
    make the component a new file on the bundle.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个为每个组件返回`import()`函数的函数时，`webpack`知道这个导入函数将进行代码拆分，并且它将使组件成为捆绑包中的一个新文件。
- en: The `import()` function was introduced as a proposal by the TC39 for module
    loading syntax. The base functionality of this function is to load any module
    that is declared asynchronously, avoiding the need to place all the files on the
    first load.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`import()`函数是由TC39提出的一个模块加载语法的建议。这个函数的基本功能是异步加载任何声明为模块的文件，避免了在第一次加载时放置所有文件的需要。'
- en: See also
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about async components at [https://vuejs.org/v2/guide/components-dynamic-async.html#Async-Components](https://vuejs.org/v2/guide/components-dynamic-async.html#Async-Components).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://vuejs.org/v2/guide/components-dynamic-async.html#Async-Components](https://vuejs.org/v2/guide/components-dynamic-async.html#Async-Components)找到有关异步组件的更多信息。
- en: You can find more information about the TC39 dynamic import at [https://github.com/tc39/proposal-dynamic-import](https://github.com/tc39/proposal-dynamic-import).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/tc39/proposal-dynamic-import](https://github.com/tc39/proposal-dynamic-import)找到有关TC39动态导入的更多信息。
