- en: '*Chapter 4*: Building a Photo Management Desktop App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：构建照片管理桌面应用程序'
- en: So far, we have only built web applications with Vue 3\. In this chapter, we
    will build a photo management desktop app with the Vue Electron plugin. We will
    learn how to easily build cross-platform desktop apps with Electron and Vue. This
    is useful because we can build cross-platform desktop apps without much additional
    effort. This will save us time and get us good results.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只构建了使用Vue 3的Web应用程序。在本章中，我们将使用Vue Electron插件构建照片管理桌面应用程序。我们将学习如何使用Electron和Vue轻松构建跨平台桌面应用程序。这很有用，因为我们可以在不费太多额外努力的情况下构建跨平台桌面应用程序。这将节省我们时间并获得良好的结果。
- en: 'In this chapter, we will focus on the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下主题：
- en: Understanding components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解组件
- en: Creating a project with Vue CLI Plugin Electron Builder
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue CLI插件Electron Builder创建项目
- en: Adding a photo submission UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加照片提交UI
- en: Adding a photo display
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加照片显示
- en: Adding routing to the Photo Manager app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为照片管理器应用程序添加路由
- en: Using our app with photo management APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的应用程序与照片管理API
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To understand this chapter, you should already know how to do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解本章，您应该已经知道如何做以下事情：
- en: Create basic Vue components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的Vue组件
- en: Create projects with the Vue CLI
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue CLI创建项目
- en: You can find all the code for this chapter at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter04](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter04).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter04](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter04)找到本章的所有代码。
- en: Understanding components
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解组件
- en: '**Components** can only have so much inside them. They take props from the
    parent component, so we can customize their behavior. Additionally, they can have
    computed properties and watchers to watch for reactive properties and return the
    data or do the things we want them to do. They can also have methods that allow
    us to do specific things with them. Components should be simple; that is, they
    should not have too much going on inside them. Templates should only have a few
    elements and components inside them in order to keep them simple. Components also
    have some built-in directives for us to manipulate the **Document Object Model**
    (**DOM**) and carry out data binding.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**内部只能有这么多东西。它们从父组件中获取props，因此我们可以定制它们的行为。此外，它们可以具有计算属性和观察者来监视响应式属性并返回数据或执行我们希望它们执行的操作。它们还可以具有允许我们对其进行特定操作的方法。组件应该简单；也就是说，它们内部不应该有太多东西。模板中应该只有少量元素和组件，以保持其简单。组件还具有一些内置指令，供我们操纵**文档对象模型**（**DOM**）并进行数据绑定。'
- en: Other than that, components cannot do much. It would be impossible to build
    anything with non-trivial complexity if we only have a few components and no way
    to navigate with URLs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，组件无法做太多事情。如果我们只有几个组件而且没有URL导航的方式，那么构建任何非平凡复杂度的东西将是不可能的。
- en: If our app only has components, then we can only nest a few of them before it
    gets too complex. Additionally, if we have lots of nested components, then the
    navigation becomes difficult. Most apps have different pages, and it's impossible
    to navigate without some kind of routing mechanism in place.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序只有组件，那么在它变得太复杂之前，我们只能嵌套其中的一些组件。此外，如果我们有大量嵌套的组件，那么导航将变得困难。大多数应用程序有不同的页面，如果没有某种路由机制，就无法进行导航。
- en: With Vue Router, we can render the components we want when we go to a given
    URL. We can also navigate to the routes with the `router-link` component provided
    by Vue Router. Vue Router has many features. It can match URLs to routes. The
    URL can have query strings and URL parameters. Additionally, we can add nested
    routes with it so that we can nest the routes inside different components. Components
    that are mapped to URLs are displayed in Vue Router's `router-view` component.
    If we have nested routes, then we need the `router-view` component in the parent
    route. This way, the child routes will be displayed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue Router，我们可以在转到特定URL时呈现我们想要的组件。我们还可以使用Vue Router提供的`router-link`组件导航到路由。Vue
    Router具有许多功能。它可以将URL与路由匹配。URL可以具有查询字符串和URL参数。此外，我们可以使用它添加嵌套路由，以便我们可以将路由嵌套在不同的组件内。映射到URL的组件显示在Vue
    Router的`router-view`组件中。如果我们有嵌套路由，那么我们需要在父路由中使用`router-view`组件。这样，子路由将被显示。
- en: To navigate to different routes, Vue Router provides a wrapper for the JavaScript
    History API, which is built into nearly all modern browsers. With this API, we
    can easily go back to a different page, go to a historical record, or go to the
    URL we want. Vue Router also supports HTML5 mode so that we can have URLs that
    don't have the hash sign to distinguish them from server-side rendered routes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导航到不同的路由，Vue Router提供了JavaScript History API的包装器，该API内置在几乎所有现代浏览器中。使用此API，我们可以轻松返回到不同的页面，转到历史记录，或者转到我们想要的URL。Vue
    Router还支持HTML5模式，以便我们可以拥有不带井号的URL，以将其与服务器端呈现的路由区分开来。
- en: Additionally, transition effects are supported, and we can see them when we
    navigate between different routes. Styles can also be applied to the links when
    the link is the one that has been navigated to and is active.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，支持过渡效果，当我们在不同路由之间导航时，我们可以看到这些效果。当链接是已导航到并且处于活动状态时，样式也可以应用于链接。
- en: Understanding Vue CLI Plugin Electron Builder
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Vue CLI插件Electron Builder
- en: We can convert JavaScript client-side web applications into desktop apps with
    Electron. Vue CLI Plugin Electron Builder enables us to add the files and settings
    to build a Vue 3 app inside a desktop app without many manual changes. Essentially,
    an Electron app is a web app that runs inside a Chromium browser wrapper that
    displays our web app. Therefore, it can do anything that we need it to do, with
    a browser. This includes some limited hardware interaction such as using microphones
    and cameras. Also, it provides some native capabilities such as displaying items
    in the notification area of popular operations systems and displaying native notifications.
    It is intended to be an easy way to build desktop apps from web apps that do not
    require low-level hardware access.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Electron将JavaScript客户端Web应用程序转换为桌面应用程序。Vue CLI插件Electron Builder使我们能够在桌面应用程序中构建Vue
    3应用程序的文件和设置，而无需进行太多手动更改。基本上，Electron应用程序是在Chromium浏览器包装器内运行的Web应用程序，它显示我们的Web应用程序。因此，它可以做任何我们需要它做的事情，使用浏览器。这包括一些有限的硬件交互，例如使用麦克风和摄像头。此外，它提供一些本机功能，例如在流行操作系统的通知区域中显示项目和显示本机通知。它旨在成为从不需要低级硬件访问的Web应用程序构建桌面应用程序的简单方法。
- en: Vue CLI Plugin Electron Builder is the fastest way to create an Electron app
    from a Vue app, as it has support for some native code. We can also include native
    modules in our code with it; we just have to include the locations of the Node.js
    modules with the native code that we want to include. Additionally, we can include
    environment variables to build our code accordingly for different environments.
    Web workers are also supported since this is supported by Chromium. We can use
    it to run background tasks so that we don't have to hold up the main browser thread
    when we want to do long-running or CPU-intensive tasks. All this can be done with
    either regular Vue app code or via configuration changes. There are also other
    things that Electron supports that are not supported with Vue CLI Plugin Electron
    Builder. This means it's more limited in its capabilities. Features such as native
    menus are not available when using this plugin. However, we can build the desktop
    app on multiple platforms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Vue CLI插件Electron Builder是从Vue应用程序创建Electron应用程序的最快方式，因为它支持一些本地代码。我们还可以在我们的代码中包含本地模块；我们只需包含我们想要包含的具有本地代码的Node.js模块的位置。此外，我们可以包含环境变量，以便根据不同的环境构建我们的代码。由于这是由Chromium支持的，因此还支持Web
    workers。我们可以使用它来运行后台任务，这样当我们想要运行长时间运行或CPU密集型任务时，就不必阻塞主浏览器线程。所有这些都可以通过常规Vue应用程序代码或通过配置更改来完成。Electron支持的其他功能也不受Vue
    CLI插件Electron Builder支持。这意味着它在功能上更有限。使用此插件时，诸如本地菜单之类的功能是不可用的。但是，我们可以在多个平台上构建桌面应用程序。
- en: In this chapter, we will build a photo manager desktop app that will run on
    Windows. The app will consist of a page to display all the photos you have added.
    Also, it will allow users to add photos and store them; it will have a form to
    enable users to add photos. The photos will be stored using our own photo storage
    mechanism. We will use Vue Router to let us navigate through the pages manually
    or automatically.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个在Windows上运行的照片管理器桌面应用程序。该应用程序将包括一个页面，用于显示您添加的所有照片。此外，它将允许用户添加照片并存储它们；它将具有一个表单，使用户能够添加照片。我们将使用Vue
    Router让我们手动或自动地浏览页面。
- en: Creating a project with Vue CLI Plugin Electron Builder
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Vue CLI插件Electron Builder创建项目
- en: 'Creating a project with Vue 3 and Vue CLI Plugin Builder is an easy task. Perform
    the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue 3和Vue CLI插件Builder创建项目是一项简单的任务。执行以下步骤：
- en: 'To create the project, create a project folder called `vue-example-ch4-photo-manager`.
    Then, go into the folder and run the following commands with `npm`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建项目，请创建一个名为`vue-example-ch4-photo-manager`的项目文件夹。然后，进入文件夹并使用`npm`运行以下命令：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can run the following commands with `yarn`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`yarn`运行以下命令：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you have run the command, you should see a menu with choices for the types
    of projects you can create.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完命令后，您应该会看到一个菜单，其中列出了您可以创建的项目类型。
- en: Pick the default **Vue 3 project** option to create a Vue 3 project. Then, add
    Vue CLI Plugin Electron Builder to our Vue app.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择默认的Vue 3项目选项来创建一个Vue 3项目。然后，将Vue CLI插件Electron Builder添加到我们的Vue应用程序中。
- en: To add the Vue CLI Electron Builder plugin, run `vue add electron-builder` in
    your project folder. Run `cd <folder path>` to navigate to the folder. All the
    files and settings will be added to the project.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加Vue CLI Electron Builder插件，请在项目文件夹中运行`vue add electron-builder`。运行`cd <folder
    path>`以导航到文件夹。所有文件和设置都将被添加到项目中。
- en: Once the command is run, we should see a couple of new things in our project.
    We now have the `background.js` file that has the code to display the Electron
    window. We also have a few new script commands added to our `package.json` file.
    The `electron:build` script command lets us build our app for production. The
    `electron:server` command lets us serve our Electron app with a development server
    so that we can develop our app with it. We are automatically provided with hot
    reload capability so that we can see all the changes live in the browser and also
    in the Electron desktop app window. Since it's just a wrapper for a browser, we
    can see the latest changes in the desktop window with our app.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，我们应该在项目中看到一些新的东西。现在我们有了 `background.js` 文件，其中包含显示 Electron 窗口的代码。我们还在
    `package.json` 文件中添加了一些新的脚本命令。`electron:build` 脚本命令允许我们为生产环境构建应用程序。`electron:server`
    命令允许我们使用开发服务器为 Electron 应用程序提供服务，以便我们可以使用它开发我们的应用程序。我们自动获得了热重载功能，以便我们可以在浏览器和 Electron
    桌面应用程序窗口中实时看到所有更改。由于它只是浏览器的包装器，我们可以在应用程序的桌面窗口中看到最新的更改。
- en: In the desktop window, we should also see the Chromium development console,
    which is the same as the one in the browser. To make debugging easier, we suggest
    looking at the browser window for debugging since we can inspect elements and
    do whatever we want to do in our development console.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面窗口中，我们还应该看到与浏览器中相同的 Chromium 开发控制台。为了使调试更容易，我们建议在浏览器窗口中进行调试，因为我们可以检查元素并在开发控制台中进行任何想要的操作。
- en: The contents of the `background.js` file can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter04/src/background.js](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter04/src/background.js).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`background.js` 文件的内容可以在 [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter04/src/background.js](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter04/src/background.js)
    找到。'
- en: The `BrowserWindow` constructor creates a browser window with a width of 800
    px and a height of 600 px, by default. We can change the window size by dragging
    the window as we would do with other desktop apps. The `win.loadURL()` method
    loads the home page for our app, which is the `index.html` file. The `index.html`
    file is in the `dist-electron` folder. Otherwise, we call the `win.loadURL()`
    method to load the `webpack-dev-server` URL in order to see the app in a window
    in the development environment. This is because `webpack-dev-server` only loads
    the app in memory when it is run in the development environment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrowserWindow` 构造函数默认创建一个宽度为 800 像素，高度为 600 像素的浏览器窗口。我们可以通过拖动窗口来改变窗口大小，就像我们在其他桌面应用程序中所做的那样。`win.loadURL()`
    方法加载我们应用的主页，也就是 `index.html` 文件。`index.html` 文件位于 `dist-electron` 文件夹中。否则，我们调用
    `win.loadURL()` 方法来加载 `webpack-dev-server` 的 URL，以便在开发环境中在窗口中查看应用程序。这是因为 `webpack-dev-server`
    只在开发环境中运行时才将应用程序加载到内存中。'
- en: The `win.webContents.openDevTools()` method opens the Chromium development console
    in the development environment. The `app.quit()` method exits the desktop app.
    We listen to the message event when it is running under Windows, as indicated
    by the `process.platform === 'win32'` expression. Otherwise, Electron listens
    to the SIGTERM event and closes the window when that is emitted. The SIGTERM event
    is emitted when we end a program.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`win.webContents.openDevTools()` 方法在开发环境中打开 Chromium 开发控制台。`app.quit()` 方法退出桌面应用程序。当程序在
    Windows 下运行时，我们监听消息事件，如 `process.platform === ''win32''` 表达式所示。否则，Electron 监听
    SIGTERM 事件，并在发出该事件时关闭窗口。当我们结束程序时，将发出 SIGTERM 事件。'
- en: 'To change the title of the window, we just change the `title` tag in the `public/index.html`
    file. For example, we can write the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改窗口的标题，我们只需更改 `public/index.html` 文件中的 `title` 标签。例如，我们可以写如下内容：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We just change the `title` tag's content to what we want, and the text will
    be displayed as the title of the window.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将`title`标签的内容更改为我们想要的内容，文本就会显示为窗口的标题。
- en: 'Then, once we run the `vue add electron-builder` command, we get the files
    and settings added. To start the development server and display the Electron app
    on our screen, we run the `yarn electron:serve` or `npm run electron:serve` commands,
    which are provided by Vue CLI Plugin Electron Builder. You should see a window
    display on the screen (please refer to *Figure 4.1*). This will automatically
    refresh when we make any changes to the existing files or if we add or remove
    files. Now we are almost ready to start building our app:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦我们运行`vue add electron-builder`命令，我们就会添加文件和设置。要启动开发服务器并在屏幕上显示 Electron 应用程序，我们运行`yarn
    electron:serve`或`npm run electron:serve`命令，这些命令由 Vue CLI 插件 Electron Builder 提供。您应该在屏幕上看到一个窗口显示（请参阅*图
    4.1*）。当我们对现有文件进行任何更改或添加或删除文件时，它将自动刷新。现在我们几乎准备好开始构建我们的应用程序了：
- en: '![Figure 4.1 – The Electron app window'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – Electron 应用程序窗口'
- en: '](image/Figure_4.1_B14405.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.1_B14405.jpg)'
- en: Figure 4.1 – The Electron app window
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Electron 应用程序窗口
- en: We will install a few packages that we need to use in our Vue app and the Vue
    Router library to add routing to our app. We will use it for the router links
    and to also navigate programmatically. We will also use the Axios HTTP client
    to make HTTP requests easily to our API. To install the packages, we can run the
    `npm install axios vue-router@4.0.0-beta.9` or `yarn add axios vue-router@4.0.0-beta.9`
    commands.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装一些我们在 Vue 应用程序中需要使用的包，以及 Vue Router 库以向我们的应用程序添加路由。我们将用它来进行路由链接，也可以通过编程方式进行导航。我们还将使用
    Axios HTTP 客户端轻松地向我们的 API 发送 HTTP 请求。要安装这些包，我们可以运行`npm install axios vue-router@4.0.0-beta.9`或`yarn
    add axios vue-router@4.0.0-beta.9`命令。
- en: We install Axios so that we can make HTTP requests conveniently. Now we are
    ready to build our app.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装 Axios，这样我们就可以方便地进行 HTTP 请求。现在我们准备构建我们的应用程序。
- en: Adding a photo submission UI
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加照片提交界面
- en: To build the app, we will first add our components and the file to store the
    constants that we will need throughout the app. To start with, we get rid of the
    `components/HelloWorld.vue` file. Then, we remove any references of it in the
    `App.vue` file, including the `import` and `components` properties to unregister
    the component. Now we will add some new components to our app.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建应用程序，我们首先将添加我们的组件和文件以存储我们在整个应用程序中需要的常量。首先，我们删除`components/HelloWorld.vue`文件。然后，我们删除`App.vue`文件中对它的任何引用，包括`import`和`components`属性以注销该组件。现在我们将向我们的应用程序添加一些新组件。
- en: 'First, we add the `PhotoFormPage.vue` component file to the `src/components`
    folder. Inside the file, we add the following template:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`PhotoFormPage.vue`组件文件添加到`src/components`文件夹中。在文件中，我们添加以下模板：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This template has the inputs for adding and editing photos. `name` and `description`
    are text inputs. The `Date Taken` field is a date input.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板具有用于添加和编辑照片的输入。`name`和`description`是文本输入。`Date Taken`字段是日期输入。
- en: 'Then, we add the photo field as a file input:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将照片字段添加为文件输入：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will read the selected file into a base64 string so that we can save the
    data easily using an HTTP request. We also use the base64 string to preview the
    image in the `img` element.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选定的文件读入 base64 字符串，以便我们可以使用 HTTP 请求轻松保存数据。我们还使用 base64 字符串在`img`元素中预览图像。
- en: 'Then, we add the `script` tag to `PhotoFormPage.vue`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`script`标签添加到`PhotoFormPage.vue`中：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This determines whether we are editing an existing photo or creating a new one
    by checking whether the `id` parameter is set. If it is, then we are editing.
    Otherwise, we are creating a new photo. This logic is used in the `submit` method
    and the `beforeMount` hook.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查`id`参数是否设置，确定我们是编辑现有照片还是创建新照片。如果设置了，那么我们正在编辑。否则，我们正在创建新照片。这个逻辑在`submit`方法和`beforeMount`钩子中使用。
- en: 'The `submit()` method''s `id` is used to make an HTTP request to the API to
    save the entry. We get the `id` parameter from the route by writing the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit()`方法的`id`用于向API发出HTTP请求以保存条目。我们通过编写以下内容从路由中获取`id`参数：'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, we add an `if` statement immediately below that to check whether it is
    set. If it is set, we make a *PUT* request to update an existing entry. Otherwise,
    we make a *POST* request to create a new entry.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在下面立即添加一个`if`语句来检查它是否设置。如果设置了，我们将发出*PUT*请求来更新现有条目。否则，我们将发出*POST*请求来创建新条目。
- en: In this component, we have a form that allows us to add and edit the photos
    in our app. We display the **Add** or **Edit** text depending on the value of
    the `edit` prop. Then, we have a form with a bunch of fields in it. The `form`
    element has the submit event listener that runs the `submit()` method when we
    click on the **Submit** **input** button. The `prevent` modifier runs the `event.preventDefault()`
    method without us having to add it ourselves inside the `submit` handler. We need
    this since we don't want the browser to execute the default `submit` behavior,
    which will submit our form data to the server directly. We want to process the
    data on the client side with our own client-side code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，我们有一个表单，允许我们在应用程序中添加和编辑照片。根据`edit`属性的值，我们显示**添加**或**编辑**文本。然后，我们有一个包含许多字段的表单。`form`元素具有提交事件侦听器，当我们点击**提交**`input`按钮时运行`submit()`方法。`prevent`修饰符在`submit`处理程序内部自动运行`event.preventDefault()`方法，我们不需要自己添加。我们需要这样做，因为我们不希望浏览器执行默认的`submit`行为，这会直接将我们的表单数据提交到服务器。我们希望使用我们自己的客户端代码在客户端处理数据。
- en: In this project, we won't create our own API and we won't do any data validation
    on the server side.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们不会创建自己的API，也不会在服务器端进行任何数据验证。
- en: Also, the modifier saves us from typing it in and also makes our code shorter.
    The directive syntax is common enough that there is a symbol for it. The `@` symbol
    can also be replaced with the `v-on` directive since `@` is the shorthand for
    the `v-on` directive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，修饰符使我们不必自己输入它，也使我们的代码更短。指令语法足够常见，有一个符号代表它。`@`符号也可以替换为`v-on`指令，因为`@`是`v-on`指令的简写。
- en: Inside the `form` tag, we have the `input` elements with the `v-model` directive
    that binds to various properties of the `form` reactive property. The `label`
    HTML element is the label of each input. The `label` has the `for` attribute,
    which allows it to map the label to the `id` parameter of the `input` element.
    This is good for accessibility since screen readers will pick it up and read it
    to the user. This is very helpful for visually impaired users of our app. We will
    use very similar code in the `textarea` tag.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`form`标签内部，我们有带有`v-model`指令的`input`元素，它绑定到`form`响应属性的各种属性。`label` HTML元素是每个输入的标签。`label`具有`for`属性，允许它将标签映射到`input`元素的`id`参数。这对于辅助功能很有用，因为屏幕阅读器会捕捉并向用户朗读它。这对我们应用程序的视障用户非常有帮助。我们将在`textarea`标签中使用非常相似的代码。
- en: The date and time picker is a native date and time picker that is created by
    setting the `type` attribute to `datetime-local`. This enables us to add a date
    and time picker that is set to the time zone of your device. Then, we set the
    `v-model` directive to bind the date and time picker value to the one that the
    user picked in the browser or desktop app window. Most modern browsers support
    this type of input, so we can use this to enable users to pick the date and time.
    The `type` attribute can also be set to `date` to add a date picker only. Additionally,
    we can set the type to `datetime` to add a date and time picker that is set to
    UTC.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间选择器是通过将`type`属性设置为`datetime-local`创建的本机日期和时间选择器。这使我们能够添加一个日期和时间选择器，该选择器设置为设备的时区。然后，我们将`v-model`指令设置为将日期和时间选择器的值绑定到用户在浏览器或桌面应用程序窗口中选择的值。大多数现代浏览器都支持这种类型的输入，因此我们可以使用它来使用户选择日期和时间。`type`属性也可以设置为`date`以添加仅日期选择器。此外，我们可以将类型设置为`datetime`以添加设置为UTC的日期和时间选择器。
- en: The `file` input is more complex. The input's `type` attribute is set to `file`
    so that we can see a file input. Additionally, it has a change event listener
    that runs the `onChange()` method to convert the binary image file into a base64
    string. This saves the image to our API as a text string. For a small app, such
    as this photo management app, we can save images directly as a string.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`输入更复杂。输入的`type`属性设置为`file`，以便我们可以看到文件输入。此外，它具有一个change事件监听器，运行`onChange()`方法将二进制图像文件转换为base64字符串。这将图像保存到我们的API中作为文本字符串。对于像这样的小型应用程序，我们可以直接将图像保存为字符串。'
- en: However, if we were building a production-quality app with lots of users using
    the app and making lots of file uploads, then it would be a good idea to save
    the files in a third-party storage service, such as Dropbox or Amazon S3\. Then,
    we could just get the files from the URL instead of as a base64 string. The HTTP
    URL and the base64 URL are equivalent. We can set both as the value of the `src`
    attribute of the `img` tag to display the image. In this case, we set the `src`
    attribute to the base64 URL in the `img` tag inside our form element.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们正在构建一个具有大量用户使用应用程序并进行大量文件上传的生产质量应用程序，那么将文件保存在第三方存储服务中，如Dropbox或Amazon
    S3，将是一个好主意。然后，我们可以从URL中获取文件，而不是作为base64字符串。HTTP URL和base64 URL是等效的。我们可以将两者都设置为`img`标签的`src`属性的值以显示图像。在这种情况下，我们将`src`属性设置为`img`标签中的base64
    URL。
- en: At the bottom of our form, we have the input with the `type` attribute set to
    `submit`. This allows us to submit the input by pressing *Enter* on a form input
    element or clicking on the **Submit input** button.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单底部，我们有一个`type`属性设置为`submit`的输入。这允许我们通过在表单输入元素上按*Enter*或单击**提交输入**按钮来提交输入。
- en: Next, we add the `data()` method. This returns the initial values of the `form`
    reactive property. The `form` reactive property includes the `name`, `description`,
    `dateTaken`, and `photoFile` properties. The `name` property is the name of our
    photo. The `description` property is the description of our photo. The `dateTaken`
    property has a string with the date and time that the photo was taken at. And
    the `photoFile` property is the base64 string representation of the photo file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加`data()`方法。这将返回`form`响应属性的初始值。`form`响应属性包括`name`、`description`、`dateTaken`和`photoFile`属性。`name`属性是我们照片的名称。`description`属性是我们照片的描述。`dateTaken`属性包含拍摄照片的日期和时间的字符串。`photoFile`属性是照片文件的base64字符串表示。
- en: Next, we have a few methods in this component. First, we have the `submit()`
    method that either makes a *PUT* request, to update an existing photo entry, or
    a *POST* request, to create a new photo entry. Before we make any HTTP requests,
    we check whether all the properties of the `this.form` reactive property are populated
    with non-falsy values. We want all the fields to be filled in. If there is a false
    value that has been set as the value of any of the properties, then we show an
    alert that tells the user to fill in all the fields.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在这个组件中有一些方法。首先，我们有`submit()`方法，它可以进行*PUT*请求，更新现有的照片条目，或者进行*POST*请求，创建新的照片条目。在进行任何HTTP请求之前，我们检查`this.form`响应式属性的所有属性是否都填充了非假值。我们希望所有字段都填写完整。如果有任何属性的值被设置为假值，那么我们会显示一个警报，告诉用户填写所有字段。
- en: To make the process of getting the properties shorter, we destructure the properties
    of the `this.form` reactive property and then carry out a check. After that, we
    check whether the `edit` prop is `true`. If it is, then we use the *PUT* request
    to update an existing entry. The `id` prop is set to the `$route.params.id` value
    so that we get the value of the ID URL parameter from the URL.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使获取属性的过程更简短，我们解构了`this.form`响应式属性的属性，然后进行检查。之后，我们检查`edit`属性是否为`true`。如果是，则使用*PUT*请求来更新现有条目。`id`属性设置为`$route.params.id`的值，以便从URL中获取ID
    URL参数的值。
- en: 'If the `edit` reactive property is `true`, then we make a *PUT* request to
    our API to update an existing photo entry. To make the *PUT* request, we call
    the `axios.put()` method. This takes the URL as the first argument and an object
    with the request body content as the second argument. Otherwise, we call `axios.post()`
    with the same arguments to make a *POST* request to create a new photo entry.
    The URL of the *PUT* request has the ID of the photo entry attached to the end
    of it so that the API can identify which entry to update:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`edit`响应式属性为`true`，那么我们会向我们的API发出*PUT*请求，以更新现有的照片条目。为了进行*PUT*请求，我们调用`axios.put()`方法。这将URL作为第一个参数，并将请求体内容作为第二个参数的对象。否则，我们调用`axios.post()`，使用相同的参数进行*POST*请求，以创建新的照片条目。*PUT*请求的URL末尾附加了照片条目的ID，以便API可以识别要更新的条目：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have also defined the `onChange()` method to be used as the change event
    listener for the file input. When we select a file, this method is run. In the
    method body, we create a new `FileReader` instance to read the selected image
    file into a base64 string. The parameter has an event object, which has the file
    that we selected. The `ev.target.files` property is an array-like object with
    the selected files. Since we only allow the user to select one file, we can use
    the `0` property to get the first file. `0` is a property name and not an index
    since the `files` property is an array-like object; that is, it just looks like
    an array but doesn't act like it. However, it is an iterative object, so we can
    use the `for-of` loop or the `spread` operator to loop through the items or convert
    them into an array.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了`onChange()`方法，用作文件输入的更改事件监听器。当我们选择一个文件时，将运行此方法。在方法体中，我们创建一个新的`FileReader`实例，将所选的图像文件读入base64字符串。参数中有一个事件对象，其中包含我们选择的文件。`ev.target.files`属性是一个类似数组的对象，其中包含所选的文件。由于我们只允许用户选择一个文件，因此我们可以使用`0`属性来获取第一个文件。`0`是一个属性名，而不是索引，因为`files`属性是一个类似数组的对象；也就是说，它看起来像一个数组，但不像一个数组。但是，它是一个可迭代的对象，因此我们可以使用`for-of`循环或`spread`运算符来循环遍历项目或将它们转换为数组。
- en: To read the selected file into a base64 string, we call the `reader.readAsDataURL`
    method with the file object as the argument to read the file into a base64 string.
    Then, we get the result by listening to the load event emitted by the `reader`
    object. We do this by setting an event handler as the value of the `onload` property.
    The result that is read is inside the `result` property. It is set to the `this.form.photoFile`
    property so that we can display the image in the `img` tag below our file input
    and also store it in our database after we submit it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所选文件读入base64字符串，我们使用文件对象调用`reader.readAsDataURL`方法来将文件读入base64字符串。然后，我们通过监听`reader`对象发出的load事件来获取结果。我们通过将事件处理程序设置为`onload`属性的值来实现这一点。读取的结果在`result`属性中。它设置为`this.form.photoFile`属性，以便我们可以在文件输入下面的`img`标签中显示图像，并在提交后将其存储在我们的数据库中。
- en: Then, we add some code to the `beforeMount` hook. We check for the value of
    the `this.edit` prop and then get the photo entry from our API if the value of
    the `this.edit` prop is `true`. We only need to check when we are mounting this
    component since we are using this component in a `route` component. Additionally,
    a `route` component is mounted when we go to a URL that maps to the component.
    When we go to another URL, the component will be unmounted. Therefore, we won't
    need a watcher to watch for the values of the `edit` or `id` props. We set the
    retrieved data to the `form` reactive property so that the user can see the data
    in the form fields and edit them as they wish.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`beforeMount`钩子中添加一些代码。我们检查`this.edit`属性的值，如果`this.edit`属性的值为`true`，则从我们的API中获取照片条目。我们只需要在挂载此组件时进行检查，因为我们在`route`组件中使用此组件。另外，当我们转到映射到该组件的URL时，`route`组件会被挂载。当我们转到另一个URL时，该组件将被卸载。因此，我们不需要监视器来监视`edit`或`id`属性的值。我们将检索到的数据设置为`form`响应属性，以便用户可以在表单字段中看到数据并根据需要进行编辑。
- en: The `axios.post()`, `axios.put()`, and `axios.get()` methods all return a promise
    that resolves to the response data as its resolved value. The `data` property
    has the response data. Therefore, we can use the `async` or `await` syntax to
    make our promise code shorter, just as we did in the entire component.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`axios.post()`，`axios.put()`和`axios.get()`方法都返回一个解析为响应数据的promise。`data`属性具有响应数据。因此，我们可以使用`async`或`await`语法来使我们的promise代码更简洁，就像我们在整个组件中所做的那样。'
- en: 'In the `style` tag, we have several styles that we can use to style our form.
    We display the form closer to the center of the screen by adding a `margin` property
    and setting it to `0 auto` in our `form` class. The width is set to `70vw` so
    that it is set to take up only 70 percent of the viewport width instead of the
    entire width. The `form-field` class has the `width` property set to 100 percent
    so that the form fields fill up the entire width of the form. Otherwise, they
    will be displayed at the default width, which is very short. The `photo-preview`
    ID is assigned to the `img` tag that we use for the preview. And we set the `width`
    property of it to `200px` so that we only show a thumbnail preview of the image:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`style`标签中，我们有几种样式可以用来设置表单的样式。我们通过在`form`类中添加`margin`属性并将其设置为`0 auto`来将表单显示在屏幕中心附近。宽度设置为`70vw`，这样它只占视口宽度的70％，而不是整个宽度。`form-field`类的`width`属性设置为100％，以便表单字段填满整个表单的宽度。否则，它们将显示为默认宽度，非常短。`photo-preview`
    ID分配给我们用于预览的`img`标签。我们将其`width`属性设置为`200px`，这样我们只显示图像的缩略图预览。
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this file, we make requests that allow us to edit or delete the photo entry.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们发出请求，允许我们编辑或删除照片条目。
- en: 'Next, we create a component for our home page. We will create a `HomePage.vue`
    file in the `src/components` folder and write the following code in it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的主页创建一个组件。我们将在`src/components`文件夹中创建一个`HomePage.vue`文件，并在其中编写以下代码：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This file is more complex than the components we previously created. In the
    `component options` object, we have the `data()` method that returns the initial
    values for our reactive properties. We only have one in this component to hold
    the photos. The `photos` reactive property will have the files. In the `methods`
    property, we have a few methods that can be used to populate the reactive properties.
    The `load` method uses the `axios.get()` method to get the data from the `photos`
    endpoint. `APIURL` is from the `constants.js` file, which we will create later.
    It simply has a string with the base URL for the endpoints, to which we can make
    HTTP requests.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件比我们之前创建的组件更复杂。在`component options`对象中，我们有一个`data()`方法，返回我们响应属性的初始值。在这个组件中，我们只有一个用于保存照片的响应属性。`photos`响应属性将具有文件。在`methods`属性中，我们有一些方法，用于填充响应属性。`load`方法使用`axios.get()`方法从`photos`端点获取数据。`APIURL`来自我们稍后将创建的`constants.js`文件。它只是一个包含端点基本URL的字符串，我们可以向其发出HTTP请求。
- en: The `axios.get()` method returns a promise that resolves to an object. The object
    has the HTTP request. The `data` property has the response body. We assign the
    body data to the `this.photos` reactive property to show the photo entries in
    the template.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`axios.get()`方法返回一个解析为对象的promise。该对象具有HTTP请求。`data`属性具有响应主体。我们将主体数据分配给`this.photos`响应属性，以在模板中显示照片条目。'
- en: 'The following code is for retrieving the photo:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于检索照片：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `edit()` method calls the `this.$router.push()` method with an object that
    has the URL path that we want to go to. Additionally, the `path` property has
    the base path for the route we want to go to plus the URL parameters that we want
    to add to the end of the path. The `id` parameter is a URL parameter that we attach
    to the path. It has the ID of the photo entry:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit()`方法调用`this.$router.push()`方法，并带有我们要转到的URL路径的对象。此外，`path`属性具有我们要转到的路由的基本路径以及我们要添加到路径末尾的URL参数。`id`参数是我们附加到路径的URL参数。它具有照片条目的ID：'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `deletePhoto()` method also takes the `id` parameter. It is the same one
    as the parameter of the `edit()` method. In this method, we call the `axios.delete()`
    method to make a *DELETE* request to the `photos` endpoint with the `id` parameter,
    which was used as the URL parameter, to identify which entry to delete. Once the
    item has been deleted, we call the `this.load()` method to reload the latest entries
    from the API:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`deletePhoto()`方法也接受`id`参数。它与`edit()`方法的参数相同。在此方法中，我们调用`axios.delete()`方法，向`photos`端点发出*DELETE*请求，并使用`id`参数作为URL参数，以标识要删除的条目。一旦项目被删除，我们调用`this.load()`方法从API重新加载最新条目：'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `template` section, we use the `v-for` directive to render the entries
    of the `photos` reactive property array into a table. The `key` prop is required
    to identify unique items with a unique ID. The `key` prop is very important since
    we are going to remove items from the list when the user clicks on the **Delete**
    button. This means that each entry must have a unique ID so that Vue 3 can identify
    all of the items after we delete one item properly. This is so that the latest
    items can render correctly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`template`部分，我们使用`v-for`指令将`photos`响应属性数组的条目呈现为表格。`key`属性是必需的，用于识别具有唯一ID的唯一项目。`key`属性非常重要，因为当用户单击**删除**按钮时，我们将从列表中删除项目。这意味着每个条目必须具有唯一的ID，以便Vue
    3在我们正确删除一个项目后能够正确识别所有项目。这样最新的项目才能正确呈现。
- en: 'We render the photos using a `v-for` loop:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`v-for`循环渲染照片：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To render the image, we use the `img` tag with the `src` prop. The `photoFile`
    property is a base64 URL that has the text form of the image. The other properties
    are strings that we render directly in our table. In the rightmost column, we
    have two buttons – **Edit** and **Delete**. The **Edit** button calls `edit()`
    with the `id` property of the photo entry when we click on it. This will navigate
    us to the photo edit form, which we will create later. The **Delete** button will
    call the `deletePhoto()` method with the `id` property of the photo entry to delete.
    The items will be reloaded once the items are deleted:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染图像，我们使用具有`src`属性的`img`标签。`photoFile`属性是图像的文本形式的base64 URL。其他属性是我们直接在表格中呈现的字符串。在最右侧的列中，我们有两个按钮
    - **编辑**和**删除**。**编辑**按钮在点击时调用`edit()`，并传递照片条目的`id`属性。这将导航我们到稍后将创建的照片编辑表单。**删除**按钮将调用`deletePhoto()`方法，并传递照片条目的`id`属性以进行删除。项目将在删除项目后重新加载：
- en: '![Figure 4.2 – The Edit and Delete buttons'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 - 编辑和删除按钮'
- en: '](image/Figure_4.2_B14405.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.2_B14405.jpg)'
- en: Figure 4.2 – The Edit and Delete buttons
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - 编辑和删除按钮
- en: In the `style` tag, we have some CSS to display `div` tags as a table. The `row`
    class has the `display` property set to `flex` so that we can use it as a `flexbox`
    container. The `flex-wrap` property is set to `wrap` so that we can wrap anything
    that overflows. Usually, we won't have anything that overflows in this template.
    `justify-content` is set to `space-between` in order to evenly distribute the
    child elements in the `flexbox` container.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`style`标签中，我们有一些CSS来将`div`标签显示为表格。`row`类具有`display`属性设置为`flex`，以便我们可以将其用作`flexbox`容器。`flex-wrap`属性设置为`wrap`，以便我们可以包裹任何溢出的内容。通常，在这个模板中我们不会有任何溢出的内容。`justify-content`设置为`space-between`，以便在`flexbox`容器中均匀分布子元素。
- en: The `div` tags inside the `div` tag with the `row` class have the `width` property
    set to `25%` so that we can evenly distribute the child elements in the row. This
    allows us to display the four `div` tags inside the `div` tag for the row side
    by side. The `img` element inside the `div` tag with the `row` class has the `width`
    property set to `100px` so that we can view a small thumbnail preview in the list
    of photos.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`row`类中的`div`标签具有`width`属性设置为`25%`，以便我们可以均匀分布行中的子元素。这允许我们将行内的四个`div`标签并排显示。`row`类中的`div`标签内的`img`元素具有`width`属性设置为`100px`，以便我们可以在照片列表中查看小缩略图预览。'
- en: 'The `style` tag has the `scoped` attribute, which means that the styles won''t
    affect any other components in our project:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`style`标签具有`scoped`属性，这意味着样式不会影响我们项目中的其他组件：'
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we create a navigation bar in our app. To do that, we go into the `src/components`
    folder and add the `NavBar.vue` component file. Once we have created the file,
    we can add the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的应用程序中创建一个导航栏。为此，我们进入`src/components`文件夹，并添加`NavBar.vue`组件文件。创建文件后，我们可以添加以下代码：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we added a `ul` element to add an unordered list. This way, we won't see
    any numbers displayed on the left of each `li` element. Inside the `li` elements,
    we have the `router-link` component from Vue Router to display the links that
    allow us to navigate our app. We use `router-link` instead of a regular `a` tag.
    This is because Vue Router will resolve the `to` prop of the `router-link` component
    to the correct path and display the component we expect if it finds a match in
    the URL patterns.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个`ul`元素来添加一个无序列表。这样，我们就不会在每个`li`元素的左边看到任何数字显示。在`li`元素内部，我们有来自Vue Router的`router-link`组件，用于显示允许我们导航应用程序的链接。我们使用`router-link`而不是常规的`a`标签。这是因为Vue
    Router将解析`router-link`组件的`to`属性，以正确的路径显示我们期望的组件，如果在URL模式中找到匹配的话。
- en: Since we haven't registered the Vue Router plugin or any of the routes yet,
    or added `NavBar` to any component, we won't see anything in the navigation bar.
    The `style` tag has some styles that can make the links display horizontally instead
    of vertically.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未注册Vue Router插件或任何路由，也没有将`NavBar`添加到任何组件中，因此在导航栏中看不到任何内容。`style`标签具有一些样式，可以使链接水平显示而不是垂直显示。
- en: 'Additionally, we have a **Log Out** link to log us out of the app. The `logout()`
    method clears the local storage with the `localStorage.clear()` method. Then,
    we redirect back to the login page by calling the `this.$router.push()` method
    with the `/login` path:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有一个**登出**链接，用于退出应用。`logout()`方法使用`localStorage.clear()`方法清除本地存储。然后，通过调用`this.$router.push()`方法并使用`/login`路径重定向回登录页面：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `ul` `li` selector has the `list-style` property set to `none`, so we don't
    see the bullet displayed to the left of the `NavBar` item. We display them horizontally
    with the `display` property set to `inline`. Then, we add the `margin-right` property
    and set it to `10px` so that we have some spaces between the links.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ul` `li`选择器将`list-style`属性设置为`none`，这样我们就看不到`NavBar`项目左侧显示的项目符号。我们使用`display`属性将它们水平显示为`inline`。然后，我们添加`margin-right`属性并将其设置为`10px`，这样我们在链接之间有一些空间。'
- en: 'The `ul` selector has the `margin` property set to `0 auto`, so we can center
    the links horizontally. The `width` is `70vw` so that they are closer to the center
    of the screen instead of putting the items on the left:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`ul`选择器将`margin`属性设置为`0 auto`，这样我们可以水平居中链接。`width`为`70vw`，这样它们就更靠近屏幕中心，而不是将项目放在左边。'
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have finished the form that allows us to save our photos, let's
    take a look at how to display the added photos on a page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了允许我们保存照片的表单，让我们看看如何在页面上显示添加的照片。
- en: Adding a photo display
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加照片显示
- en: Here, we add a search page so that we can search for photo entries using their
    names. To do that, we add the `SearchPage.vue` component file to our project's
    `src/components` folder.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个搜索页面，以便可以通过名称搜索照片条目。为此，我们将`SearchPage.vue`组件文件添加到项目的`src/components`文件夹中。
- en: 'The `SearchPage.vue` component is simpler than the `PhotoForm` component. It
    has one form element with one form field. The form field is used to accept a keyword
    from the user to search our photo collection. The input has the `type` attribute
    set to `text`, so we have a regular text input in our code. As with the other
    inputs, we bind the input value to a reactive property with the `v-model` directive.
    The `id` parameter is set so that we can use the `for` attribute with the label.
    The form also has a **Search** button, which has an `input` type set to `submit`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchPage.vue`组件比`PhotoForm`组件简单。它有一个表单元素和一个表单字段。表单字段用于接受用户的关键字来搜索我们的照片集。输入的`type`属性设置为`text`，因此我们的代码中有一个常规文本输入。与其他输入一样，我们使用`v-model`指令将输入值绑定到一个响应式属性。设置`id`参数，以便我们可以在标签中使用`for`属性。表单还有一个**搜索**按钮，其`input`类型设置为`submit`：'
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, the search results are displayed in a `row` class so that the items are
    in rows. This is similar to how we display the photos in the `HomePage` component.
    `img` has the base64 URL set as the value of the `src` prop. Additionally, we
    have the `name` and `description` properties to the right of it. The `v-for` directive
    loops through the `photos` reactive property array to enable us to display the
    data. Once again, we have the `key` prop set to a unique ID to display the items
    by their IDs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，搜索结果以`row`类显示，使项目按行排列。这类似于我们在`HomePage`组件中显示照片的方式。`img`的base64 URL设置为`src`属性的值。此外，我们在其右侧有`name`和`description`属性。`v-for`指令循环遍历`photos`响应式属性数组，使我们能够显示数据。再次，我们将`key`属性设置为唯一ID，以便按ID显示项目。
- en: 'In the `component options` object, we use the `data()` method to initialize
    our reactive properties. They include `keyword` and `photos`. The `keyword` reactive
    property is used for the search keyword. The `photos` reactive property is used
    to store the photo collection search results:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`component options`对象中，我们使用`data()`方法来初始化我们的响应式属性。它们包括`keyword`和`photos`。`keyword`响应式属性用于搜索关键字。`photos`响应式属性用于存储照片集搜索结果：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `methods` property, we have a few methods that we can use. The `search()`
    method allows us to get the data with the `axios.get()` method. This method makes
    a *GET* request with a query string, so we can get the entries we are looking
    for. The `this.$route.query.q` property is used to get the `q` query parameter
    from the URL. This property is made available because we will register the Vue
    Router plugin so that we can get the `query` parameter from this property. Once
    we get the response data, we assign it to the `this.photos` reactive property.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`methods`属性中，我们有一些可以使用的方法。`search()`方法允许我们使用`axios.get()`方法获取数据。这个方法使用查询字符串发出*GET*请求，因此我们可以获取我们正在寻找的条目。`this.$route.query.q`属性用于从URL中获取`q`查询参数。这个属性是可用的，因为我们将注册Vue
    Router插件，以便我们可以从这个属性获取`query`参数。一旦我们获取了响应数据，我们就将其分配给`this.photos`响应式属性。
- en: The `submit()` method is run when the form is being submitted, either by clicking
    on the **Search** button or pressing *Enter*. Since we listen to the `submit`
    event in the form, this method will be run. Like with all the other forms, we
    add the `prevent` modifier to the `@submit` directive. This is so that we can
    call to the `event.preventDefault()` method to prevent data from being submitted
    to the server side. In this method, we call the `this.$router.push()` method to
    redirect the page to the `/search` path with a query string. The `/search` path
    will be mapped to the current component, so we just remount this component with
    the new query string in the URL. This way, we can set the `this.$router.query.
    q` property to get the query string parameter with the key to get the query string
    value and use it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit()`方法在表单提交时运行，无论是点击**搜索**按钮还是按下*Enter*键。由于我们监听表单中的`submit`事件，这个方法将被运行。和其他表单一样，我们在`@submit`指令中添加了`prevent`修饰符。这样我们就可以调用`event.preventDefault()`方法来阻止数据被提交到服务器端。在这个方法中，我们调用`this.$router.push()`方法将页面重定向到带有查询字符串的`/search`路径。`/search`路径将映射到当前组件，因此我们只需使用URL中的新查询字符串重新挂载这个组件。这样，我们就可以设置`this.$router.query.q`属性来获取带有键的查询字符串参数，以获取查询字符串的值并使用它。'
- en: The `name_like` URL query parameter will be picked up by the API so that we
    can search for the text that we set as the value in the `name` field.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`name_like` URL查询参数将被API捕获，这样我们就可以搜索我们在`name`字段中设置为值的文本。'
- en: Finally, we have a watcher for the `$route` reactive property. We need to set
    the `immediate` property to `true` so that we get the latest value of the `query`
    parameter, and then run the `search()` method to get the data from the *GET* request
    when this component mounts. The `handler()` method has a method that runs when
    the `$route` object changes. The changes to the `query` property will be picked
    up. Therefore, inside the method, we set the `keyword` reactive property to the
    value of `this.$route.query.q` to display the latest value of the `q` query string
    in the input box. Additionally, we call the `this.search()` method to get the
    latest search results based on the query string.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为`$route`响应式属性设置了一个监视器。我们需要将`immediate`属性设置为`true`，这样我们才能获取`query`参数的最新值，然后运行`search()`方法来从*GET*请求中获取数据，当这个组件挂载时。`handler()`方法有一个在`$route`对象改变时运行的方法。`query`属性的更改将被捕获。因此，在方法内部，我们将`keyword`响应式属性设置为`this.$route.query.q`的值，以显示输入框中`q`查询字符串的最新值。另外，我们调用`this.search()`方法，根据查询字符串获取最新的搜索结果。
- en: 'The `styles` tag has some styles that we can use to style our form and rows.
    They are similar to the ones we had before. We make the form fields wide and display
    the form closer to the center. The rows are displayed with a flexbox container
    with all of the cells having an even width within the rows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`styles`标签中有一些样式，我们可以用它们来为我们的表单和行设置样式。它们与我们以前使用的样式类似。我们使表单字段变宽，并将表单显示在靠近中心的位置。行以flexbox容器显示，行内的所有单元格宽度均匀：'
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we need to create a file to export an `APIURL` variable so that the
    components can reference them. We have used these in most of the components we
    have created so far. In the `src` folder, we create the `constants.js` file and
    write the following code to export the `APIURL` variable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个文件来导出一个`APIURL`变量，以便组件可以引用它们。到目前为止，我们在大多数已创建的组件中都使用了这些。在`src`文件夹中，我们创建`constants.js`文件，并编写以下代码来导出`APIURL`变量：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we can import `SearchPage.vue` to all of our components properly and add
    a search page.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以正确地将`SearchPage.vue`导入到所有组件中，并添加一个搜索页面。
- en: Adding routing to the Photo Manager app
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将路由添加到照片管理器应用程序
- en: 'Without the Vue Router plugin, we cannot display the page components inside
    our app. The links won''t work and we cannot redirect anywhere. To add the Vue
    Router plugin, we need to register it and then add the routes. We add the following
    code to the `src/main.js` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Vue Router插件，我们无法在应用程序内显示页面组件。链接将无法工作，我们也无法重定向到任何地方。要添加Vue Router插件，我们需要注册它，然后添加路由。我们在`src/main.js`文件中添加以下代码：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this file, we import all of the page components and then put them into the
    `routes` array. The `routes` array has the routes. Each object in the array has
    the `path` and `component` properties. The path has the URL patterns we want to
    match to the component and the `component` property has the `component` object
    that we want to load when the URL pattern matches what we have in the path. The
    path is a string with a URL pattern. We have one URL parameter placeholder in
    our string. The `:id` string has the URL placeholder for the `id URL` parameter.
    In our `EditPhotoFormPage` component, we retrieve the `id URL` parameter by using
    the `this.$route.params.id` property. It will be returned as a string.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们导入所有页面组件，然后将它们放入`routes`数组中。`routes`数组包含路由。数组中的每个对象都有`path`和`component`属性。路径具有我们想要与组件匹配的URL模式，`component`属性具有我们想要在URL模式与路径中的内容匹配时加载的`component`对象。路径是一个带有URL模式的字符串。我们的字符串中有一个URL参数占位符。`:id`字符串具有`id
    URL`参数的URL占位符。在我们的`EditPhotoFormPage`组件中，我们通过使用`this.$route.params.id`属性来检索`id
    URL`参数。它将作为字符串返回。
- en: The `createRouter()` function enables us to create a router object that we can
    register in our app using the `app.use()` method. This is new to Vue Router 4
    and is different from Vue Router 3\. The way we register the Vue Router plugin
    and the routes is different from Vue Router 3\. Therefore, Vue Router 4 is the
    only version that can be used with Vue 3\. The `createWebHistory()` function lets
    us use HTML5 mode. Using this, we can remove the hash sign between the base URL
    segment and the rest of the URL. This makes the URLs look better and more familiar
    to the user. The `routes` property has the array of routes that we created earlier.
    Then, to register the routes and the Vue Router plugin, we call `app.use(router)`
    to register both. Now the `router-link` components and the redirects should work.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`createRouter()` 函数使我们能够创建一个路由器对象，我们可以使用 `app.use()` 方法在我们的应用程序中注册它。这是Vue Router
    4的新功能，与Vue Router 3不同。我们注册Vue Router插件和路由的方式与Vue Router 3不同。因此，Vue Router 4是唯一可以与Vue
    3一起使用的版本。`createWebHistory()` 函数允许我们使用HTML5模式。使用这个，我们可以删除基本URL段和URL其余部分之间的井号。这样做使URL看起来更好，更符合用户的习惯。`routes`
    属性具有我们之前创建的路由数组。然后，为了注册路由和Vue Router插件，我们调用 `app.use(router)` 来注册两者。现在 `router-link`
    组件和重定向应该可以工作了。'
- en: 'The `beforeEnter()` method is a per-route navigation guard. We need this method
    so that we can only access the pages that are available after login. In this method,
    we check whether the local storage item with the key logged in is `true`. Then,
    if that is `false`, we redirect to the login page by calling the `next()` function
    with the `path` property set to `login`. The `return` keyword is required before
    calling `next` since we don''t want to run the rest of the function''s code. Otherwise,
    we just call `next` to continue with the navigation to the destination route,
    which is the value of the `path` property. We also add the `beforeEnter()` method
    to the route objects that we want to apply:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEnter()` 方法是一个每个路由的导航守卫。我们需要这个方法，这样我们只能在登录后访问可用的页面。在这个方法中，我们检查具有键值为
    `true` 的本地存储项。然后，如果是 `false`，我们通过调用 `next()` 函数并将 `path` 属性设置为 `login` 来重定向到登录页面。在调用
    `next` 之前需要使用 `return` 关键字，因为我们不希望运行函数的其余代码。否则，我们只需调用 `next` 来继续导航到目标路由，即 `path`
    属性的值。我们还将 `beforeEnter()` 方法添加到我们想要应用的路由对象中：'
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, in `src/App.vue`, we add the `router-view` component and the `NavBar`
    component by writing the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `src/App.vue` 中，我们通过以下代码添加了 `router-view` 组件和 `NavBar` 组件：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We import the `NavBar.vue` component and then register it by putting it in the
    `components` property. Then, we add the `nav-bar` component to display the navigation
    bar with the `router-link` components using router links. The `router-view` component
    displays the component that is matched by Vue Router by comparing the URL pattern
    to the patterns in the `routes` array.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `NavBar.vue` 组件，然后通过将其放入 `components` 属性中注册它。然后，我们添加了 `nav-bar` 组件来显示带有路由链接组件的导航栏。`router-view`
    组件通过将URL模式与 `routes` 数组中的模式进行比较，显示与Vue Router匹配的组件。
- en: Now, when we click on the links or submit the forms successfully, we will see
    the routes loaded.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们单击链接或成功提交表单时，我们将看到加载的路由。
- en: We don't have to display the `nav-bar` component when we are on the login page.
    Therefore, we add a check for the `$route.fullPath.includes()` method to check
    whether we are on the login page. The `$route.fullPath` property has the full
    path without the base URL of the current page.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在登录页面时，我们不必显示 `nav-bar` 组件。因此，我们添加了一个检查 `$route.fullPath.includes()` 方法，以检查我们是否在登录页面上。`$route.fullPath`
    属性具有当前页面的完整路径，不包括基本URL。
- en: Using our app with photo management APIs
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的应用程序与照片管理API
- en: In the previous sections, we looked at the client-side part of the photo display.
    To return the photos from the API, we have to add a backend API that will enable
    us to store and retrieve the data for our app. Since this book is mostly focused
    on client-side app development with Vue 3 and not server-side app development,
    we will use a simple API solution to store our data with JSON so that we don't
    have to create our own API. All of the data is stored in a flat-file database,
    which is entirely JSON. To do this, we use the JSON Server package. This is a
    package that requires no configuration, and we can get it running in only a minute.
    All our fields are stored as JSON object properties, so they need to be text,
    including images. This package is made for frontend developers who require a backend
    to quickly prototype our apps.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的部分中，我们看了照片显示的客户端部分。要从 API 返回照片，我们必须添加一个后端 API，这将使我们能够存储和检索我们应用程序的数据。由于本书主要关注于使用
    Vue 3 进行客户端应用程序开发，而不是服务器端应用程序开发，我们将使用一个简单的 API 解决方案来使用 JSON 存储我们的数据，这样我们就不必创建自己的
    API。所有数据都存储在一个平面文件数据库中，完全是 JSON。为此，我们使用 JSON Server 包。这是一个不需要配置的包，我们可以在一分钟内让它运行起来。我们所有的字段都存储为
    JSON 对象属性，因此它们需要是文本，包括图像。这个包是为需要快速原型化我们应用程序的前端开发人员而设计的后端。
- en: 'First, we run `npm i –g json-server` to install the JSON Server package. This
    way, we can access the JSON Server package from any folder. Once we do that, we
    create a `photo-api` folder to store our photo database. Then, inside the folder,
    we add the `db.json` file. Next, we create the `photo-api` folder, go to the folder
    we just created, and run `json-server --watch db.json` to run the server. Inside
    the folder, we add the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们运行 `npm i –g json-server` 来安装 JSON Server 包。这样，我们可以从任何文件夹访问 JSON Server
    包。一旦我们这样做了，我们创建一个 `photo-api` 文件夹来存储我们的照片数据库。然后，在文件夹内，我们添加 `db.json` 文件。接下来，我们创建
    `photo-api` 文件夹，转到我们刚创建的文件夹，并运行 `json-server --watch db.json` 来运行服务器。在文件夹内，我们添加以下代码：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `db.json` files, we will have all the endpoints that we point to in
    our Vue 3 app. The server should be listening to port `3000`, and so, the base
    URL for the API is `localhost:3000`. Now, we should have access to the following
    API endpoints:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `db.json` 文件中，我们将拥有我们在 Vue 3 应用程序中指向的所有端点。服务器应该监听端口 `3000`，因此，API 的基本 URL
    是 `localhost:3000`。现在，我们应该可以访问以下 API 端点：
- en: '`GET /photos`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /photos`'
- en: '`GET /photos/1`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /photos/1`'
- en: '`POST /photos`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /photos`'
- en: '`PUT /photos/1`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /photos/1`'
- en: '`PATCH /photos/1`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH /photos/1`'
- en: '`DELETE /photos/1`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /photos/1`'
- en: The `GET /photos` endpoint allows us to get all the items in the `photos` JSON
    array. The `GET /photos/1` endpoint returns a single photo entry with an ID of
    `1`. We can replace it with any ID. The `POST /photos` endpoint enables us to
    add a new entry in the `photos` JSON array. `PUT /photos/1` and `PATCH /photos/1`
    allow us to update a photo entry with ID `1`. The `DELETE /photos` route lets
    us delete a photo with an ID of `1`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET /photos` 端点允许我们获取 `photos` JSON 数组中的所有项目。`GET /photos/1` 端点返回 ID 为 `1`
    的单个照片条目。我们可以用任何 ID 替换它。`POST /photos` 端点使我们能够在 `photos` JSON 数组中添加新条目。`PUT /photos/1`
    和 `PATCH /photos/1` 允许我们更新 ID 为 `1` 的照片条目。`DELETE /photos` 路由允许我们删除 ID 为 `1` 的照片。'
- en: The *GET* request also takes a query string. In order to search the field with
    a given piece of text, we can make a *GET* request to a URL such as `GET /photos?tname_like=foo`.
    This enables us to search the Name field of each entry and find the `photos` entries
    with the Name field containing the text as its value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*GET* 请求也可以带有查询字符串。为了搜索具有特定文本的字段，我们可以向 URL 发出 *GET* 请求，例如 `GET /photos?tname_like=foo`。这使我们能够搜索每个条目的
    Name 字段，并找到包含文本的 Name 字段值的 `photos` 条目。'
- en: Now, we should be able to make the requests that we have in the client-side
    API to get the things we want. The whole JSON array is returned as JSON so that
    we can render the items easily. The JSON Server package will watch for any updates
    to the JSON, so we will always get the latest data. Additionally, we can change
    the port by using the `port` flag. So, we can write something such as `run json-server
    --watch db.json –port 3005` to run the JSON server in port `3005`. The `APIURL`
    variable also has to change accordingly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够发出客户端API中的请求，以获取我们想要的内容。整个JSON数组以JSON格式返回，以便我们可以轻松呈现这些项目。JSON服务器包将监视JSON的任何更新，因此我们将始终获得最新数据。此外，我们可以使用`port`标志更改端口。因此，我们可以编写诸如`run
    json-server --watch db.json –port 3005`这样的内容来在端口`3005`上运行JSON服务器。`APIURL`变量也必须相应更改。
- en: 'When the server is running, we should see something similar to the following
    in Command Prompt:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器运行时，我们应该在命令提示符中看到类似以下内容：
- en: '![Figure 4.3 – JSON Server output'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 - JSON服务器输出'
- en: '](image/Figure_4.3_B14405.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.3_B14405.jpg)'
- en: Figure 4.3 – JSON Server output
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - JSON服务器输出
- en: 'Now our Electron desktop app window has the Vue 3 photo management app displayed,
    and we can manipulate our photo collection as we wish. We should now be able to
    view our app as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的Electron桌面应用程序窗口显示了Vue 3照片管理应用程序，我们可以随心所欲地操作我们的照片收藏。我们现在应该能够查看我们的应用程序如下：
- en: '![Figure 4.4 – The Photo App form'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 - 照片应用程序表单'
- en: '](image/Figure_4.4_B14405.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.4_B14405.jpg)'
- en: Figure 4.4 – The Photo App form
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 - 照片应用程序表单
- en: 'We can view the Search page in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中查看搜索页面：
- en: '![Figure 4.5 – The Search page'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 - 搜索页面'
- en: '](image/Figure_4.5_B14405.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.5_B14405.jpg)'
- en: Figure 4.5 – The Search page
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 - 搜索页面
- en: The photo app project is now finished. We added forms to enable users to add
    photo entries. We used Vue Router to allow us to add apps with multiple pages
    and easily navigate between them. We also added the Vue CLI Electron plugin so
    that we can easily build cross-platform desktop apps with Vue 3.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 照片应用程序项目现在已经完成。我们添加了表单，以便用户添加照片条目。我们使用Vue Router允许我们添加具有多个页面的应用程序，并在它们之间轻松导航。我们还添加了Vue
    CLI Electron插件，以便我们可以轻松地使用Vue 3构建跨平台桌面应用程序。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So, we can build apps that are beyond simple apps using a few components with
    Vue Router. This allows us to map different URLs to different components. This
    way, we can go to different URLs and have different components rendered. The URLs
    can have query strings, hashes, and URL parameters in them, and they will be parsed
    automatically by Vue Router. They will be matched with the route patterns listed
    in the route definition arrays.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用Vue Router构建超出简单应用的应用程序，这允许我们将不同的URL映射到不同的组件。这样，我们可以转到不同的URL并呈现不同的组件。URL可以在其中包含查询字符串、哈希和URL参数，并且Vue
    Router会自动解析它们。它们将与路由定义数组中列出的路由模式匹配。
- en: Routes can be nested, and they can have names so that we can identify them by
    their name rather than their route pattern. Additionally, we can have a catchall
    or a 404 route to enable us to display something when none of the route patterns
    listed in our route definitions are matched.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 路由可以嵌套，并且它们可以具有名称，以便我们可以根据它们的名称而不是它们的路由模式来识别它们。此外，我们可以有一个catchall或404路由，以便在我们的路由定义中列出的路由模式都不匹配时显示一些内容。
- en: Vue Router also has methods for programmatic navigation, which are named in
    the same way as the ones in the browser history API and can be called with the
    same arguments.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Vue Router还具有用于编程导航的方法，这些方法的命名方式与浏览器历史API中的方法相同，并且可以使用相同的参数进行调用。
- en: Additionally, we learned how to restrict some routes from being displayed unless
    certain conditions are met. To restrict when the route components can be seen
    by the user, we can use navigation guards to do our checks before we go to a route.
    Navigation guards can also be added to run after the route is loaded. They can
    also be applied globally or with individual routes. If we apply navigation guards
    individually, then the checks for the navigation can be tailored to each route.
    Additionally, we can apply more than one per-route navigation guard to a route.
    This enables us to have much more flexibility than we would otherwise have with
    global navigation guards.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们学会了如何限制某些路由在满足特定条件之前不显示。为了限制用户何时可以看到路由组件，我们可以使用导航守卫在进入路由之前进行检查。导航守卫也可以添加以在路由加载后运行。它们也可以全局应用或应用于单个路由。如果我们单独应用导航守卫，那么对导航的检查可以针对每个路由进行定制。此外，我们可以对一个路由应用多个路由导航守卫。这使我们比使用全局导航守卫时拥有更多的灵活性。
- en: Then, we looked at how to convert our Vue 3 web app into a desktop app. With
    Electron, we can build desktop apps from browser apps. This is very handy since
    we can build business apps that are web-based and convert them into desktop apps
    with ease. The apps are cross-platform, and we can do a lot of stuff that we can
    do with regular desktop apps easily. For example, we can have limited access to
    hardware such as cameras and microphones just as we do with browser apps. Additionally,
    we can show native notifications to users, as we would in a desktop app since
    this is supported by the Chromium browser engine. Electron just runs our app in
    the Chromium browser. The Vue CLI Electron Builder plugin lets us convert a Vue
    app into an Electron app with one command.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看了如何将我们的Vue 3 web应用程序转换为桌面应用程序。使用Electron，我们可以从浏览器应用程序构建桌面应用程序。这非常方便，因为我们可以构建基于Web的业务应用程序，并轻松将它们转换为桌面应用程序。这些应用程序是跨平台的，我们可以像使用常规桌面应用程序一样轻松地完成许多工作。例如，我们可以像在浏览器应用程序中一样，对硬件进行有限访问，如摄像头和麦克风。此外，我们可以向用户显示原生通知，就像在桌面应用程序中一样，因为这受到Chromium浏览器引擎的支持。Electron只是在Chromium浏览器中运行我们的应用程序。Vue
    CLI Electron Builder插件让我们可以用一条命令将Vue应用程序转换为Electron应用程序。
- en: In the next chapter, we will build a calculator mobile app with Ionic.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Ionic构建一个计算器移动应用程序。
