- en: Proper Creation of Vue Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确创建Vue项目
- en: In this chapter, we'll be looking at how we can create maintainable Vue projects,
    and take advantage of the many tools and patterns available. If you currently
    aren't maximizing the use of these things within your development workflow, you
    may find that the majority of the concepts we discuss in this chapter are applicable
    to other technologies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何创建可维护的Vue项目，并充分利用许多可用的工具和模式。如果您目前在开发工作流程中没有充分利用这些功能，您可能会发现本章讨论的大部分概念也适用于其他技术。
- en: 'In this chapter, we will be looking at the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下内容：
- en: Vue devtools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue devtools
- en: Visual Studio Code extensions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code扩展
- en: TypeScript integration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript集成
- en: Reactivity with RxJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJS进行响应式编程
- en: Visual Studio Code extensions
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code扩展
- en: 'Our development environment is an important part of application development.
    When using Visual Studio Code to create Vue applications, the following extensions
    are recommended:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发环境是应用程序开发的重要部分。在使用Visual Studio Code创建Vue应用程序时，建议安装以下扩展：
- en: Vetur
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vetur
- en: Vue 2 Snippets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue 2 Snippets
- en: Let's take a look at both of these in more detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这两个。
- en: Vetur
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vetur
- en: 'Vetur is powered by the Vue Language Server and provides us with syntax highlighting,
    Emmet (for increased HTML/CSS workflow), snippets, linting, IntelliSense, and
    more. This greatly improves our development experience and is widely supported,
    with over 1,000 stars on GitHub. To install the extension, click the Extensions
    icon within Visual Studio Code and type `Vetur`; from here, you can select Install
    and it''ll automatically be used throughout your project(s):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Vetur由Vue语言服务器提供支持，为我们提供语法高亮、Emmet（用于增加HTML/CSS工作流程）、代码片段、linting、IntelliSense等功能。这极大地改善了我们的开发体验，并得到了广泛的支持，在GitHub上有超过1,000个星标。要安装该扩展，点击Visual
    Studio Code中的扩展图标，然后输入`Vetur`；从这里，您可以选择安装，它将自动在您的项目中使用：
- en: '![](assets/cc72dedd-cdee-4a3a-ae5d-12840c66693a.png)Installing Vetur'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/cc72dedd-cdee-4a3a-ae5d-12840c66693a.png)安装Vetur'
- en: 'This then gives us access to snippets such as `scaffold`, which generates a
    new blank template, script, and style object(s) for us to use within our Vue components:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以访问到诸如`scaffold`之类的代码片段，它为我们在Vue组件中生成了一个新的空模板、脚本和样式对象：
- en: '![](assets/15c16209-2768-4463-9632-9d735b08bc6e.jpg)Scaffolding a new Vue project'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/15c16209-2768-4463-9632-9d735b08bc6e.jpg)搭建一个新的Vue项目'
- en: Vue 2 Snippets
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 2 Snippets
- en: Snippets are an important part of application development; in a similar way
    to Emmet, they allow us to quickly scaffold common patterns within our application.
    We'll also be installing another Visual Studio Code extension that provides us
    with a variety of commonly used snippets named Vue 2 Snippets**.**
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段是应用程序开发的重要部分；与Emmet类似，它们允许我们快速搭建应用程序中常见的模式。我们还将安装另一个名为Vue 2 Snippets的Visual
    Studio Code扩展，该扩展为我们提供了各种常用的代码片段。
- en: 'This allows us to save a substantial amount of time that we otherwise would
    have had to spend writing out the same boilerplate code. Take the next example;
    although it''s simplistic in nature, we get a description of the snippet, and
    with a hit of *Tab* it expands to our predefined code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以节省大量时间，否则我们将不得不花费时间编写相同的样板代码。接下来的例子，虽然它很简单，但我们可以得到代码片段的描述，然后按下*Tab*键，它就会扩展为我们预定义的代码：
- en: '![](assets/234a2a64-d70c-44f4-902d-6c6c603f10be.jpg)Taking advantage of Vue
    snippets'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/234a2a64-d70c-44f4-902d-6c6c603f10be.jpg)充分利用Vue代码片段'
- en: Vue CLI
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue CLI
- en: The Vue **Command Line Interface** (**CLI**) allows us to quickly scaffold new
    Vue projects with a variety of different template options. Currently, the template
    options available include technologies such as Webpack, Browserify, and Progressive
    Web Application features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Vue **命令行界面**（**CLI**）允许我们快速使用各种不同的模板选项搭建新的Vue项目。目前，可用的模板选项包括Webpack、Browserify和渐进式Web应用程序功能等技术。
- en: Sure, we could create our own Vue application and manually add tools such as
    Webpack, but this creates technical overhead in the sense that we have to learn,
    build, and maintain our configuration. The Vue CLI does this for us while maintaining
    a select set of official templates, but doesn't restrict us from modifying the
    generated Webpack configuration. All of this allows us to generate new unopinionated
    Vue projects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以创建自己的Vue应用程序，并手动添加诸如Webpack之类的工具，但这会在技术上增加负担，因为我们必须学习、构建和维护我们的配置。Vue
    CLI可以为我们做到这一点，同时保持一组官方模板，但不限制我们修改生成的Webpack配置。所有这些都允许我们生成新的无偏见的Vue项目。
- en: 'To start using the Vue CLI, let''s ensure we have it installed:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Vue CLI，让我们确保已经安装了它：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can then use the Vue `init` command to scaffold a new Vue project using
    the Webpack template:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用Vue `init`命令使用Webpack模板搭建一个新的Vue项目：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On entering the preceding command we should get the following as shown on the
    Terminal:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输入上述命令后，我们应该在终端上看到以下内容：
- en: '![](assets/ddc98095-267c-405f-bed1-fda9f1cfd584.png)Creating projects with
    Vue init'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ddc98095-267c-405f-bed1-fda9f1cfd584.png)使用Vue init创建项目'
- en: If we break this down, we're essentially initializing a new Vue project based
    on the webpack-simple template named my-vue-project. We're then navigated to a
    wizard process that asks us for more metadata about our project. This metadata
    and configuration will differ depending on the template you choose.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分解这个，实质上我们正在基于webpack-simple模板初始化一个新的Vue项目，名为my-vue-project。然后我们会进入一个向导过程，询问我们关于项目的更多元数据。这些元数据和配置将根据您选择的模板而有所不同。
- en: 'Let''s investigate the files and folders that the template created:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来研究模板创建的文件和文件夹：
- en: '| **File/Folder** | **Description** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **文件/文件夹** | **描述** |'
- en: '| `src/` | This folder contains all of our project code. We''ll spend the majority
    of our time within src. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `src/` | 这个文件夹包含我们项目的所有代码。我们将在src中花费大部分时间。 |'
- en: '| `.bablrc` | This is our Babel configuration file that allows us to write
    ES2015 and have it appropriately transpiled. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `.bablrc` | 这是我们的Babel配置文件，允许我们编写ES2015并进行适当的转译。 |'
- en: '| `index.html` | This is our default HTML file. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `index.html` | 这是我们的默认HTML文件。 |'
- en: '| `package.json` | This holds our dependencies and other project-specific metadata.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `package.json` | 这个文件包含我们的依赖和其他项目特定的元数据。 |'
- en: '| `webpack.config.js` | This is our Webpack configuration file, allowing us
    to use `.vue` files, Babel, and more. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `webpack.config.js` | 这是我们的Webpack配置文件，允许我们使用`.vue`文件、Babel等。 |'
- en: Notice how we're no longer working with `.js` files, and we now have `.vue`
    files inside of our `src` directory. A Vue file is known as a Single File Component
    and it has a template, script, and style tag, allowing us to scope everything
    to this component only.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不再使用`.js`文件，现在我们的`src`目录里有`.vue`文件。Vue文件被称为单文件组件，它包含模板、脚本和样式标签，允许我们将所有内容限定在这个组件内部。
- en: This is possible due to our Webpack template, as we have a custom "loader".
    How does this work? Prior to looking at this, let's take a quick detour and review
    modern JavaScript build systems.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，因为我们有一个自定义的“loader”。这是如何工作的？在看这个之前，让我们快速了解一下现代JavaScript构建系统。
- en: JavaScript modules
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript模块
- en: In order to create reusable modular code, our aim should be to have one file
    per feature in most cases. This allows us to avoid the dreaded "Spaghetti code"
    anti-pattern, where we have strong coupling and little separation of concerns.
    Continuing with the pasta-oriented theme, the solution to this is to embrace the
    "Ravioli code" pattern with smaller, loosely coupled, distributed modules that
    are easier to work with. What does a JavaScript module look like?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建可重用的模块化代码，我们的目标应该是在大多数情况下每个功能有一个文件。这使我们能够避免可怕的“意大利面代码”反模式，其中我们有强耦合和关注点分离很少。继续以意大利面为主题，解决这个问题的方法是采用更小、松散耦合、分布式模块的“意大利饺子代码”模式，这样更容易处理。JavaScript模块是什么样子的？
- en: 'In ECMAScript2015, a module is simply a file that uses the `export` keyword,
    and allows other modules to then import that piece of functionality:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript2015中，模块只是使用`export`关键字的文件，并允许其他模块导入该功能：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We could then `import` `add` from another module:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以从另一个模块中`import` `add`：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As browsers haven't fully caught up with module imports yet, we often use tools
    to assist with the bundling process. Common projects in this area are Babel, Bublé,
    Webpack, and Browserify. When we create a new project with the Webpack template,
    it uses the Vue-loader to transform our Vue components into a standard JavaScript
    module.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器尚未完全跟上模块导入的步伐，我们经常使用工具来辅助打包过程。在这个领域常见的项目有Babel、Bublé、Webpack和Browserify。当我们使用Webpack模板创建一个新项目时，它使用Vue-loader将我们的Vue组件转换为标准的JavaScript模块。
- en: Vue-loader
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue-loader
- en: 'Inside of our `./webpack-config.js` within the standard `webpack-simple` template,
    we have a module object that allows us to set up our loader; this tells Webpack
    that we''d like it to use `.vue` files inside of our project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的`webpack-simple`模板中的`./webpack-config.js`内，我们有一个模块对象，允许我们设置我们的加载器；这告诉Webpack我们想要在项目中使用`.vue`文件：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For this to work, Webpack runs a regular expression for anything that matches
    `.vue` and then passes this to our `vue-loader` to be transformed into a plain
    JavaScript module. In this simple example, we're loading files with a `.vue` extension,
    but `vue-loader` can be further customized and you may want to look into this
    further ([https://goo.gl/4snNfD](https://goo.gl/4snNfD)). We could certainly do
    this configuration ourselves, but hopefully, you can see the benefits of using
    the Vue CLI to generate our Webpack projects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，Webpack对与`.vue`匹配的任何内容运行正则表达式，然后将其传递给我们的`vue-loader`，以转换为普通的JavaScript模块。在这个简单的例子中，我们正在加载扩展名为`.vue`的文件，但`vue-loader`可以进一步定制，您可能希望进一步了解这一点（[https://goo.gl/4snNfD](https://goo.gl/4snNfD)）。我们当然可以自己进行这种配置，但希望您能看到使用Vue
    CLI生成我们的Webpack项目的好处。
- en: Loading modules without Webpack
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在没有Webpack的情况下加载模块
- en: Although Webpack helps us in more ways than simply loading a module, we can
    load a JavaScript module at this moment in time natively in the browser. It tends
    to perform worse than bundling tools (at the time of writing), but this may change
    over time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Webpack在更多方面帮助我们，但我们目前可以在浏览器中本地加载JavaScript模块。在写作时，它的性能往往不如打包工具（但这可能会随着时间的推移而改变）。
- en: 'To demonstrate this, let''s head over to the terminal and make a simple counter
    with a project based on the simple template. This template effectively starts
    a new Vue project without any bundling tools:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们转到终端，并在基于简单模板的项目中创建一个简单的计数器。这个模板有效地启动了一个新的Vue项目，没有任何打包工具：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can then edit our `index.html` to add script files from `type="module"`
    this allows us to use the export/import syntax outlined before:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以编辑我们的`index.html`，添加来自`type="module"`的脚本文件，这使我们可以使用之前概述的导出/导入语法：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Warning: Ensure that your browser is up to date so that the preceding code
    can run successfully.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：确保您的浏览器是最新的，以便上述代码可以成功运行。
- en: 'Then, inside of our `counter.js`, we can export a new `default` object, which
    acts as a new Vue instance. It acts as a simple counter that allows us to either
    increment or decrements a value:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`counter.js`中，我们可以导出一个新的`default`对象，它充当一个新的Vue实例。它充当一个简单的计数器，允许我们增加或减少一个值：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can then import the `counter.js` file inside of `app.js`, thus demonstrating
    the ways we can import/export modules. To get our counter to display inside of
    our root Vue instance, we''re registering the counter as a component inside this
    instance, and setting the template to `<counter></counter>`, the name of our component:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在`app.js`中导入`counter.js`文件，从而演示我们可以导入/导出模块的方式。为了在我们的根Vue实例中显示计数器，我们将计数器注册为此实例中的一个组件，并将模板设置为`<counter></counter>`，这是我们组件的名称：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We'll look at this in more detail in future sections of the book, but all you
    need to know at this point is that it effectively acts as another Vue instance.
    When we register the component inside of our instance, we're only able to access
    this component from that instance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后续部分更详细地讨论这一点，但在这一点上，你需要知道的是它实际上充当另一个Vue实例。当我们在我们的实例中注册组件时，我们只能从该实例中访问这个组件。
- en: 'Awesome! Here are the results of our module import/exports:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这是我们模块导入/导出的结果：
- en: '![](assets/0439ff73-38f9-4452-88a0-6c0695188524.png)Vue.js Modules'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/0439ff73-38f9-4452-88a0-6c0695188524.png)Vue.js模块'
- en: In the next section, we'll take a deeper look at debugging our Vue applications,
    and the role Vue devtools plays in this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入了解调试Vue应用程序以及Vue devtools在其中的作用。
- en: VueJS devtools
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VueJS devtools
- en: 'Being able to accurately debug our application is an important part of our
    development workflow. In the previous chapter, we installed the VueJS devtools,
    and we''ll be looking at using it in more detail within this section. Let''s make
    a playground project:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 能够准确调试我们的应用程序是开发工作流程的重要部分。在上一章中，我们安装了VueJS devtools，并将在本节中更详细地使用它。让我们创建一个示例项目：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can then open up our developer console and navigate to the Vue tab. When
    we select App from within the components list, we can see the data object(s) and
    other information for this component. By default, we have the `msg` variable that
    we''re then binding to within our template, and we can see this within our developer
    tools:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以打开开发者控制台并导航到Vue选项卡。当我们从组件列表中选择App时，我们可以看到该组件的数据对象和其他信息。默认情况下，我们有一个`msg`变量，然后我们将其绑定到我们的模板中，并且我们可以在开发者工具中看到这一点：
- en: '![](assets/9b7c49cd-7e51-45ff-9ba0-992d0231b6cc.png)Inspecting a Vue instance'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9b7c49cd-7e51-45ff-9ba0-992d0231b6cc.png)检查Vue实例'
- en: 'This goes both ways though - we could access the objects inside of this Vue
    instance with `$vm0.$data`, scoping this to `msg`. To view this within the console,
    selecting `<Root>` then `<App>` will display the `msg`0;within the console. We
    can change this value and as Vue is watching the value, it will automatically
    change on screen:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这两种方式都是可以的 - 我们可以使用`$vm0.$data`来访问Vue实例中的对象，将其范围限定为`msg`。要在控制台中查看这一点，选择`<Root>`然后选择`<App>`将在控制台中显示`msg`。我们可以更改这个值，由于Vue正在监视这个值，它将自动在屏幕上更改。
- en: '![](assets/e5e7927c-b0ee-4b93-a634-9116253f9c37.png)Editing Vue instance data
    from the console'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e5e7927c-b0ee-4b93-a634-9116253f9c37.png)从控制台编辑Vue实例数据'
- en: Notice how our message has changed to `"Hello Vue Devtools!"`; if we had multiple
    Vue instances, there would be other prefixed versions of Vue with `$vm1`, `$vm2`,
    and so on. Later in the book when we come to using `Vuex`, we'll be using this
    often. Next, let's take a look at how we can integrate TypeScript into our Vue
    projects. This is useful for those with an Angular background or anyone that's
    looking to take advantage of static typing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的消息已更改为`"Hello Vue Devtools!"`；如果我们有多个Vue实例，将会有其他带有`$vm1`，`$vm2`等前缀版本的Vue。在本书后面当我们开始使用`Vuex`时，我们会经常使用这个。接下来，让我们看看如何将TypeScript集成到我们的Vue项目中。这对于具有Angular背景或任何希望利用静态类型的人都很有用。
- en: TypeScript and Vue
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript和Vue
- en: You may have used TypeScript in the past, or you may be curious about how you
    can take advantage of the extra tooling TypeScript provides inside of your Vue
    projects. Why use TypeScript? A recent study by Gao et al found that TypeScript/static
    typing tools reduced committed bugs by 15% ([https://goo.gl/XUTPf4](https://goo.gl/XUTPf4)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能以前使用过TypeScript，或者您可能对如何在Vue项目中利用TypeScript提供的额外工具感到好奇。为什么要使用TypeScript？高等人最近的一项研究发现，TypeScript/静态类型工具将提交的错误减少了15%（[https://goo.gl/XUTPf4](https://goo.gl/XUTPf4)）。
- en: 'If you''ve used Angular before, this syntax should make you feel right at home,
    as we''ll be using decorators and ES2015 classes. Let''s investigate how we can
    add TypeScript to a project built with the Vue CLI:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前使用过Angular，这种语法应该让您感到非常亲切，因为我们将使用装饰器和ES2015类。让我们研究一下如何将TypeScript添加到使用Vue
    CLI构建的项目中：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should get the following output on the Terminal:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端上获得以下输出：
- en: '![](assets/c023a2c4-80d8-4527-aca1-b542d61685d3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c023a2c4-80d8-4527-aca1-b542d61685d3.png)'
- en: 'If we navigate to our project directory and run `npm install` as per the instructions,
    we then need to install the TypeScript loader and edit our Webpack configuration.
    This allows us to load `.ts` files inside of the project, and because we''ve used
    the `webpack-simple` template, it''s as simple as installing the loader and making
    a few changes. At the same time, we can also install TypeScript to the project:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照说明导航到我们的项目目录并运行 `npm install`，然后我们需要安装TypeScript加载器并编辑我们的Webpack配置。这允许我们在项目内加载`.ts`文件，并且因为我们使用了`webpack-simple`模板，所以只需安装加载器并进行一些更改即可。同时，我们还可以将TypeScript安装到项目中：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We then need to make some changes to our Webpack configuration to add our new
    loader. Hot Module Replacement is enabled by default, so there is no need to refresh
    to see any changes once loaded.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要对我们的Webpack配置进行一些更改，以添加新的加载器。热模块替换默认启用，因此加载后无需刷新即可看到任何更改。
- en: Remember to run the project from the command line, and type `npm dev`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记得从命令行运行项目，并输入 `npm dev`。
- en: 'We need to change our entry point to be `main.ts` (and subsequently rename
    it), as well as define the `ts-loader` and remove the `babel-loader` in order
    to do it, and edit the `webpack.config.js` file, pasting the following contents:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将入口点更改为`main.ts`（并随后重命名它），并定义`ts-loader`并删除`babel-loader`以执行此操作，并编辑`webpack.config.js`文件，粘贴以下内容：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After this, we can create a `tsconfig.json` inside of our project root, which
    is responsible for appropriately configuring our TypeScript setup:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以在项目根目录内创建一个`tsconfig.json`，负责适当配置我们的TypeScript设置：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'TypeScript is now set up in our project, but to truly take advantage of this
    within our Vue applications we should also use `vue-class-component`. This allows
    us to take advantage of static typing on our component properties, as well as
    define components as native JavaScript classes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目中已经设置了TypeScript，但要真正利用它在我们的Vue应用程序中，我们还应该使用`vue-class-component`。这使我们能够利用组件属性的静态类型，并将组件定义为本机JavaScript类：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can then define our `App.vue` file by first specifying it as a script with
    the `lang="ts"` attribute. We can then import Vue as always, but as well as this,
    we're also importing `Component` from `vue-class-component` to be used as a decorator
    within this file. This allows us to specify this as a new Vue component, and using
    the Component decorator we can define properties, templates, and more.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过首先将其指定为具有`lang="ts"`属性的脚本来定义我们的`App.vue`文件。然后像往常一样导入Vue，但除此之外，我们还从`vue-class-component`导入`Component`，以便在此文件中用作装饰器。这允许我们将其指定为新的Vue组件，并且使用Component装饰器，我们可以定义属性、模板等。
- en: 'Inside of our Component decorator, we''re specifying a template with an input
    box and button. This example allows us to see how we can bind to class properties,
    as well as call methods from our class. The following code should replace the
    code already in the `App.vue` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Component装饰器内部，我们正在指定一个模板，其中包含一个输入框和按钮。此示例允许我们看到如何绑定到类属性，以及从我们的类中调用方法。以下代码应替换已在`App.vue`文件中的代码：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After running the preceding code, you should get something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码后，您应该会得到类似以下的结果：
- en: '![](assets/d9abed5a-93a7-495b-8592-96c52b9268ec.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d9abed5a-93a7-495b-8592-96c52b9268ec.png)'
- en: Lifecycle hooks
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期钩子
- en: Lifecycle hooks such as `created()`, `mounted()`, `destroyed()`, and so on can
    be defined as functions within the class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子，如`created()`、`mounted()`、`destroyed()`等，可以在类中定义为函数。
- en: '`created()`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created()`'
- en: This allows for actions to be performed to a component before it is added into
    the DOM. Using this hook allows access to both data and events.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许在将组件添加到DOM之前执行操作。使用此钩子允许访问数据和事件。
- en: '`mounted()`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mounted()`'
- en: Mounted gives access to a component before it is rendered as well as after it
    has been rendered. It provides full access for interacting with the DOM and component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Mounted在组件呈现之前和呈现后都可以访问。它提供了与DOM和组件进行交互的完全访问权限。
- en: '`destroyed()`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroyed()`'
- en: Everything that was attached to the component has been destroyed. It allows
    for cleanup of the component when it is removed from the DOM.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到组件的所有内容都已被销毁。它允许在组件从DOM中移除时进行清理。
- en: 'They''ll be recognized and act the same way as expected without TypeScript.
    Here''s an example when using the `created` and `mounted` hooks:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将被识别并且与预期的方式一样起作用，而不需要TypeScript。在使用`created`和`mounted`钩子时的示例：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now if we head over to the console, we can see that the message of ''Hello''
    is outputted with the name of Paul:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们转到控制台，我们可以看到“Hello”的消息与Paul的名称一起输出：
- en: '![](assets/429bcf4f-96d4-4d7e-a833-13c72456ac3a.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/429bcf4f-96d4-4d7e-a833-13c72456ac3a.png)'
- en: Properties
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'We''ve seen how we can create classes and use the Component decorator; let''s
    now take a look at how we can define "props" inside of our class using the `vue-property-decorator`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建类并使用Component装饰器；现在让我们看看如何在我们的类中使用`vue-property-decorator`定义“props”：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This depends on the `vue-class-component`, so anytime we install `vue-property-decorator`
    you''ll need to ensure `vue-class-component` is also installed. Let''s then define
    a `Component` property using the `@Prop` decorator:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于`vue-class-component`，因此每次安装`vue-property-decorator`时，您都需要确保也安装了`vue-class-component`。然后，我们可以使用`@Prop`装饰器定义一个`Component`属性：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice how we''re now importing the `Component` from `''vue-property-decorator''`
    instead of `vue-class-component`. This is because it exports this as a module
    for us to import. We''re then defining a new component property with the key of
    name and the `default` value of `''Paul Halliday''`; prior to using TypeScript,
    it would have looked as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在从`'vue-property-decorator'`而不是`vue-class-component`中导入`Component`。这是因为它将其作为模块导出供我们导入。然后，我们使用名称键和`'Paul
    Halliday'`的`default`值定义了一个新的组件属性；在使用TypeScript之前，它看起来应该是这样的：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Computed
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性
- en: 'Computed properties allow for multiple expressions to be passed, and these
    properties on the Vue instance require the use of class getters/setters. So, if
    we wanted to retrieve a reversed version of our name, we could simply pass the
    following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性允许传递多个表达式，Vue实例上的这些属性需要使用类的getter/setter。因此，如果我们想要获取我们名字的反转版本，我们可以简单地传递以下内容：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This would otherwise have been equivalent to:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，这将等同于：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Other decorators can be used, such as `@Watch`, `@Inject`, `@Model`, and `@Provide`.
    Each decorator allows for a consistent implementation, and provides a similar
    API to the vanilla Vue instance. In the next section, we're going to look at how
    we can enhance the reactivity of our Vue applications with RxJS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其他装饰器也可以使用，比如`@Watch`、`@Inject`、`@Model`和`@Provide`。每个装饰器都允许一致的实现，并为原始Vue实例提供类似的API。在下一节中，我们将看看如何使用RxJS增强Vue应用程序的响应性。
- en: RxJS and Vue
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS和Vue
- en: If you come from an Angular background, you'll most likely feel right at home
    with *at least* the basic concepts of RxJS. This means we're usually dealing with
    things such as Observables, Subjects, and a variety of operators. If you haven't
    used them before, not to worry - we'll be investigating what RxJS is, and why
    we'd want to use it within Vue.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Angular背景，你很可能会对RxJS的基本概念感到非常熟悉。这意味着我们通常处理诸如Observables、Subjects和各种操作符之类的东西。如果你以前没有使用过它们，不用担心——我们将调查RxJS是什么，以及为什么我们想要在Vue中使用它。
- en: What is RxJS?
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS是什么？
- en: 'If we look at the RxJS documentation, we''re greeted with the following definition:
    *"**ReactiveX is a library for composing asynchronous and event-based programs
    by using observable sequences"* ([http://reactivex.io/intro.html](http://reactivex.io/intro.html)).
    At first glance, this is not exactly a description that makes us feel comfortable
    using this within our projects.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看RxJS文档，我们会看到以下定义：“**ReactiveX是一个通过使用可观察序列来组合异步和基于事件的程序的库**”([http://reactivex.io/intro.html](http://reactivex.io/intro.html))。乍一看，这并不是一个让我们在项目中感到舒适的描述。
- en: RxJS assists us in using reactive programming principles inside of our application,
    often referred to as a more declarative style rather than imperative. When we
    talk about an imperative programming style, we're usually telling the computer
    the exact steps of how to do a particular task. A declarative style allows us
    to focus more on the expected outcome rather than the implementation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS帮助我们在应用程序中使用响应式编程原则，通常被称为更具声明性而不是命令性的风格。当我们谈论命令式编程风格时，我们通常是在告诉计算机如何执行特定任务的确切步骤。声明式风格允许我们更多地关注预期的结果而不是实现。
- en: 'In JavaScript, we can create an `event` stream by using the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们可以通过以下方式创建一个`event`流：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This then allows us to observe any mouse clicks on the document. We can capture
    things such as the click coordinates, target, event type, and so on. Evidently,
    this is an asynchronous observable data stream. We don't know when someone is
    going to click the screen, nor do we care. All we do is observe and perform a
    particular action when that event occurs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以观察文档上的任何鼠标点击。我们可以捕获诸如点击坐标、目标、事件类型等内容。显然，这是一个异步的可观察数据流。我们不知道什么时候有人会点击屏幕，也不在乎。我们所做的就是观察，并在事件发生时执行特定的操作。
- en: We can use RxJS to take these same principles and apply it to our modern day
    applications where everything is a stream. We could have an observable data stream
    of everything from a Facebook feed to document click events, timers, anything!
    Everything can be a stream.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用RxJS将这些原则应用到我们的现代应用程序中，其中一切都是一个流。我们可以有一个可观察的数据流，从Facebook动态到文档点击事件，定时器，任何东西！一切都可以是一个流。
- en: Integrating with Vue
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Vue集成
- en: To integrate RxJS with Vue, we'll need to make a new Vue project and install
    both RxJS and Vue-Rx. One of the great things about using the Vue-Rx plugin is
    that it's officially supported by the Vue.js team, which gives us confidence that
    it'll be supported in the long term.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要将RxJS与Vue集成，我们需要创建一个新的Vue项目，并安装RxJS和Vue-Rx。使用Vue-Rx插件的一个很棒的地方是它得到了Vue.js团队的官方支持，这让我们有信心它将在长期内得到支持。
- en: 'Let''s create a new project with the Vue CLI, and integrate RxJS:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Vue CLI创建一个新项目，并集成RxJS：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We now need to tell Vue that we''d like to use the `VueRx` plugin. This can
    be done using `Vue.use()`, and is not specific to this implementation. Any time
    we''re looking to add new plugins to our Vue instance(s), calling `Vue.use()`
    makes an internal call to the plugin''s `install()` method, extending the global
    scope with the new functionality. The file to edit will be our `main.js` file,
    which is located at `src/main.js`. We''ll be looking at plugins in more detail
    within later chapters of this book:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要告诉Vue我们想要使用`VueRx`插件。这可以通过`Vue.use()`来完成，并且不是特定于这个实现。每当我们想要向我们的Vue实例添加新的插件时，调用`Vue.use()`会内部调用插件的`install()`方法，扩展全局范围的新功能。要编辑的文件将是我们的`main.js`文件，位于`src/main.js`。我们将在本书的后面章节更详细地讨论插件：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice any issues with the preceding implementation? Well, in the interests
    of application performance and reducing bundle size, we should only import what
    we need. This then becomes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到前面的实现中有什么问题吗？嗯，在应用性能和减少捆绑包大小的利益上，我们应该只导入我们需要的内容。这样就变成了：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can then create an `Observable` data stream inside of our Vue application.
    Let''s head over to `App.vue`, and import the necessary modules from RxJS:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在Vue应用程序内创建一个`Observable`数据流。让我们转到`App.vue`，并从RxJS导入必要的模块：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then create a new `Observable` of data; in this example, we''ll be using
    a simple array of people:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个新的数据`Observable`；在这个例子中，我们将使用一个简单的人员数组：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This then allows us to subscribe to this `Observable` from within the subscriptions
    object. If you''ve ever used Angular before, this allows us to access the `Observable`
    (and handles the necessary unsubscription) similar to the Async pipe:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们就可以在订阅对象内订阅这个`Observable`。如果您以前使用过Angular，这样可以让我们访问`Observable`（并处理必要的取消订阅），类似于Async管道：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As well as this, if we wanted to create a new instance of our `Observable`
    for each component, we can instead declare our subscriptions as a function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，如果我们想要为每个组件创建一个新的`Observable`实例，我们可以将我们的订阅声明为一个函数：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we can then display the results of the `Observable` inside of our
    template. We can use the `v-for` directive to iterate over the array and display
    the results on screen. How does this work? Using the following example, the `v-for`
    syntax uses an `item in items` syntax, which can be thought of a `person in people$`
    in our context. This allows us to access each item inside of our `people$` Observable
    (or any other array) with interpolation binding:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在我们的模板中显示`Observable`的结果。我们可以使用`v-for`指令来遍历数组并在屏幕上显示结果。这是如何工作的？使用以下示例，`v-for`语法使用`item
    in items`语法，可以在我们的上下文中被认为是`person in people$`。这允许我们访问我们的`people$` Observable（或任何其他数组）中的每个项目与插值绑定：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see inside of the browser, our three items have now appeared on
    the screen inside of our list item:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在浏览器中所看到的，我们的三个项目现在已经出现在列表项中的屏幕上：
- en: '![](assets/2230e189-f1b4-412e-9141-6a0dfc296b15.png)Iterating over RxJS Observables'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2230e189-f1b4-412e-9141-6a0dfc296b15.png)遍历RxJS Observables'
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how we can take advantage of the Vue CLI to scaffold
    new Vue projects with appropriate bundling configurations and ES2015 support.
    We've seen that not only does this give us extra power, but it also saves us a
    significant amount of time in the long run. We don't have to remember how to create
    a Webpack or Babel configuration, as this is all handled for us by the starter
    templates; but even still, if we want to add extra configuration options, we can.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何利用Vue CLI来搭建新的Vue项目，并配置适当的打包配置和ES2015支持。我们看到这不仅给了我们额外的能力，而且在长远来看也节省了大量时间。我们不必记住如何创建Webpack或Babel配置，因为这一切都由起始模板为我们处理；但即使如此，如果我们想添加额外的配置选项，我们也可以。
- en: We then looked at how we can implement TypeScript with Webpack and the `ts-loader`,
    as well as taking advantage of common TypeScript and Vue patterns with the property
    decorator(s). This allows us to take advantage of core tooling and help reduce
    bugs in our code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看了如何使用Webpack和`ts-loader`来实现TypeScript，以及利用属性装饰器来利用常见的TypeScript和Vue模式。这使我们能够利用核心工具，并帮助减少代码中的错误。
- en: Finally, we also implemented RxJS and Vue-Rx in our application to take advantage
    of the Observable pattern. If you're interested in using RxJS inside of your projects,
    this is a good starting point for future integrations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还在我们的应用程序中实现了RxJS和Vue-Rx，以利用Observable模式。如果您有兴趣在项目中使用RxJS，这是未来集成的良好起点。
- en: In the next chapter, we're going to take a deeper look at the Vue.js instance
    and the different reserved properties, such as data, computed, ND watch, as well
    as creating getters and setters. This chapter especially considers when you should
    use computed to use or watch properties.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地了解Vue.js实例和不同的保留属性，比如data、computed、watch，以及创建getter和setter。本章特别考虑了何时应该使用computed来使用或监视属性。
- en: In this section, we'll be investigating how a Vue.js instance works at a lower
    level by looking at how this is handled by Vue. We'll also be looking at the various
    properties on our instance such as data, computed, watch, as well as best practices
    when using each one. Furthermore, we'll be looking at the various lifecycle hooks
    available within our Vue instance, allowing us to call particular functions at
    various stages of our application. Finally, we'll be investigating the **Document
    Object Model** (**DOM**) and why Vue implements a Virtual DOM for enhanced performance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过查看Vue如何处理来了解Vue.js实例在更低级别上是如何工作的。我们还将查看实例上的各种属性，如data、computed、watch，以及在使用每个属性时的最佳实践。此外，我们将查看Vue实例中可用的各种生命周期钩子，允许我们在应用程序的各个阶段调用特定函数。最后，我们将调查**文档对象模型**（**DOM**）以及Vue为了增强性能而实现虚拟DOM。
- en: 'By the end of this chapter you will:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将：
- en: Have a greater understanding of how `this` keyword works within JavaScript
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地理解`this`关键字在JavaScript中的工作原理
- en: Understand how Vue proxies `this` keyword within Vue instances
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Vue如何在Vue实例中代理`this`关键字
- en: Use data properties to create reactive bindings
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据属性创建响应式绑定
- en: Use computed properties to create declarative functions based on our data model
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算属性基于我们的数据模型创建声明性函数
- en: Use watched properties to access asynchronous data and build upon the foundations
    of computed properties
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用watched属性访问异步数据，并在计算属性的基础上构建
- en: Use lifecycle hooks to activate functionality at particular stages of the Vue
    lifecycle
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生命周期钩子在Vue生命周期的特定阶段激活功能
- en: Investigate the DOM and Virtual DOM for an understanding of how Vue renders
    data to the screen
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查DOM和虚拟DOM，了解Vue如何将数据渲染到屏幕上
- en: To begin, let's start off by looking into how this works within JavaScript and
    how this relates to the context within our Vue instances.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看这在JavaScript中是如何工作的，以及这与我们Vue实例中的上下文有什么关系。
- en: Proxying
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: 'So far, you may have interacted with a Vue application and thought to yourself:
    How does `this` work the way it does? Before looking into how Vue.js handles `this`,
    let''s have a look at how it works within JavaScript.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经与Vue应用程序互动，并且想过：`this`是如何工作的呢？在了解Vue.js如何处理`this`之前，让我们先看看它在JavaScript中是如何工作的。
- en: How 'this' works within JavaScript
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JavaScript中'this'的工作原理
- en: 'Within JavaScript, `this` has varying contexts that range from the global window
    context to eval, newable, and function contexts. As the default context for this
    relates to the global scope, this is our window object:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`this`有不同的上下文，从全局窗口上下文到eval、newable和函数上下文。由于默认上下文与全局作用域相关，因此这是我们的window对象：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The context of this changes depending on where we are in scope. This means,
    that if we had a `Student` object with particular values, such as `firstName`,
    `lastName`, `grades`, and so on, the context of `this` would be related to the
    object itself:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域中，this的上下文会发生变化。这意味着，如果我们有一个`Student`对象，其中包含特定的值，比如`firstName`、`lastName`、`grades`等等，那么`this`的上下文将与对象本身相关：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we run the preceding code with `console.log(Student.toString())`, we get
    this: `Student Paul Halliday scored 315/500` as the context of this is now scoped
    to the object itself rather than the global window scope.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用`console.log(Student.toString())`运行上述代码时，我们得到了这个结果：`Student Paul Halliday
    scored 315/500`，因为此时`this`的上下文现在是对象本身，而不是全局窗口作用域。
- en: 'If we wanted to display this in the document we could do it like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在文档中显示这个，我们可以这样做：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that, with the preceding code, once again we don't have to use `this`
    as it isn't needed with the global context.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过上述代码，我们再次不需要使用`this`，因为它在全局上下文中是不需要的。
- en: Now that we have an understanding of how `this` works at a basic level, we can
    investigate how Vue proxies `this` inside of our instances to make interacting
    with the various properties much easier.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`this`的基本工作原理有了一定的了解，我们可以研究Vue如何代理我们实例中的`this`，以便更轻松地与各种属性进行交互。
- en: How Vue handles 'this'
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue如何处理'this'
- en: You may have noticed up to this point that we're able to reference values inside
    of our data, methods, and other objects using `this` syntax, but the actual structure
    of our instance is `this.data.propertyName` or `this.methods.methodName`; all
    of this is possible due to the way Vue proxies our instance properties.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经注意到我们能够使用`this`语法引用数据、方法和其他对象中的值，但我们实例的实际结构是`this.data.propertyName`或`this.methods.methodName`；所有这些都是由于Vue代理了我们实例的属性。
- en: Let's take a very simple Vue application that has one instance. We have a `data`
    object that has a `message` variable and a method named `showAlert`; how does
    Vue know how to access our alert text with `this.message`?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个非常简单的Vue应用程序，它只有一个实例。我们有一个`data`对象，其中有一个`message`变量和一个名为`showAlert`的方法；Vue是如何知道如何通过`this.message`访问我们的警报文本的呢？
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Vue proxies the instance properties to the top level object, allowing us to
    access these properties via this. If we were to log out the instance to the console
    (with the help of Vue.js devtools), we''d get the following result:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Vue将实例属性代理到顶层对象，使我们能够通过`this`访问这些属性。如果我们将实例记录到控制台（借助Vue.js开发工具），我们会得到以下结果：
- en: '![](assets/41cc6781-067d-452c-8da3-53bb10569abb.png)Console logout'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/41cc6781-067d-452c-8da3-53bb10569abb.png)控制台输出'
- en: The key properties to look at within the preceding screenshot are `message`
    and `showAlert`, both of which are defined on our Vue instance yet proxied to
    the root object instance at initialization time.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中要查看的关键属性是`message`和`showAlert`，它们都在我们的Vue实例上定义，但在初始化时被代理到根对象实例。
- en: Data properties
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据属性
- en: 'When we add a variable to our data object, we''re essentially creating a reactive
    property that updates the view any time it changes. This means that, if we had
    a data object with a property named `firstName`, that property would be re-rendered
    on the screen each time the value changes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向数据对象添加一个变量时，实质上是创建了一个响应式属性，它会在任何更改时更新视图。这意味着，如果我们有一个数据对象，其中有一个名为`firstName`的属性，那么每次该值更改时，该属性都会在屏幕上重新渲染：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This reactivity does not extend to objects added to our Vue instance after
    the instance has been created outside of the data object. If we had another example
    of this, but this time including appending another property such as `fullName`
    to the instance itself:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种响应性不会扩展到在数据对象之外创建的对象添加到我们的Vue实例之后。如果我们有另一个例子，但这次包括将另一个属性（如`fullName`）附加到实例本身：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Even though this item is on the root instance (the same as our `firstName` variable),
    `fullName` is not reactive and will not re-render upon any changes. This does
    not work because, when the Vue instance is initialized, it maps over each one
    of the properties and adds a getter and setter to each data property, thus, if
    we add a new property after initialization, it lacks this and is not reactive.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个项目在根实例上（与我们的`firstName`变量一样），`fullName`也不是响应式的，不会在任何更改时重新渲染。这是因为当Vue实例初始化时，它会遍历每个属性并为每个数据属性添加getter和setter，因此，如果我们在初始化后添加一个新属性，它就缺少了这个并且不是响应式的。
- en: 'How does Vue achieve reactive properties? Currently, it uses `Object.defineProperty`
    to define a custom getter/setter for items inside of the instance. Let''s create
    our own property on an object with standard `get`/`set` features:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Vue如何实现响应式属性？目前，它使用`Object.defineProperty`为实例内的项目定义自定义getter/setter。让我们在具有标准`get`/`set`功能的对象上创建自己的属性：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As the watchers are set with a custom property setter/getter, merely adding
    a property to the instance after initialization doesn't allow for reactivity.
    This is likely to change within Vue 3 as it will be using the newer ES2015+ Proxy
    API (but potentially lacking support for older browsers).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于观察者是使用自定义属性的setter/getter设置的，因此在初始化后仅仅添加一个属性到实例中并不会实现响应性。这可能会在Vue 3中发生变化，因为它将使用更新的ES2015+
    Proxy API（但可能缺乏对旧版浏览器的支持）。
- en: There's more to our Vue instance than a data property! Let's use computed to
    create reactive, derived values based on items inside of our data model.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Vue实例不仅仅是一个数据属性！让我们使用计算属性来创建基于数据模型内项目的响应式派生值。
- en: Computed properties
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性
- en: In this section, we'll be looking at computed properties within our Vue instance.
    This allows us to create small, declarative functions that return a singular value
    based on items inside of our data model. Why is this important? Well, if we kept
    all of our logic inside of our templates, both our team members and our future
    self would have to do more work to understand what our application does.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看Vue实例中的计算属性。这使我们能够创建基于数据模型内项目的小型声明性函数，返回一个基于数据模型内项目的单一值。为什么这很重要？如果我们将所有逻辑都放在模板内，我们的团队成员和未来的自己都需要更多的工作来理解我们的应用程序在做什么。
- en: Therefore, we can use computed properties to vastly simplify our templates and
    create variables that we can reference instead of the logic itself. It goes further
    than an abstraction; computed properties are cached and will not be recalculated
    unless a dependency has changed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用计算属性来大大简化我们的模板，并创建我们可以引用的变量，而不是逻辑本身。它不仅仅是一个抽象；计算属性是被缓存的，并且只有在依赖项发生变化时才会重新计算。
- en: 'Let''s create a simple project to see this in action:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的项目来看看它的实际效果：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Interpolation is powerful; for example, inside of our Vue.js templates we can
    take a string (for example, `firstName`) and reverse this using the `reverse()`
    method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 插值是强大的；例如，在我们的 Vue.js 模板中，我们可以使用 `reverse()` 方法来取一个字符串（例如，`firstName`）并将其反转：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We'll now be showing a reversed version of our `firstName`, so Paul would become
    luaP. The issue with this is that it's not very practical to keep logic inside
    of our templates. If we'd like to reverse multiple fields, we have to then add
    another `split()`, `reverse()`, and `join()` on each property. To make this more
    declarative, we can use computed properties.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将展示一个反转后的 `firstName`，所以 Paul 将变成 luaP。这样做的问题在于，在模板中保留逻辑并不是非常实际的。如果我们想要反转多个字段，我们必须在每个属性上添加另一个
    `split()`、`reverse()` 和 `join()`。为了使这更具声明性，我们可以使用计算属性。
- en: 'Inside of `App.vue`, we can add a new computed object, that contains a function
    named `reversedName`; this takes our logic for reversing our string and allows
    us to abstract this into a function containing logic that would otherwise pollute
    the template:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.vue` 中，我们可以添加一个新的计算对象，其中包含一个名为 `reversedName` 的函数；这个函数包含了我们反转字符串的逻辑，并允许我们将其抽象成一个包含逻辑的函数，否则会污染模板：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We could then see more information about our computed properties within Vue.js
    devtools:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在 Vue.js devtools 中看到关于我们计算属性的更多信息：
- en: '![](assets/016c15d1-b6a4-4798-a04f-f37bcdc56ba3.png)Using devtools to display
    data'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/016c15d1-b6a4-4798-a04f-f37bcdc56ba3.png)使用 devtools 显示数据'
- en: In our simple example, it's important to realize that, while we could make this
    a method, there are reasons why we should keep this as a computed property. Computed
    properties are cached and are not re-rendered unless their dependency changes,
    which is especially important if we have a larger data-driven application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单例子中，重要的是要意识到，虽然我们可以将这个方法，但是有理由将其保留为一个计算属性。计算属性是被缓存的，除非它们的依赖项发生了变化，它们不会被重新渲染，这在我们有一个更大的数据驱动应用程序时尤其重要。
- en: Watched properties
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视属性
- en: Computed properties are not always the answer to our reactive data problems,
    sometimes we need to create our own custom watched properties. Computed properties
    can only be synchronous, must be pure (for example, no observed side-effects),
    and return a value; this is in direct contrast to a watched property, which is
    often used to deal with asynchronous data.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性并不总是解决我们的响应式数据问题的答案，有时我们需要创建自己的自定义监视属性。计算属性只能是同步的，必须是纯的（例如，没有观察到的副作用），并且返回一个值；这与监视属性形成了鲜明对比，后者通常用于处理异步数据。
- en: 'A watched property allows us to reactively execute a function whenever a piece
    of data changes. This means that we can call a function every time an item from
    our data object changes, and we''ll have access to this changed value as a parameter.
    Let''s take a look at this with a simple example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被监视的属性允许我们在数据改变时反应性地执行一个函数。这意味着我们可以在数据对象中的每个项目改变时调用一个函数，并且我们将可以访问到这个改变的值作为参数。让我们通过一个简单的例子来看一下：
- en: 'Note: `Axios` is a library that will need to be added to the project. To do
    so, head to [https://github.com/axios/axios](https://github.com/axios/axios) and
    follow the installation steps provided.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`Axios` 是一个需要添加到项目中的库。要这样做，前往 [https://github.com/axios/axios](https://github.com/axios/axios)
    并按照提供的安装步骤进行操作。
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this example, any time our text box changes with a new `id` (1-10), we get
    information about that particular user, like so:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每当我们的文本框使用新的`id`（1-10）更改时，我们会得到关于特定用户的信息，如下所示：
- en: '![](assets/63948d07-5f10-4348-ab27-e44f5bc310e8.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63948d07-5f10-4348-ab27-e44f5bc310e8.png)'
- en: This is effectively watching for any changes on the `id` and calling the `getDataForUser`
    method, retrieving new data about this user.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是在监视`id`上的任何更改，并调用`getDataForUser`方法，检索有关此用户的新数据。
- en: Although watched properties do have a lot of power, the benefits of computed
    properties on performance and ease of use should not be understated; therefore
    wherever possible, favor computed properties over watched properties.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管观察属性确实具有很大的威力，但计算属性在性能和易用性方面的好处不容忽视；因此，在可能的情况下，应优先选择计算属性而不是观察属性。
- en: Lifecycle hooks
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期钩子
- en: We have access to a variety of lifecycle hooks that fire at particular points
    during the creation of our Vue instance. These hooks range from prior to creation
    with `beforeCreate`, to after the instance is `mounted`, `destroyed`, and many
    more in between.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以访问各种生命周期钩子，在创建Vue实例的过程中的特定时刻触发。这些钩子从`beforeCreate`到实例`mounted`、`destroyed`等等。
- en: As the following figure shows, the creation of a new Vue instance fires off
    functions at varying stages of the instance lifecycle.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，创建新的Vue实例会在实例生命周期的不同阶段触发函数。
- en: 'We''ll be looking at how we can activate these hooks within this section:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中看看如何激活这些钩子：
- en: '![](assets/1ad4f9ba-c04c-44f6-b6a5-3b6e4e297c38.png)Vue.js instance lifecycle
    hooks'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1ad4f9ba-c04c-44f6-b6a5-3b6e4e297c38.png)Vue.js实例生命周期钩子'
- en: 'Taking advantage of the lifecycle hooks ([https://vuejs.org/v2/guide/instance.html](https://vuejs.org/v2/guide/instance.html))
    can be done in a similar way to any other property on our Vue instance. Let''s
    take a look at how we can interact with each one of the hooks, starting from the
    top; I''ll be creating another project based on the standard `webpack-simple`
    template:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 利用生命周期钩子（[https://vuejs.org/v2/guide/instance.html](https://vuejs.org/v2/guide/instance.html)）可以以与Vue实例上的任何其他属性类似的方式完成。让我们看看如何与每个钩子交互，从顶部开始；我将基于标准的`webpack-simple`模板创建另一个项目：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice how we''ve simply added these functions to our instance without any
    extra imports or syntax. We then get two different log statements in our console,
    one prior to the creation of our instance and one after it has been created. The
    next stage for our instance is the `beforeMounted` and `mounted` hooks; if we
    add these, we''ll be able to see a message on the console once again:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只是将这些函数添加到我们的实例中，而没有任何额外的导入或语法。然后我们在控制台中得到两个不同的日志声明，一个是在创建实例之前，另一个是在创建之后。我们实例的下一个阶段是`beforeMounted`和`mounted`钩子；如果我们添加这些，我们将能够再次在控制台上看到一条消息：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we then modified our template so it had a button that updated one of our
    data properties, we''d be able to fire a `beforeUpdated` and `updated` hook:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改模板，使其具有更新我们的数据属性的按钮，我们将能够触发`beforeUpdated`和`updated`钩子：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Whenever we select the `Update Message` button, our `beforeUpdated` and `updated`
    hooks both fire. This allows us to perform an action at this stage in the lifecycle,
    leaving us only with `beforeDestroy` and destroyed yet to cover. Let''s add a
    button and a method to our instance that call `$destroy`, allowing us to trigger
    the appropriate lifecycle hook:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们选择`Update Message`按钮时，我们的`beforeUpdated`和`updated`钩子都会触发。这使我们能够在生命周期的这个阶段执行操作，只剩下`beforeDestroy`和`destroyed`尚未涵盖。让我们向我们的实例添加一个按钮和一个调用`$destroy`的方法，从而触发适当的生命周期钩子：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can then add the `remove` method to our instance, as well as the functions
    that allow us to capture the appropriate hooks:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将`remove`方法添加到我们的实例中，以及允许我们捕获适当的钩子的函数：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When we select the `destroy` instance button, the `beforeDestroy` and `destroy`
    lifecycle hooks will fire. This allows us to clean up any subscriptions or perform
    any other action(s) when destroying an instance. In a real-world scenario, lifecycle
    control should be left up to data-driven directives, such as `v-if` and `v-for`.
    We'll be looking at these directives in more detail in the next chapter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择`destroy`实例按钮时，`beforeDestroy`和`destroy`生命周期钩子将触发。这使我们能够在销毁实例时清理任何订阅或执行任何其他操作。在实际场景中，生命周期控制应该交给数据驱动的指令，比如`v-if`和`v-for`。我们将在下一章更详细地讨论这些指令。
- en: Vue.js and the Virtual DOM
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js和虚拟DOM
- en: On the topic of performance improvements, let's consider why Vue.js makes extensive
    use of the Virtual DOM to render our elements on the screen. Before looking at
    the Virtual DOM, we need to have a foundational understanding of what the DOM
    actually is.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能改进方面，让我们考虑为什么Vue.js广泛使用虚拟DOM来在屏幕上呈现我们的元素。在看虚拟DOM之前，我们需要对DOM的实际含义有一个基本的理解。
- en: DOM
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM
- en: 'The DOM is what is used to describe the structure of an HTML or XML page. It
    creates a tree-like structure that provides us with the ability to do everything
    from creating, reading, updating, and deleting nodes to traversing the tree and
    many more features, all within JavaScript. Let''s consider the following HTML
    page:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: DOM用于描述HTML或XML页面的结构。它创建了一个类似树状的结构，使我们能够在JavaScript中进行创建、读取、更新和删除节点以及遍历树等许多功能。让我们考虑以下HTML页面：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We''re able to look at the HTML and see that we have one **div**, two **p**,
    one **ul**, and **li** tags. The browser parses this HTML and produces the DOM
    Tree, which at a high level looks similar to this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看HTML，看到我们有一个**div**，两个**p**，一个**ul**和**li**标签。浏览器解析这个HTML并生成DOM树，高层次上看起来类似于这样：
- en: '![](assets/cb087b90-2dfe-4994-ab62-1da34db49db7.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb087b90-2dfe-4994-ab62-1da34db49db7.jpg)'
- en: 'We can then interact with the DOM to get access to these elements by `TagName`
    using `document.getElementsByTagName()`, returning a HTML collection. If we wanted
    to map over these collection objects, we could create an array of these elements
    using `Array.from`. The following is an example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以与DOM交互，通过`document.getElementsByTagName()`按`TagName`获取这些元素的访问权限，返回一个HTML集合。如果我们想要映射这些集合对象，我们可以使用`Array.from`创建一个这些元素的数组。以下是一个例子：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This should then log the `innerHTML` of each item to the console inside of
    our array(s), thus showing how we can access items inside of the DOM:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这样应该会在我们的数组中将每个项目的`innerHTML`记录到控制台中，从而显示我们如何访问DOM中的项目：
- en: '![](assets/dda3c743-af98-4890-90ef-62707cec011e.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dda3c743-af98-4890-90ef-62707cec011e.png)'
- en: Virtual DOM
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟DOM
- en: Updating DOM nodes is computationally expensive and depending on the size of
    your application, this can substantially slow down the performance of your application.
    The Virtual DOM takes the concept of the DOM and provides us an abstraction, which
    allows for a diffing algorithm to be used to update DOM nodes. To fully take advantage
    of this, these nodes are no longer accessed with the document prefix and instead
    are often represented as JavaScript objects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 更新DOM节点的计算成本很高，取决于应用程序的大小，这可能会大大降低应用程序的性能。虚拟DOM采用了DOM的概念，并为我们提供了一个抽象，允许使用差异算法来更新DOM节点。为了充分利用这一点，这些节点不再使用document前缀访问，而是通常表示为JavaScript对象。
- en: This allows Vue to work out exactly *what* changed and only re-render items
    in the actual DOM that is different from the previous.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Vue能够准确地确定*什么*发生了变化，并且只重新渲染与之前不同的实际DOM中的项目。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned more about the Vue instance and how we can take
    advantage of a variety of property types such as data, watchers, computed values,
    and more. We've learned about how `this` works in JavaScript and the differences
    when using it inside of a Vue instance. Furthermore, we've investigated the DOM
    and why Vue uses the Virtual DOM to create performant applications.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更多地了解了Vue实例以及如何利用各种属性类型，如数据、监视器、计算值等。我们了解了JavaScript中`this`的工作原理，以及在Vue实例中使用它时的区别。此外，我们还调查了DOM以及Vue为什么使用虚拟DOM来创建高性能应用程序。
- en: In summary, data properties allow for reactive properties within our templates,
    computed properties allow us to take our template and filtering logic and separate
    it into performant properties that can be accessed within our templates, and watched
    properties allow us to work with the complexities of asynchronous operations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，数据属性允许我们在模板中使用响应式属性，计算属性允许我们将模板和过滤逻辑分离成可在模板中访问的高性能属性，而监视属性则允许我们处理异步操作的复杂性。
- en: In the next chapter, we'll be taking an in-depth look at Vue directives, such
    as `v-if`, `v-model`, `v-for`, and how they can be used to create powerful reactive
    applications.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究Vue指令，比如`v-if`、`v-model`、`v-for`，以及它们如何用于创建强大的响应式应用程序。
