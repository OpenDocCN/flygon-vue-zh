- en: Chapter 2. Fundamentals – Installing and Using
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章.基础知识-安装和使用
- en: In the previous chapter, we gained some familiarity with Vue.js. We were able
    to use it in two different applications that we created from scratch. We learned
    how to integrate Vue.js into an already existing project. We were able to see
    Vue's reactive data binding in action.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们对Vue.js有了一些了解。我们能够在两个不同的应用程序中使用它，这两个应用程序是从头开始创建的。我们学会了如何将Vue.js集成到已经存在的项目中。我们能够看到Vue的响应式数据绑定是如何运作的。
- en: 'Now, you are probably asking yourself: how does it work? What does it do to
    achieve this behavior of fast UI changes when the data model is changed? Probably,
    you decided to use Vue.js in your project and are now wondering whether it follows
    some architectural pattern or paradigm so that you should adopt it in your project.
    In this chapter, we will explore the key concepts of the Vue.js framework to understand
    all its behind the scenes features. Also in this chapter, we will analyze all
    the possible ways of installing Vue.js. We will also create a skeleton for our
    applications, which we will develop and enhance through the next chapters. We
    will also learn ways of debugging and testing our applications.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会问自己：它是如何工作的？在数据模型发生变化时，它是如何实现快速UI变化的行为？也许，你决定在你的项目中使用Vue.js，并且现在想知道它是否遵循某种架构模式或范式，以便你应该在你的项目中采用它。在本章中，我们将探讨Vue.js框架的关键概念，以了解其所有幕后功能。此外，在本章中，我们将分析安装Vue.js的所有可能方式。我们还将为我们的应用程序创建一个骨架，我们将通过接下来的章节来开发和增强它。我们还将学习调试和测试我们应用程序的方法。
- en: 'So, in this chapter, we are going to learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将学习：
- en: What the MVVM architecture paradigm is and how it applies to Vue.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM架构范式是什么，以及它如何应用于Vue.js
- en: What declarative Views are
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是声明式视图
- en: How Vue.js explores defined properties, getters, and setters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js如何探索定义的属性、getter和setter
- en: How reactivity and data binding works in Vue.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js中响应性和数据绑定的工作原理
- en: What dirty checking, DOM, and virtual DOM are
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是脏检查、DOM和虚拟DOM
- en: The main differences between Vue.js 1.0 and Vue.js 2.0
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js 1.0和Vue.js 2.0之间的主要区别
- en: What reusable components are
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用组件是什么
- en: How plugins, directives, custom plugins, and custom directives work in Vue.js
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js中插件、指令、自定义插件和自定义指令的工作原理
- en: How to install, start, run, and debug a Vue application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装、启动、运行和调试Vue应用程序
- en: MVVM architectural pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM架构模式
- en: 'Do you remember how we were creating the `Vue` instance in the first chapter?
    We were instantiating it calling `new Vue({...})`. You also remember that in the
    options, we were passing the element on the page where this `Vue` instance should
    be bound and the `data` object that contained the properties we wanted to bind
    to our View. The `data` object is our Model and the DOM element where the `Vue`
    instance is bound is our View:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在第一章中如何创建`Vue`实例吗？我们通过调用`new Vue({...})`来实例化它。你还记得在选项中，我们传递了页面上应该绑定这个`Vue`实例的元素，以及包含我们想要绑定到我们视图的属性的`data`对象。`data`对象是我们的模型，而`Vue`实例绑定的DOM元素是我们的视图：
- en: '![MVVM architectural pattern](../Images/image00239.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![MVVM架构模式](../Images/image00239.jpeg)'
- en: Classic View-Model representation where the Vue instance binds one to another
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的视图-模型表示，其中Vue实例将一个绑定到另一个
- en: 'In the meantime, our `Vue` instance is something that helps to bind our Model
    to the View and vice versa. Our application thus follows **Model-View-ViewModel**
    (**MVVM**) pattern, where the `Vue` instance is a ViewModel:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们的`Vue`实例是帮助将我们的模型绑定到视图以及反之的东西。因此，我们的应用程序遵循**模型-视图-视图模型**（**MVVM**）模式，其中`Vue`实例是视图模型：
- en: '![MVVM architectural pattern](../Images/image00240.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![MVVM架构模式](../Images/image00240.jpeg)'
- en: The simplified diagram of the Model-View-ViewModel pattern
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-视图模型模式的简化图表
- en: Our **Model** contains data and some business logic, and our **View** is responsible
    for its representation. **ViewModel** handles data binding, ensuring that the
    data changed in the **Model** is immediately affecting the **View** layer and
    vice versa.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**Model**包含数据和一些业务逻辑，我们的**View**负责其表示。**ViewModel**处理数据绑定，确保在**Model**中更改的数据立即影响**View**层，反之亦然。
- en: Our Views thus become completely data driven. **ViewModel** becomes responsible
    for the control of the data flow, making data binding fully declarative for us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的视图完全是数据驱动的。**ViewModel**负责控制数据流，使数据绑定对我们来说完全是声明性的。
- en: DefineProperty, getters, and setters
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DefineProperty、getter和setter
- en: So, what happens with the data once passed to the `Vue` instance? What are these
    transformations that `Vue` applies to it so that it becomes so automatically bound
    to the View layer?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一旦数据传递给`Vue`实例，会发生什么？`Vue`对其应用了哪些转换，使其自动绑定到View层？
- en: Let's analyze what would we do if we had, let's say, a string, and every time
    it changes we would like to apply some transformations to some DOM element. How
    would we apply the string-changing listener function? To what would we attach
    it? There is no such thing as `var stringVar='hello';stringVar.onChange(doSomething)` .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下，如果我们有一个字符串，每次它改变时，我们想对某个DOM元素应用一些转换，我们会怎么做。我们会如何应用字符串更改的监听函数？我们会将它附加到什么上？没有`var
    stringVar='hello';stringVar.onChange(doSomething)`这样的东西。
- en: So we would probably wrap the string's value setting and getting in some sort
    of function that would do something, for example, updating the DOM each time the
    string was updated. How would you implement it? While you're thinking about it,
    I'll prepare a quick demo of something interesting.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可能会将字符串的值设置和获取包装在某种函数中，该函数会做一些事情，例如每次字符串更新时更新DOM。你会如何实现它？当你考虑这个问题时，我会准备一个有趣的快速演示。
- en: 'Open the developer tools on your shopping list application. Let''s code a little
    bit. Create an `obj` variable and another `text` variable:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的购物清单应用程序的开发者工具。让我们写一点代码。创建一个`obj`变量和另一个`text`变量：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s store the DOM element `h2` in a variable:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将DOM元素`h2`存储在一个变量中：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we assign `text` to the `obj.text` property, how can we achieve that in every
    change of this property the `innerHTML` of `h2` would change as well?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`text`分配给`obj.text`属性，如何才能在每次更改此属性时，`h2`的`innerHTML`也会相应更改？
- en: Let's use the `Object.defineProperty` method ( [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)
    ).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Object.defineProperty`方法（[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)）。
- en: 'This method allows the creation of getter and setter functions, thus specifying
    what must happen when the property is accessed or changed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法允许创建getter和setter函数，从而指定在访问或更改属性时必须发生什么：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now try to change the `obj.text` property from the console. Look at the title:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试从控制台更改`obj.text`属性。看看标题：
- en: '![DefineProperty, getters, and setters](../Images/image00241.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![DefineProperty, getter和setter](../Images/image00241.jpeg)'
- en: The set method of object.defineProperty is called every time the property changes
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每次属性更改时都会调用对象.defineProperty的set方法
- en: 'This exact mechanism was used by Vue.js. Once the data are passed to the `Vue`
    instance, all its properties go through the `Object.defineProperty` method, which
    assigns reactive getters and setters to them. For each directive existing on a
    page, a watcher is added, which is being notified within the `set` method. Open
    the `vue.js` code in the console and search for the line that says `set: function
    reactiveSetter(newVal)`. Add a breakpoint and try to change the title of the shopping
    list in the input. Now step over until you reach the last call in this function
    that says `dep.notify()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '这个确切的机制被Vue.js使用过。一旦数据被传递给`Vue`实例，它的所有属性都会通过`Object.defineProperty`方法，为它们分配响应式的getter和setter。对于页面上存在的每个指令，都会添加一个观察者，它会在`set`方法中被通知。在控制台中打开`vue.js`代码，并搜索一下说`set:
    function reactiveSetter(newVal)`的那一行。添加一个断点，尝试在输入框中更改购物清单的标题。现在一步步执行，直到达到这个函数中的最后一个调用，它说`dep.notify()`：'
- en: '![DefineProperty, getters, and setters](../Images/image00242.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![DefineProperty, getters, and setters](../Images/image00242.jpeg)'
- en: Breakpoint inside the setter function that calls the watchers notify method
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用观察者通知方法的setter函数内部设置断点
- en: Step into the function. You will see that this function is iterating through
    the watchers of the property and updates them. If you step over this call, you
    will see that the DOM is not being updated. This is because the updates performed
    on the same event loop are being put into the queue that is being flushed periodically.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 进入这个函数。你会看到这个函数正在遍历属性的观察者并更新它们。如果你跳过这个调用，你会发现DOM没有被更新。这是因为在同一个事件循环中执行的更新被放入了定期刷新的队列中。
- en: 'Find the `runBatcherQueue` function and put a breakpoint inside it. Try to
    change the title again. As you can see, this function iterates through all the
    watchers that are waiting inside the queue and calls the `run` method on each
    of them. If you step into this method, you will see that it compares the new value
    with the previous one:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`runBatcherQueue`函数并在其中设置一个断点。再次尝试更改标题。你会看到这个函数遍历了所有等待在队列中的观察者，并在每个观察者上调用`run`方法。如果你进入这个方法，你会看到它将新值与先前的值进行比较：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It then it calls a callback''s execution:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它调用了回调的执行：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you step into this callback function, you will see that in the end, it will
    finally update the DOM value:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入这个回调函数，你会看到最终它会更新DOM的值：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Isn't it simple?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很简单吗？
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意：
- en: In this debugging Vue version 1.0 is used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调试中使用的是Vue版本1.0。
- en: 'So the mechanism behind the Vue.js reactive data binding is very simple. **Watchers**
    are being assigned to all the directives and data properties. Then, during the
    `set` method of `Object.defineProperty`, the **Watchers** are notified and, in
    turn, they update the corresponding **DOM** or **data**:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以Vue.js响应式数据绑定背后的机制非常简单。观察者被分配给所有的指令和数据属性。然后，在`Object.defineProperty`的`set`方法中，观察者被通知，然后它们更新相应的DOM或数据：
- en: '![DefineProperty, getters, and setters](../Images/image00243.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![DefineProperty, getters, and setters](../Images/image00243.jpeg)'
- en: The data flow from the data object to the DOM
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据对象到DOM的数据流
- en: '**DOM** elements that have directives have attached listeners that listen to
    their updates and call the corresponding **data** property setter that, in turn,
    wakes up its **Watchers**.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 具有指令的DOM元素附加了监听器，监听它们的更新并调用相应的数据属性setter，然后唤醒它们的观察者。
- en: Comparing with other frameworks
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他框架相比
- en: 'When you try a new tool, you want to know how it compares with other tools
    or frameworks. You can find a deep analysis in this regard on the official page
    of Vue.js: [http://vuejs.org/guide/comparison.html](http://vuejs.org/guide/comparison.html)
    . I will just point to some topics that I find important regarding the mostly
    used frameworks.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试一个新的工具时，你想知道它与其他工具或框架相比如何。你可以在Vue.js的官方页面上找到关于这方面的深入分析：[http://vuejs.org/guide/comparison.html](http://vuejs.org/guide/comparison.html)。我只会指出一些我认为对于大多数使用的框架很重要的主题。
- en: React
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React
- en: React and Vue are really similar. They both use virtual DOM, have reusable components,
    and are about reactive data. It is worth mentioning, however, that Vue only uses
    virtual DOM starting from its second major version. Prior to Vue 2.0, it used
    real DOM. The Vue 2.0 release not only became more performant than Vue 1.0 but
    it also became more performant than React ( [http://vuejs.org/guide/comparison.html#Performance-Profiles](http://vuejs.org/guide/comparison.html#Performance-Profiles)
    ).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: React和Vue非常相似。它们都使用虚拟DOM，具有可重用的组件，并且都是关于反应性数据。然而，值得一提的是，Vue只从其第二个主要版本开始使用虚拟DOM。在Vue
    2.0之前，它使用真实的DOM。Vue 2.0发布不仅比Vue 1.0更高效，而且比React更高效（[http://vuejs.org/guide/comparison.html#Performance-Profiles](http://vuejs.org/guide/comparison.html#Performance-Profiles)）。
- en: The most significant difference is probably the way you create your components
    in both frameworks. You might already know that in React, everything is JavaScript.
    Developing everything, even templates, in JavaScript, can actually be good, so
    programmers are always in the same scope and rendering becomes more flexible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的区别可能是两个框架中如何创建组件的方式。你可能已经知道在React中，一切都是JavaScript。即使是模板，也是用JavaScript开发的，这实际上可能是好的，因此程序员总是在相同的范围内，渲染变得更加灵活。
- en: 'However, for some designers who want to do rapid prototyping or for developers
    with not-so-strong programming skills, or for people who simply don''t want to
    learn JSX, it might become really painful to work like this. In Vue components,
    you can actually also use JSX, but you can still follow a common web development
    structure: writing CSS inside the `<style>` tags, writing HTML code inside the
    `<template>` tags, and writing the component''s logic in JavaScript inside the
    `<script>` tags. Compare, for example, the template inside the render function
    in React and the template that you can write inside the Vue component. In this
    example, I will show how to render the list of items of the shopping list that
    we have seen before. So in React, you will end up with the JSX code similar to
    this one:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于一些想要进行快速原型设计的设计师，或者对编程技能不是很强的开发人员，或者只是不想学习JSX的人来说，这可能会变得非常痛苦。在Vue组件中，你实际上也可以使用JSX，但你仍然可以遵循常见的Web开发结构：在`<style>`标签内编写CSS，在`<template>`标签内编写HTML代码，在`<script>`标签内编写组件的逻辑。例如，比较一下React中渲染函数内的模板和你可以在Vue组件内编写的模板。在这个例子中，我将展示如何渲染我们之前看到的购物清单的项目列表。因此，在React中，你最终会得到类似于这样的JSX代码：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using Vue, you will just write the following HTML code inside the `template`
    tag:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue，你只需在`template`标签内写入以下HTML代码：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I, personally, like to have these things separated, thus I find it nice that
    Vue offers this possibility.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人喜欢将这些东西分开，因此我觉得Vue提供了这种可能性很好。
- en: 'Another nice thing about Vue is that it allows to scope style within the components
    using the `scoped` attribute attached to the `style` tag:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的另一个好处是它允许使用`scoped`属性附加到`style`标签来在组件内部限定样式：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Within this style, in case you use preprocessors, you still have access to all
    globally defined variables and can create or redefine styles that will be only
    accessible by this component.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种样式中，如果你使用预处理器，你仍然可以访问所有全局定义的变量，并且可以创建或重新定义只能由该组件访问的样式。
- en: It's also worth to mention the learning curve for both frameworks. To be able
    to start developing applications using React, you would probably have to learn
    JSX and ES2105 syntax, since most examples in official React documentation use
    it. With Vue, you can start out of the blue. Just include it in the page, like
    you would do with jQuery, and you can already use Vue models and data binding
    using pretty simple and easy to understand syntax, and any JavaScript version
    you like to use. After that, you can scale up in your learning and in your applications
    style.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，这两个框架的学习曲线。要开始使用React开发应用程序，您可能需要学习JSX和ES2105语法，因为官方React文档中的大多数示例都使用它。而对于Vue，您可以从零开始。只需将其包含在页面中，就像您使用jQuery一样，您就可以使用相当简单和易于理解的语法来使用Vue模型和数据绑定，以及您喜欢使用的任何JavaScript版本。之后，您可以在学习和应用程序风格上进行扩展。
- en: In case you want to perform a deeper analysis of both frameworks, have a look
    at the documentation, try to elaborate similar examples, and check what suits
    your needs more.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想对这两个框架进行更深入的分析，请查看文档，尝试阐述类似的例子，并检查哪个更适合您的需求。
- en: Angular
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular
- en: There is a huge difference between Angular 1 and Angular 2\. We all know that
    the second version of Angular is completely different from its predecessor. It
    offers more performance, the API is different, and the underlying implementation
    has been rewritten.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 1和Angular 2之间有很大的区别。我们都知道，Angular的第二个版本与其前身完全不同。它提供了更高的性能，API也不同，并且底层实现已经被重写。
- en: These two versions are so different that in Vue official documentation, you
    will find the comparison between both the Angular versions as it was between two
    different frameworks. However, the learning curve and the way in which each of
    the frameworks forces you to structure the application are transversal for both
    the Angular versions. It turns out that Vue is much less opinionated than Angular
    1 as well as Angular 2\. Just compare Angular's quick start guide and Vue's hello
    world applications at [https://angular.io/docs/js/latest/quickstart.html](https://angular.io/docs/js/latest/quickstart.html)
    and [http://vuejs.org/guide/index.html#Hello-World](http://vuejs.org/guide/index.html#Hello-World)
    .
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个版本的区别如此之大，以至于在Vue的官方文档中，您会发现对比两个Angular版本的比较，就像对比两个不同的框架一样。然而，学习曲线以及每个框架强制您构建应用程序的方式对于两个Angular版本都是横跨的。事实证明，Vue比Angular
    1和Angular 2都不那么武断。只需比较一下Angular的快速入门指南和Vue的hello world应用程序，就可以看出这一点。[https://angular.io/docs/js/latest/quickstart.html](https://angular.io/docs/js/latest/quickstart.html)
    和 [http://vuejs.org/guide/index.html#Hello-World](http://vuejs.org/guide/index.html#Hello-World)
    。
- en: '|   | *"Even without TypeScript, Angular''s Quickstart guide starts out with
    an app that uses ES2015 JavaScript, NPM with 18 dependencies, 4 files, and over
    3,000 words to explain it all - just to say Hello World."* |   |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|   | *"即使没有TypeScript，Angular的快速入门指南也从一个使用ES2015 JavaScript、NPM的应用程序开始，有18个依赖项，4个文件，超过3000个字来解释这一切
    - 只是为了说Hello World。"* |   |'
- en: '|   | --*http://vuejs.org/guide/comparison.html#Learning-Curve* |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|   | --*http://vuejs.org/guide/comparison.html#Learning-Curve* |'
- en: If you still use Angular 1, it's worth to mention that the big difference between
    this framework and Vue is that in this version of Angular, each time the scope
    changed, re-evaluated all the watchers, thus performing dirty checking, hence
    reducing the performance when the amount of watchers became considerably high.
    Hence, in Vue, when something in the scope changes, only this property's watcher
    is being re-evaluated. All others are sitting idle and waiting for their respective
    calls.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍在使用Angular 1，值得一提的是，这个框架与Vue之间的重大区别在于，在这个版本的Angular中，每次作用域发生变化时，都会重新评估所有的观察者，从而执行脏检查，因此当观察者的数量变得相当高时，性能会降低。因此，在Vue中，当作用域中的某些内容发生变化时，只有这个属性的观察者会被重新评估。其他观察者都会保持空闲，等待它们各自的调用。
- en: Vue
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue
- en: No, it is not a typo. It is also worth comparing Vue with Vue. Vue has also
    recently launched its second version, which is faster and cleaner than its predecessor.
    If you still use Vue 1.0, it is worth to upgrade. If you don't know anything about
    Vue versions, it is worth to check how it evolved and what does the new version
    allow. Check the Vue blog post that announced Vue 2.0 in April 2016 at [https://vuejs.org/2016/04/27/announcing-2.0/](https://vuejs.org/2016/04/27/announcing-2.0/)
    .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不是打字错误。值得一提的是，Vue也值得与Vue进行比较。Vue最近推出了它的第二个版本，比起前身更快更干净。如果你仍在使用Vue 1.0，值得升级。如果你对Vue的版本一无所知，值得了解它的发展以及新版本允许做什么。查看Vue在2016年4月发布Vue
    2.0的博客文章[https://vuejs.org/2016/04/27/announcing-2.0/](https://vuejs.org/2016/04/27/announcing-2.0/)。
- en: Vue.js fundamentals
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js基础知识
- en: Before putting our hands into the code and starting to enhance our applications
    with components, plugins, mixins, templates, and other things, let's overview
    the main Vue features. Let's analyze what are reusable components and how the
    application state can be managed, and also talk about plugins, filters, and mixins.
    In this section, we will have just a slight overview of these features. We will
    learn them deeply in the next chapters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的手放入代码并开始用组件、插件、混合、模板和其他东西增强我们的应用程序之前，让我们回顾一下主要的Vue特性。让我们分析可重用组件是什么，以及如何管理应用程序状态，还谈论插件、过滤器和混合。在本节中，我们将对这些特性进行简要概述。我们将在接下来的章节中深入学习它们。
- en: Reusable components
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重用组件
- en: Now that you know not only what data binding in Vue.js is and how to use it,
    but also how it works, it is time to introduce another powerful Vue.js feature.
    Components created with Vue.js can be used and reused in the application as bricks
    you build your house of. Each component has its own scope of styles and bindings,
    being completely isolated from the other components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你不仅知道Vue.js中的数据绑定是什么以及如何使用它，还知道它是如何工作的，现在是时候介绍Vue.js的另一个强大特性了。使用Vue.js创建的组件可以在应用程序中被使用和重复使用，就像你用砖块建造房子一样。每个组件都有自己的样式和绑定范围，与其他组件完全隔离。
- en: 'The component creation syntax is very similar to the `Vue` instance creation
    that we already know, and you should only use `Vue.extend` instead of just `Vue`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 组件创建语法与我们已经了解的`Vue`实例创建非常相似，你只需要使用`Vue.extend`而不是`Vue`：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Reusable components](../Images/image00244.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![可重用组件](../Images/image00244.jpeg)'
- en: Custom components in Vue.js
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js中的自定义组件
- en: 'Let''s, for example, try to divide our shopping list code into components.
    As you remember, our shopping list consists essentially of three parts: the part
    that contains the shopping list item, another part that contains the input for
    adding new items, and the third part that allows changing the title of the shopping
    list:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们尝试将我们的购物清单代码分成组件。你记得，我们的购物清单基本上由三部分组成：包含购物清单项目的部分，包含添加新项目的输入的另一部分，以及允许更改购物清单标题的第三部分。
- en: '![Reusable components](../Images/image00245.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![可重用组件](../Images/image00245.jpeg)'
- en: Three essential parts of the shopping list application
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 购物清单应用程序的三个基本部分
- en: Let's change the code of the application so that it uses three components, one
    for each part.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改应用程序的代码，使其使用三个组件，每个部分一个组件。
- en: 'Our code was looking like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码看起来像下面这样：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we will create three components: `ItemsComponent`, `ChangeTitleComponent`,
    and `AddItemComponent`. All of them will have the `data` property with the `data`
    object. The `addItem` method will jump from the main `Vue` instance to `ChangeTitleComponent`.
    All the necessary HTML will go from our `index.html` file to each of the components.
    So in the end, our main script will look like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建三个组件：`ItemsComponent`、`ChangeTitleComponent` 和 `AddItemComponent`。它们都将具有带有
    `data` 对象的 `data` 属性。`addItem` 方法将从主 `Vue` 实例跳转到 `ChangeTitleComponent`。所有必要的
    HTML 将从我们的 `index.html` 文件转移到每个组件中。因此，最终，我们的主脚本将如下所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'How do we use these components inside the View? We should just replace the
    corresponding markup with the tag of the registered component. Our markup looked
    like the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在视图中使用这些组件？我们只需用注册组件的标签替换相应的标记。我们的标记看起来像下面这样：
- en: '![Reusable components](../Images/image00246.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![可重用组件](../Images/image00246.jpeg)'
- en: The shopping list application markup with defined components
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 具有定义组件的购物清单应用程序标记
- en: 'So, the first highlighted area we will replace with the `<add-item-component></add-item-component>`
    tag, the second one with the `<items-component></items-component>` tag, and the
    third one with the `<change-title-component></change-title-component>` tag. Thus,
    our previously huge markup now looks like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将用 `<add-item-component></add-item-component>` 标签替换第一个高亮区域，用 `<items-component></items-component>`
    标签替换第二个高亮区域，用 `<change-title-component></change-title-component>` 标签替换第三个高亮区域。因此，我们之前庞大的标记现在看起来像下面这样：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will go deeply into components in the next chapter and will learn an even
    nicer way of structuring them. Stay tuned!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章深入研究组件，并学习一种更好的组织方式。敬请关注！
- en: Vue.js directives
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue.js 指令
- en: You have already learned in the previous chapter what directives are and how
    they are used to enhance the application's behavior.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您已经学习了指令是什么，以及它们如何用于增强应用程序的行为。
- en: You've already used some directives that allow data binding in different ways
    to the View layer (`v-model`, `v-if`, `v-show`, and so on). Besides these default
    directives, Vue.js allows you to create custom directives. Custom directives provide
    a mechanism to enable custom behavior of DOM to data mapping.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用了一些指令，这些指令以不同的方式允许数据绑定到视图层（`v-model`、`v-if`、`v-show`等）。除了这些默认指令之外，Vue.js
    还允许您创建自定义指令。自定义指令提供了一种机制，可以实现 DOM 到数据的自定义映射行为。
- en: 'When registering a custom directive, you can provide three functions: `bind`,
    `update`, and `unbind`. Inside the `bind` function, you can attach an event listener
    to the element and do whatever needs to be done there. Inside the `update` function
    that receives old and new values as parameters, you can define a custom behavior
    of what should happen when data changes. The `unbind` method provides all the cleaning
    operations needed (for example, detach event listeners).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册自定义指令时，您可以提供三个函数：`bind`、`update` 和 `unbind`。在 `bind` 函数中，您可以将事件侦听器附加到元素，并在那里执行任何需要执行的操作。在接收旧值和新值作为参数的
    `update` 函数中，您可以定义数据更改时应该发生的自定义行为。`unbind` 方法提供了所有所需的清理操作（例如，分离事件侦听器）。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In Vue 2.0, directives have significantly reduced the scope of responsibility—now
    they are only used to apply low-level direct DOM manipulations. Vue's changing
    guide suggests to prefer using components over custom directives ( [https://github.com/vuejs/vue/issues/2873](https://github.com/vuejs/vue/issues/2873)
    ).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 2.0 中，指令显著减少了责任范围，现在它们只用于应用低级别的直接 DOM 操作。Vue 的变更指南建议优先使用组件而不是自定义指令（[https://github.com/vuejs/vue/issues/2873](https://github.com/vuejs/vue/issues/2873)）。
- en: 'Thus, the full version of the custom directive would look like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，自定义指令的完整版本将如下所示：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The simplified version, in case you just need to do something on the value
    update, can only have the `update` method that can be passed directly as the second
    parameter of the directive function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 简化版本，如果您只需要在值更新时执行某些操作，则只能具有`update`方法，该方法可以直接作为指令函数的第二个参数传递：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The theory is nice, but without a small example, it turns out boring. So let's
    have a look at a very simple example, which will show the square of the number
    each time its value is updated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 理论很好，但没有一个小例子，它就会变得无聊。所以让我们看一个非常简单的例子，每次更新其值时都会显示数字的平方。
- en: 'Our custom directive will look like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义指令将如下所示：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use this directive in your template file using the `v-` prefix:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板文件中使用`v-`前缀使用此指令：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Instantiate the `Vue` instance with `item` in its data and try to change the
    value of `item`. You will see that the value inside the `div` element will immediately
    display the square number of the changed value. The complete code for this custom
    directive can be found in the JSFiddle at [https://jsfiddle.net/chudaol/we07oxbd/](https://jsfiddle.net/chudaol/we07oxbd/)
    .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在其数据中实例化`Vue`实例，并尝试更改`item`的值。您会看到`div`元素内的值将立即显示更改后的值的平方数。此自定义指令的完整代码可以在JSFiddle上找到[https://jsfiddle.net/chudaol/we07oxbd/](https://jsfiddle.net/chudaol/we07oxbd/)。
- en: Plugins in Vue.js
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Vue.js中的插件
- en: 'Vue''s core functionality, as we have already analyzed, provides declarative
    data binding and components composing. This core behavior is enhanced with plugins
    that provide a rich set of functionality. There are several types of plugins:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的核心功能，正如我们已经分析的那样，提供了声明性数据绑定和组件组合。这种核心行为通过提供丰富功能的插件得到增强。有几种类型的插件：
- en: Plugins that add some global property or method (`vue-element`)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一些全局属性或方法（`vue-element`）的插件
- en: Plugins that add some global assets (`vue-touch`)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一些全局资源（`vue-touch`）的插件
- en: Plugins that add `Vue` instance methods attaching them to Vue's prototype
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`Vue`实例方法并将它们附加到Vue的原型上的插件
- en: Plugins that provide some external functionality or API (`vue-router`)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一些外部功能或API（`vue-router`）的插件
- en: Plugins must provide an `install` method that has access to the global `Vue`
    object that can enhance and modify it. In order to use this plugin, Vue provides
    the `use` method that receives plugins instances (`Vue.use(SomePlugin)`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 插件必须提供一个`install`方法，该方法可以访问全局`Vue`对象，以增强和修改它。为了使用此插件，Vue提供了`use`方法，该方法接收插件实例（`Vue.use(SomePlugin)`）。
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can also write a Vue plugin of your own to enable custom behavior for your
    `Vue` instance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编写自己的Vue插件，以启用对`Vue`实例的自定义行为。
- en: 'Let''s use the previous custom directives example and create a minimalistic
    plugin that implements mathematical square and square root directives. Create
    a file named `VueMathPlugin.js` and add the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用先前的自定义指令示例，并创建一个实现数学平方和平方根指令的简约插件。创建一个名为`VueMathPlugin.js`的文件，并添加以下代码：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now create a file called `script.js`. Let''s add the main script to this file.
    In this script, we will import both `Vue` and `VueMathPlugin`, and will call Vue''s
    `use` method in order to tell it to use the plugin and call the plugin''s `install`
    method. Then we''ll just initiate a `Vue` instance as we always do:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`script.js`的文件。让我们将主要脚本添加到此文件中。在此脚本中，我们将同时导入`Vue`和`VueMathPlugin`，并将调用Vue的`use`方法，以告诉它使用插件并调用插件的`install`方法。然后我们将像往常一样初始化一个`Vue`实例：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now create an `index.html` file that includes the `main.js` file (we will build
    it with Browserify and Babelify). In this file, let''s add an input using the
    `v-model` directive that will be used to change the value of the item. Create
    two spans using `v-square` and `v-sqrt` directives as well:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个包含`main.js`文件的`index.html`文件（我们将使用Browserify和Babelify构建它）。在这个文件中，让我们使用`v-model`指令添加一个输入，用于更改项目的值。使用`v-square`和`v-sqrt`指令创建两个span：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a `package.json` file to include the needed dependencies for building
    the project and add a script for building the `main.js` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`package.json`文件，包括构建项目所需的依赖项，并添加一个构建`main.js`文件的脚本：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now install the dependencies and build the project from the following command
    line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用以下命令安装依赖并构建项目：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open `index.html` in the browser. Try to change the number in the input box.
    Both square and square root values change immediately:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开`index.html`。尝试更改输入框中的数字。正方形和平方根的值都会立即改变：
- en: '![Plugins in Vue.js](../Images/image00247.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Vue.js中的插件](../Images/image00247.jpeg)'
- en: The changes in the data are applied immediately to the directives created as
    a part of custom plugin
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的更改立即应用于作为自定义插件的一部分创建的指令
- en: Exercise
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Enhance `MathPlugin` with trigonometrical functions (sine, cosine, and tangent).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三角函数（正弦、余弦和正切）增强`MathPlugin`。
- en: A possible solution to this exercise can be found in the *Annexes*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的可能解决方案可以在*附录*中找到。
- en: Application state and Vuex
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用状态和Vuex
- en: When an application reaches a considerable size, it might become necessary for
    us to manage the global application state somehow. Inspired from Flux ( [https://facebook.github.io/flux/](https://facebook.github.io/flux/)
    ), there is a Vuex module that allows us to manage and share the global application
    state among Vue components.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序达到相当大的规模时，可能需要我们以某种方式管理全局应用程序状态。受Flux（[https://facebook.github.io/flux/](https://facebook.github.io/flux/)）的启发，有一个Vuex模块，允许我们在Vue组件之间管理和共享全局应用程序状态。
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not think about the application state as something complex and difficult
    to understand. In fact, it is no more than just data. Each component has its own
    data, and "application state" is data that can be easily shared between all the
    components!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将应用程序状态视为复杂和难以理解的东西。实际上，它只不过是数据。每个组件都有自己的数据，“应用程序状态”是可以在所有组件之间轻松共享的数据！
- en: '![Application state and Vuex](../Images/image00248.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![应用状态和Vuex](../Images/image00248.jpeg)'
- en: How Vuex store manages applications state updates
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex存储库如何管理应用程序状态更新
- en: 'Like the other plugins, in order to be able to use and to instantiate the Vuex
    store, you need to instruct Vue to use it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他插件一样，为了能够使用和实例化Vuex存储库，您需要指示Vue使用它：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, when initializing the main component, assign the store instance to it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在初始化主组件时，将存储实例分配给它：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now the main application and all its components are aware about the store, have
    access to the data inside it, and are able to trigger actions on it at any time
    of the application's life cycle. We will dig deeply into the application state
    in the next chapters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，主应用程序及其所有组件都知道存储库，可以访问其中的数据，并能够在应用程序的任何生命周期中触发操作。我们将在接下来的章节中深入挖掘应用程序状态。
- en: vue-cli
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: vue-cli
- en: Yes, Vue has its own command-line interface. It allows us to initialize a Vue
    application with whatever configuration we want. You can initialize it with Webpack
    boilerplate, with Browserify boilerplate, or just with a simple boilerplate that
    just creates an HTML file and prepares everything for you to start working with
    Vue.js.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Vue有自己的命令行界面。它允许我们使用任何配置初始化Vue应用程序。您可以使用Webpack样板初始化它，使用Browserify样板初始化它，或者只是使用一个简单的样板，只需创建一个HTML文件并为您准备好一切，以便开始使用Vue.js进行工作。
- en: 'Install it with `npm`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm`安装它：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The different ways of initializing an application are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化应用程序的不同方式如下：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To see the difference, let''s run `vue init` with the simple template and with
    the Webpack template, and look at the differences in the generated structure.
    Following is how the output differs from both commands:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到区别，让我们分别使用简单模板和Webpack模板运行`vue init`，并查看生成结构的差异。以下是两个命令的输出差异：
- en: '![vue-cli](../Images/image00249.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![vue-cli](../Images/image00249.jpeg)'
- en: The output from the commands vue init webpack and vue init simple
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`vue init webpack`和`vue init simple`的输出
- en: 'The following is how the application structure differs:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用程序结构的不同之处：
- en: '![vue-cli](../Images/image00250.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![vue-cli](../Images/image00250.jpeg)'
- en: The difference in structure in application scaffolded with vue init simple and
    vue init webpack
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vue init simple`和`vue init webpack`脚手架生成的应用程序结构的不同之处
- en: The `index.html` file in the simple configuration already contains Vue.js from
    the CDN, so if you just need to do something really simple such as quick prototyping,
    use this one.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 简单配置中的`index.html`文件已经包含了来自CDN的Vue.js，所以如果你只需要做一些非常简单的事情，比如快速原型设计，就可以使用这个。
- en: But if you are about to start a complex **Single Page Application** (**SPA**)
    project that will require testing and hot reloading during development, use the
    Webpack or Browserify configuration.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你要开始一个需要在开发过程中进行测试和热重载的复杂**单页面应用程序**（**SPA**）项目，请使用Webpack或Browserify配置。
- en: Vue plugins for IDEs
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDE的Vue插件
- en: 'There are plugins for Vue syntax highlighting for some major IDEs. I will leave
    you with the links to the fanciest of them:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些主要IDE的Vue语法高亮插件。我会给你留下最潮的链接：
- en: '| **IDE** | **Link to the Vue plugin** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **IDE** | **链接到Vue插件** |'
- en: '| Sublime | [https://github.com/vuejs/vue-syntax-highlight](https://github.com/vuejs/vue-syntax-highlight)
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| Sublime | [https://github.com/vuejs/vue-syntax-highlight](https://github.com/vuejs/vue-syntax-highlight)
    |'
- en: '| Webstorm | [https://github.com/postalservice14/vuejs-plugin](https://github.com/postalservice14/vuejs-plugin)
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| Webstorm | [https://github.com/postalservice14/vuejs-plugin](https://github.com/postalservice14/vuejs-plugin)
    |'
- en: '| Atom | [https://github.com/hedefalk/atom-vue](https://github.com/hedefalk/atom-vue)
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| Atom | [https://github.com/hedefalk/atom-vue](https://github.com/hedefalk/atom-vue)
    |'
- en: '| Visual Studio Code | [https://github.com/LiuJi-Jim/vscode-vue](https://github.com/LiuJi-Jim/vscode-vue)
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| Visual Studio Code | [https://github.com/LiuJi-Jim/vscode-vue](https://github.com/LiuJi-Jim/vscode-vue)
    |'
- en: '| vim | [https://github.com/posva/vim-vue](https://github.com/posva/vim-vue)
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| vim | [https://github.com/posva/vim-vue](https://github.com/posva/vim-vue)
    |'
- en: '| Brackets | [https://github.com/pandao/brackets-vue](https://github.com/pandao/brackets-vue)
    |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| Brackets | [https://github.com/pandao/brackets-vue](https://github.com/pandao/brackets-vue)
    |'
- en: Installing, using, and debugging a Vue.js application
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装、使用和调试Vue.js应用程序
- en: In this section, we will analyze all the possible ways of installing Vue.js.
    We will also create a skeleton for our applications that we will develop and enhance
    through the next chapters. We will also learn the ways of debugging and testing
    our applications.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析安装Vue.js的所有可能方式。我们还将为我们将在接下来的章节中开发和增强的应用程序创建一个骨架。我们还将学习调试和测试我们的应用程序的方法。
- en: Installing Vue.js
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Vue.js
- en: There are a number of ways to install Vue.js. Starting from classic, including
    the downloaded script into HTML within the `<script>` tags, using tools like bower,
    npm, or Vue's command-line interface (`vue-cli`), to bootstrap the whole application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种安装Vue.js的方式。从经典的开始，包括将下载的脚本放入HTML的`<script>`标签中，使用诸如bower、npm或Vue的命令行接口（`vue-cli`）等工具，以启动整个应用程序。
- en: Let's have a look at all these methods and choose our favorite. In all these
    examples, we will just show a header on a page saying **`Learning Vue.js`**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看所有这些方法，并选择我们喜欢的。在所有这些示例中，我们只会在页面上显示一个标题，写着**`学习Vue.js`**。
- en: Standalone
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立使用
- en: Download the `vue.js` file. There are two versions, minified and developer version.
    The development version is at [https://vuejs.org/js/vue.js](https://vuejs.org/js/vue.js)
    . The minified version is at [https://vuejs.org/js/vue.min.js](https://vuejs.org/js/vue.min.js)
    .
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下载`vue.js`文件。有两个版本，压缩和开发者版本。开发版本在[https://vuejs.org/js/vue.js](https://vuejs.org/js/vue.js)。压缩版本在[https://vuejs.org/js/vue.min.js](https://vuejs.org/js/vue.min.js)。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are developing, make sure you use the development non-minified version
    of Vue. You will love the nice tips and warnings on the console.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在开发，请确保使用Vue的开发非压缩版本。您会喜欢控制台上的良好提示和警告。
- en: 'Then just include `vue.js` in the `<script>` tags, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后只需在`<script>`标签中包含`vue.js`，如下所示：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Vue is registered in the global variable. You are ready to use it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Vue已在全局变量中注册。您可以开始使用它。
- en: 'Our example will then look as simple as the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将如下所示：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: CDN
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CDN
- en: 'Vue.js is available in the following CDNs:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js在以下CDN中可用：
- en: '**jsdelivr**: [https://cdn.jsdelivr.net/vue/2.0.3/vue.js](https://cdn.jsdelivr.net/vue/2.0.3/vue.js)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jsdelivr**：[https://cdn.jsdelivr.net/vue/2.0.3/vue.js](https://cdn.jsdelivr.net/vue/2.0.3/vue.js)'
- en: '**cdnjs**: [https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.3/vue.js](https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.3/vue.js)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cdnjs**：[https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.3/vue.js](https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.3/vue.js)'
- en: '**unpkg**:  [https://unpkg.com/vue@2.0.3/dist/vue.js](https://unpkg.com/vue@2.0.3/dist/vue.js)
    (recommended)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unpkg**：[https://unpkg.com/vue@2.0.3/dist/vue.js](https://unpkg.com/vue@2.0.3/dist/vue.js)（推荐）'
- en: Just put the URL in source in the `script` tag and you are ready to use Vue!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将URL放在`script`标签中的源中，您就可以使用Vue了！
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Beware the CDN version might not be synchronized with the latest available version
    of Vue.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意CDN版本可能与Vue的最新可用版本不同步。
- en: Thus, the example will look exactly the same as in the standalone version, but
    instead of using downloaded file in the `<script>` tags, we are using a CDN URL.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，示例看起来与独立版本完全相同，但是我们使用CDN URL而不是在`<script>`标签中使用下载的文件。
- en: Bower
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bower
- en: 'If you are already managing your application with Bower and don''t want to
    use other tools, there''s also a Bower distribution of Vue. Just call `bower install`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在Bower中管理您的应用程序，并且不想使用其他工具，Vue也有一个Bower分发版本。只需调用`bower install`：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our example will look exactly like the two previous examples, but it will include
    the file from the `bower` folder:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例看起来与前两个示例完全相同，但它将包括来自`bower`文件夹的文件：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: CSP-compliant
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符合CSP
- en: '**Content Security Policy** (**CSP**) is a security standard that provides
    a set of rules that must be obeyed by the application in order to prevent security
    attacks. If you are developing applications for browsers, you are likely familiar
    with this policy!'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容安全策略**（**CSP**）是一种安全标准，提供了一组规则，必须由应用程序遵守，以防止安全攻击。如果您正在为浏览器开发应用程序，您可能熟悉这个策略！'
- en: For the environments that require CSP-compliant scripts, there's a special version
    of Vue.js at [https://github.com/vuejs/vue/tree/csp/dist](https://github.com/vuejs/vue/tree/csp/dist)
    .
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要符合CSP的脚本的环境，Vue.js有一个特殊版本，位于[https://github.com/vuejs/vue/tree/csp/dist](https://github.com/vuejs/vue/tree/csp/dist)。
- en: Let's do our example as a Chrome application to see the CSP-compliant Vue.js
    in action!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的示例作为Chrome应用程序，看看符合CSP的Vue.js在其中的表现！
- en: 'Start by creating a folder for our application example. The most important
    thing in a Chrome application is the `manifest.json` file, which describes your
    application. Let''s create it. It should look like the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个文件夹用于我们的应用程序示例。Chrome应用程序中最重要的是`manifest.json`文件，它描述了您的应用程序。让我们创建它。它应该如下所示：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The next step is to create our `main.js` file, which will be the entry point
    for the Chrome application. The script should listen for the application launching
    and open a new window with given sizes. Let''s create a window of 500 x 300 size
    and open it with `index.html`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的“main.js”文件，这将是Chrome应用程序的入口点。该脚本应监听应用程序的启动并打开一个给定大小的新窗口。让我们创建一个大小为500
    x 300的窗口，并使用“index.html”打开它：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'At this point, the Chrome-specific application magic is over and now we shall
    just create our `index.html` file that will do the same thing as in the previous
    examples. It will include the `vue.js` file and our script, where we will initialize
    our Vue application:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Chrome特定的应用程序魔法已经结束，现在我们只需创建一个“index.html”文件，该文件将执行与之前示例中相同的操作。它将包括“vue.js”文件和我们的脚本，我们将在其中初始化我们的Vue应用程序：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Download the CSP-compliant version of Vue.js and add it to the `assets` folder.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下载符合CSP标准的Vue.js版本，并将其添加到“assets”文件夹中。
- en: 'Now let''s create the `app.js` file and add the code that we already wrote
    added several times:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建“app.js”文件，并添加我们已经多次编写的代码：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Add it to the `assets` folder.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到“assets”文件夹中。
- en: Do not forget to create two icons of 16 and 128 pixels and call them `icon_16.png`
    and `icon_128.png`, respectively.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记创建两个16和128像素的图标，并分别将它们命名为“icon_16.png”和“icon_128.png”。
- en: 'Your code and structure in the end should look more or less like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您的代码和结构应该看起来与以下内容差不多：
- en: '![CSP-compliant](../Images/image00251.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![CSP-compliant](../Images/image00251.jpeg)'
- en: Structure and code for the sample Chrome application using vue.js
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用vue.js创建示例Chrome应用程序的结构和代码
- en: 'And now the most important thing. Let''s check if it works! It is very, very
    simple:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最重要的事情。让我们检查它是否有效！这非常非常简单：
- en: Go to `chrome://extensions/url`  in your Chrome browser.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chrome浏览器中转到“chrome://extensions/url”。
- en: Check the **`Developer mode`** checkbox.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**“开发者模式”**复选框。
- en: Click on **`Load unpacked extension...`** and check the folder that we've just
    created.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**“加载未打包的扩展程序...”**，并检查我们刚刚创建的文件夹。
- en: Your app will appear in the list! Now just open a new tab, click on apps, and
    check that your app is there. Click on it!
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的应用程序将出现在列表中！现在只需打开一个新标签，单击应用程序，然后检查您的应用程序是否存在。单击它！
- en: '![CSP-compliant](../Images/image00252.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![CSP-compliant](../Images/image00252.jpeg)'
- en: Sample Chrome application using vue.js in the list of Chrome apps
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome应用程序列表中使用vue.js的示例Chrome应用程序
- en: Congratulations! You have just created a Chrome application!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚创建了一个Chrome应用程序！
- en: npm
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: npm
- en: 'The `npm` installation method is recommended for large-scale applications.
    Just run `npm install vue` as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 建议对于大型应用程序使用“npm”安装方法。只需按照以下方式运行“npm install vue”：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then require it:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后需要引入它：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or, for ES2015 lovers, run the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于ES2015爱好者，请运行以下命令：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our HTML will look exactly like in the previous examples:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML将与之前的示例完全相同：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s create a `script.js` file that will look almost exactly the same
    as in a standalone or CDN version, with the only difference being that it will
    require `vue.js`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个“script.js”文件，它几乎与独立版本或CDN版本完全相同，唯一的区别是它将需要“vue.js”：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s install Vue and Browserify in order to be able to compile our `script.js`
    file into the `main.js` file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装Vue和Browserify，以便能够将我们的“script.js”文件编译成“main.js”文件：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `package.json` file, add a script for build as well that will execute
    Browserify on `script.js` transpiling it into `main.js`. So our `package.json`
    file will look like the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在“package.json”文件中，添加一个构建脚本，该脚本将在“script.js”上执行Browserify，将其转换为“main.js”。因此，我们的“package.json”文件将如下所示：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now run the following command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And open `index.html` in the browser.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在浏览器中打开“index.html”。
- en: 'I have a friend that at this point would say something like: really? So many
    steps, installations, commands, explanations... Just to output some header? I''m
    out!'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个朋友在这一点上会说类似的话：真的吗？这么多步骤，安装，命令，解释...只是为了输出一些标题？我不干了！
- en: If you are also thinking this, wait. Yes, this is true, now we've done something
    really simple in a rather complex way, but if you stay with me a bit longer, you
    will see how complex things become easy to implement if we use the proper tools.
    Also, do not forget to check your Pomodoro timer, maybe it's time to take a rest!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您也在思考这个问题，请等一下。是的，这是真的，现在我们以一种相当复杂的方式做了一些非常简单的事情，但是如果您和我一起坚持一会儿，您将看到如果我们使用适当的工具，复杂的事情变得容易实现。另外，不要忘记检查您的番茄钟，也许是休息的时候了！
- en: vue-cli
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: vue-cli
- en: 'As we have already mentioned in the previous chapter, Vue provides its own
    command-line interface that allows bootstrapping single-page applications using
    whatever workflows you want. It immediately provides hot reloading and structure
    for a test-driven environment. After installing `vue-cli`, just run `vue init
    <desired boilerplate> <project-name>` and then just install and run:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中已经提到的，Vue提供了自己的命令行界面，允许使用您想要的任何工作流来引导单页应用程序。它立即提供了热重载和测试驱动环境的结构。安装了`vue-cli`之后，只需运行`vue
    init <desired boilerplate> <project-name>`，然后只需安装和运行：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now open your browser on `localhost:8080`. You just used `vue-cli` to scaffold
    your application. Let's adapt it to our example. Open a source folder. In the
    `src` folder, you will find an `App.vue` file. Do you remember we talked about
    Vue components that are like bricks from which you build your application? Do
    you remember that we were creating and registering them inside our main script
    file, and I mentioned that we will learn to build components in a more elegant
    way? Congratulations, you are looking at the component built in a fancy way!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`localhost:8080`上打开您的浏览器。您刚刚使用`vue-cli`来搭建您的应用程序。让我们将其调整到我们的示例中。打开一个源文件夹。在`src`文件夹中，您将找到一个`App.vue`文件。您还记得我们谈到过Vue组件就像是您构建应用程序的砖块吗？您还记得我们是如何在主脚本文件中创建和注册它们的，并且我提到我们将学习以更优雅的方式构建组件吗？恭喜，您正在看一个以时髦方式构建的组件！
- en: 'Find the line that says `import Hello from ''./components/Hello''`. This is
    exactly how the components are being reused inside other components. Have a look
    at the template at the top of the component file. At some point, it contains the
    `<hello></hello>` tag. This is exactly where in our HTML file the `hello` component
    will appear. Have a look at this component; it is in the `src/components` folder.
    As you can see, it contains a template with `{{ msg }}` and a script that exports
    data with defined `msg`. This is exactly the same as we were doing in our previous
    examples without using components. Let''s slightly modify the code to make it
    the same as in the previous examples. In the `Hello.vue` file, change `msg` in
    the `data` object:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 找到说`import Hello from './components/Hello'`的那一行。这正是组件在其他组件中被重用的方式。看一下组件文件顶部的模板。在某个地方，它包含`<hello></hello>`标记。这正是在我们的HTML文件中`hello`组件将出现的地方。看一下这个组件；它在`src/components`文件夹中。正如您所看到的，它包含一个带有`{{
    msg }}`的模板和一个导出带有定义的`msg`数据的脚本。这与我们在之前的示例中使用组件时所做的完全相同。让我们稍微修改代码，使其与之前的示例相同。在`Hello.vue`文件中，更改`data`对象中的`msg`：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `App.vue` component, remove everything from the template except the
    `hello` tag so that the template looks like the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.vue`组件中，从模板中删除除了`hello`标记之外的所有内容，使模板看起来像下面这样：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now if you rerun the application, you will see our example with beautiful styles
    that we didn''t touch:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果重新运行应用程序，您将看到我们的示例具有美丽的样式，而我们没有触及：
- en: '![vue-cli](../Images/image00253.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![vue-cli](../Images/image00253.jpeg)'
- en: Vue application bootstrapped using vue-cli
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用vue-cli引导的Vue应用程序
- en: Tip
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Besides Webpack boilerplate template, you can use the following configurations
    with your `vue-cli`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Webpack样板模板，你可以使用以下配置与你的`vue-cli`一起使用：
- en: '`webpack-simple`: A simple Webpack + vue-loader setup for quick prototyping'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpack-simple`：一个用于快速原型设计的简单Webpack + vue-loader设置'
- en: '`browserify`: A full-featured Browserify + Vueify setup with hot-reload, linting,
    and unit testing'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browserify`：一个具有热重载、linting和单元测试的全功能Browserify + Vueify设置'
- en: '`browserify-simple`: A simple Browserify + Vueify setup for quick prototyping'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browserify-simple`：一个用于快速原型设计的简单Browserify + Vueify设置'
- en: '`simple`: The simplest possible Vue setup in a single HTML file'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simple`：一个在单个HTML文件中的最简单的Vue设置'
- en: Dev build
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dev build
- en: My dear reader, I can see your shining eyes and I can read your mind. Now that
    you know how to install and use Vue.js and how it works, you definitely want to
    put your hands deeply into the core code and contribute!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 亲爱的读者，我能看到你闪亮的眼睛，我能读懂你的心思。现在你知道如何安装和使用Vue.js以及它的工作原理，你肯定想深入了解核心代码并做出贡献！
- en: I understand you. For this, you need to use the development version of Vue.js,
    which you have to download from GitHub and compile yourself.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我理解你。为此，你需要使用Vue.js的开发版本，你需要从GitHub上下载并自行编译。
- en: Let's build our example with this development version of Vue. Create a new folder,
    for example, `dev-build`, and copy all the files from the npm example to this
    folder.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这个开发版本的Vue来构建我们的示例。创建一个新文件夹，例如`dev-build`，并将所有文件从npm示例复制到此文件夹中。
- en: 'Do not forget to copy the `node_modules` folder. You should `cd` into it and
    download files from GitHub to it, and then run `npm install` and `npm run build`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记复制`node_modules`文件夹。你应该`cd`进入它，并从GitHub下载文件到其中，然后运行`npm install`和`npm run
    build`：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now build our example application:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建我们的示例应用程序：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Open `index.html` in the browser; you will see the usual **`Learning Vue.js`**
    header.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开`index.html`，你会看到通常的**`学习Vue.js`**标题。
- en: 'Let''s now try to change something in `vue.js` source! Go to the `node_modules/vue/src/compiler/parser`
    folder and open the `text-parser.js` file. Find the line that says the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试更改`vue.js`源代码中的一些内容！转到`node_modules/vue/src/compiler/parser`文件夹，并打开`text-parser.js`文件。找到以下行：
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Actually, this regular expression defines default delimiters used in the HTML
    templates. The things inside these delimiters are recognized as a Vue data or
    as a JavaScript code. Let''s change them! Let''s replace `{` and `}` with double
    percentage signs! Go on and edit the file:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个正则表达式定义了HTML模板中使用的默认定界符。这些定界符内的内容被识别为Vue数据或JavaScript代码。让我们改变它们！让我们用双百分号替换`{`和`}`！继续编辑文件：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now rebuild both Vue source and our application and refresh the browser. What
    do you see?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新构建Vue源代码和我们的应用程序，然后刷新浏览器。你看到了什么？
- en: '![Dev build](../Images/image00254.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![Dev build](../Images/image00254.jpeg)'
- en: After changing the Vue source and replacing delimiters, {{}} delimiters do not
    work anymore!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 更改Vue源代码并替换定界符后，{{}}定界符不再起作用！
- en: The message inside `{{}}` is no longer recognized as data that we passed to
    Vue. In fact, it is being rendered as part of HTML.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{}}`中的消息不再被识别为我们传递给Vue的数据。实际上，它被呈现为HTML的一部分。'
- en: 'Now go to the `index.html` file and replace our curly brackets delimiters with
    double percentage, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到`index.html`文件，并用双百分号替换我们的花括号定界符，如下所示：
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Rebuild our application and refresh the browser! What about now? You see how
    easy it is to change the framework's code and to try out your changes. I'm sure
    you have plenty of ideas about how to improve or add some functionality to Vue.js.
    So change it, rebuild, test, deploy! Happy pull requests!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建我们的应用程序并刷新浏览器！现在怎么样？你看到了改变框架代码并尝试你的改变是多么容易。我相信你有很多关于如何改进或添加一些功能到Vue.js的想法。所以改变它，重新构建，测试，部署！愉快的拉取请求！
- en: Debugging your Vue application
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试您的Vue应用程序
- en: You can debug your Vue application the same way you debug any other web application.
    Use your developer tools (firebug), breakpoints, debugger statements, and so on.
    If you want to dive deep inside the Chrome debugging tools, check Chrome's documentation
    at [https://developer.chrome.com/devtools](https://developer.chrome.com/devtools)
    .
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像调试任何其他Web应用程序一样调试您的Vue应用程序。使用开发者工具（firebug），断点，调试器语句等。如果您想深入了解Chrome调试工具，请查看Chrome的文档[https://developer.chrome.com/devtools](https://developer.chrome.com/devtools)。
- en: Vue also provides *Vue.js devtools*, so it gets easier to debug Vue applications.
    You can download and install it from the Chrome web store at [https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)
    .
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Vue还提供了*Vue.js devtools*，因此调试Vue应用程序变得更容易。您可以从Chrome网络商店下载并安装它[https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)。
- en: Unfortunately, it doesn't work with locally opened files, so use some simple
    HTTP server in order to serve our examples as a web page (for example, [https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)
    ).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它不适用于本地打开的文件，因此请使用一些简单的HTTP服务器来将我们的示例作为Web页面提供（例如，[https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)）。
- en: 'After installing it, open, for example, our shopping list application. Open
    developer tools. You will see the **`Vue`** tab has automatically appeared:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，打开，例如，我们的购物清单应用程序。打开开发者工具。您将看到**`Vue`**选项卡已自动出现：
- en: '![Debugging your Vue application](../Images/image00255.jpeg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![调试您的Vue应用程序](../Images/image00255.jpeg)'
- en: Vue devtools
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Vue devtools
- en: 'In our case, we only have one component—**`<Root>`**. As you can imagine, once
    we start working with components and having lots of them, they will all appear
    in the left part of the Vue devtools palette. Click on the **`<Root>`** component
    and inspect it. You''ll see all the data attached to this component. If you try
    to change something, for example, add a shopping list item, check or uncheck a
    checkbox, change the title, and so on, all these changes will be immediately propagated
    to the data in the Vue devtools. You will immediately see the changes on the right-hand
    side of it. Let''s try, for example, to add a shopping list item. Once you start
    typing, you see on the right how `newItem` changes accordingly:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只有一个组件—**`<Root>`**。可以想象，一旦我们开始使用组件并且有很多组件，它们都会出现在Vue devtools调色板的左侧。单击**`<Root>`**组件并对其进行检查。您将看到附加到此组件的所有数据。如果您尝试更改某些内容，例如添加购物清单项目，检查或取消复选框，更改标题等，所有这些更改都将立即传播到Vue
    devtools中的数据。您将立即在其右侧看到更改。例如，让我们尝试添加一个购物清单项目。一旦开始输入，您会看到`newItem`如何相应更改：
- en: '![Debugging your Vue application](../Images/image00256.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![调试您的Vue应用程序](../Images/image00256.jpeg)'
- en: The changes in the Models are immediately propagated to the Vue devtools data
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 模型中的更改立即传播到Vue devtools数据
- en: When we start adding more components and introduce complexity to our Vue applications,
    the debugging will certainly become more fun!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始添加更多组件并向我们的Vue应用程序引入复杂性时，调试肯定会变得更有趣！
- en: Scaffolding our applications
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搭建我们的应用程序
- en: Do you remember the two applications that we started to work on in the first
    chapter, the shopping list application and the Pomodoro one? In this section,
    we will scaffold these applications using the `vue-cli` tool in order for them
    to be ready to contain reusable components, be tested, and be deployed. Once we
    bootstrap these applications, we will work on them until the end of this book.
    So let's do it carefully and with lots of love!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在第一章开始工作的两个应用程序，购物清单应用程序和番茄钟应用程序吗？在本节中，我们将使用`vue-cli`工具搭建这些应用程序，以便它们准备好包含可重用组件，进行测试和部署。一旦我们引导这些应用程序，我们将在本书的最后工作。所以让我们小心谨慎地做，并充满爱心！
- en: Scaffolding the shopping list application
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搭建购物清单应用程序
- en: We will scaffold the shopping list application using `vue-cli` Webpack configuration.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`vue-cli` Webpack配置来搭建购物清单应用程序。
- en: Tip
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In case you have ignored all previous practical exercises related to `vue-cli`,
    do not forget to install it before proceeding to the next steps: **npm install
    -g vue-cli**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忽略了与`vue-cli`相关的所有先前的实际练习，请不要忘记在继续下一步之前安装它：**npm install -g vue-cli**
- en: 'If you already have `vue-cli` installed, go to the directory where you want
    to bootstrap the application and run the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了`vue-cli`，请转到要引导应用程序的目录并运行以下命令：
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Answer yes to all the questions (just click enter) and voilà! You have the
    application bootstrapped:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有问题回答yes（只需点击回车键），voilà！你已经引导了应用程序：
- en: '![Scaffolding the shopping list application](../Images/image00257.jpeg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![搭建购物清单应用程序](../Images/image00257.jpeg)'
- en: Bootstraping the shopping list application with vue-cli
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用vue-cli引导购物清单应用程序
- en: 'Switch to the shopping list directory and run `npm install` and `npm run dev`.
    Open your browser at `localhost:8080`. You will see the **`Hello World`** page
    of the newly created Vue application:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到购物清单目录并运行`npm install`和`npm run dev`。在`localhost:8080`上打开你的浏览器。你会看到新创建的Vue应用程序的**`Hello
    World`**页面：
- en: '![Scaffolding the shopping list application](../Images/image00258.jpeg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![搭建购物清单应用程序](../Images/image00258.jpeg)'
- en: The Hello World view of the newly bootstrapped application
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 新引导应用程序的Hello World视图
- en: 'Let''s clean the bootstrapped code so that the application gets ready to be
    populated with our application-specific code. Go to the `App.vue` file and remove
    everything, leaving just the tags that define the application structure:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们清理引导代码，使应用程序准备好填充我们的特定应用程序代码。转到`App.vue`文件并删除所有内容，只留下定义应用程序结构的标签：
- en: '`<template>` with the main `<div>` inside'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<template>`与主要的`<div>`内部'
- en: The `<script>` tag
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<script>`标签'
- en: The `<style>` tag
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<style>`标签'
- en: 'So, in the end, your `App.vue` file looks like the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终，你的`App.vue`文件看起来像下面这样：
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Have a look at the page opened in the browser. Funny, you haven't done anything, but
    the page now doesn't contain the default **`Hello World`**. The page is empty!
    It has changed automatically!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 看看在浏览器中打开的页面。有趣的是，你什么都没做，但页面现在不再包含默认的**`Hello World`**。页面是空的！它自动改变了！
- en: 'Try adding something inside the `<template>` tags. Look at the page; it automatically
    reloads once you introduce changes. This works because of the `vue-hot-reload`
    plugin that detects changes in your Vue components and automatically rebuilds
    the project and reloads the browser page. Try to write some JavaScript code inside
    the `<script>` tags that doesn''t correspond to lint standards, for example, using
    `notDefinedVariable`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在`<template>`标签内添加一些内容。查看页面；一旦你引入更改，它会自动重新加载。这是因为`vue-hot-reload`插件会检测你的Vue组件的更改，并自动重建项目并重新加载浏览器页面。尝试在`<script>`标签内写一些不符合lint标准的JavaScript代码，例如使用`notDefinedVariable`：
- en: '[PRE53]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The page in the browser is not refreshed. Look at your shell console. It shows
    the *lint* errors and "refuses" to build your application:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的页面没有刷新。看看你的shell控制台。它显示了*lint*错误，并且“拒绝”构建你的应用程序：
- en: '![Scaffolding the shopping list application](../Images/image00259.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![搭建购物清单应用程序](../Images/image00259.jpeg)'
- en: Each time the application is changed the lint rules are checked
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 每次应用程序更改时都会检查lint规则
- en: This happens, thanks to the ESLint plugin, which checks the code against the
    lint rules each time the application changes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为ESLint插件会检查代码是否符合lint规则，每次应用程序更改时都会发生这种情况。
- en: With that, we can be sure that our code will follow the best quality standards.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以确信我们的代码将遵循最佳的质量标准。
- en: 'Speaking of quality, we should also prepare our application to be able to run
    unit tests. Luckily for us, `vue-cli` with Webpack has already done it for us.
    Run `npm run unit` to run unit tests and `npm run e2e` to run end-to-end nightwatch
    tests. End-to-end tests will not run in parallel with your running application
    since both are using the same port. So, if you want to run tests during development,
    you should change the port in the `config/index.js` configuration file or simply
    stop the application between running tests. After running tests, you will see
    the end-to-end tests fail. This is because they are checking for the application''s
    specific elements that we have removed. Open the file `test.js` from the `test/e2e/specs/`
    directory and clean all the assertions that we don''t need anymore. Now it should
    look like the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 说到质量，我们还应该准备好我们的应用程序能够运行单元测试。幸运的是，`vue-cli`与Webpack已经为我们做好了准备。运行`npm run unit`来运行单元测试，运行`npm
    run e2e`来运行端到端的nightwatch测试。端到端测试不会与正在运行的应用程序并行运行，因为两者都使用相同的端口。因此，如果你想在开发过程中运行测试，你应该在`config/index.js`配置文件中更改端口，或者在运行测试之间简单地停止应用程序。运行测试后，你会看到端到端测试失败。这是因为它们正在检查我们已经删除的应用程序特定元素。打开`test/e2e/specs/`目录下的`test.js`文件，并清除所有我们不再需要的断言。现在它应该看起来像下面这样：
- en: '[PRE54]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Rerun the tests. Now they should be passing. From now on, as we will add code
    to our application, we will add unit and end-to-end tests.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试。现在它们应该通过了。从现在开始，当我们向我们的应用程序添加代码时，我们将添加单元测试和端到端测试。
- en: Bootstraping your Pomodoro application
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动你的番茄钟应用程序
- en: For the Pomodoro application, do the same as for the shopping list application.
    Run `vue init webpack pomodoro` and repeat all the necessary steps to ensure that
    the structure is ready to be populated with the Pomodoro application code!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于番茄钟应用程序，做与购物清单应用程序相同的事情。运行`vue init webpack pomodoro`，并重复所有必要的步骤，以确保结构已准备好用于填充番茄钟应用程序的代码！
- en: Exercise
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Implement our Pomodoro application as a Chrome app! You just need to use it
    with a CSP-compliant version of Vue.js and add a `manifest.json` file.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的番茄钟应用程序实现为Chrome应用程序！你只需要使用符合CSP的Vue.js版本，并添加一个`manifest.json`文件。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have analyzed the behind-the-scenes of Vue.js. You learned
    how data reactivity is achieved. You saw how Vue.js leverages `Object.defineProperty`
    getters and setters to propagate changes in the data. You saw an overview of the
    key Vue.js concepts, such as reusable components, plugins system, and state management
    with Vuex. We have bootstrapped the applications that we will develop during the
    next chapters.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了Vue.js的幕后情况。你学会了如何实现数据的响应性。你看到了Vue.js如何利用`Object.defineProperty`的getter和setter来传播数据的变化。你看到了Vue.js概念的概述，比如可重用组件、插件系统和使用Vuex进行状态管理。我们已经启动了我们将在接下来的章节中开发的应用程序。
- en: In the next chapter, we will have a deeper look into the Vue's components system.
    We will use components in our applications.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地了解Vue的组件系统。我们将在我们的应用程序中使用组件。
