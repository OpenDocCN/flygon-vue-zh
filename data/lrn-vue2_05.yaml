- en: Chapter 5. Vuex – Managing State in Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Vuex-管理应用程序中的状态
- en: In the previous chapter, you learned one of the most important concepts of Vue.js: data
    binding. You learned and applied a lot of ways of binding data to our application.
    You also learned how to use directives, how to listen to events, and how to create
    and invoke methods. In this chapter, you will see how to manage the data that
    represents a global application state. We will talk about Vuex, a special architecture
    for centralized states in Vue applications. You will learn how to create a global
    data store and how to retrieve and change it inside the components. We will define
    what data is local and what should be global in our applications, and we will
    use the Vuex store to work with a global state in them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了Vue.js中最重要的概念之一：数据绑定。您学习并应用了许多将数据绑定到我们的应用程序的方法。您还学习了如何使用指令，如何监听事件，以及如何创建和调用方法。在本章中，您将看到如何管理表示全局应用程序状态的数据。我们将讨论Vuex，这是Vue应用程序中用于集中状态的特殊架构。您将学习如何创建全局数据存储以及如何在组件内部检索和更改它。我们将定义应用程序中哪些数据是本地的，哪些应该是全局的，并且我们将使用Vuex存储来处理其中的全局状态。
- en: 'Summing it up, in this chapter, we are going to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，在本章中，我们将：
- en: Understand the difference between local and global application states
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解本地和全局应用程序状态之间的区别
- en: Understand what Vuex is and how it works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Vuex是什么以及它是如何工作的
- en: Learn how to use data from the global store
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用全局存储中的数据
- en: Learn about store getters, mutations, and actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解存储的getter、mutation和action
- en: Install and use the Vuex store in the shopping list and Pomodoro applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并在购物清单和番茄钟应用程序中使用Vuex存储
- en: Parent-child components' communication, events, and brain teaser
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 父子组件的通信、事件和脑筋急转弯
- en: Remember our shopping list application? Do you remember our `ChangeTitleComponent`
    and how we ensured that typing in its input box would affect the title of the
    shopping list that belongs to the parent component? You remember that each component
    has its own scope, and the scope of the parent component cannot be affected by
    children components. Thus, in order to be able to propagate the changes from inside
    the children components to the parent components, we used events. Putting it very
    simply, you can call the `$emit` method from the child component with the name
    of the event being dispatched and listen to this event within the `v-on` directive
    on the parent component.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们的购物清单应用程序吗？还记得我们的`ChangeTitleComponent`以及我们如何确保在其输入框中输入会影响属于父组件的购物清单的标题吗？您记得每个组件都有自己的作用域，父组件的作用域不能受到子组件的影响。因此，为了能够将来自子组件内部的更改传播到父组件，我们使用了事件。简单地说，您可以从子组件调用`$emit`方法，并传递要分发的事件的名称，然后在父组件的`v-on`指令中监听此事件。
- en: If it is a native event, such as `input`, it's even more simple. Just bind the
    needed attribute to the child component as a `v-model` and then call the `$emit`
    method with the name of the event (for example, `input`) from the child component.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是原生事件，比如`input`，那就更简单了。只需将所需的属性绑定到子组件作为`v-model`，然后从子组件调用`$emit`方法并传递事件的名称（例如，`input`）。
- en: Actually, this is exactly what we have done with `ChangeTitleComponent`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这正是我们在`ChangeTitleComponent`中所做的。
- en: Open the code inside the [chapter5/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list)
    folder and check if I'm right. (You might also want to run `npm install` and `npm
    run dev` if you want to check the application's behavior in your browser.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 打开[chapter5/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list)文件夹中的代码，并检查我是否正确。（如果您想在浏览器中检查应用程序的行为，您可能还需要运行`npm
    install`和`npm run dev`。）
- en: 'We bound the title using the `v-model` directive to `ChangeTitleComponent`
    inside the `ShoppingListComponent` template:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`v-model`指令将标题绑定到`ShoppingListComponent`模板中的`ChangeTitleComponent`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After that, we declare the value of the title model inside the `props` attribute
    of the `ChangeTitleComponent` and emit the `input` event on the `input` action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在`ChangeTitleComponent`的`props`属性中声明了标题模型的值，并在`input`动作上发出了`input`事件：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Seems pretty straightforward, right?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来非常简单，对吧？
- en: 'If we try to change the title in the input box, the title of our shopping list
    changes accordingly:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在输入框中更改标题，我们的购物清单的标题会相应更改：
- en: '![Parent-child components'' communication, events, and brain teaser](../Images/image00285.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![父子组件的通信、事件和脑筋急转弯](../Images/image00285.jpeg)'
- en: After establishing events-based communication between the parent and child components,
    we are able to change the title
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在父子组件之间建立基于事件的通信之后，我们能够改变标题
- en: 'Looks like we were actually able to achieve our purpose. However, if you open
    your devtools, you will see an ugly error:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们实际上能够实现我们的目的。然而，如果你打开你的开发工具，你会看到一个丑陋的错误：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ouch! Vue is actually right, we are mutating the data that is contained inside
    the `ShoppingList` component's `props` attribute. This attribute comes from the
    main parent component, `App.vue`, which is, in turn, the parent of our `ShoppingListComponent`.
    And we already know that we cannot mutate the parent's data from the child component.
    If the title belonged directly to the `ShoppingListComponent`, we were all good,
    but in this case, we are definitely doing something wrong.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！Vue实际上是对的，我们正在改变包含在`ShoppingList`组件的`props`属性中的数据。这个属性来自于主父组件`App.vue`，它又是我们的`ShoppingListComponent`的父组件。而我们已经知道我们不能从子组件改变父组件的数据。如果标题直接属于`ShoppingListComponent`，那就没问题，但在这种情况下，我们肯定做错了什么。
- en: Also, if you are paying enough attention, you probably noticed that there's
    one more place that contains the same piece of data that doesn't change despite
    our effort. Look at the tab's title. It continues to display the word **`Groceries`**.
    But we want it to change as well!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你足够注意，你可能会注意到还有一个地方包含了相同的数据，尽管我们努力了，它也没有改变。看看标签的标题。它继续显示单词**`Groceries`**。但我们也希望它改变！
- en: 'Small side note: I''ve added a new component, `ShoppingListTitleComponent`.
    It represents the tab''s title. Do you remember computed properties? Note that
    this component contains one that just prepends  `#` to the ID imported through
    the `props` attribute to generate an anchor:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 小小的侧记：我添加了一个新组件，`ShoppingListTitleComponent`。它代表了标签的标题。你还记得计算属性吗？请注意，这个组件包含一个计算属性，它只是在通过`props`属性导入的ID前面添加`#`来生成一个锚点：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The anchor that displays the tab's title contains an `href` binding directive
    that relies on this computed property.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 显示标签标题的锚点包含一个依赖于这个计算属性的`href`绑定指令。
- en: So, back to the title changing. What can we do to change the title of this component
    when the title inside the `ChangeTitleComponent` changes? If we could propagate
    the event to the main `App.vue` component, we could actually solve both problems.
    Whenever the data in the parent component changes, it affects all the children
    components.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，回到标题更改。当`ChangeTitleComponent`内部的标题改变时，我们能做些什么来改变这个组件的标题？如果我们能将事件传播到主`App.vue`组件，我们实际上可以解决这两个问题。每当父组件中的数据改变时，它都会影响所有子组件。
- en: So, we need to somehow make the event flow from `ChangeTitleComponent` until
    the main `App` component. Sounds difficult, but actually, we just need to register
    our custom event in both `ChangeTitleComponent` and its parent and emit it until
    it reaches the `App` component. The `App` component should handle this event by
    applying the change to the corresponding title. In order for `App.vue` to know
    exactly which shopping list is being changed, its child `ShoppingListComponent`
    should also pass the ID of the shopping list that it represents. For this to happen,
    `App.vue` should pass the `id` property to the component, and the shopping list
    component should register it in its `props` attribute.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要以某种方式使事件从`ChangeTitleComponent`流向主`App`组件。听起来很困难，但实际上，我们只需要在`ChangeTitleComponent`及其父级中注册我们的自定义事件，并发出它直到它到达`App`组件。`App`组件应该通过将更改应用于相应的标题来处理此事件。为了让`App.vue`确切地知道正在更改哪个购物清单，它的子`ShoppingListComponent`还应该传递它所代表的购物清单的ID。为了实现这一点，`App.vue`应该将`id`属性传递给组件，购物清单组件应该在其`props`属性中注册它。
- en: 'So, we will do the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将执行以下操作：
- en: Bind the `id` property to `ShoppingListComponent` on its creation inside the
    `App` component's template.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`组件的模板中，在`ShoppingListComponent`的创建时将`id`属性绑定到`ShoppingListComponent`。
- en: Bind property `title` instead of `v-model` to the `change-title-component` from
    within the `ShoppingList` component.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ShoppingList`组件内部绑定属性`title`而不是`v-model`到`change-title-component`。
- en: Attach the custom event (let's call it `changeTitle`) to `input` inside the
    `ChangeTitleComponent`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自定义事件（我们称之为`changeTitle`）附加到`ChangeTitleComponent`内部的`input`上。
- en: Tell `ShoppingListComponent` to listen to the custom `changeTitle` event coming
    from the `change-title-component` using the `v-on` directive and handle it by
    emitting another event (it can also be called `changeTitle`) that should be caught
    by the `App` component.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉`ShoppingListComponent`监听来自`change-title-component`的自定义`changeTitle`事件，使用`v-on`指令处理它，通过发出另一个事件（也可以称为`changeTitle`）来处理它，应该被`App`组件捕获。
- en: Attach listener to the `changeTitle` event to the `shopping-list-component`
    inside `App.vue` and handle it by actually changing the title of the corresponding
    shopping list.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.vue`内部为`shopping-list-component`附加`changeTitle`事件的监听器，并通过实际更改相应购物清单的标题来处理它。
- en: 'Let''s start by modifying the `App.vue` file''s template and binding the shopping
    list''s ID to `shopping-list-component`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修改`App.vue`文件的模板开始，并将购物清单的ID绑定到`shopping-list-component`：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now register the `id` attribute inside the `ShoppingListComponent` component''s
    `props`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`ShoppingListComponent`组件的`props`中注册`id`属性：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Bind the `title` data property instead of the `v-model` directive to the `change-title-component`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将`title`数据属性绑定到`change-title-component`而不是`v-model`指令：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Emit a custom event instead of `input` from the `ChangeTitleComponent` and
    listen to this event in its parent component:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ChangeTitleComponent`发出自定义事件而不是`input`，并在其父组件中监听此事件：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create the `onChangeTitle` method in `ShoppingListComponent` that will emit
    its own `changeTitle` event. Listen to this event in the `App.vue` component using
    the `v-on` directive. Note that the `onChangeTitle` method of the shopping list
    component should send its ID in order for `App.vue` to know which shopping list''s
    title is being changed. So, the `onChangeTitle` method and its handling will look
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ShoppingListComponent`中创建`onChangeTitle`方法，该方法将发出自己的`changeTitle`事件。使用`v-on`指令在`App.vue`组件中监听此事件。请注意，购物清单组件的`onChangeTitle`方法应发送其ID，以便`App.vue`知道正在更改哪个购物清单的标题。因此，`onChangeTitle`方法及其处理将如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, let''s create a `changeTitle` method inside `App.vue` that will find
    a shopping list in the `shoppinglists` array by its ID and change its title:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`App.vue`中创建一个`changeTitle`方法，该方法将通过其ID在`shoppinglists`数组中找到一个购物清单并更改其标题：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we have used the `underscore` class's `findWhere` method ( [http://underscorejs.org/#findWhere](http://underscorejs.org/#findWhere)
    ) to make our task of finding the shopping list by its ID easier.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`underscore`类的`findWhere`方法（[http://underscorejs.org/#findWhere](http://underscorejs.org/#findWhere)）来使我们通过ID查找购物清单的任务更容易。
- en: And ... we are done! Check the final code for this teaser in the [chapter5/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list2)
    folder. Check the page in the browser. Try to change the title in the input box.
    You will see that it changes everywhere!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 而且...我们完成了！检查这个提示的最终代码在[chapter5/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list2)文件夹中。在浏览器中检查页面。尝试在输入框中更改标题。你会看到它在所有地方都改变了！
- en: 'Admit that this was quite challenging. Try to repeat all the steps by yourself.
    In the meantime, let me be random and tell you two words: global and local. Think
    about it.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 承认这是相当具有挑战性的。试着自己重复所有的步骤。与此同时，让我随机地告诉你两个词：全局和局部。想一想。
- en: Why do we need a global state store?
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要一个全局状态存储？
- en: As a developer, you are already familiar with global and local concepts. There
    are global variables that are accessible by each section of the application, but
    methods also have their own (local) scope and their scope is not accessible by
    other methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，你已经熟悉全局和局部的概念。有一些全局变量可以被应用程序的每个部分访问，但方法也有它们自己的（局部）作用域，它们的作用域不可被其他方法访问。
- en: A component-based system also has its local and global states. Each component
    has its local data, but the application has a global application state that can
    be accessed by any component of the application. The challenge that we have met
    in the previous paragraph would be easily solved if we had some kind of a global
    variables store containing the titles of the shopping lists and each component
    could access and modify them. Fortunately for us, Vue's creator thought about
    us and created Vuex architecture. This architecture allows us to create a global
    application store—the place where the global application state can be stored and
    managed!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的系统也有它的局部和全局状态。每个组件都有它的局部数据，但应用程序有一个全局的应用程序状态，可以被应用程序的任何组件访问。我们在前面段落中遇到的挑战，如果我们有某种全局变量存储器，其中包含购物清单的标题，并且每个组件都可以访问和修改它们，那么这个挑战将很容易解决。幸运的是，Vue的创作者为我们考虑到了这一点，并创建了Vuex架构。这种架构允许我们创建一个全局应用程序存储——全局应用程序状态可以被存储和管理的地方！
- en: What is Vuex?
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Vuex？
- en: 'As previously mentioned, Vuex is an application architecture for centralized
    state management. It was inspired by Flux and Redux, but it is a little bit easier
    to understand and to use:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Vuex是用于集中状态管理的应用程序架构。它受Flux和Redux的启发，但更容易理解和使用：
- en: '![What is Vuex?](../Images/image00286.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![什么是Vuex？](../Images/image00286.jpeg)'
- en: Vuex architecture; the image is taken from the Vuex GitHub page at https://github.com/vuejs/vuex
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex架构；图片取自Vuex GitHub页面，网址为https://github.com/vuejs/vuex
- en: Look in the mirror (do not forget to smile to yourself). You see a nice pretty
    human. However, there's a whole complex system inside it. What do you do when
    you feel cold? And how do you feel when it's hot? How does it feel to be hungry?
    And very hungry? And how does it feel to touch a fluffy cat? The human can be
    in various types of states (happy, hungry, smiley, angry, and so on). The human
    also has a lot of components, such as hands, arms, legs, stomach, face, and so
    on. Can you imagine how would it be if, let's say, a hand were able to directly
    influence your stomach, making you feel hungry, without your awareness?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 看着镜子（不要忘记对自己微笑）。你看到一个漂亮的人。然而，里面有一个复杂的系统。当你感到冷时你会怎么做？当天气炎热时你会有什么感觉？饥饿是什么感觉？非常饥饿又是什么感觉？摸一只毛茸茸的猫是什么感觉？人可以处于各种状态（快乐，饥饿，微笑，生气等）。人还有很多组件，比如手、胳膊、腿、胃、脸等。你能想象一下，如果比如一只手能够直接影响你的胃，让你感到饥饿，而你却不知情，那会是什么感觉？
- en: The way we work is very similar to the centralized state management system.
    Our brain contains an initial state of things (happy, not hungry, satisfied, and
    so on). It also provides the mechanism that allows pulling the strings in it that
    can affect the state. For example, *make a smile*, *feel satisfied*, *clap your
    hands*, and so on. Our hands, stomach, mouth, and other components cannot directly
    affect the state. But they can tell our brain to dispatch certain changes, and
    these changes, in turn, will affect the state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作方式与集中式状态管理系统非常相似。我们的大脑包含事物的初始状态（快乐，不饿，满足等）。它还提供了允许在其中拉动的机制，可以影响状态。例如，*微笑*，*感到满足*，*鼓掌*等。我们的手、胃、嘴巴和其他组件不能直接影响状态。但它们可以告诉我们的大脑触发某些改变，而这些改变反过来会影响状态。
- en: For example, when you are hungry, you eat. Your stomach at some certain point
    tells the brain that it is full. The action dispatches a mutation of the state
    of being hungry to be satisfied. Your component mouth is bound to this state and
    it makes it express the smile. Thus, the components are bound to the read-only
    brain state and can dispatch brain actions that will alter the state. The components
    are not aware of each other and cannot modify each other's state directly in any
    way. They also can also not affect directly the brain's initial state. They can
    only call the actions. Actions belong to the brain, and in their callbacks, the
    state can be modified. Thus, our brain is a single source of truth.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你饿了的时候，你会吃东西。你的胃在某个特定的时刻告诉大脑它已经饱了。这个动作会改变饥饿状态为满足状态。你的嘴巴组件与这个状态绑定，让你露出微笑。因此，组件与只读的大脑状态绑定，并且可以触发改变状态的大脑动作。这些组件彼此不知道对方，也不能直接以任何方式修改对方的状态。它们也不能直接影响大脑的初始状态。它们只能调用动作。动作属于大脑，在它们的回调中，状态可以被修改。因此，我们的大脑是唯一的真相来源。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Single source of truth in information systems is a way of designing the architecture
    of the application in such a way that every data element is only stored once.
    This data is read-only to prevent the application's components from corrupting
    the state that is accessed by other components. The Vuex store is designed in
    such a way that it is not possible to change its state from any component.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 信息系统中的唯一真相来源是一种设计应用架构的方式，其中每个数据元素只存储一次。这些数据是只读的，以防止应用程序的组件破坏被其他组件访问的状态。Vuex商店的设计方式使得不可能从任何组件改变它的状态。
- en: How does the store work and what is so special about it?
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商店是如何工作的，它有什么特别之处？
- en: 'The Vuex store contains essentially two things: **state** and **mutations**.
    State is an object that represents the initial state of the application data.
    Mutations is also an object containing action functions that affect the state.
    Vuex store is just a plain JavaScript file that exports these two objects and
    tells Vue to use Vuex (`Vue.use(Vuex)`). Then it can be imported into any other
    component. If you import it in the main `App.vue` file and register the store
    on the `Vue` application initialization, it is passed to the whole children chain
    and can be accessed through the `this.$store` variable. So, very roughly, in a
    very simplified way, we would create a store, import it in the main app, and use
    it in a component in the following way:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex存储基本上包含两件事：**状态**和**变化**。状态是表示应用程序数据的初始状态的对象。变化也是一个包含影响状态的动作函数的对象。Vuex存储只是一个普通的JavaScript文件，它导出这两个对象，并告诉Vue使用Vuex（`Vue.use(Vuex)`）。然后它可以被导入到任何其他组件中。如果你在主`App.vue`文件中导入它，并在`Vue`应用程序初始化时注册存储，它将传递给整个子代链，并且可以通过`this.$store`变量访问。因此，非常粗略地，以一种非常简化的方式，我们将创建一个存储，在主应用程序中导入它，并在组件中使用它的方式：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The very logical question might arise: why create a Vuex store instead of just
    having a shared JavaScript file that imports some state? You can, of course, do
    that, but then you must make sure that none of the components can mutate the state
    directly. Being able to change the store attributes directly would, of course,
    be a lot easier, but then it might lead to errors and inconsistencies. Vuex provide
    a clean way of implicitly protecting the store''s state of direct access. And,
    it''s reactive. Putting all this in statements:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常合乎逻辑的问题可能会出现：为什么创建Vuex存储而不是只有一个共享的JavaScript文件导入一些状态？当然，你可以这样做，但是然后你必须确保没有组件可以直接改变状态。当然，能够直接更改存储属性会更容易，但这可能会导致错误和不一致。Vuex提供了一种干净的方式来隐式保护存储状态免受直接访问。而且，它是反应性的。将所有这些放在陈述中：
- en: The Vuex store is reactive. Once components retrieve a state from it, they will
    reactively update their views every time the state changes.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vuex存储是反应性的。一旦组件从中检索状态，它们将在状态更改时自动更新其视图。
- en: Components are not able to directly mutate the store's state. Instead, they
    have to dispatch mutations declared by the store, which allows easy tracking of
    changes.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件无法直接改变存储的状态。相反，它们必须分派存储声明的变化，这样可以轻松跟踪更改。
- en: Our Vuex store thus becomes a single source of truth.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我们的Vuex存储成为了唯一的真相来源。
- en: Let's create a simple greetings example to see Vuex in action.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的问候示例，看看Vuex的运作方式。
- en: Greetings with store
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带存储的问候
- en: 'We will create a very simple Vue application with two components: one of them
    will contain the greetings message and the other one will contain `input` that
    will allow us to change this message. Our store will contain the initial state
    that will represent the initial greeting and the mutation that will be able to
    change the message. Let''s start by creating a Vue application. We will use `vue-cli`
    and the `webpack-simple` template:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个非常简单的Vue应用程序，其中包含两个组件：其中一个将包含问候消息，另一个将包含`input`，允许我们更改此消息。我们的存储将包含表示初始问候的初始状态，以及能够更改消息的变化。让我们从创建Vue应用程序开始。我们将使用`vue-cli`和`webpack-simple`模板：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Install the dependencies and run the application as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 安装依赖项并按以下方式运行应用程序：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The application is started! Open the browser in `localhost:8080`. Actually,
    the greeting is already there. Let''s now add the necessary components:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已启动！在`localhost:8080`中打开浏览器。实际上，问候已经存在。现在让我们添加必要的组件：
- en: '`ShowGreetingsComponent` will just display the greetings message'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShowGreetingsComponent`将只显示问候消息'
- en: '`ChangeGreetingsComponent` will display the input field that will allow to
    change the message'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChangeGreetingsComponent`将显示输入字段，允许更改消息'
- en: In the `src` folder, create a `components` subfolder. Start by adding `ShowGreetingsComponent.vue`
    to this folder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，创建一个`components`子文件夹。首先将`ShowGreetingsComponent.vue`添加到这个文件夹中。
- en: 'It will look as simple as the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来就像下面这样简单：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that, add `ChangeGreetingsComponent.vue` to this folder. It has to contain
    the input with the `v-model=''msg''` directive:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将`ChangeGreetingsComponent.vue`添加到这个文件夹中。它必须包含带有`v-model='msg'`指令的输入：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now open the `App.vue` file, import the components, and replace the markup
    with these two components. Do not forget to bind `msg` to both of them. So, your
    `App.vue` after the modifications will look like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`App.vue`文件，导入组件，并用这两个组件替换标记。不要忘记将`msg`绑定到它们两个。所以，修改后的`App.vue`将看起来像下面这样：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open the browser. You will see the input box with our greeting; however, typing
    in it will not change the message in the title. We were already expecting that
    because we know that components cannot directly affect each other''s state. Let''s
    now introduce the store! First of all, we must install `vuex`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器。你会看到带有我们问候语的输入框；然而，在其中输入不会改变标题中的消息。我们已经预料到了，因为我们知道组件不能直接影响彼此的状态。现在让我们引入store！首先，我们必须安装`vuex`：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a folder named `vuex` in the `src` folder. Create a JavaScript file
    named `store.js`. This will be our state management entry. First of all, import
    both `Vue` and `Vuex` and tell `Vue` that we want to use `Vuex` in this application:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建一个名为`vuex`的文件夹。创建一个名为`store.js`的JavaScript文件。这将是我们的状态管理入口。首先导入`Vue`和`Vuex`，并告诉`Vue`我们想在这个应用程序中使用`Vuex`：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now create two constants, `state` and `mutations`. `State` will contain the
    message `msg` while `mutations` will export the method that will allow us to modify `msg`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建两个常量，`state`和`mutations`。`State`将包含消息`msg`，而`mutations`将导出允许我们修改`msg`的方法：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now initialize the Vuex store with the already created `state` and `mutations`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用已创建的`state`和`mutations`初始化Vuex store：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'As we are using ES6, the notation `{state: state, mutations: mutations}` can
    be replaced with, simply, `{state, mutations}`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们使用ES6，`{state: state, mutations: mutations}`的表示法可以简单地替换为`{state, mutations}`'
- en: 'Our whole store''s code will thus look like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整个商店的代码看起来就像下面这样：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can now import the store in our `App.vue`. By doing this, we tell all the
    components that they can use the global store, and as a result, we can remove
    data from `App.vue`. Also, we do not need to bind data to the components anymore:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`App.vue`中导入store。通过这样做，我们告诉所有组件它们可以使用全局store，因此我们可以从`App.vue`中删除数据。而且，我们不再需要将数据绑定到组件：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now let''s go back to our components and reuse the data from the store. In
    order to be able to reuse reactive data from the store''s state, we should use
    computed properties. Vue is so smart that it will do all the work for us to reactively
    update these properties whenever the state changes. And no, we do not need to
    import the store inside the components. We have access to it just by using the
    `this.$store` variable. So, our `ShowGreetingsComponent` will look like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到我们的组件，并重用store中的数据。为了能够重用store状态中的响应式数据，我们应该使用计算属性。Vue是如此聪明，它将为我们做所有的工作，以便在状态更改时，反应地更新这些属性。不，我们不需要在组件内部导入store。我们只需使用`this.$store`变量就可以访问它。因此，我们的`ShowGreetingsComponent`将看起来像下面这样：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Follow the same logic to reuse the store''s `msg` in the `ChangeGreetingsComponent`.
    Now we just have to dispatch the mutation on each `keyup` event. For this to happen,
    we just need to create a method that will commit the corresponding store''s mutation
    and that we will call from the input''s `keyup` listener:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的逻辑在`ChangeGreetingsComponent`中重用存储的`msg`。现在我们只需要在每个`keyup`事件上分发变异。为此，我们只需要创建一个方法，该方法将提交相应的存储变异，并且我们将从输入的`keyup`监听器中调用它：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Open the page. Try to change the title. Et voilà! It works!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面。尝试更改标题。Et voilà！它奏效了！
- en: '![Greetings with store](../Images/image00287.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![商店问候](../Images/image00287.jpeg)'
- en: Using the Vuex store to call the mutations and change the store's state propagating
    it through the components
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vuex存储调用变异并通过组件传播更改存储状态
- en: 'We don''t need to bind the `v-model` directive anymore because all the changes
    happen due to the calling store''s mutation method. Thus, the `msg` property can
    be bound as the value''s attribute to the input box:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要绑定`v-model`指令，因为所有的更改都是由调用存储的变异方法引起的。因此，`msg`属性可以绑定为输入框的值属性：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Check the code for this section in the [chapter5/simple-store](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/simple-store)
    folder. In this example, we have used a very simplified version of the store.
    However, complex **Single-Page Applications** (**SPAs**) require a more complex
    and modular structure. We can and should extract the store's getters and actions
    that dispatch mutations to separated files. We can also group these files according
    to the corresponding data's responsibilities. In the next sections, we will see
    how we can achieve such a modular structure by using getters and actions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 检查[chapter5/simple-store](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/simple-store)文件夹中的此部分的代码。在这个例子中，我们使用了一个非常简化的存储版本。然而，复杂的**单页应用程序**（**SPAs**）需要更复杂和模块化的结构。我们可以并且应该将存储的getter和分发变化的操作提取到单独的文件中。我们还可以根据相应数据的责任对这些文件进行分组。在接下来的章节中，我们将看到如何通过使用getter和action来实现这样的模块化结构。
- en: Store state and getters
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储状态和getter
- en: 'It is, of course, good that we can reuse the `this.$store.state` keyword inside
    the components. But imagine the following scenarios:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在组件内部重用`this.$store.state`关键字是好的。但想象一下以下情景：
- en: In a large-scale app where different components access the state of the store
    using `$this.store.state.somevalue`, we decide to change the name of `somevalue`.
    This means that we have to change the name of the variable inside each and every
    component that uses it!
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个大型应用程序中，不同的组件使用`$this.store.state.somevalue`访问存储的状态，我们决定更改`somevalue`的名称。这意味着我们必须更改每个使用它的组件内部变量的名称！
- en: We want to use a *computed* value of state. For example, let's say we want to
    have a counter. Its initial state is "0". Each time we use it, we want to increment
    it. This means that each component has to contain a function that reuses the store's
    value and increments it, which means having repeated code in each component, which
    is not good at all!
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要使用状态的*计算*值。例如，假设我们想要一个计数器。它的初始状态是“0”。每次我们使用它，我们都想要递增它。这意味着每个组件都必须包含一个重用存储值并递增它的函数，这意味着在每个组件中都有重复的代码，这一点一点也不好！
- en: Sorry for the not-so-good scenarios, guys! Fortunately, there is a nice way
    not to fall into any of them. Imagine the centralized getter that accesses the
    store's state and provides a getter function to each of the state's items. If
    needed, this getter can apply some computation to the state's item. And if we
    need to change the name of some of the attributes, we only change it in one place,
    in this getter. It's rather a good practice or a convention than an architectural
    mandatory system, but I strongly recommend to use it even if you have only a couple
    of state items.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对不起，情景不太好，伙计们！幸运的是，有一种不会陷入其中任何一种情况的好方法。想象一下，中央获取器访问存储状态并为每个状态项提供获取器函数。如果需要，此获取器可以对状态项应用一些计算。如果我们需要更改某些属性的名称，我们只需在此获取器中更改一次。这更像是一种良好的实践或约定，而不是强制性的架构系统，但我强烈建议即使只有几个状态项，也要使用它。
- en: 'Let''s create such a getter for our simple greetings application. Just create
    a `getters.js` file inside the `vuex` folder and export a `getMessage` function
    that will return `state.msg`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的简单问候应用程序创建这样的获取器。只需在`vuex`文件夹中创建一个`getters.js`文件，并导出一个将返回`state.msg`的`getMessage`函数：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then it should be imported by the store and exported in the new `Vuex` object,
    so the store knows what its getters are:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它应该被存储导入并在新的`Vuex`对象中导出，这样存储就知道它的获取器是什么：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And then, in our components, we use getters instead of directly accessing the
    store''s state. Just replace your `computed` property in both the components with
    the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的组件中，我们使用获取器而不是直接访问存储状态。只需在两个组件中替换您的`computed`属性为以下内容：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Open the page; everything works like a charm!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面；一切都像魅力一样工作！
- en: 'Still the `this.$store.getters` notation contains so many letters to write.
    We, programmers are lazy, right? Vue is nice enough to provide us with an easy
    way to support our laziness. It provides a `mapGetters` helper that does exactly
    as its name suggests—provides all the store''s getters to our components. Just
    import it and use it in your `computed` properties as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然`this.$store.getters`表示法包含太多要写的字母。我们，程序员是懒惰的，对吧？Vue很好地为我们提供了一种支持我们懒惰的简单方法。它提供了一个`mapGetters`助手，正如其名称所示，为我们的组件提供了所有存储的获取器。只需导入它并在您的`computed`属性中使用它，如下所示：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that we''ve changed the property used inside the template to have the
    same name as the getter''s method name. However, it is also possible to map the
    corresponding getter method''s name to the property name that we want to use in
    our component:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已更改模板中使用的属性，使其与获取器方法名称相同。但是，也可以将相应的获取器方法名称映射到我们在组件中想要使用的属性名称。
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, we were able to extract the getter for the `msg` property to the centralized
    store's getters file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们能够将`msg`属性的获取器提取到中央存储的获取器文件中。
- en: Now, if you decide to add some computation to the `msg` property, you only need
    to do it in one place. Just in one place!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您决定为`msg`属性添加一些计算，您只需要在一个地方做就可以了。只在一个地方！
- en: '![Store state and getters](../Images/image00288.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![存储状态和获取器](../Images/image00288.jpeg)'
- en: Rick was always changing the code in all the components and just discovered
    that it is possible to only change it in one place
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Rick总是在所有组件中更改代码，刚刚发现只需在一个地方更改代码就可以了
- en: 'For example, if we want to reuse the uppercased message in all the components,
    we can apply the `uppercase` function inside the getter as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在所有组件中重用大写消息，我们可以在获取器中应用`uppercase`函数，如下所示：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'From now on, each component that uses the getter to retrieve the state will
    have an uppercased message:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每个使用获取器检索状态的组件都将具有大写消息：
- en: '![Store state and getters](../Images/image00289.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![存储状态和获取器](../Images/image00289.jpeg)'
- en: The ShowTitleComponent uppercased message. The toUpperCase function is applied
    inside the getters
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ShowTitleComponent将消息大写。toUpperCase函数应用在getter内部
- en: Note also how smoothly the message is being changed to uppercase inside the
    input box while you're typing in it! Check the final code for this section inside
    the [chapter5/simple-store2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/simple-store2)
    folder.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，当您在输入框中输入时，消息如何平稳地变成大写！查看[chapter5/simple-store2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/simple-store2)文件夹中此部分的最终代码。
- en: 'If we decide to change the name of the state''s attribute, we will only change
    it inside the getters function. For example, if we want to change the name of
    `msg` to `message`, we will do it inside our store:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定更改状态属性的名称，我们只需要在getter函数内部进行更改。例如，如果我们想将`msg`的名称更改为`message`，我们将在我们的store内部进行更改：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And then, we will also change it inside the corresponding getter *function*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还将在相应的getter *函数*内部进行更改：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That's it! The rest of the application is left completely untouched. This is
    the power of such architecture. In some very complex applications, we can have
    more than one getters files that export state for different kind of the application's
    properties. **Modularity** is a power that drives the maintainability; use it!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！应用的其余部分完全不受影响。这就是这种架构的力量。在一些非常复杂的应用程序中，我们可以有多个getter文件，为应用程序的不同属性导出状态。**模块化**是推动可维护性的力量；利用它！
- en: Mutations
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变化
- en: 'From the previous example, it should be clear that mutations are no more than
    simple event handler functions that are defined by **name**. Mutation handler
    functions receive a `state` as a first argument. Other arguments can be used to
    pass different parameters to the handler function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，应该清楚地看到，变化不过是由**名称**定义的简单事件处理程序函数。变化处理程序函数将`state`作为第一个参数。其他参数可以用于向处理程序函数传递不同的参数：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A particularity of mutations is that they cannot be called directly. To be
    able to dispatch a mutation, we should call a method called `commit` with a name
    of the corresponding mutation and parameters:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 变化的一个特点是它们不能直接调用。为了能够分发一个变化，我们应该调用一个名为`commit`的方法，其中包含相应变化的名称和参数：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Prior to Vue 2.0, a method to dispatch mutation was called "dispatch". So you
    would call it as follows: `store.dispatch(''changeMessage'', ''newMessage'')`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 2.0之前，分发变化的方法被称为“dispatch”。因此，您可以按照以下方式调用它：`store.dispatch('changeMessage',
    'newMessage')`
- en: 'You can create as many mutations as you wish. They can perform different operations
    on same-state items. You can go even further and declare mutation names as constants
    in a separated file. In this way, you can easily import them and use them instead
    of strings. So, for our example, we would create a file inside the `vuex` directory
    and call it `mutation_types.js`, and export all the constant names there:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建任意数量的变化。它们可以对相同状态项执行不同的操作。您甚至可以进一步声明变化名称为常量在一个单独的文件中。这样，您可以轻松地导入它们并使用它们，而不是字符串。因此，对于我们的例子，我们将在`vuex`目录内创建一个文件，并将其命名为`mutation_types.js`，并在那里导出所有的常量名称：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, in our store, we will import these constants and reuse them:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的store中，我们将导入这些常量并重复使用它们：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside the components that dispatch mutations, we will import the corresponding
    mutation type and dispatch it using the variable name:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在分发变化的组件内部，我们将导入相应的变化类型，并使用变量名进行分发：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This kind of structure makes a lot of sense in big applications. Again, you
    can group your mutation types according to the functionality they provide to the
    application and import only those mutations in the components that are needed
    for the specific component. This is, again, about best practices, modularity,
    and maintainability.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构在大型应用程序中非常有意义。同样，您可以根据它们为应用程序提供的功能对 mutation 类型进行分组，并仅在组件中导入那些特定组件所需的 mutations。这再次涉及最佳实践、模块化和可维护性。
- en: Actions
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作
- en: When we dispatch a mutation, we basically perform an action. Saying that we
    *commit* a `CHANGE_MSG` mutation is the same as saying that we *perform an action*
    of changing the message. For the sake of beauty and total extraction, like we
    extract the store state's items into getters and mutations names constants to
    the `mutation_types` we can also extract the mutations to the actions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分发一个 mutation 时，我们基本上执行了一个 action。说我们 *commit* 一个 `CHANGE_MSG` mutation 就等同于说我们
    *执行了一个* 改变消息的 action。为了美观和完全抽取，就像我们将 store 状态的项抽取到 getters 和将 mutations 名称常量抽取到
    `mutation_types` 一样，我们也可以将 mutations 抽取到 actions 中。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Thus, action is no more than just a function that dispatches a mutation!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，action 实际上只是一个分发 mutation 的函数！
- en: '`function changeMessage(msg) { store.commit(CHANGE_MSG, msg) }`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`function changeMessage(msg) { store.commit(CHANGE_MSG, msg) }`'
- en: 'Let''s create a simple `actions` file for our change, message example. But
    before that, let''s create one more item for the store''s initial state, `counter`,
    and initialize it with a "0" value. So, our store will look like the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的改变消息示例创建一个简单的 `actions` 文件。但在此之前，让我们为 store 的初始状态创建一个额外的项 `counter`，并将其初始化为
    "0" 值。因此，我们的 store 将如下所示：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s also add a counter getter to the getters file, so our `getters.js` file
    looks like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还在 getters 文件中添加一个计数器 getter，这样我们的 `getters.js` 文件看起来像下面这样：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And, finally, let''s use the counter''s getter inside `ShowGreetingsComponent`
    to show the amount of times the message `msg` was changed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在 `ShowGreetingsComponent` 中使用计数器的 getter 来显示消息 `msg` 被改变的次数：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s now create actions for both the mutations, for the counter and for the
    change message. Inside a `vuex` folder, create an `actions.js` file and export
    the `actions` functions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为计数器和改变消息的两个 mutations 创建 actions。在 `vuex` 文件夹中，创建一个 `actions.js` 文件并导出
    `actions` 函数：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can and should use ES2015 arguments destructuring and make our code more
    elegant. Let''s also export all the actions in a single `export default` statement:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以并且应该使用 ES2015 参数解构，使我们的代码更加优雅。让我们也在单个 `export default` 语句中导出所有的 actions：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Okay, now we have nice and beautiful actions. Let''s use them in our `ChangeGreetingsComponent`!
    To be able to use actions inside components, we should first import them to our
    store and then export in the new `Vuex` object. Then actions can be dispatched
    using the `this.$store.dispatch` method inside the components:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们有了漂亮而美丽的 actions。让我们在 `ChangeGreetingsComponent` 中使用它们！为了能够在组件中使用 actions，我们首先应该将它们导入到我们的
    store 中，然后在新的 `Vuex` 对象中导出。然后可以在组件中使用 `this.$store.dispatch` 方法来分发 actions：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So what''s actually the difference? We continue to write `this.$store` code,
    the only difference is that instead of calling the `commit` method we call `dispatch`.
    Do you remember how we discovered `mapGetters` helper? Wasn''t it nice? Actually
    Vue also provides a `mapActions` helper that allows us to avoid writing the extensive
    `this.$store.dispatch` something method. Just import `mapActions` in the same
    way as we import `mapGetters` and use it inside the component''s methods property:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 那么实际上有什么区别呢？我们继续编写 `this.$store` 代码，唯一的区别是，我们不再调用 `commit` 方法，而是调用 `dispatch`。你还记得我们是如何发现
    `mapGetters` 辅助函数的吗？是不是很好？实际上，Vue 也提供了一个 `mapActions` 辅助函数，它允许我们避免编写冗长的 `this.$store.dispatch`
    方法。只需像导入 `mapGetters` 一样导入 `mapActions`，并在组件的 methods 属性中使用它：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that we changed the handler's function for the `keyup` event, so we don't
    have to map the events' names to the corresponding actions. However, just like
    in the case of `mapGetters`, we can also map custom events' names to the corresponding
    actions names.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经改变了`keyup`事件的处理函数，所以我们不必将事件名称映射到相应的actions。然而，就像`mapGetters`一样，我们也可以将自定义事件名称映射到相应的actions名称。
- en: 'We should also change the `changeMessage` invocation because we don''t extract
    any event''s target value inside the actions now; thus, we should do it inside
    the invocation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该改变`changeMessage`的调用，因为我们现在不在actions中提取任何事件的目标值；因此，我们应该在调用中进行提取：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, let''s bind the `incrementCounter` action to the user''s input. Let''s,
    for example, call this action from our input template on the `keyup.enter` event:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将`incrementCounter` action绑定到用户的输入上。例如，让我们在输入模板中在`keyup.enter`事件上调用这个action：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you open the page, and try to change the title and hit the *Enter* button,
    you will see that the counter will be incremented each time you hit *Enter:*
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开页面，尝试改变标题并按下*Enter*按钮，你会发现每次按下*Enter*时计数器都会增加：
- en: '![Actions](../Images/image00290.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Actions](../Images/image00290.jpeg)'
- en: Using actions to increment the counter on the page
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用actions来增加页面上的计数器。
- en: So, you see how easy it is to modularize our application by using actions instead
    of directly accessing the store. You export actions in your Vuex store, import
    the `mapActions` in the components, and call them from the event handler directives
    in the templates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你看到了使用actions而不是直接访问store来模块化我们的应用是多么容易。你在Vuex store中导出actions，在组件中导入`mapActions`，并在模板中的事件处理程序指令中调用它们。
- en: Do you remember our "human" example in which we were comparing the parts of
    the human body to the components and the human brain to the store of the application
    state? Imagine that you are running. It is only *one* action but how many changes
    are being dispatched and how many components are being affected by those changes?
    When you run, your heart rate increases, you sweat, your arms move, and your face
    smiles because you realize how nice it is to run! When you eat, you also smile
    because it is good to eat. You also smile when you see a kitten. So, different
    actions can dispatch more than one change, and the same change can be dispatched
    by more than one action.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们的“人体”例子吗？在那个例子中，我们将人体的部分与组件进行比较，将人脑与应用状态的存储进行比较。想象一下你在跑步。这只是*一个*动作，但有多少变化被派发，有多少组件受到这些变化的影响？当你跑步时，你的心率增加，你出汗，你的手臂移动，你的脸上露出微笑，因为你意识到跑步是多么美好！当你吃东西时，你也会微笑，因为吃东西是美好的。当你看到小猫时，你也会微笑。因此，不同的actions可以派发多个变化，同一个变化也可以被多个action派发。
- en: 'The same happens with our Vuex store, and its mutations and actions. Within
    the same action, more than one mutation can be dispatched. For instance, we could
    dispatch our mutation for changing a message and increasing the counter within
    the same action. Let''s create this action inside our `action.js` file. Let''s
    call it `handleMessageInputChanges` and make it receive one argument: `event`.
    It will dispatch the `CHANGE_MSG` mutation with `event.target.value`, and in case
    `event.keyCode` is `enter`, it will dispatch the `INCREMENT_COUNTER` mutation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Vuex存储和它的mutations和actions也是一样的。在同一个action中，可以派发多个mutation。例如，我们可以在同一个action中派发改变消息和增加计数器的mutation。让我们在`action.js`文件中创建这个action。让我们称之为`handleMessageInputChanges`，并让它接收一个参数：`event`。它将使用`event.target.value`派发`CHANGE_MSG`
    mutation，并且如果`event.keyCode`是`enter`，它将派发`INCREMENT_COUNTER` mutation。
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now let''s import this action inside our `ChangeGreetingsComponent` component''s
    `mapActions` object and let''s use it calling it with the `$event` parameter:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`ChangeGreetingsComponent`组件的`mapActions`对象中导入这个action，并使用它调用带有`$event`参数的action：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Open the page, and try to change the greetings message and increment the counter
    by hitting the *Enter* button. It works!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面，尝试更改问候消息并通过点击*Enter*按钮增加计数器。它有效！
- en: The final code for the simple-store example can be found in the [chapter5/simple-store3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/simple-store3)
    folder.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 简单存储示例的最终代码可以在[chapter5/simple-store3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/simple-store3)文件夹中找到。
- en: Installing and using the Vuex store in our applications
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用程序中安装和使用Vuex store
- en: Now that we know what Vuex is, how to create a store, dispatch mutations, and
    how to use getters and actions, we can install the store in our applications and
    use it to finalize their data flow and communication chain.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了Vuex是什么，如何创建store，分发mutations，以及如何使用getter和action，我们可以在我们的应用程序中安装store，并用它来完成它们的数据流和通信链。
- en: 'You can find the applications to work on in the following folders:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下文件夹中找到要处理的应用程序：
- en: '**Pomodoro**: [chapter5/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**番茄钟**：[chapter5/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro)'
- en: '**Shopping list**: [chapter5/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list2)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**购物清单**：[chapter5/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list2)'
- en: Do not forget to run `npm install` on both applications.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在两个应用程序上运行`npm install`。
- en: Start by installing `vuex` and define the necessary directory and file structure
    in both applications.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装`vuex`，并在两个应用程序中定义必要的目录和文件结构。
- en: 'To install `vuex`, just run the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`vuex`，只需运行以下命令：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After installing `vuex`, create a subfolder `vuex` in each of the application''s
    `src` folders. In this folder, create four files: `store.js`, `mutation_types.js`,
    `actions.js`, and `getters.js`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`vuex`后，在每个应用程序的`src`文件夹中创建一个名为`vuex`的子文件夹。在此文件夹中，创建四个文件：`store.js`、`mutation_types.js`、`actions.js`和`getters.js`。
- en: 'Prepare the `store.js` structure:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 准备`store.js`结构：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Import and use the store in the main `App.vue`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`App.vue`中导入并使用store：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We will now define which is the global and which is the local state in each
    of the applications, define what data and binding are missing, divide the data,
    and add all the missing stuff using what we've just learned.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将定义每个应用程序中的全局状态和局部状态，定义缺少的数据和绑定，划分数据，并使用我们刚学到的内容添加所有缺失的内容。
- en: Using the Vuex store in the shopping list application
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在购物清单应用程序中使用Vuex store
- en: 'I hope you still remember the challenge we were facing at the beginning of
    this chapter. We would like to establish communication between the components
    in such a way that it would be easy to change the title of the shopping lists
    from the `ChangeTitleComponent` and propagate it to both `ShoppingListTitle` and
    `ShoppingListComponent`. Let''s remove the hardcoded array of shopping lists from `App.vue`
    and copy it to the store''s state:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您还记得我们在本章开头面临的挑战。我们希望在组件之间建立通信，以便可以轻松地从`ChangeTitleComponent`更改购物清单的标题，并将其传播到`ShoppingListTitle`和`ShoppingListComponent`。让我们从`App.vue`中删除硬编码的购物清单数组，并将其复制到store的状态中：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s define getters for the shopping lists:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为购物清单定义getter：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, import `mapGetters` in `App.vue` and map the `shoppinglists` value to
    the `getLists` method so that the `<script>` tag inside the `App.vue` component
    will look like the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`App.vue`中导入`mapGetters`，并将`shoppinglists`值映射到`getLists`方法，以便`App.vue`组件内的`<script>`标签看起来像下面这样：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The rest is left untouched!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分保持不变！
- en: Now let's define a mutation inside our store that will be responsible for changing
    the title. It is clear that it should be a function that receives a new title
    string as a parameter. However, there is some difficulty. We don't know which
    of the shopping lists title should be changed. If we could pass a list's ID from
    a component to this function, we could actually write a piece of code that would
    find a correct list by its ID. Did I just say *if we could*? Of course, we can!
    Actually, our `ShoppingListComponent` already receives the ID from its parent
    `App.vue`. Let's just pass this ID from `ShoppingListComponent` to `ChangeTitleComponent`.
    In this way, we will be able to invoke the necessary action from the component
    where the title is actually changed, without having to propagate the event through
    the parents' chain.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在存储中定义一个负责更改标题的mutation。很明显，它应该是一个接收新标题字符串作为参数的函数。但是，有一些困难。我们不知道应该更改哪个购物清单的标题。如果我们可以从组件将列表的ID传递给此函数，实际上我们可以编写一段代码来通过其ID找到正确的列表。我刚刚说*如果我们可以*？当然可以！实际上，我们的`ShoppingListComponent`已经从其父级`App.vue`接收了ID。让我们只是将这个ID从`ShoppingListComponent`传递给`ChangeTitleComponent`。这样，我们将能够从实际更改标题的组件中调用必要的操作，而无需通过父级链传播事件。
- en: 'So, just bind the ID to the `change-title-component` inside the `ShoppingListComponent` component''s
    template, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只需将ID绑定到`ShoppingListComponent`组件模板中的`change-title-component`，如下所示：
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Do not forget to add the `id` attribute to the `ChangeTitleComponent` component''s
    `props` attribute:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记向`ChangeTitleComponent`组件的`props`属性添加`id`属性：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Okay, now our `ChangeTitleComponent` has access to both `title` and `id` of
    the shopping list. Let's add the corresponding mutation to the store.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`ChangeTitleComponent`可以访问购物清单的`title`和`id`。让我们向存储中添加相应的mutation。
- en: We can start by writing a function that finds a shopping list by its ID. For
    this, I will use the `underscore` class's `_.findWhere` method, just like we did
    in the `App.vue` component's `changeTitle` method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先编写一个通过其ID查找购物清单的函数。为此，我将使用`underscore`类的`_.findWhere`方法，就像我们在`App.vue`组件的`changeTitle`方法中所做的那样。
- en: 'Import `underscore` inside `mutations.js` and add the `findById` function as
    follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mutations.js`中导入`underscore`并添加`findById`函数如下：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s now add the mutation and let''s call it, for example, `CHANGE_TITLE`.
    This mutation will receive the `data` object as a parameter containing `title`
    and `id`, and assign the value of the received title to the title of the found
    shopping list item. First of all, let''s declare a constant `CHANGE_TITLE` in
    `mutation_types.js` and reuse it instead of writing the mutation''s name as a
    string:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加mutation，并将其命名为`CHANGE_TITLE`。此mutation将接收`data`对象作为参数，其中包含`title`和`id`，并将接收到的标题值分配给找到的购物清单项的标题。首先，在`mutation_types.js`中声明一个常量`CHANGE_TITLE`，并重用它而不是将mutation的名称写为字符串：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We are almost finished. Let''s now define a `changeTitle` action inside the
    `actions.js` file and reuse it in our `ChangeTitleComponent`. Open the `actions.js`
    file and add the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快要完成了。现在让我们在`actions.js`文件中定义一个`changeTitle`操作，并在我们的`ChangeTitleComponent`中重用它。打开`actions.js`文件并添加以下代码：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And, the final touch. Open `ChangeTitleComponent.vue`, import the `mapActions`
    helper, map the `onInput` method to the `changeTitle` action, and call it inside
    `template` with the object mapping title to `event.target.value` and ID to the `id`
    parameter. So, the code of `ChangeTitleComponent` will look like the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步。打开`ChangeTitleComponent.vue`，导入`mapActions`辅助程序，将`onInput`方法映射到`changeTitle`操作，并在`template`中调用它，对象映射标题为`event.target.value`和ID为`id`参数。因此，`ChangeTitleComponent`的代码将如下所示：
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can now remove all the events-handling code from the `ShoppingListComponent`
    and the main `App` component.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从`ShoppingListComponent`和主`App`组件中删除所有事件处理代码。
- en: 'Open the page and try to type in the input box! The title will change in all
    locations:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面并尝试在输入框中输入！标题将在所有位置更改：
- en: '![Using the Vuex store in the shopping list application](../Images/image00291.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![在购物清单应用程序中使用Vuex存储](../Images/image00291.jpeg)'
- en: Using store, mutations, and actions—all components update their state without
    the need of events handling mechanism
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储、突变和操作——所有组件都可以更新其状态，而无需事件处理机制
- en: The final code for the shopping list application after applying the store's
    functions can be found in the [chapter5/shopping-list3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list3)
    folder.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 应用存储功能后购物清单应用程序的最终代码可以在[chapter5/shopping-list3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list3)文件夹中找到。
- en: Using Vuex store in the Pomodoro application
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Pomodoro应用程序中使用Vuex存储
- en: Finally, we got back to our Pomodoro! When was the last time you took a 5-minute
    break? Let's build our Pomodoro application with the Vuex architecture and then
    take a rest look at kittens. Let's start with the base in the [chapter5/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro)
    folder, where you already included the basic structure of the Vuex store (if not,
    go to the start of the *Installing and using Vuex store in our applications* section).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回到了我们的Pomodoro！你上次休息了多久？让我们使用Vuex架构构建我们的Pomodoro应用程序，然后休息一下，看看小猫。让我们从[chapter5/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro)文件夹中的基础开始，您已经包含了Vuex存储的基本结构（如果没有，请转到*在我们的应用程序中安装和使用Vuex存储*部分的开头）。
- en: Bringing life to start, pause, and stop buttons
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为启动、暂停和停止按钮注入生命
- en: 'Let''s start by analyzing what can actually be done with our Pomodoro timer.
    Look at the page. We have only three buttons: start, pause, and stop. This means
    that our application can be in one of these three states. Let''s define and export
    them in our `store.js` file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先分析我们的番茄钟定时器实际上可以做什么。看看页面。我们只有三个按钮：启动、暂停和停止。这意味着我们的应用程序可以处于这三种状态之一。让我们在`store.js`文件中定义并导出它们：
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Initially, all these states are set to `false`, which makes sense because the
    application is not started, it's not paused and, of course, it is not stopped!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，所有这些状态都设置为`false`，这是有道理的，因为应用程序尚未启动，尚未暂停，当然也没有停止！
- en: 'Let''s now define getters for these states. Open the `getters.js` file and
    add the getter functions for all three states:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为这些状态定义getter。打开`getters.js`文件，并为所有三种状态添加getter函数：
- en: '[PRE62]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'What should happen to our control buttons for each of the defined states:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个定义的状态，我们的控制按钮应该发生什么变化：
- en: The start button should become disabled when the application is started. However,
    it should be enabled again when the application is paused so that we can use this
    button to resume the application.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序启动时，启动按钮应该变为禁用。然而，当应用程序暂停时，它应该再次启用，以便我们可以使用此按钮恢复应用程序。
- en: The pause button can only be enabled when the application is started (because
    we cannot pause something that has not been started yet). However, it should be
    disabled if the application is paused (because we cannot pause something that
    is already paused).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停按钮只能在应用程序启动时启用（因为我们不能暂停尚未启动的东西）。但是，如果应用程序已暂停，它应该被禁用（因为我们不能暂停已经暂停的东西）。
- en: The stop button can only be enabled when the application is started.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止按钮只能在应用程序启动时启用。
- en: Let's translate this into code by adding the `disabled` class to our control
    buttons conditionally, depending on the application states.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过根据应用程序状态有条件地向我们的控制按钮添加`disabled`类来将其翻译成代码。
- en: Tip
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Once we apply the `disabled` class, Bootstrap will take care of the buttons'
    behavior for us by not only applying special styling but also deactivating interactive
    elements.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们应用了“disabled”类，Bootstrap将通过不仅应用特殊样式而且禁用交互元素来为我们处理按钮的行为。
- en: 'In order to be able to use the already defined getters, we must import `mapGetters`
    into the `<script>` tag of the component. After that, we must tell the component
    that we want to use them by exporting them within the `computed` property object:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用已定义的getter，我们必须在组件的`<script>`标签中导入`mapGetters`。之后，我们必须通过在`computed`属性对象中导出它们来告诉组件我们想要使用它们：
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now these getters can be used inside the template. So, we will apply the `disabled`
    class to the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些getter可以在模板中使用。因此，我们将把“disabled”类应用于以下内容：
- en: The start button when the application is started and not paused (`isStarted
    && !isPaused`)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序启动且未暂停时启动按钮（`isStarted && !isPaused`）
- en: The pause button when the application is not started or paused (`!isStarted
    || isPaused`)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序未启动或已暂停时暂停按钮（`!isStarted || isPaused`）
- en: The stop button when the application is not started (`!isStarted`)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序未启动时停止按钮（`!isStarted`）
- en: 'Our template will now look like the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板现在看起来像这样：
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You see now that the pause and stop buttons look different! If you mouse hover
    your mouse over them, the cursor is not changed, which means that they are really
    disabled! Let''s just create a style for the icons that are inside the disabled
    buttons to highlight the disabled state even more:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你看到暂停和停止按钮看起来不同了！如果你将鼠标悬停在它们上面，光标不会改变，这意味着它们真的被禁用了！让我们为禁用按钮内部的图标创建一个样式，以更加突出禁用状态：
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Okay, now that we have beautiful disabled buttons, let's bring a bit of life
    into them!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们有了漂亮的禁用按钮，让我们为它们注入一些生命吧！
- en: 'Let''s think about what should actually happen to the application states when
    we start, pause, or stop the application:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下当我们启动、暂停或停止应用程序时实际上应该发生什么：
- en: When we start the application, the state `started` should become `true` and
    both `paused` and `stopped` states should for sure become `false`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们启动应用程序时，状态“started”应该变为“true”，而“paused”和“stopped”状态肯定会变为“false”。
- en: When we pause the application, the state `paused` is `true`, state `stopped`
    is `false`, and state `started` is `true` because a paused application continues
    to be started.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们暂停应用程序时，状态“paused”为“true”，状态“stopped”为“false”，而状态“started”为“true”，因为暂停的应用程序仍然是启动的。
- en: When we stop the application, the state `stopped` becomes `true` and both the `paused`
    and `started` states become `false`. Let's translate all this behavior into mutation_types,
    mutations, and actions!
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们停止应用程序时，状态“stopped”变为“true”，而“paused”和“started”状态变为“false”。让我们将所有这些行为转化为mutation_types、mutations和actions！
- en: 'Open `mutation_types.js` and add three mutation types as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`mutation_types.js`并添加三种mutation类型如下：
- en: '[PRE66]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now let''s define mutations! Open the `mutations.js` file and add three mutations
    for each of the mutation types. So, we have decided that when we:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义mutations！打开`mutations.js`文件并为每种mutation类型添加三种mutations。因此，我们决定当我们：
- en: '**Start the application**: The state `started` is `true`, and states `paused`
    and `stopped` are `false`.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动应用程序**：状态“started”为“true”，而状态“paused”和“stopped”为“false”。'
- en: '**Pause the application**: The state `started` is `true`, the state `paused`
    is `true`, and `stopped` are `false`.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暂停应用程序**：状态“started”为“true”，状态“paused”为“true”，而“stopped”为“false”。'
- en: '**Stop the application**: The state `stopped` is `true`, and states `started`
    and `paused` are `false`.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止应用程序**：状态“stopped”为“true”，而状态“started”和“paused”为“false”。'
- en: 'Now let''s put it into the code. Import `mutation_types` to `mutations.js`
    and write all three necessary mutations as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把它放到代码中。将`mutation_types`导入到`mutations.js`中，并编写所有三个必要的mutations如下：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now let''s define our actions! Go to the `actions.js` file, import mutation
    types, and export three functions:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义我们的actions！转到`actions.js`文件，导入mutation类型，并导出三个函数：
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The final touch to bring our buttons to life is to import these actions into
    `ControlsComponent` and call them on the `click` event on each button. Let''s
    do it. Do you still remember how to call the action on some event applied to the
    HTML element? If we are talking about the `click` event, it is just the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的按钮生效，最后一步是将这些actions导入到`ControlsComponent`中，并在每个按钮的`click`事件上调用它们。让我们来做吧。你还记得如何在HTML元素上应用事件时调用action吗？如果我们谈论的是`click`事件，就是下面这样的：
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'So, in our `ControlsComponent.vue`, we import the `mapActions` object, map
    it to the component''s `methods` property, and apply it to the corresponding button''s
    clicks. That''s all! The `<script>` tag of `ControlsComponent` will thus look
    like the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的`ControlsComponent.vue`中，我们导入`mapActions`对象，将其映射到组件的`methods`属性，并将其应用于相应按钮的点击事件。就是这样！`ControlsComponent`的`<script>`标签看起来像下面这样：
- en: '[PRE70]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now call these functions inside the event handler directives within the template
    so that the `<template>` tag of the `ControlsComponent` looks like the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在模板中的事件处理程序指令内调用这些函数，使得`ControlsComponent`的`<template>`标签看起来像下面这样：
- en: '[PRE71]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Try to click the buttons. They do exactly what we need them to do. Nice work!
    Check it out in the [chapter5/pomodoro2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro2)
    folder. However, we are not done yet. We still have to make our Pomodoro timer
    into an actual timer and not just some page that allows you to click some buttons
    and watch them changing their states from disabled to enabled.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试点击按钮。它们确实做到了我们需要它们做的事情。干得漂亮！在[chapter5/pomodoro2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro2)文件夹中查看。然而，我们还没有完成。我们仍然需要将我们的番茄钟定时器变成一个真正的定时器，而不仅仅是一些允许您点击按钮并观察它们从禁用状态到启用状态的页面。
- en: Binding Pomodoro minutes and seconds
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定番茄钟的分钟和秒
- en: 'In the previous section, we were able to define three different states of the
    Pomodoro application: `started`, `paused`, and `stopped`. However, let''s not
    forget about what the Pomodoro application should be used for. It must countdown
    some given time for work and then switch to the break count down timer, and then
    come back to work, and so on.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们能够定义番茄钟应用的三种不同状态：`开始`，`暂停`和`停止`。然而，让我们不要忘记番茄钟应用应该用于什么。它必须倒计时一定的工作时间，然后切换到休息倒计时器，然后再回到工作，依此类推。
- en: 'This leads us to realize that there is one more very important Pomodoro application''s
    state: the binary state that toggles between *working* and *resting* periods of
    time. This state cannot be toggled by buttons; it should somehow be managed by
    our application''s internal logic.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们意识到，还有一个非常重要的番茄钟应用状态：在*工作*和*休息*时间段之间切换的二进制状态。这个状态不能由按钮切换；它应该以某种方式由我们应用的内部逻辑来管理。
- en: 'Let''s start by defining two state properties: one for the counter that will
    be decreased with the time and the other one to distinguish between the working
    and not-working states. Let''s assume that when we start our Pomodoro, we start
    our working day, so the working state should be set to true and the countdown
    counter should be set to the amount of time that we define for our working Pomodoro
    period. For the sake of modularity and maintainability, let''s define the amount
    of time for work and for rest in an external file. Let''s call it, for example,
    `config.js`. Create the `config.js` file in the project''s root directory and
    add the following content:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义两个状态属性：一个用于随着时间减少的计数器，另一个用于区分工作状态和非工作状态。假设当我们开始番茄钟时，我们开始工作，所以工作状态应该设置为true，倒计时计数器应该设置为我们定义的工作番茄钟时间。为了模块化和可维护性，让我们在外部文件中定义工作和休息的时间。比如，我们称之为`config.js`。在项目的根目录下创建`config.js`文件，并添加以下内容：
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: By these initializations I mean that our Pomodoro should count down *20* minutes
    for the working Pomodoro interval and *5* minutes for breaks. Of course, you are
    free to define your own values that are most suitable for you. Let's now export
    `config.js` in our store and reuse the `WORKING_TIME` value to initialize our
    counter. Let's also create a property that toggles between work/break and call
    it `isWorking`. Let's initialize it to `true`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些初始化，我的意思是我们的番茄钟应该倒计时*20*分钟的工作番茄钟间隔和*5*分钟的休息时间。当然，你可以自由定义最适合你的值。现在让我们在我们的存储中导出`config.js`，并重用`WORKING_TIME`值来初始化我们的计数器。让我们还创建一个在工作/休息之间切换的属性，并将其命名为`isWorking`。让我们将其初始化为`true`。
- en: 'So, our new state will look like the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的新状态将如下所示：
- en: '[PRE73]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: So, we have these two nice new properties. Before starting to create methods,
    actions, mutations, and other things that decrease the counter and toggle the
    `isWorking` property, let's think of the visual elements that rely on these properties.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有了这两个新的属性。在开始创建方法、操作、突变和其他减少计数器和切换`isWorking`属性的事情之前，让我们考虑依赖这些属性的可视元素。
- en: We don't have so many elements, so it's easy to define.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有那么多元素，所以很容易定义。
- en: 'The `isWorking` state is affecting the title: we should display **`Work!`**
    when it''s time to work and **`Rest!`** when it''s time to have a rest.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isWorking`状态影响标题：当是工作时间时，我们应该显示**`工作！`**，当是休息时间时，我们应该显示**`休息！`**。'
- en: 'The `isWorking` state is also affecting the kittens component visibility: it
    should be displayed only when `isWorking` is `false`.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isWorking`状态也影响着小猫组件的可见性：只有当`isWorking`为`false`时才应该显示。'
- en: 'The `counter` property affects `minute` and `second`: each time it decreases,
    the `second` should also decrease its value, and every 60 decreases, the `minute`
    should also decrease its value.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counter`属性影响`minute`和`second`：每次它减少时，`second`的值也应该减少，每减少60次，`minute`的值也应该减少。'
- en: 'Let''s define getters functions for the `isWorking` state and for the `minute`
    and the `second`. After defining these getters, we can reuse them in our components
    instead of using the hardcoded values. Let''s start by defining a getter for the
    `isWorking` property:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`isWorking`状态和`minute`和`second`定义获取函数。在定义这些获取函数之后，我们可以在我们的组件中重用它们，而不是使用硬编码的值。让我们首先定义一个用于`isWorking`属性的获取器：
- en: '[PRE74]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s reuse this getter in the components that were using hardcoded `isworking`
    defined in the `App.vue` component. Open `App.vue`, remove all the references
    to the `isworking` hardcoded variable, import the `mapGetters` object, and map
    the `isworking` property to the `isWorking` method inside the `computed` property
    as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在使用在`App.vue`组件中定义的硬编码`isworking`的组件中重用此getter。 打开`App.vue`，删除对`isworking`硬编码变量的所有引用，导入`mapGetters`对象，并将`isworking`属性映射到`computed`属性中的`isWorking`方法，如下所示：
- en: '[PRE75]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Repeat the same steps in `StateTitleComponent`. Import `mapGetters` and replace
    `props` with mapped `computed` property:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StateTitleComponent`中重复相同的步骤。 导入`mapGetters`并用映射的`computed`属性替换`props`：
- en: '[PRE76]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The rest is left untouched in both the components! Inside the templates, the
    `isworking` property is used. This property continues to exist; it's just imported
    from the reactive Vuex store and not from the hardcoded data!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件中的其余部分保持不变！ 在模板内，使用`isworking`属性。 此属性仍然存在； 它只是从响应式的Vuex存储中导入，而不是从硬编码数据中导入！
- en: 'Now we must define getters for minutes and seconds. This part is trickier because
    in these getters, we have to apply some computation to the counter state''s property.
    This is not difficult at all. Our counter represents a total number of seconds.
    This means that we can easily extract minutes by dividing the counter by 60 and
    rounding to the lowest integer (`Math.floor`). The seconds can be extracted by
    taking the remainder of the division by 60\. Thus, we can write our getters for
    minutes and seconds in the following way:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须为分钟和秒定义getter。 这部分比较棘手，因为在这些getter中，我们必须对计数器状态的属性应用一些计算。 这一点一点也不难。 我们的计数器表示总秒数。
    这意味着我们可以通过将计数器除以60并四舍五入到最低整数（`Math.floor`）来轻松提取分钟。 秒数可以通过取除以60的余数来提取。 因此，我们可以以以下方式编写我们的分钟和秒的getter：
- en: '[PRE77]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'That''s it! Let''s now reuse these getters in the `CountdownComponent`. Import
    `mapGetters` and map its corresponding methods to the `min` and `sec` properties
    inside the `computed` property. Do not forget to remove the hardcoded data. Our
    `script` tag of the `CountdownComponent.vue` will thus look like the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！ 现在让我们在`CountdownComponent`中重用这些getter。 导入`mapGetters`并将其相应的方法映射到`computed`属性中的`min`和`sec`属性。
    不要忘记删除硬编码的数据。 因此，我们的`CountdownComponent.vue`的`script`标签如下所示：
- en: '[PRE78]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The rest is left completely untouched! The template was referencing the `min`
    and `sec` properties, and they continue to exist. The code as it was until now
    can be found in the [chapter5/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro3)
    folder. Look at the page; now the displayed minutes and seconds correspond to
    the amount of working time we''ve defined in our configuration file! If you change
    it, it will change as well:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分完全不变！ 模板引用了`min`和`sec`属性，它们仍然存在。 到目前为止的代码可以在[chapter5/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro3)文件夹中找到。
    看看页面； 现在显示的分钟和秒数对应于我们在配置文件中定义的工作时间！ 如果您更改它，它也会随之更改：
- en: '![Binding Pomodoro minutes and seconds](../Images/image00292.jpeg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![绑定番茄钟分钟和秒](../Images/image00292.jpeg)'
- en: Changing the configuration for the amount of working time will immediately affect
    the Pomodoro application view
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 更改工作时间的配置将立即影响番茄钟应用程序视图
- en: Creating the Pomodoro timer
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建番茄钟定时器
- en: Okay, now everything is ready to actually start to count down our working time
    so we can finally have some rest! Let's define two auxiliary functions, `togglePomodoro`
    and `tick`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在一切准备就绪，可以开始倒计时我们的工作时间，这样我们最终可以休息一下！ 让我们定义两个辅助函数，`togglePomodoro`和`tick`。
- en: The first one will just toggle the `isWorking` property. It will also redefine
    the state's counter. When the state `isWorking`, the counter should correspond
    to the working time, and when the state is not working, the counter should correspond
    to the resting time.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将只是切换`isWorking`属性。它还将重新定义状态的计数器。当状态为`isWorking`时，计数器应该对应工作时间，当状态不工作时，计数器应该对应休息时间。
- en: 'The `tick` function will just decrease the counter and check if it has reached
    "0" value, and in this case, will toggle the Pomodoro state. The rest is already
    being taken care of. So, the `togglePomodoro` function will look like the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: tick`函数将只是减少计数器并检查是否已达到“0”值，在这种情况下，将切换Pomodoro状态。其余的已经被照顾好了。因此，`togglePomodoro`函数将如下所示：
- en: '[PRE79]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Ah, and do not forget to import `WORKING_TIME` and `RESTING_TIME` from our
    config! Also, do not forget to import `underscore` since we are using it for the `_.isBoolean`
    check:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，不要忘记从我们的配置中导入`WORKING_TIME`和`RESTING_TIME`！还有，不要忘记导入`underscore`，因为我们在`_.isBoolean`检查中使用它：
- en: '[PRE80]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, the `tick` function will just decrease the counter and check if it has
    reached the "0" value:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`tick`函数将只是减少计数器并检查是否已达到“0”值：
- en: '[PRE81]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Fine! It's still not enough. We need to set the interval that would call the
    `tick` function for each second. Where should it be set? Well, it is more than
    clear that it should be done when we start our Pomodoro, in the `START` mutation!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！还不够。我们需要设置一个间隔，每秒调用一次`tick`函数。它应该在哪里设置？嗯，很明显，当我们开始Pomodoro时，应该这样做在`START`变异中！
- en: 'But if we set the interval in the `START` mutation and it calls the `tick`
    function each second, how will it be stopped or paused on hitting the pause or
    stop button? That''s why the `setInterval` and `clearInterval` JavaScript functions
    exist and that''s why we have a store where we can save the initial state for
    the `interval` value! Let''s start by defining `interval` as `null` in the store''s
    state:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们在`START`变异中设置了间隔，并且它每秒调用一次`tick`函数，那么在点击暂停或停止按钮时，它将如何停止或暂停？这就是为什么存在`setInterval`和`clearInterval`
    JavaScript函数，这也是为什么我们有一个存储可以保存`interval`值的初始状态的地方！让我们首先在存储状态中将`interval`定义为`null`：
- en: '[PRE82]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, in our `START` mutation, let''s add the following code that initializes
    the interval:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`START`变异中，让我们添加以下代码来初始化间隔：
- en: '[PRE83]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We just set an interval that will call the `tick` function each second. In turn,
    the `tick` function will decrease the counter. The values that rely on the counter's
    value—minute and second—will change and reactively propagate these changes to
    the view.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚设置了一个间隔，每秒调用一次`tick`函数。反过来，`tick`函数将减少计数器。依赖于计数器值的值——分钟和秒——将改变，并且会将这些更改反应地传播到视图中。
- en: 'If you click on the start button now, you will set the countdown in action!
    Yay! It''s almost done. We just need to add the `clearInterval` function on the
    `pause` and `stop` mutation methods. Apart from this, on the `stop` method, let''s
    call the `togglePomodoro` function with `true`, which will reset the Pomodoro
    timer to the working state:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在点击开始按钮，你将启动倒计时！耶！几乎完成了。我们只需要在`pause`和`stop`变异方法上添加`clearInterval`函数。除此之外，在`stop`方法上，让我们调用`togglePomodoro`函数，并传入`true`，这将重置Pomodoro计时器到工作状态：
- en: '[PRE84]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Changing the kitten
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改小猫咪
- en: 'I hope you worked a lot and your resting time has finally come! If not and
    if you can''t wait for it, just change the `WORKING_TIME` value in the `config.js`
    file for something considerably small and wait for it. I think I finally deserve
    some rest, so I''ve been staring at this nice image for some minutes already:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你工作了很多，你的休息时间终于到了！如果没有，或者如果你等不及了，只需在`config.js`文件中将`WORKING_TIME`的值更改为相当小的值，然后等待。我认为我终于应该休息一下了，所以我已经盯着这张漂亮的图片看了几分钟了：
- en: '![Changing the kitten](../Images/image00293.jpeg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![更改小猫咪](../Images/image00293.jpeg)'
- en: I am staring at the image, the cat is staring at me
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我盯着这张图片，猫也盯着我。
- en: Wouldn't you like the displayed image to change sometimes? Of course, you would!
    In order to achieve this, we must just append something to the image source so
    that it changes with time and delivers a non-cached image to us.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想有时候显示的图片改变吗？当然想！为了实现这一点，我们只需向图像源附加一些内容，以便随着时间的推移而改变，并向我们提供一个非缓存的图像。
- en: Tip
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One of the best practices to deliver non-cached things is to append the *timestamp*
    to the requested URL.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 提供非缓存内容的最佳实践之一是将*时间戳*附加到请求的URL中。
- en: 'We could, for example, have another property in our store, let''s say, `timestamp`,
    which would be updated with each counter decrease and its value would be appended
    to the image-source URL. Let''s do it! Let''s start by defining a `timestamp`
    property in our store''s state as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在存储中有另一个属性，比如`timestamp`，它将随着每次计数器减少而更新，并且它的值将被附加到图像源URL。让我们做吧！让我们首先在我们存储的状态中定义一个`timestamp`属性，如下所示：
- en: '[PRE85]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Tell the `tick` function to update this value on each tick:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉`tick`函数在每次滴答时更新这个值：
- en: '[PRE86]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Create the getter for this value in `getters.js` and use it inside the `KittensComponent`
    by accessing the `this.$store.getters.getTimestamp` method inside the `computed`
    property:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getters.js`中为这个值创建getter，并在`KittensComponent`中使用它，通过在`computed`属性中访问`this.$store.getters.getTimestamp`方法：
- en: '[PRE87]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now it''s a little bit too fast, right? Let''s define a time to show each kitten.
    It''s not difficult at all. For example, if we decide to show each kitten for
    3 seconds, before changing the state of the timestamp inside the `tick` function,
    we just have to check if the counter value is divisible by 3\. Let''s also make
    the amount of seconds to show the kitten configurable. Add the following to `config.js`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在速度有点太快了，对吧？让我们定义一个时间来展示每只小猫。这一点都不难。例如，如果我们决定每只小猫展示3秒钟，在`tick`函数内改变时间戳状态之前，我们只需要检查计数器的值是否可以被3整除。让我们也把展示小猫的秒数变成可配置的。在`config.js`中添加以下内容：
- en: '[PRE88]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now import it to the `mutations.js` file and use it in the `tick` function
    to check if it''s time to change the timestamp''s value:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其导入到`mutations.js`文件中，并在`tick`函数中使用它来检查是否是改变时间戳值的时候：
- en: '[PRE89]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We are done! You can check the final code for this section in the [chapter5/pomodoro4](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro4)
    folder. Yes, I've set the working time to 6 seconds so that you can have a break
    and enjoy some really nice kittens from [thecatapi.com](http://thecatapi.com)
    .
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！您可以在[chapter5/pomodoro4](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro4)文件夹中检查本节的最终代码。是的，我将工作时间设置为6秒，这样您就可以休息一下，并欣赏一些来自[thecatapi.com](http://thecatapi.com)的非常可爱的小猫。
- en: 'So, before reading the summary of this chapter and starting the next one, take
    a break! Just like this wonderful species:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在阅读本章摘要并开始下一章之前，休息一下！就像这个美妙的物种一样：
- en: '![Changing the kitten](../Images/image00294.jpeg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![改变小猫](../Images/image00294.jpeg)'
- en: Wonderful thing having its break. Be like him. Take a break.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 美好的事物需要休息。像它一样。休息一下。
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you saw how to use the events handling and triggering mechanism
    to propagate the components' data changes to their parents.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到了如何使用事件处理和触发机制来将组件的数据更改传播到它们的父级。
- en: Most importantly, you used the power of Vuex architecture to be able to establish
    the data flow between the components. You saw how the store is created, and its
    main parts, mutations, and states. You learned how to structure the application
    that uses the store so that it becomes modular and maintainable. You also learned
    how to create the store's getters and how to define actions that dispatch the
    store state's mutations. We applied all the learned mechanisms to our applications
    and saw the data flow in action.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，您利用了Vuex架构的力量，能够在组件之间建立数据流。您看到了如何创建存储库以及其主要部分，即mutations和states。您学会了如何构建使用存储库的应用程序，使其变得模块化和可维护。您还学会了如何创建存储库的getters以及如何定义分派存储库状态变化的actions。我们将所有学到的机制应用到我们的应用程序中，并看到了数据流的实际操作。
- en: At this point, we are able to use any data exchanging mechanism in Vue applications,
    starting from simple local data binding inside the components and going further
    to global state management. At this point, we know all the bases to operate data
    inside our Vue application. We're almost done!
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们能够在Vue应用程序中使用任何数据交换机制，从简单的组件内部的本地数据绑定开始，逐渐扩展到全局状态管理。到目前为止，我们已经掌握了在Vue应用程序中操作数据的所有基础知识。我们快要完成了！
- en: In the next chapter, we will go deep into the plugins system for Vue applications.
    You will learn how to use existing plugins and create your own plugin to enrich
    your applications with custom behavior.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨Vue应用程序的插件系统。您将学习如何使用现有的插件并创建自己的插件，以丰富您的应用程序的自定义行为。
