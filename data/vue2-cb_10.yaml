- en: Large Application Patterns with Vuex
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vuex的大型应用程序模式
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Dynamically loading pages in your vue-router
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在vue-router中动态加载页面
- en: Building a simple storage for the application state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个简单的应用程序状态存储
- en: Understanding Vuex mutations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Vuex的mutations
- en: Listing your actions in Vuex
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vuex中列出您的操作
- en: Separating concerns with modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块分离关注点
- en: Building getters to help retrieve your data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建getter以帮助检索数据
- en: Testing your store
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试您的存储
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, you will learn how Vuex works and how to use it to support
    a scalable application. Vuex implements a pattern that is popular in frontend
    frameworks and consists of dividing the different concerns to manage a big global
    application state. The mutations are the only things that can change the state,
    so you have only one place to look for that. Much of the logic, along with all
    the asynchronous logic, is contained in the actions; finally, getters and modules
    further help to spread the cognitive load when it comes to computing the derived
    state and splitting your code into different files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习Vuex的工作原理以及如何使用它来支持可扩展的应用程序。Vuex实现了一种在前端框架中流行的模式，它将不同的关注点分开管理一个大型全局应用程序状态。只有mutations可以改变状态，所以您只需要在一个地方查找。大部分逻辑以及所有异步逻辑都包含在actions中；最后，getters和modules进一步帮助在计算派生状态和将代码拆分为不同文件时分散认知负荷。
- en: Along with recipes, you will find grains of wisdom that I found useful when
    developing real large applications; some have to do with naming conventions and
    others with little tricks to avoid bugs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配方之外，您还会发现在开发实际的大型应用程序时我发现有用的一些智慧之粒；有些与命名约定有关，有些则是为了避免错误的小技巧。
- en: If you complete all the recipes, you will be ready to develop big frontend applications
    with fewer bugs and seamless collaboration.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完成了所有的配方，您将准备好开发具有较少错误和无缝协作的大型前端应用程序。
- en: Dynamically loading pages in your vue-router
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在vue-router中动态加载页面
- en: Soon, you will build huge Vue websites with loads of components. Loading a lot
    of JavaScript may generate wasteful and useless upfront delay. In the *Loading
    your components asynchronously*  recipe in [Chapter 4](text00195.html) , *All
    About Components* , we already saw a hint of how to retrieve our components remotely.
    Here we will apply a similar technique to components loaded by a route in vue-router.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，您将构建具有大量组件的大型Vue网站。加载大量JavaScript可能会产生浪费和无用的前期延迟。在[第4章](text00195.html)的*关于组件的一切*中的*异步加载组件*配方中，我们已经看到了如何远程检索组件的提示。在这里，我们将使用类似的技术来加载由vue-router路由加载的组件。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe requires knowledge of vue-router. If you want, you can go through *Loading
    your components asynchronously*  in  [Chapter 4](text00195.html) , *All About
    Components* , to get a better idea of what is happening.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要了解vue-router。如果您愿意，您可以通过在[第4章](text00195.html)的*关于组件的一切*中的*异步加载组件*来更好地了解发生了什么。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new project with `vue-cli` by making a new directory and running the
    following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个新目录并运行以下命令，使用`vue-cli`创建一个新项目：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can answer the question as you prefer, as long as you add the `vue-router`
    to the template when asked.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据自己的喜好回答问题，只要在要求时将`vue-router`添加到模板中即可。
- en: 'We will create two components: one will be our home page and it will be small
    and light, the other component will be very big and very slow to load. What we
    want to achieve is to load the home page immediately, without having to wait for
    the huge component to be downloaded by the browser.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个组件：一个将是我们的主页，它将是小而轻巧的，另一个组件将非常大且加载速度非常慢。我们想要实现的是立即加载主页，而不必等待浏览器下载巨大的组件。
- en: 'Open the `Hello.vue` file in the `components` folder. Delete everything and
    only leave the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`文件夹中打开`Hello.vue`文件。删除所有内容，只留下以下内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the same folder, create another file named `Massive.vue` and write the following
    inside it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件夹中，创建另一个名为`Massive.vue`的文件，并在其中写入以下内容：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Leave an open back tick at the last line because we have to bloat the file with
    a lot of useless data. Save and close `Massive.vue` .
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行留下一个打开的反引号，因为我们必须用大量无用的数据膨胀文件。保存并关闭`Massive.vue`。
- en: 'In a console, go to the same directory where the file is stored and use the
    following file to put a lot of garbage into it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，进入与文件存储在同一目录的位置，并使用以下文件将大量垃圾数据放入其中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What this command does is append the `XXX`  line to the file repeatedly 10⁶
     times; this will add 4 million bytes to the file, making it too huge for a fast
    browsing experience.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的作用是将`XXX`行重复附加到文件中10⁶次；这将使文件增加400万字节，使其对于快速浏览体验来说太大了。
- en: 'Now we need to close the back tick we opened. Don''t try to open the file now,
    as your text editor may not be capable of opening such a big file; instead, use
    the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要关闭我们打开的反引号。现在不要尝试打开文件，因为你的文本编辑器可能无法打开这么大的文件；相反，使用以下命令：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `Massive` component is now complete.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Massive`组件现在已经完成。
- en: 'Open the `index.js` inside the `router` folder and add the component and its route:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`router`文件夹中的`index.js`文件，并添加组件及其路由：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After installing all the dependencies with `npm install` , we are now ready
    to launch our very large app with the `npm run dev`  command.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm install`安装所有依赖项后，我们现在可以使用`npm run dev`命令启动我们非常大的应用程序了。
- en: 'The app will load quite fast, but that''s because it''s loading directly from
    your local storage; to simulate a more realistic scenario, open the developer
    tools at the Network tab and select network throttling. Pick something slow, such
    as GPRS or maybe good 3G, which most of us may have:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将加载得非常快，但这是因为它直接从本地存储加载；为了模拟更真实的情况，打开开发者工具的网络选项卡，并选择网络限制。选择一些慢速的网络，比如GPRS或者较好的3G，这是我们大多数人可能拥有的：
- en: '![](img/Image00170.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00170.jpg)'
- en: 'Now right-click on the refresh button and select Hard Reload to bypass the
    cache (or press *Shift* + *Cmd* + *R* ):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在右键单击刷新按钮，选择强制刷新以绕过缓存（或按*Shift* + *Cmd* + *R*）：
- en: '![](img/Image00171.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00171.jpg)'
- en: You will notice that the page doesn't load for a few minutes. You can stop the
    loading of the page by clicking on the refresh button again when it becomes an
    X.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到页面在几分钟内不会加载。您可以通过在刷新按钮变成X时再次点击来停止页面的加载。
- en: 'To fix this, go back to the `index.js` file in the `router` folder. Delete
    the following line, where you import the `Massive` component:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这个问题，请返回到“router”文件夹中的“index.js”文件。删除以下行，其中导入“Massive”组件：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding line is telling Webpack to include all the code contained in the
    `Massive` component in a single js bundle. Instead, we want to tell Webpack to
    keep the `Massive` component as a separate bundle and to load it only when necessary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行告诉Webpack将“Massive”组件中包含的所有代码包含在一个js包中。相反，我们希望告诉Webpack将“Massive”组件保持为一个单独的包，并且只在必要时加载它。
- en: 'Instead of directly importing the component, declare `Massive` with the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不要直接导入组件，使用以下代码声明“Massive”：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Webpack will turn this special syntax into a separate file that will be loaded
    lazily. Save and do another hard refresh with the throttling still set to slow
    speed (like GPRS to good 3G). After a few seconds, you should be able to see the
    hello page. If you want to load the `Massive` component, just add `massive` to
    the URL, but you'll be in for some waiting.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack将把这个特殊的语法转换成一个单独的文件，它将被懒加载。保存并进行另一个硬刷新，同时将限制速度设置为较慢的速度（如GPRS到良好的3G）。几秒钟后，您应该能够看到hello页面。如果您想加载“Massive”组件，只需将“massive”添加到URL中，但您将需要等待一段时间。
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now you obviously won't have such a big component in a real application, but
    you can easily see that if the `Massive` component represents all the other components
    of your app, they can quickly amount to such a big size.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显然在真实应用程序中不会有这么大的组件，但您可以很容易地看到，如果“Massive”组件代表应用程序的所有其他组件，它们可能很快达到如此大的大小。
- en: The trick here is to load them asynchronously; Webpack will help you separate
    them into smaller bundles so that they will be loaded only if and when required.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是异步加载它们；Webpack将帮助您将它们分成较小的包，以便只在需要时加载。
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is an alternative syntax to import components lazily. It may become an
    ECMA standard in the future, so you should be aware of it. Open `index.js` inside
    the `router` directory and completely remove the import of the `Massive` component
    or the `Massive` constant line we added in this recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种替代的语法可以懒加载导入组件。它可能成为未来的ECMA标准，所以您应该知道它。打开“router”目录中的“index.js”文件，并完全删除对“Massive”组件的导入或我们在这个示例中添加的“Massive”常量行。
- en: 'Inside the routes, try the following when specifying the component for the
    `/massive` route:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由中，尝试在指定“/massive”路由的组件时使用以下代码：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will be equivalent to what we have done before, because Webpack will take
    the line and instead of directly importing the code of the Massive component,
    it will create a different js file, loaded lazily.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将等同于我们之前所做的，因为Webpack将获取该行，并且不会直接导入Massive组件的代码，而是创建一个不同的js文件，进行懒加载加载。
- en: Building a simple storage for the application state
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序状态构建一个简单的存储
- en: In this recipe, you will understand the fundamentals of Vuex when building a
    big application. This recipe is a little unorthodox because to understand how
    Vuex's store work, we will manipulate it directly; you should never do that in
    a real application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将了解在构建大型应用程序时使用Vuex的基本原理。这个示例有点不正规，因为为了理解Vuex存储的工作原理，我们将直接操作它；在真实的应用程序中，您永远不应该这样做。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before trying this recipe, you should complete Making two components talk with
    Vuex  in [*Chapter 4*](text00195.html) ,  *All About Components* .
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试这个示例之前，您应该完成[*第4章*](text00195.html)中的“使用Vuex使两个组件通信”。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: 'Create a new project based on the Webpack template with the following command
    run in a new directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新目录中运行以下命令，基于Webpack模板创建一个新项目：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How you answer the question is not relevant. Run `npm intall`  and install Vuex
    with `npm install vuex --save` or `yarn add vuex` if you use yarn.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何回答这个问题并不重要。运行`npm intall`并使用`npm install vuex --save`或`yarn add vuex`（如果使用yarn）安装Vuex。
- en: 'Open the  `main.js`  file inside the `src` folder and add the following highlighted
    lines to finish installing Vuex:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`src`文件夹中的`main.js`文件，并添加以下突出显示的行以完成安装Vuex：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, there is no `store` module right now, so you need to create one.
    To do this, create a folder just under the `src` folder and call it `store` .
    Inside it, create a file named `index.js` . In the `main.js`  file, we didn't
    specify to use the `index.js` file, but that's the default behavior when no file
    is specified but only the folder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在没有`store`模块，所以您需要创建一个。为此，请在`src`文件夹下创建一个文件夹，并将其命名为`store`。在其中创建一个名为`index.js`的文件。在`main.js`文件中，我们没有指定使用`index.js`文件，但当没有指定文件而只有文件夹时，这是默认行为。
- en: 'What we will implement is a simplified stock market. We have three assets:
    stars (STAR), lamps (LAMP), and diamonds (DIAM). We will define two routes: one
    for the STAR/LAMP market and another for the LAMP/DIAM market.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个简化的股票市场。我们有三种资产：星星（STAR），灯（LAMP）和钻石（DIAM）。我们将定义两个路线：一个用于STAR/LAMP市场，另一个用于LAMP/DIAM市场。
- en: 'Inside the `index.js` file in the store folder, write the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在store文件夹中的`index.js`文件中编写以下内容：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We are creating a new `Vuex` store that will hold our balance. Initially, we
    have 100 of each asset; in the store, the exchange rate between stars and lamps
    and between lamps and diamonds is also fixed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个新的`Vuex`存储，用于保存我们的余额。最初，我们每种资产有100个；在存储中，星星和灯之间以及灯和钻石之间的汇率也是固定的。
- en: 'Create a new component under the `components` directory, named `Market.vue`
    . It will have the following template:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`目录下创建一个名为`Market.vue`的新组件。它将具有以下模板：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`symbol1` and `symbol2` represent the two assets traded. In the JavaScript
    of this component, where we define the `sell` and `buy` methods, we operate directly
    on the global `Vuex` store:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbol1`和`symbol2`代表两个交易的资产。在这个组件的JavaScript中，我们定义了`sell`和`buy`方法，直接在全局的`Vuex`存储中进行操作：'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should never touch the state directly like I've done here. You should always
    use mutations. Here, we are skipping the middleman to keep the recipe minimalistic.
    There's more on mutations in the next recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不应该像我在这里所做的那样直接操作状态。你应该始终使用mutations。在这里，我们跳过了中间人，以保持这个示例的简洁性。在下一个示例中会更多地介绍mutations。
- en: 'You have to use this component in `index.js` , inside the `router` folder,
    in the following way:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在`index.js`中的`router`文件夹中以以下方式使用这个组件：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we are using the `Market` component for any route that
    contains a couple of trade symbols. As a home page, we are using the STAR/LAMP
    market.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用`Market`组件来处理包含一对交易符号的任何路由。作为主页，我们使用了STAR/LAMP市场。
- en: 'To display some navigation links to a different market and our current balance,
    we can edit the `App.vue` component with the following template:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示一些导航链接到不同的市场和我们当前的余额，我们可以使用以下模板编辑`App.vue`组件：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We don't need any JavaScript for this component, so you can delete the `<script>`
    tag.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个组件，我们不需要任何JavaScript代码，所以你可以删除`<script>`标签。
- en: 'Our app is now ready; launch it and start trading with it. The following image
    is our completed app without the styles contained in `App.vue` :'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在已经准备好了；启动它并开始进行交易。下面的图片是我们完成的应用程序，不包含在`App.vue`中的样式：
- en: '![](img/Image00172.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00172.jpg)'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The balance in the bottom is like a summary of the global state. With Vuex,
    we were able to affect other components by accessing the `$store` variable that
    gets injected in every component by the Vuex plugin. You can easily imagine how
    to use this strategy in a big application when you want to basically expand the
    scope of a variable beyond the component itself.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的余额就像是全局状态的一个总结。通过访问每个组件中由Vuex插件注入的`$store`变量，我们可以影响其他组件。当你想要将变量的作用域扩展到组件本身之外时，你可以很容易地想象如何使用这种策略在一个大型应用程序中。
- en: Some of the states may be local, for example if you need some animations or
    you need some variables to show modal dialogs for the component; it's perfectly
    okay to not put these values in the store. Otherwise, having a structured centralized
    state in one place helps a lot. In the subsequent recipes, you'll use more advanced
    techniques to exploit the power of Vuex better.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一些状态可能是局部的，例如如果你需要一些动画或者你需要一些变量来显示组件的模态对话框；不把这些值放在存储中是完全可以的。否则，在一个地方拥有一个结构化的集中状态会有很大帮助。在接下来的示例中，你将使用更高级的技术来更好地利用Vuex的强大功能。
- en: Understanding Vuex mutations
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Vuex的mutations
- en: The proper way to mutate the state in a Vuex application is with the help of
    mutations. Mutations are a very useful abstraction to decompose state changes
    in the atomic unit. In this recipe, we will explore just that.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vuex应用程序中，改变状态的正确方式是通过mutations的帮助。mutations是一种非常有用的抽象，用于将状态变化分解为原子单位。在这个示例中，我们将探索这一点。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe can be completed without knowing too much about Vuex, but completing
    the previous recipe first is suggested.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不需要对Vuex了解太多就可以完成这个示例，但建议先完成前一个示例。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Add Vuex as a dependency to your project (the CDN address is `https://unpkg.com/vuex`
    ). I will assume that you are using JSFiddle to follow along; otherwise, just
    remember to put `Vue.use(Vuex)` before the store code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将Vuex作为项目的依赖项添加进来（CDN地址为`https://unpkg.com/vuex`）。我假设你正在使用JSFiddle进行跟随；否则，请记得在存储代码之前放置`Vue.use(Vuex)`。
- en: The sample application we will build is to broadcast notifications to the users
    of the website.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的示例应用程序是向网站用户广播通知。
- en: 'The HTML layout looks as shown:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: HTML布局如下所示：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The idea is to have a textbox to write messages and the broadcasted messages
    will be displayed on the top with the most recent appearing first. The messages
    can be dismissed by clicking on the little x .
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的想法是有一个文本框用于编写消息，广播的消息将显示在顶部，最新的消息将首先显示。可以通过点击小x来关闭消息。
- en: 'First, let''s build a store that will hold the list of broadcasted messages
    and enumerate the possible mutations we can make to said list:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们构建一个存储库，用于保存广播消息的列表，并枚举我们可以对该列表进行的可能的变化：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, we have a list of messages; we can push one to the top of the list or we
    can remove a message by knowing its index.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有一个消息列表；我们可以将一个消息推送到列表的顶部，或者通过知道其索引来删除一个消息。
- en: 'Next, we need to write the logic of the application itself:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写应用程序本身的逻辑：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can now launch the app and start broadcasting messages to our imaginary
    users:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以启动应用程序并开始向我们的虚拟用户广播消息了：
- en: '![](img/Image00173.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00173.jpg)'
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: I think it's important to note the names of the mutations; they are called `pushMessage`
    and `removeMessage` , but what they really do in this application is show the
    message in a stack on the screen and (fictionally) broadcast messages to users.
    Would it be better to call them `showMessage` , or `broadcastMessage` and `hideMessage`
    ? No, that's because there has to be a clear separation of intent between the
    mutation itself and the particular effects of that mutation. The problem becomes
    clear when, for example, we decide to give users the ability to ignore these notifications
    or we introduce a delay before actually broadcasting the notifications. Then we
    will have a `showMessage` mutation that does not actually show a message.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为值得注意的是突变的名称；它们被称为`pushMessage`和`removeMessage`，但在这个应用程序中它们实际上是在屏幕上显示消息并（虚构地）向用户广播消息。将它们称为`showMessage`或`broadcastMessage`和`hideMessage`会更好吗？不，因为突变本身和突变的特定效果之间必须有明确的意图分离。当我们决定让用户有能力忽略这些通知或在实际广播通知之前引入延迟时，问题就变得清晰了。然后我们将有一个`showMessage`突变，它实际上不显示消息。
- en: 'The computed syntax we have used is as illustrated:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的计算语法如下所示：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You don't have to explicitly use Vuex in your expression when you are importing
    Vuex as an ES6 module. You just need to write
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将Vuex作为ES6模块导入时，您不必在表达式中显式使用Vuex。您只需要写
- en: '`import { mapState } from ''Vuex''` .'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { mapState } from ''Vuex''`。'
- en: Then, the `mapState` function will be available.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`mapState`函数将可用。
- en: The `mapState` method takes an array of strings as a parameter, looks for a
    `state` variable in the store with the same name as the string, and creates a
    computed property with the same name. You can do this with as many variables as
    you want.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapState`方法接受一个字符串数组作为参数，在存储中查找与字符串同名的`state`变量，并创建一个同名的计算属性。您可以使用任意多个变量进行此操作。'
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you followed along on a local npm project, open the Vue developer tools
    (unfortunately Vue developer tools is not available when using JSFiddle) and you
    will see that a new mutation is issued with each message. Consider that you click
    on the little clock:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本地npm项目上跟随，打开Vue开发者工具（不幸的是，在使用JSFiddle时无法使用Vue开发者工具），您将看到每个消息都会发出一个新的突变。考虑一下，您点击了小时钟：
- en: '![](img/Image00174.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00174.jpg)'
- en: 'Y ou can actually undo the mutation with that, as shown in the following illustration:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以使用它来撤消突变，如下图所示：
- en: '![](img/Image00175.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00175.jpg)'
- en: Note how the state didn't change when clicking the time travel option; that's
    because the purple ribbon is still at the last state. To examine a different state,
    just click on the name of the mutation itself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当点击时间旅行选项时，状态没有改变；这是因为紫色丝带仍然在最后一个状态。要检查不同的状态，只需点击突变名称。
- en: This debug mechanism is possible because mutations are always synchronous; this
    means that it's possible to take a snapshot of the state before and after the
    mutation and navigate through time. In the next recipe, you will learn how to
    use Vuex to perform asynchronous actions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调试机制是可能的，因为突变总是同步的；这意味着可以在突变之前和之后对状态进行快照，并通过时间进行导航。在下一个示例中，您将学习如何使用Vuex执行异步操作。
- en: Listing your actions in Vuex
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Vuex中列出您的操作
- en: All your mutations must be synchronous, so how do you do things such as waiting
    for a timeout or using Axios for an AJAX request? Actions are the next level of
    abstraction that will help you with this. Inside an action, you can commit multiple
    mutations and make asynchronous operations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您的所有突变都必须是同步的，那么如何等待超时或使用Axios进行AJAX请求呢？操作是下一级的抽象层，将帮助您解决这个问题。在操作内部，您可以提交多个突变并进行异步操作。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Mutations are the building blocks of actions, so it's highly suggested you complete
    the preceding recipe before trying this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 突变是操作的构建块，因此强烈建议您在尝试此操作之前完成前面的示例。
- en: We will be using the setup from the *Building a simple storage for the application
    state*  recipe; you can use your own as well, but in any case this recipe is based
    on a slight modification of the official Webpack template.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用“构建应用程序状态的简单存储”示例中的设置；您也可以使用自己的设置，但无论如何，此示例都基于官方Webpack模板的轻微修改。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: You will build a clone of the popular Xkcd website. Actually, it will be a wrapper
    more than a real clone, since we will reuse the panels from the website.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您将构建一个流行的Xkcd网站的克隆。实际上，它将更像是一个包装器，而不是一个真正的克隆，因为我们将重用网站上的面板。
- en: 'Create a Vue project based on the Webpack template with `vue init webpack`
    . The first thing we will do is wire up the API to the Xkcd website in the `index.js`
    inside the `config` folder. Put the following lines inside the `proxyTable` object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Webpack模板创建一个Vue项目，使用`vue init webpack`。我们将首先在`config`文件夹中的`index.js`中将API连接到Xkcd网站。将以下行放入`proxyTable`对象中：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will redirect all the requests we make to `/comic` to the Xkcd website.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将将我们发出的所有请求重定向到`/comic`到Xkcd网站。
- en: 'Inside `src` , make a new `store` directory and an `index.js` inside it; here,
    start building the application store:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`中，创建一个新的`store`目录，并在其中创建一个`index.js`文件；在这里，开始构建应用程序存储：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You should import this inside `main.js` like in previous recipes. We want to
    trace the current panel number, the link to the panel image, and the possible
    errors. The only way to modify the state is through mutations, while actions can
    perform asynchronous work.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该像在之前的示例中那样在`main.js`中导入它。我们想要跟踪当前面板编号、面板图像的链接和可能的错误。修改状态的唯一方法是通过突变，而操作可以执行异步工作。
- en: 'When the app is loaded, we plan to display the latest comic. For this, we create
    an action:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序加载时，我们计划显示最新的漫画。为此，我们创建一个操作：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For this code to work, we need to declare the endpoint and install Axios:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此代码工作，我们需要声明端点并安装Axios：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It should be easy for you to write the corresponding mutations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 编写相应的变异应该很容易：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll recycle the `Hello.vue` component and put the following template inside
    it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用`Hello.vue`组件，并将以下模板放在其中：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To make the last panel appear on loading you can use the following JavaScript
    in the component:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要在加载时显示最后一个面板，可以在组件中使用以下JavaScript代码：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Also, you can delete most of the `App.vue` template and leave only the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以删除大部分`App.vue`模板，只保留以下内容：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `proxyTable` object will configure the `http-proxy-middleware` . This is
    useful every time we are developing the UI of a bigger web application and we
    launch our developer server on `localhost` , but our API responds to another web
    server. This is especially relevant when we want to use CORS and we don't allow
    other websites to use our API. The Xkcd API doesn't allow `localhost` to consume
    the web service. This is why, even if we try to use the Xkcd API directly, our
    browser won't let us. The `changeOrigin` option will send the request with Xkcd
    as host, making CORS unnecessary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxyTable`对象将配置`http-proxy-middleware`。每当我们开发一个较大的Web应用程序的UI，并在`localhost`上启动我们的开发服务器时，这非常有用，但我们的API响应到另一个Web服务器。当我们想要使用CORS并且不允许其他网站使用我们的API时，这一点尤为重要。Xkcd
    API不允许`localhost`使用Web服务。这就是为什么，即使我们尝试直接使用Xkcd API，我们的浏览器也不会让我们这样做。`changeOrigin`选项将使用Xkcd作为主机发送请求，从而使CORS变得不必要。'
- en: To call an action from a component, we used the `dispatch` function. It's also
    possible to pass the second argument, the first being the name of the action itself.
    The second argument is then passed when you define the action as the second parameter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要从组件中调用一个动作，我们使用了`dispatch`函数。还可以传递第二个参数，第一个参数是动作本身的名称。然后，在定义动作时，将第二个参数作为第二个参数传递。
- en: A last note on the naming--it being implicit that actions are asynchronous while
    mutations are synchronous, there is no need, in my opinion, to make the asynchronicity
    in the name of the actions explicit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命名的最后一点说明——在我的观点中，动作是异步的，而变异是同步的，因此没有必要在动作的名称中显式地表明异步性。
- en: Separating concerns with modules
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块分离关注点
- en: When building big applications, the Vuex store can become crowded. Luckily,
    it's possible to divide the different concerns of the applications into separate
    compartments with modules.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建大型应用程序时，Vuex存储可能会变得拥挤。幸运的是，可以使用模块将应用程序的不同关注点分成单独的部分。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe can be a reference if you want to use modules. You are expected
    to already know enough about Vuex.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用模块，可以将此示例作为参考。您应该已经了解足够多的Vuex知识。
- en: For this recipe, you will have to be a little familiar with Webpack.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您需要对Webpack有一定的了解。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we will model a fully functional human body in a slightly simplified
    manner. Every organ will have a separate module.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将以稍微简化的方式对一个完全功能的人体进行建模。每个器官都将有一个单独的模块。
- en: 'Create a new Webpack template with `vue init webpack`  and `npm install vuex`
    . Create a new directory with the `src/store/index.js`  file in it. Inside, write
    the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `vue init webpack` 创建一个新的 Webpack 模板，并安装 `npm install vuex`。创建一个包含 `src/store/index.js`
    文件的新目录。在其中，写下以下内容：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `heart` module is like this; put it before the store declaration:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`heart` 模块是这样的；在 store 声明之前放置它：'
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note how the state passed inside the mutations is not the root state, but the
    local state of the module.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 mutations 中传递的状态不是根状态，而是模块的本地状态。
- en: 'Then comes the brain, which is divided into the left and right lobes; write
    the following before the store:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是大脑，它被分为左右两个脑叶；在 store 之前写下以下内容：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can implement them as simple Boolean states (write them before the brain
    on which they depend):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将它们实现为简单的布尔状态（在它们所依赖的大脑之前写下它们）：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Setting `namespaced`  to true modifies the way you can call the mutator. Since
    they are both called `toggle` , now you can specify which lobe, for example, for
    the left lobe the mutation string becomes `left/toggle` , where `left`  says it
    is the key used in the brain to refer to the left lobe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `namespaced` 设置为 true 会修改你调用 mutator 的方式。由于它们都被称为 `toggle`，现在你可以指定是哪个脑叶，例如，对于左脑，突变字符串变为
    `left/toggle`，其中 `left` 表示它是大脑中用于引用左脑的键。
- en: 'To see your store in action, you can create a component that uses all the mutations.
    For the brain, we can have two pictures of the lobes, like so:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你的 store 在运行中的情况，你可以创建一个使用所有 mutations 的组件。对于大脑，我们可以有两个脑叶的图片，如下所示：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will create two drawings of brain lobes in red pencil; note the use of
    the name of the modules in a nested way. The following `off` CSS rule grays the
    lobes out:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建两个红铅笔绘制的脑叶图；注意嵌套方式中模块名称的使用。以下的 `off` CSS 规则将使脑叶变灰：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To call the mutations, we use the aforementioned strings in the right methods:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用 mutations，我们在正确的方法中使用上述字符串：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also create an input textbox and call the other two mutations, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个输入文本框并调用其他两个 mutations，如下所示：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This was very easy, but how do you retrieve the loved name? You can put these
    mustachios in your template:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但是如何获取所爱的名称呢？你可以在模板中使用这些胡子：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You obviously have to declare the `partner` variable on your Vue instance:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你必须在 Vue 实例上声明 `partner` 变量：
- en: '![](img/Image00177.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00177.jpg)'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have seen how to use modules to split your application concerns into different
    units. This ability may become important as the project grows in size.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用模块将应用程序的关注点分割成不同的单元。随着项目规模的增长，这种能力可能变得重要。
- en: 'The common pattern is that while inside a mutation, you have direct access
    to the local state:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的模式是，在一个 mutation 中，你可以直接访问本地状态：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In a mutation, it makes sense to have access only to the local state. The brain,
    for example, cannot change the heart and vice versa, but what about actions? If
    we declare an action inside a module, we are passed an object called context that
    looks like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在mutation中，只能访问本地状态是有意义的。例如，大脑不能改变心脏，反之亦然，但是动作呢？如果我们在模块内声明一个动作，我们会传递一个名为context的对象，它看起来像这样：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, if we want to declare an action in the left lobe and we want to affect
    the heart, we have to do something like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们想在左侧叶子中声明一个动作，并且我们想要影响心脏，我们必须做以下操作：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Building getters to help retrieve your data
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建getter来帮助检索数据
- en: You don't want to keep too much data in your state. It can be especially dangerous
    to keep duplicate or derivative data because it can be brought out of sync very
    easily. Getters help you with this without shifting the burden onto the components
    by keeping all the logic in one place.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想在状态中保留太多数据。保留重复或派生数据尤其危险，因为它很容易使数据不同步。Getter可以帮助你解决这个问题，而不会将负担转移到组件上，因为所有逻辑都集中在一个地方。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is for you if you already have some Vuex knowledge and want to expand
    your horizons.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经具备一些Vuex知识并且想要扩展你的视野，那么这个教程适合你。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Imagine that you are building a Bitcoin wallet. You want to give your users
    an overview of their balance, and you want them to see how many Euros it corresponds
    to.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在构建一个比特币钱包。你想给用户一个关于他们余额的概览，并且你希望他们看到对应的欧元数量。
- en: 'Create a new Webpack template with `vue init webpack`  and `npm install vuex`
    . Create a new `src/store/index.js`  file and write the following inside it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vue init webpack`和`npm install vuex`创建一个新的Webpack模板。创建一个新的`src/store/index.js`文件，并在其中写入以下内容：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code is prone to errors. The first error can be a miscalculation of the
    Euro amount if we don't get the multiplication right. The second kind of error
    can be that we tell the user the `bitcoin` and `euro` balance during a transaction,
    resulting in a stale and wrong amount for one of the two.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码容易出错。第一个错误可能是欧元金额的计算错误，如果我们没有正确进行乘法运算。第二种错误可能是在交易过程中告诉用户`bitcoin`和`euro`余额，导致其中一个金额过时和错误。
- en: 'To tackle these issues, we use `getters` :'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们使用`getters`：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This way the `euro` amount is never in the state but always computed. Moreover,
    it is centralized in the store, so we don't need to add anything to our components.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`euro`金额永远不会在状态中，而是始终计算得出。此外，它集中在存储中，所以我们不需要在组件中添加任何内容。
- en: 'Now, it''s easy to retrieve the two amounts from a template:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从模板中轻松检索两个金额：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, `&#3647 ;`  is the HTML entity for the Bitcoin symbol.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`&#3647 ;`是比特币符号的HTML实体。
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Having a `getter` for derived data is always a good idea if we are not talking
    about input data. A notable feature of getters we have not yet discussed is their
    ability to interact with other getters and take an argument.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不谈论输入数据，那么为派生数据设置一个`getter`总是一个好主意。我们还没有讨论过getter的一个显著特点是它们能够与其他getter进行交互并接受一个参数。
- en: Accessing other getters
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问其他getter
- en: 'The second argument passed to a getter when called is the object that contains
    the other `getters` :'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用getter时传递的第二个参数是包含其他`getter`的对象：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In our recipe, we could call the `euro` getter to have some more derived data,
    like roughly how many houses we can buy with our Bitcoin given an average price
    of 150,000 euros:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以调用`euro` getter来获得一些派生数据，例如我们可以用平均价格为150,000欧元的比特币购买多少房屋：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Passing an argument
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递参数
- en: 'If a getter returns a function with an argument, that argument will be the
    argument of the getter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个getter返回一个带有参数的函数，那么该参数将是getter的参数：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In our recipe, a practical example could specify the average cost of a house
    in the getter from the previous paragraph:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，一个实际的例子可以在前一段中的getter中指定房屋的平均成本：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Testing your store
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的商店
- en: As you know from [*Chapter 7*](text00346.html) , *Unit Testing and End-To-End
    Testing* , testing is the most important part of professional software. As the
    store often defines the business logic of your application, testing it may be
    vital for your application. In this recipe, you will write tests for a Vuex store.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从[*第7章*](text00346.html)中所了解的，测试是专业软件中最重要的部分。由于商店通常定义应用程序的业务逻辑，因此对其进行测试对于应用程序可能是至关重要的。在这个示例中，你将为Vuex商店编写测试。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires knowledge from [*Chapter 7*](text00346.html) , *Unit Testing
    and End-To-End Testing* and familiarity with Vuex; you can get it from the earlier recipes
    of this chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例需要来自[*第7章*](text00346.html)的知识，即*单元测试和端到端测试*以及对Vuex的熟悉；你可以从本章的早期示例中获得它。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, I'll define some features that our store must implement; then you will
    write tests that prove that the features are present and working.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将定义一些我们的商店必须实现的功能；然后你将编写测试来证明这些功能是否存在并且正常工作。
- en: Software requirements
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件要求
- en: 'Our store consists of items in a to-do list, like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的商店由待办事项列表中的项目组成，如下所示：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have two requirements:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个要求：
- en: We must have an `MARK_ITEM_AS_DONE` mutation that changes the `done` field from
    false to true
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个`MARK_ITEM_AS_DONE`变异，将`done`字段从false更改为true
- en: We must have a `downloadNew`  action that downloads the latest items from our
    server and adds them to the list
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个`downloadNew`操作，从服务器下载最新的项目并将它们添加到列表中
- en: Testing mutations
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试变异
- en: 'To be able to test your mutations, you have to make them available for your
    test files. To do this, you have to extract the mutation object from your store.
    Consider something like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够测试你的变异，你必须使它们在测试文件中可用。为此，你必须从商店中提取变异对象。考虑类似于这样的东西：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You have to extract it to something similar to this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须将其提取到类似以下的内容中：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This way, you can import the mutations in your test files with the following
    line:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您可以在测试文件中使用以下代码导入mutations：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The test for requirement number 1 can be written as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 满足需求1的测试可以编写如下：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you are using the official Webpack template, you can run your tests with
    `npm run unit` . This uses PhantomJS by default, which doesn't implement some
    features. You can either use Babel polyfills or simply go into `karma.conf.js`
    and write `Chrome`  instead of `PhantomJS`  in the `browsers` array. Remember
    to install the Chrome launcher with `npm install karma-chrome-launcher --save-dev`
    .
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用官方的Webpack模板，可以使用`npm run unit`运行测试。默认情况下，这将使用PhantomJS，它不实现某些功能。您可以使用Babel
    polyfills，或者只需进入`karma.conf.js`并在`browsers`数组中将`PhantomJS`替换为`Chrome`。记得使用`npm
    install karma-chrome-launcher --save-dev`安装Chrome launcher。
- en: Testing actions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试actions
- en: '**Testing actions** means testing that the action commits the expected mutations.
    We are not interested in the mutations themselves (not in unit tests at least)
    because they are already tested separately. We might, though, need to mock some
    dependencies.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试actions**意味着测试操作是否提交了预期的mutations。我们对mutations本身不感兴趣（至少在单元测试中不感兴趣），因为它们已经单独测试过了。但是，我们可能需要模拟一些依赖项。'
- en: 'To avoid any dependencies from Vue or Vuex (since we don''t need them and they
    may pollute the tests), we create a new `actions.js` file inside the `store` directory.
    Install Axios with `npm install axios` . The  `actions.js` file can look like
    the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免依赖于Vue或Vuex（因为我们不需要它们，而且它们可能会污染测试），我们在store目录中创建一个新的`actions.js`文件。使用`npm
    install axios`安装Axios。`actions.js`文件可以如下所示：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To test for requirement number 2, we start by mocking the call to the server
    that should download the new to-do items:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试需求2，我们首先模拟应该下载新的待办事项的服务器调用：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This will ensure that any call to the get method of `axios` will always return
    a new to-do item.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保对`axios`的get方法的任何调用都将始终返回一个新的待办事项。
- en: 'Then, we want to ensure that the `ADD_ITEMS` mutation is called upon dispatch:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们希望确保在调度时调用`ADD_ITEMS` mutation：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '工作原理如下... '
- en: While the testing of the mutations is pretty straightforward, I think the testing
    of the actions deserves some more explaining.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对mutations的测试非常简单，但我认为对actions的测试值得更多解释。
- en: Since we didn't want to depend on external services for actions, we had to mock
    the `axios` service. We used the `inject-loader` , which takes the original library
    and mocks the parts we specify with arbitrary code (the `@` symbol is a shorthand
    for `src` ); in our case, we mocked the `axios` library and, precisely, the `get`
    method. We had to use the CommonJS syntax (with the `require` ) because that's
    the only way to tell Webpack to use loaders in imports.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想依赖外部服务来执行操作，我们不得不模拟`axios`服务。我们使用了`inject-loader`，它接受原始库并使用任意代码模拟我们指定的部分（`@`符号是`src`的简写）；在我们的情况下，我们模拟了`axios`库，特别是`get`方法。我们必须使用CommonJS语法（使用`require`）因为这是告诉Webpack在导入时使用加载器的唯一方式。
- en: What we have done in the test is that we also mocked the `commit` function.
    Normally, this function calls a mutation that modifies the state. We just want
    to know if the correct mutation is called and with the right arguments. Moreover,
    we had to wrap everything in a `try` block; without it, the test would fail over
    a timeout and we'd lose the error. Instead, now we fail immediately and we can
    read, from the console, what error caused the test to fail.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们所做的是模拟`commit`函数。通常，这个函数调用一个修改状态的mutation。我们只想知道是否调用了正确的mutation，并且传入了正确的参数。此外，我们不得不将所有内容包装在一个`try`块中；如果没有它，测试将超时失败，我们将丢失错误信息。相反，现在我们立即失败，并且可以从控制台中读取导致测试失败的错误。
