- en: Getting Started with Vue.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue.js入门
- en: 'In this chapter the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Writing Hello World with Vue.js
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue.js编写Hello World
- en: Writing lists
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写列表
- en: Creating a dynamic and animated list
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个动态和动画列表
- en: Reacting to events such as clicks and keystrokes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应事件，如点击和按键
- en: Choosing a development environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择开发环境
- en: Formatting your text with filters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器格式化文本
- en: Debugging your application with mustaches (for example, a JSON filter)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mustaches调试应用程序（例如JSON过滤器）
- en: X-raying your application with Vue developer tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue开发者工具分析应用程序
- en: Upgrading to Vue.js 2
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级到Vue.js 2
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Vue is a very powerful framework but one of its strengths is that it is very
    lightweight and easy to pick up. As a matter of fact, in the first recipe you
    will build a simple but functioning program in minutes, with no setup required.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Vue是一个非常强大的框架，但其优势之一是它非常轻量级且容易上手。事实上，在第一个示例中，您将在几分钟内构建一个简单但功能齐全的程序，无需任何设置即可完成。
- en: In this chapter, you will learn lists which will help you create web pages where
    an element is repeated (like a catalog). Furthermore, you will build an interactive
    page with event listeners.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何创建重复元素的网页列表（如目录）。此外，您将构建一个带有事件监听器的交互式页面。
- en: Some development environments are presented so you can choose the one that suits
    you better; you will use some debugging tricks that will give you a head start
    when developing your own code and better insight to kill bugs in your apps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您更好地选择开发环境，我们还介绍了一些开发环境。您将使用一些调试技巧来快速开发自己的代码，并更好地理解如何解决应用程序中的错误。
- en: Please note that, at the time of writing, ES5 is the most well supported standard
    for JavaScript in browsers. In this chapter, I will use ES5 so you can follow
    along even if your browser does not support the newer ES6\. Remember though that
    in following chapters ES6 will be used. By now, Chrome is compatible with most
    ES6 important constructs, but in general you should use **Babel** to make your
    app compatible with older browsers. Refer to the recipe *How to use Babel to compile
    from ES6* in [Chapter 8](text00390.html) , *Organize + Automate + Deploy = Webpack*
    , when you are ready to use Babel.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在撰写本文时，ES5是浏览器中JavaScript最好支持的标准。在这一章中，我将使用ES5，这样即使您的浏览器不支持更新的ES6，您也可以跟着学习。请记住，在后续章节中将使用ES6。目前，Chrome与大多数ES6的重要构造兼容，但通常您应该使用**Babel**使您的应用程序兼容旧版浏览器。当您准备好使用Babel时，请参考[第8章](text00390.html)中的配方*如何使用Babel编译ES6*，以及*组织
    + 自动化 + 部署 = Webpack*。
- en: Writing Hello World with Vue.js
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Vue.js编写Hello World
- en: Let's create the simplest possible program in Vue.js, the obligatory Hello World
    program. The objective here is to get our feet wet with how Vue manipulates your
    webpage and how data binding works.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Vue.js创建最简单的程序，即必备的Hello World程序。我们的目标是让您熟悉Vue如何操作您的网页以及数据绑定是如何工作的。
- en: Getting Ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To complete this introductory recipe, we will only need the browser. That is,
    we will use JSFiddle to write our code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个入门示例，我们只需要使用浏览器。也就是说，我们将使用JSFiddle来编写代码：
- en: '![](img/Image00004.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00004.jpg)'
- en: 'If you have never used JSFiddle, don''t worry; you are about to become an expert
    frontend developer and using JSFiddle will become a handy tool in your pocket:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从未使用过JSFiddle，请不要担心；您即将成为一名专业的前端开发人员，使用JSFiddle将成为您口袋中的有用工具：
- en: 'Head your browser to [https://jsfiddle.net](https://jsfiddle.net) :'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的浏览器导航到[https://jsfiddle.net](https://jsfiddle.net)：
- en: You will be presented with a blank page divided into quadrants. The bottom-left
    is where we will write our JavaScript code. Going clockwise, we have an HTML section,
    a CSS section, and finally our preview of the resulting page.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个空白页面分为四个象限。左下方是我们将编写JavaScript代码的地方。按顺时针方向，我们有一个HTML部分，一个CSS部分，最后是我们预览的结果页面。
- en: Before beginning, we should tell JSFiddle that we want to use the Vue library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，我们应该告诉JSFiddle我们想要使用Vue库。
- en: In the top-right part of the JavaScript quadrant, press the cogwheel and select
    Vue 2.2.1 from the list (you should find more than one version, "edge" refers
    to the latest version and at the time of writing corresponds to Vue 2).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript象限的右上角，点击齿轮图标并从列表中选择Vue 2.2.1（你会找到多个版本，“edge”代表最新版本，在撰写时对应的是Vue 2）。
- en: We are now ready to write our first Vue program.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好编写我们的第一个Vue程序了。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体步骤如下：
- en: 'In the JavaScript section, write:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript部分写入：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the HTML quadrant, we create the `<div>` :'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML象限中，创建`<div>`：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Click the Run button in the upper-left corner; we see the page greeting us
    with Hello world :'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左上角的运行按钮，我们可以看到页面显示Hello world：
- en: '![](img/Image00005.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00005.jpg)'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理如下：
- en: '`new Vue({el:''#app''})` will instantiate a new Vue instance. It accepts an
    options object as a parameter. This object is central in Vue, and defines and
    controls data and behavior. It contains all the information needed to create Vue
    instances and components. In our case, we only specified the `el` option which
    accepts a selector or an element as an argument. The `#app`  parameter is a selector
    that will return the element in the page with `app` as the identifier. For example,
    in a page like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Vue({el:''#app''})`将实例化一个新的Vue实例。它接受一个选项对象作为参数。这个对象在Vue中是核心的，它定义和控制数据和行为。它包含了创建Vue实例和组件所需的所有信息。在我们的例子中，我们只指定了`el`选项，它接受一个选择器或一个元素作为参数。`#app`参数是一个选择器，将返回页面中以`app`作为标识符的元素。例如，在这样的页面中：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Everything that we will write inside the `<div>`  with the ID as `app` will
    be under the scope of Vue.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在具有ID为`app`的`<div>`中编写的所有内容都将在Vue的范围之内。
- en: Now, JSFiddle takes everything we write in the HTML quadrant and wraps it in
    body tags. This means that if we just need to write the `<div>` in the HTML quadrant,
    JSFiddle will take care of wrapping it in the body tags.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JSFiddle会将我们在HTML象限中编写的所有内容包装在body标签中。这意味着，如果我们只需要在HTML象限中写入`<div>`，JSFiddle会负责将其包装在body标签中。
- en: It's also important to note that placing the `#app`  on the `body` or `html`
    tag will throw an error, as Vue advises us to mount our apps on normal elements,
    and its the same thing goes for selecting the `body` in the `el` option.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点要注意，将`#app`放置在`body`或`html`标签上会抛出错误，因为Vue建议我们将应用挂载在普通元素上，选择`body`也是同样的情况。
- en: The mustaches (or handlebars) are a way to tell Vue to take everything inside
    them and parse it as code. The quotes are a normal way to declare a literal string
    in JavaScript, so Vue just returns the string concatenation of `hello`  and `world`
    . Nothing fancy, we just concatenated two strings and displayed the result.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号（或者叫handlebars）是告诉Vue将其内部的所有内容解析为代码的一种方法。引号是JavaScript中声明字面字符串的一种正常方法，所以Vue只会返回`hello`和`world`的字符串拼接。没有什么花哨的东西，我们只是将两个字符串拼接在一起并显示结果。
- en: There's more
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容
- en: 'We can leverage that to do something more interesting. If we were aliens and
    we wanted to greet more than one world at a time, we could write:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这一点做一些更有趣的事情。如果我们是外星人，想要同时问候多个世界，我们可以这样写：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We may lose track of how many worlds we conquer. No problem, we can do math
    inside the mustaches. Also, let''s put `Hello`  and `worlds`  outside brackets:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会追踪不住我们征服了多少个世界。没问题，我们可以在花括号内进行数学运算。另外，让我们将`Hello`和`worlds`放在花括号之外：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Having the number of worlds as raw numbers inside the mustaches is just messy.
    We are going to use data binding to put it inside a named variable inside our
    instance:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在花括号内使用原始数字表示世界的数量会显得很混乱。我们将使用数据绑定将其放在实例中的一个命名变量中：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is how tidy applications are done. Now, every time we conquer a planet,
    we have to edit only the `countWorlds` variable. In turn, every time we modify
    this variable, the HTML will be automatically updated.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整洁应用程序的实现方式。现在，每次我们征服一个星球，我们只需要编辑`countWorlds`变量。反过来，每次我们修改这个变量，HTML将自动更新。
- en: Congratulations, you completed your first step into the Vue world and are now
    able to build simple interactive applications with reactive data-binding and string
    interpolation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已经完成了进入Vue世界的第一步，现在可以使用响应式数据绑定和字符串插值构建简单的交互式应用程序。
- en: Writing lists
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写列表
- en: The desire to produce lists almost seems to be an innate part of human nature.
    There is a deeply satisfying feeling that one obtains by watching a well ordered
    list marching down the computer screen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 生产列表的欲望似乎是人类天性中固有的一部分。通过观察一个井然有序的列表在计算机屏幕上滚动，人们可以获得一种深深满足的感觉。
- en: With Vue, we are given the tools to make lists of any kind with a stunning appearance
    and maximum ease.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 借助Vue，我们可以使用出色的外观和极大的便利性制作各种类型的列表。
- en: Getting Ready
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe we are going to use basic data-binding, if you follow the very
    first recipe you are already familiar with it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇文章中，我们将使用基本的数据绑定，如果您遵循了最初的教程，您已经很熟悉它了。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体操作如下...
- en: 'We are going to build lists in a couple of different ways: with a range of
    numbers, with an array, and finally with an object.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以几种不同的方式构建列表：使用一系列数字、使用数组以及使用对象。
- en: Range of numbers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一系列数字
- en: 'To start off with lists, set up your JSFiddle like in the preceding recipe,
    adding Vue.js as a framework. Select Vue 2.2.1 (or Vue (edge) ):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建列表，请像前面的教程中一样设置您的JSFiddle，并添加Vue.js作为框架。选择Vue 2.2.1（或Vue（edge））：
- en: 'In the JavaScript section, write:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript部分编写如下内容：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And in the HTML write:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML中编写如下内容：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will result in a list with *Hello!*  written four times. In a few seconds
    your first list is complete, nice job!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致一个列表，其中*Hello!*重复出现四次。几秒钟后，您的第一个列表就完成了，做得好！
- en: 'We can write a countdown with this technique--in the HTML, replace the content
    of the `<div>` with the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种技术编写一个倒计时 - 在HTML中，将<div>标签的内容替换为以下内容：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Arrays
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'In the HTML, to achieve the same result, edit the list to reflect the following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML中，为了得到相同的结果，编辑列表以反映以下内容：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although this list is identical to the previous one, we shouldn't put literal
    arrays in HTML markup.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个列表与上一个列表相同，但我们不应该在HTML标记中放置字面数组。
- en: 'We''re better off with a variable that contains the array. Edit the preceding code
    to match the following:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最好使用一个包含数组的变量。将前面的代码修改为以下内容：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then put the array countdown in the JavaScript:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在JavaScript中放置数组倒计时：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/Image00006.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00006.jpg)'
- en: Arrays with index notation
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用索引表示的数组
- en: 'When enumerating an array, we also have access to the index, represented by
    the variable `i`  in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '当枚举一个数组时，我们还可以访问索引，由变量`i`在下面的代码中代表:'
- en: 'The HTML becomes:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'HTML如下:'
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the code part, write:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在代码部分中，写:'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](img/Image00007.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00007.jpg)'
- en: Objects
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: The preceding example can be refactored to match animal names and their sounds
    so that an accidental misalignment of the index will not affect our list.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子可以进行重构，以匹配动物的名称和声音，这样索引的意外错位就不会影响我们的列表。
- en: 'The HTML becomes:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'HTML如下:'
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And we need to create the  `animals`  object in the JavaScript:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们需要在JavaScript中创建`animals`对象:'
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The workings of lists are quite simple; here is a little more explanation on
    the syntax.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的工作原理非常简单; 这里对语法进行了更多解释。
- en: Range of numbers
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字范围
- en: 'The variable `n` is in scope inside the `<li>` tag. To prove it to yourself,
    you can quickly build a countdown list as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '变量`n`在`<li>`标签内是可见的。为了证明这一点，你可以快速构建一个倒计时列表，如下所示:'
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We write `11` instead of `10` because enumeration in Vue is 1-indexed; this
    means that `n` in `10` will start to count from `1` , not from `0` like someone
    might expect, and go up to `10` . If we want our countdown to start from `10`
    , then we have to put `11` . The last number will be `10` , so we'll have `1`
    as the last number before the missile is launched.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写`11`而不是`10`，因为在Vue中枚举是从1开始计数的；这意味着`10`中的`n`将从`1`开始计数，而不是从`0`开始计数，而有些人可能会期望从`0`开始，并一直增加到`10`。如果我们希望倒计时从`10`开始，那么我们必须写`11`。最后一个数将是`10`，所以在导弹发射前，我们将会有`1`作为最后一个数字。
- en: What `v-for="n in 10"` does is call **enumeration** ; specifically we are enumerating
    a range of numbers (1 to 10).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-for="n in 10"`的作用是调用**枚举**; 具体来说，我们正在枚举一个数字范围（从1到10）。'
- en: Arrays
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Vue allows us to enumerate arrays too. The general syntax is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'Vue也允许我们枚举数组。一般的语法如下:'
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As seen, the index and parenthesis can be omitted if all we want are the array
    elements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，如果我们只想要数组元素，索引和括号可以省略。
- en: This form of enumeration is guaranteed to be ordered. In other words, the ordered
    sequence of elements in the array will be the same you will see on the screen;
    this is not the case when enumerating objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种枚举形式是有序的。换句话说，数组中元素的有序序列将与屏幕上看到的相同；而当枚举对象时则不是这样。
- en: Objects
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: The syntax is `v-for="(value, property)"` and if you want you can also squeeze
    in the index with `v-for="(value, property, index)"` . The latter is not recommended
    though since, as already said, the order in which properties are enumerated is
    not fixed. In practice, in most browsers, the order is the same as the insertion
    order but this is not guaranteed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是`v-for =“（value，property）”`，如果你想的话也可以加上索引`v-for =“（value，property，index）”`。后者不推荐使用，因为如前所述，枚举属性的顺序是不固定的。实际上，在大多数浏览器中，顺序与插入顺序相同，但不保证一定如此。
- en: Creating a dynamic and animated list
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个动态和动画列表
- en: In Vue most data is reactive. In practice this means that if something is going
    to change in our view-model, we will see the results immediately. This is what
    lets you concentrate on the app itself, leaving aside all the drawing logic. In
    this recipe, we are also going to acknowledge some limitations of this system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue中，大部分数据都是响应式的。实际上，这意味着如果我们的视图模型中有变化，我们将立即看到结果。这就是让您专注于应用本身，抛开所有绘图逻辑的原因。在本篇中，我们还将了解此系统的一些限制。
- en: Getting Ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you should know how to use basic data-binding (introduced
    in the very first recipe) and how to create lists (second recipe).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，你应该知道如何使用基本的数据绑定（在第一个教程中介绍）以及如何创建列表（第二个教程）。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'In the previous recipe we built a list for a countdown for a missile launch:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的教程中，我们为导弹发射倒计时构建了一个列表：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Wouldn''t it be great if it was animated? We can tweak the JavaScript to add
    numbers to countdown as seconds pass:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它能被动画化就好了！我们可以调整JavaScript代码，以使倒计时在秒数增加时添加数字：
- en: Copy the preceding code in the HTML and JavaScript sectors of JSFiddle, with
    the exception that we will fill the countdown ourselves, so set it to an empty
    array.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上述代码复制到JSFiddle的HTML和JavaScript区域，除了我们将自己填充倒计时，所以将其设置为空数组。
- en: To get hold of the countdown variable we must pass the variable through the
    Vue instance itself.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取倒计时变量，我们必须通过Vue实例本身传递该变量。
- en: 'Assign the Vue instance to a variable for later reference:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Vue实例分配给一个变量以供以后参考：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This way we can use `vm` to access the Vue instance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以使用`vm`来访问Vue实例。
- en: 'Initialize the countdown from 10:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从10开始初始化倒计时：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Set up a function that repeatedly adds the number of remaining seconds to the
    now empty `countdown` array:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个函数，该函数重复将剩余秒数添加到现在为空的`countdown`数组中：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we are going to do is get a reference of the `countdown` array and fill
    it with decrementing numbers with the help of `setInterval` .
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是获取`countdown`数组的引用，并借助于`setInterval`将其填充为递减的数字。
- en: We are accessing `countdown` through the `vm` variable we set in the line `vm.countdown.push(counter--)`
    , so our list will get updated every time we add a new number to the array.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`vm.countdown.push(counter--)`行中设置的`vm`变量来访问`countdown`，因此每次向数组添加新数字时，我们的列表都将更新。
- en: 'This code is very simple, just note that we must use the `push` function to
    add elements to the array. Adding elements with the square brackets notation will
    not work:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常简单，只需注意我们必须使用`push`函数将元素添加到数组中。使用方括号表示法添加元素将无效：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The array will get updated, but this way of assignment will skip Vue's reactive
    system due to how JavaScript is implemented.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 数组将被更新，但是由于JavaScript的实现方式，这种赋值方式将跳过Vue的响应式系统。
- en: There's more
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: Running the code now will add countdown numbers one at a time; great, but what
    about the final element `launch missile` ? We want that to appear only at the
    end.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行代码将一次添加一个倒计时数字；很好，但是最后一个元素`发射导弹`呢？我们希望它只在最后出现。
- en: 'To do that here is a little hack we can do directly in HTML:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，在HTML中我们可以直接进行一个小的技巧：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This solution is not the best we can do; learn more in the recipe on `v-show`
    .
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案不是我们所能做到的最好的；在`v-show`的示例中了解更多内容。
- en: 'We just learned that we cannot add elements to a reactive array with the brackets
    notation if we want it to update in the view. This is true also for the modification
    of elements using brackets and for manually changing the length of the array:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解到，如果我们希望在视图中更新，不能使用方括号表示法向响应式数组中添加元素。对于使用方括号修改元素和手动更改数组长度也是如此：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can overcome this limitation using the splice method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用splice方法克服这个限制：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Reacting to events such as clicks and keystrokes
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于点击和按键等事件的响应
- en: A fundamental part of every application is the interaction with the user. Vue
    has shorthand to intercept most user events and connect them to relevant actions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序的一个基本部分是与用户的交互。Vue提供了简化的方式来拦截大多数用户事件，并将它们与相关操作连接起来。
- en: Getting Ready
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To successfully complete this recipe, you should know how to create a list.
    If you don't, check out recipe *Filtering a list with a computed property* in
    [Chapter 2](text00082.html) , *Basic Vue.js Features* .
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成这个示例，您应该知道如何创建一个列表。如果不知道，请查看[第2章](text00082.html)的*使用计算属性过滤列表*这个示例，以及*Vue.js基本特性*。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following bit of code shows how to react to a `click`  event:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何对`click`事件作出反应：
- en: 'Fill in the following HTML:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写以下HTML：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As for the JavaScript, write the following:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于JavaScript，写下以下内容：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the code! An event listener will be installed on the button.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码！一个事件监听器将会安装在按钮上。
- en: Click the button and you should see a popup that says *Toasted!*
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮，您会看到一个弹出窗口，上面写着*Toasted！*
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Running the preceding code will install an event handler on the button. The
    syntax is `v-on:DOMevent="methodEventHandler"` . The handler must be a method,
    that is, a function in the methods option. In the preceding example,  `toast`
    is the handler.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码将在按钮上安装一个事件处理程序。语法是`v-on:DOMevent="methodEventHandler"`。处理程序必须是一个方法，即在methods选项中的一个函数。在上面的示例中，`toast`就是处理程序。
- en: Two-way data binding
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向数据绑定
- en: The `v-on`  attribute will have you covered in most cases, especially if the
    event comes from the element. On the other hand, it may sometimes be too verbose
    for some tasks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，v-on属性可以满足您的需求，特别是当事件来自元素时。另一方面，对于某些任务来说，它可能有时过于冗长。
- en: For example, if we had a textbox and we wanted to update a variable with the
    content of the textbox and ensure that the textbox always has an updated value
    of the variable (which is called **two-way data binding** ), we would have to
    write a couple of handlers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个文本框，并且我们想要使用文本框的内容更新一个变量，并确保文本框始终具有变量的更新值（这称为**双向数据绑定**），我们必须编写几个处理程序。
- en: 'Instead, this operation is carried out by the `v-model` attribute, as the following
    code shows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个操作是由`v-model`属性完成的，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Play a little with this application and notice how no handler is necessary to
    keep the textbox in sync. Every time `toastedBreads` is updated, the text will
    update too; conversely, every time you write a number, the quantity gets updated
    as well.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 玩一下这个应用程序，并注意到保持文本框同步不需要处理程序。每次更新`toastedBreads`时，文本也会更新；反之，每次你写一个数字，数量也会更新。
- en: There's more
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'If you followed the first recipe in this chapter, you''ll remember how we greeted
    a variable number of worlds; we can make the experience more interactive. Let''s
    build a list of planets we''d like to greet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循本章的第一个示例，你会记得我们向一个变量打招呼，变量可以包含数量不定的单词；我们可以使体验更加互动。让我们建立一个我们想要问候的行星列表：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We want to be able to keep track of newly conquered worlds and delete the ones
    we destroy. This means adding and removing elements from the list. Consider the
    following HTML:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够追踪新征服的星球并删除我们摧毁的星球。这意味着在列表中添加和删除元素。考虑以下HTML：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here the `@`  symbol is the shorthand for `v-on` : Let''s examine the modifications:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“@”符号是`v-on`的简写：让我们来看看修改的地方：
- en: We added a button to remove the planet (we needed to write out the index in
    the `v-for` )
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个按钮来删除行星（我们需要在`v-for`中写出索引）
- en: We placed a textbox that is bound to the data variable `newWorld`
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们放置了一个文本框，它绑定到数据变量`newWorld`
- en: We placed a corresponding button that adds what's inside the textbox to the
    list
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们放置了一个相应的按钮，将文本框中的内容添加到列表中
- en: 'Running this code will work. But if you look at the console, you will see a
    warning when you update the text field:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码将会起作用。但是如果你看一下控制台，你会看到在更新文本字段时会有一个警告。
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is because we never declared `newWorld` in our Vue instance, but that''s
    easy to fix:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们没有在Vue实例中声明`newWorld`，但这很容易修复：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![](img/Image00008.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00008.jpg)'
- en: Choosing a development environment
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择开发环境
- en: We are going to explore some different styles of developing, from the naive
    JSFiddle approach, to a more robust approach with WebStorm support. Since we want
    to use libraries to add new functionalities to our software, I'll provide you
    with a guide to add them regardless of whichever method of development you choose.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索一些不同的开发方式，从简单的JSFiddle方法到更健壮的WebStorm支持方法。由于我们想要使用库来为我们的软件添加新功能，所以我将为您提供一个添加库的指南，无论您选择的开发方法如何。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: I will start from the simplest method and then present you some more involved
    methods for bigger projects.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从最简单的方法开始，然后为您呈现一些更复杂的用于大型项目的方法。
- en: Just the browser
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅使用浏览器
- en: There are a series of websites such as JSFiddle that let you write a Vue application
    right from the browser (CodePen and JS Bin among others) and those are very good
    to test new functionalities and try recipes in this book. On the other hand, they
    are too limited in terms of code organization to develop anything more. In first
    recipe of this chapter, this style of development is used so please refer to that
    to learn how to develop with only the browser. In general, you should take what
    you learn by doing the recipes this way and transfer it into more structured projects,
    depending on what you are developing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有一系列的网站（如JSFiddle、CodePen和JS Bin等）可以让您直接在浏览器中编写Vue应用程序，这些网站非常适合测试新功能并尝试本书中的示例。另一方面，它们在代码组织方面的限制太多，无法开发更复杂的项目。在本章的第一个示例中，使用了这种开发方式，请参考该示例以了解如何仅使用浏览器进行开发。一般来说，您应该通过使用这种方式来学习，并将其转化为更结构化的项目，具体取决于您正在开发的内容。
- en: Adding dependencies with just the browser
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅使用浏览器添加依赖项
- en: Every time I mention an external library, you will search for the relative `.js`
    file on the Internet, preferably distributed by a CDN, and add it to the left
    menu of JSFiddle. Let's try with moment.js .
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我提到一个外部库时，您可以在互联网上搜索相关的`.js`文件，最好通过CDN（内容分发网络）来分发，并将其添加到JSFiddle的左侧菜单中。让我们尝试一下moment.js。
- en: Open a new JSFiddle (point your browser to [https://jsfiddle.net/](https://jsfiddle.net/)
    ).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开一个新的JSFiddle（将浏览器指向[https://jsfiddle.net/](https://jsfiddle.net/)）。
- en: In another tab, search for `momentjs CDN`  in your favorite search engine.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个标签页中，在你喜欢的搜索引擎中搜索“momentjs CDN”。
- en: The first result should lead you to a CDN website with a list of links; you
    should eventually find something like `https://somecdn.com/moment.js/X.X.X/moment.js`
    where the *X* represents the version number.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个结果应该会带你到一个CDN网站，上面有一列链接；你应该最终能找到一些像“https://somecdn.com/moment.js/X.X.X/moment.js”的链接，其中*X*代表版本号。
- en: Copy the link you found and go back to JSFiddle.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你找到的链接，然后回到JSFiddle。
- en: In the External Resources  section in the left sidebar, paste your link and
    press *Enter* .
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧边栏的“External Resources”部分，粘贴你的链接，然后按下“Enter”键。
- en: For many libraries this is sufficient; some libraries do not support this and
    you will have to include them in your JSFiddle in some other way.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多库来说这样就足够了；有些库不支持这种方式，你就需要用其他方式将它们包含在JSFiddle中。
- en: TextEditor
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: The rawest way to be up and running is with a text editor and a browser. This
    is totally legitimate for simple, self contained components.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方式是使用文本编辑器和浏览器。对于简单的、自包含的组件来说这完全合法。
- en: 'There are plenty of text editors from which to choose these days. One I like
    to use is Microsoft Visual Studio Code ( [https://github.com/Microsoft/vscode](https://github.com/Microsoft/vscode)
    ). There is little difference if you use another, is just so happens that Code
    has a plugin for Vue:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多文本编辑器可供选择。我喜欢使用的是Microsoft Visual Studio Code（[https://github.com/Microsoft/vscode](https://github.com/Microsoft/vscode)）。如果你使用其他编辑器也没什么大不了的，只是恰巧Code有一个针对Vue的插件：
- en: 'Create a new file called  `myapp.html` , in which we write:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`myapp.html`的新文件，在其中编写如下内容：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Open the file you just created in a browser.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开刚刚创建的文件。
- en: Vue gets downloaded from [https://cdnjs.com/](https://cdnjs.com/)  and the text
    `hello world` should appear (without mustaches--if you see the mustaches, chances
    are something's gone wrong so check the console for errors).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Vue会从[https://cdnjs.com/](https://cdnjs.com/)下载，然后文本“hello world”应该会显示出来（如果看到了花括号，则可能出现了问题，请检查控制台是否有错误）。
- en: 'This approach resembles the JSFiddle one: we have an HTML part, a JavaScript
    part, and a CSS part on the top. We are just bringing everything under our control.
    Also, this way we can use Vue developer tools (check out the recipe *X-raying
    your application with Vue developer tools* for an introduction of those).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法类似于JSFiddle的方法：在顶部有一个HTML部分、一个JavaScript部分和一个CSS部分。我们只是将所有内容都控制在自己手中。此外，这种方式我们还可以使用Vue开发者工具（查看配方“使用Vue开发者工具扫描你的应用程序”了解介绍）。
- en: Adding dependencies with a TextEditor
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用文本编辑器添加依赖项
- en: 'Adding external libraries in this configuration means simply adding another
    `<script>` entry to your file and setting the source attribute to the respective
    link. If we wanted to add `moment.js` , we look for the library in the same way
    as explained before and we add the following snippet to our page:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中添加外部库只需将另一个`<script>`标签添加到你的文件中，然后将源属性设置为相应的链接。如果我们想添加`moment.js`，我们按照之前解释的方式查找该库，然后将以下代码片段添加到我们的页面中：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Please note that you have to paste the link you found instead of the fake one
    mentioned in the preceding snippet.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你需要将找到的链接粘贴到前面代码片段中虚假链接的位置。
- en: Node package manager (npm)
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node包管理器（npm）
- en: The canonical way to work with Vue projects, and the one officially supported
    by the Vue community, involves the use of npm and in particular an npm package
    named `vue-cli` .
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与Vue项目一起工作的规范方式，也是Vue社区官方支持的方式，涉及使用npm，尤其是一个名为`vue-cli`的npm包。
- en: If you are not familiar with npm , put it on your list of things to do, especially
    if you plan to develop with JavaScript extensively.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对npm不太熟悉，将其列入您计划广泛使用JavaScript进行开发的事项清单中是一个好主意。
- en: 'Briefly stated, npm is a tool to organize and share your code, beyond using
    other people''s code in your projects. More formally, it''s a package manager
    for everything JavaScript. We will use some basic commands now and some more advanced
    later in the book, but you are invited to learn more by yourself:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，npm是一个用于组织和共享代码的工具，超越了在项目中使用其他人的代码。更正式地说，它是一个用于JavaScript的软件包管理器。我们将在本书中使用一些基本命令，以及一些更高级的命令，但是我鼓励您自己学习更多：
- en: Install npm. As it's bundled in Node.js, the best route to follow is to install
    Node.js directly. You will find instructions at [https://nodejs.org/en/download/](https://github.com/Microsoft/vscode)
    .
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装npm。由于它与Node.js捆绑在一起，因此最好直接安装Node.js。您可以在[https://nodejs.org/en/download/](https://github.com/Microsoft/vscode)上找到安装说明。
- en: After you install npm, open a command line and type `npm install -g vue-cli`
    ; this will install `vue-cli` . The `-g` options stands for globally and it means
    that wherever you are, you can type `vue` and it will run the program.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完npm后，打开命令行并输入`npm install -g vue-cli`，这将安装`vue-cli`。选项`-g`表示全局安装，这意味着无论您身在何处，都可以输入`vue`来运行该程序。
- en: Create a new directory that will act as a workspace. We will put all of our
    projects inside it.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个作为工作区的新目录。我们将把所有项目放在这个目录中。
- en: Type `vue list` ; we get all the available templates from the official Vue template
    repository--other templates can be used from other sources.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`vue list`，我们可以从官方Vue模板仓库中获取所有可用的模板。其他来源的模板也可以使用。
- en: The `simple` template will create a page similar to what we have done a few
    paragraphs before. I invite you to run `vue init simple` and check it out; spot
    the difference between that and what we have done. What we are doing now instead
    is a step further. We are going to use a more involved template that includes
    a bundler. There is one for `webpack` and `browserify` ; we are going with the
    first.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple`模板将创建一个类似于前面几段所做内容的页面。我邀请您运行`vue init simple`并检查一下；请注意它与我们所做的内容之间的差异。我们现在要做的是更进一步。我们将使用更复杂的模板，该模板包括一个打包工具。有一个用于`webpack`和`browserify`的模板；我们选择使用第一个。'
- en: 'If you are not familiar with `webpack` or `browserify` they are programs to
    control the build process of JavaScript programs from sources and assets (images,
    css files, and others) to customized bundles. For example, for a single `.js`
    file:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对`webpack`或`browserify`不太熟悉，它们是用于控制从源代码和资源（图像、CSS文件等）到定制捆绑包的JavaScript程序的构建过程的程序。例如，对于单个`.js`文件：
- en: Type `vue init webpack-simple` and the program will ask you some questions on
    how you would like your project to be. If you don't know how to answer, press
    *Enter* to go with the default.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`vue init webpack-simple`，程序将询问您有关项目的一些问题。如果您不知道如何回答，请按下*Enter*键使用默认选项。
- en: We could have chosen in an equivalent way the `browserify-simple` template;
    those are two different libraries to achieve the same results.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以选择等效地选择`browserify-simple`模板；这两个库可以达到相同的结果。
- en: Once the scaffolding is complete, type `npm install` . This will take care of
    downloading and installing all the npm packages we need to write our Vue app.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成脚手架后，输入`npm install`。这将负责下载和安装我们编写Vue应用所需的所有npm软件包。
- en: After this, you'll have a functioning demo application already in place.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您将已经拥有一个具备功能的演示应用程序。
- en: Type `npm run dev` to run your application. Further instruction, will appear
    on the screen and will tell you to visit a specific web address, but there is
    a good chance that your browser will be opened automatically.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`npm run dev`来运行你的应用程序。进一步的指导会在屏幕上出现，并告诉你访问一个特定的网址，但你的浏览器很有可能会自动打开。
- en: Point the browser at the specified address. You should be able to see the demo
    application right away.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器定位到指定的地址。你应该能够立即看到演示应用程序。
- en: 'Exploring the source files created by `vue-cli` , you will find two notable
    files. The first file is the entry point for your application, `src/main.js` .
    It will contain something like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`vue-cli`创建的源文件中，你会发现两个值得注意的文件。第一个文件是你的应用程序的入口点，`src/main.js`。它将包含类似以下的内容：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code was loaded in the `index.html` page you just saw. It just tells the
    main Vue instance to load and render the `App` component in an element selected
    by `#app`  (the element with the attribute `id="app"` , a `<div>` in our case).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码加载在你刚刚看到的`index.html`页面中。它只是告诉主Vue实例在被`#app`选择的元素中（在我们的情况下是一个带有`id="app"`属性的`<div>`元素）加载和渲染`App`组件。
- en: The `App.vue` file you will find is a self contained way you can write Vue components.
    You will find more on components in other recipes, but for now think of it as
    a way you can further divide your application to keep it more ordered.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在`App.vue`文件中找到一种自包含的方式来编写Vue组件。关于组件的更多内容将在其他教程中介绍，但现在请将其视为一种更进一步划分你的应用程序以保持其有序的方法。
- en: 'The following code is different from what you''ll find in the official template
    but it summarizes the general structure:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码与官方模板中的代码不同，但概括了一般的结构：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can see that having code divided into HTML, JavaScript, and CSS is a recurring
    pattern. In this file we can see something similar to what we saw in JSFiddle
    in the first recipes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到将代码划分为HTML、JavaScript和CSS是一种重复出现的模式。在这个文件中，我们可以看到与我们在第一个例子中在JSFiddle中看到的类似的东西。
- en: In the `<template>` tag we put our HTML, in the `<script>` tag JavaScript code
    and we use the `<style>` tag to add some styling to our application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<template>`标签中，我们放置我们的HTML，在`<script>`标签中放置JavaScript代码，并使用`<style>`标签为我们的应用程序添加一些样式。
- en: After running `npm run dev` , you can try to edit the `msg` variable in this
    file; the webpage will reload the component automatically after saving your modifications.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm run dev`后，你可以尝试在这个文件中编辑`msg`变量；在保存修改后，网页会自动重新加载组件。
- en: Adding dependencies with npm
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用npm添加依赖项
- en: 'To add external libraries in this configuration you simply type `npm install`
    followed by the name of the library. Then in your code you use it with something
    along the lines of the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此配置中添加外部库，只需键入`npm install`后跟库的名称。然后在你的代码中，使用以下类似的方式使用它：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can import `moment.js` with the following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令导入`moment.js`：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then in our JavaScript we add the following lines:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们的JavaScript中添加以下行：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: IDE
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE
- en: 'If you have a very big project, chances are you are already using tools such
    as IntelliJ or Webstorm. In this case, I suggest you stick to the embedded console
    for most of the work and only use features such as syntax highlighting and code
    completion. This is because developer tools are still immature for Vue and you
    will probably spend more time configuring your tools than actually programming:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个非常庞大的项目，很有可能你已经在使用IntelliJ或Webstorm等工具。在这种情况下，我建议你在大部分工作中坚持使用嵌入的控制台，并只使用诸如语法高亮和代码补全等功能。这是因为Vue的开发工具还不成熟，你很可能会花更多的时间来配置工具，而不是实际编程：
- en: 'Open Webstorm and create a new Empty Project :'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Webstorm并创建一个新的空项目：
- en: '![](img/Image00009.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00009.jpg)'
- en: 'In the bottom-left corner you should be able to open up the console or Terminal
    :'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左下角，你应该能够打开控制台或终端：
- en: '![](img/Image00010.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00010.jpg)'
- en: From this prompt you should be able to work with npm exactly as explained in
    the previous paragraph. Read it if you haven't yet. In our case, we are going
    to suppose Node is installed and vue-cli is also installed.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个提示中，你应该能够按照前面的段落中所解释的那样使用npm。如果你还没有看过，请阅读一下。在我们的例子中，我们假设已经安装了Node和vue-cli。
- en: 'Type `vue init simple`  and answer the questions; you should end up with something
    similar to this:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`vue init simple`并回答问题；你应该得到类似于以下内容的东西：
- en: '![](img/Image00011.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00011.jpg)'
- en: Open the `index.html`  file by double-clicking it.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击打开`index.html`文件。
- en: 'Hover over the top-right corner of the `index.html` file, and you should see
    the browser icons; click one:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在`index.html`文件的右上角，你应该能够看到浏览器图标；点击其中一个：
- en: '![](img/Image00012.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00012.jpg)'
- en: Your sample application is up and running!
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的示例应用程序已经启动运行了！
- en: '![](img/Image00013.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00013.jpg)'
- en: Wrap up
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You can see more of how this works in dedicated recipes. Here I wanted you to
    have an overview of the possibilities for developing with Vue. For quick prototypes,
    you can definitely go with JSFiddle. When you need your own environment or you
    need to use Vue developer tools but not much more, using just a text editor can
    be acceptable. For the majority of serious projects though, you should familiarize
    yourself with npm , webpack, or Browserify and use vue-cli to scaffold your new
    projects.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在专门的案例中了解更多关于这个的工作原理。在这里，我希望你对使用Vue进行开发的可能性有一个概述。对于快速原型，你可以使用JSFiddle。当你需要自己的环境或者只需要使用Vue开发工具的时候，使用文本编辑器就足够了。然而，对于大多数严肃的项目，你应该熟悉npm、webpack或者Browserify，并使用vue-cli来创建你的新项目。
- en: Formatting your text with filters
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器格式化你的文本
- en: The first version of Vue came bundled with some text filters that helped format
    text and solve some common problems.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的第一个版本附带了一些文本过滤器，用于帮助格式化文本和解决一些常见问题。
- en: 'In this new version, there are no built-in filters (except the equivalent of
    the JSON  filter covered in the next recipe). I think this is because it''s very
    easy to write your own filter and also very easy to find online libraries that
    do a much better job in specialized situations. Finally, filters have somewhat
    changed purpose: they are more for post-processing now and less for actual filtering
    and sorting arrays.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新版本中，没有内置的过滤器（除了下一个案例中介绍的JSON等效过滤器）。我认为这是因为编写自己的过滤器非常容易，而且在专门情况下可以很容易地找到在线库来完成更好的工作。最后，过滤器的用途有些变化：它们现在更多用于后处理，而不是实际的过滤和排序数组。
- en: 'To demonstrate how easy it is to create a filter, we will recreate a filter
    of the old version of Vue: capitalize .'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示创建过滤器有多容易，我们将重新创建Vue旧版本中的一个过滤器：capitalize。
- en: Getting Ready
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You don't need any particular knowledge to complete this recipe.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要任何特殊的知识来完成这个案例。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: Sometimes we have some strings floating around in our variables like labels.
    When we put them in the middle of a sentence they work fine, but on the other
    hand they don't look very good at the beginning of a sentence or bullet point.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们有一些字符串漂浮在我们的变量中，比如标签。当我们把它们放在句子中间时，它们工作得很好，但是在句子或者项目符号的开头，它们看起来就不太好了。
- en: 'We want to write a filter that will capitalize whatever string we put into
    it. If, for example, we want the string `hello world`  to start with a capital
    `H` , we''d like to be able to write:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要编写一个过滤器，可以将我们放入其中的任何字符串都变成大写。如果，例如，我们希望字符串`hello world`以大写字母`H`开头，我们希望能够这样写：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we try to run this as HTML in a Vue app, it will complain `[Vue warn]: Failed
    to resolve filter: capitalize` .'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们尝试在Vue应用程序中将其作为HTML运行，它会报错`[Vue warn]: Failed to resolve filter: capitalize`。'
- en: 'Let''s create the filter and add it to Vue''s internal list of filters:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建这个过滤器并将它添加到Vue的内部过滤器列表中：
- en: 'Write the following JavaScript to register a filter and instantiate Vue:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下以下JavaScript代码以注册一个过滤器并实例化Vue：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the HTML section, write:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML部分中，写下以下内容：
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Run your code and notice how the text now reads Hello world .
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意到文本现在显示为“Hello world”。
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理如下...
- en: The pipe sign indicates that the following is the name of a filter; in our case
    `capitalize` is not in Vue's list of filters, hence the warning. Vue will print
    the string as is.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 竖线表示以下内容是一个过滤器的名称；在我们的例子中，`capitalize`不在Vue的过滤器列表中，因此会有警告。Vue将按原样打印字符串。
- en: 'What Vue will do before even starting is register our filter (with `Vue.filter`
    ) in its asset library. Vue has an the internal filters object and will create
    a new entry: `capitalize` . Every time it sees the pipe symbol it will look for
    a corresponding filter. Remember to write it before the actual instantiation of
    a Vue instance because otherwise Vue will not find it.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue开始之前，它会在资产库中注册我们的过滤器（使用`Vue.filter`）。Vue有一个内部过滤器对象，并将创建一个新条目：`capitalize`。每次遇到竖线符号时，Vue都会查找相应的过滤器。记得在Vue实例的实际创建之前写好它，否则Vue将找不到它。
- en: 'The working of the filter is very basic JavaScript, in fact, a better way to
    write this filter with ES6 would be:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器的工作原理非常基本的JavaScript，事实上，使用ES6来编写这个过滤器会更好：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you are not familiar with ES6, here is a brief explanation. The second line
    is called a **destructuring** assignment of string; in particular we are interpreting
    string as an array of characters, separating the first character into first and
    putting all the other characters in `tail` . This is a faster way to assign different
    parts of an array to multiple variables. The other thing that may seems mysterious
    is that `join('')` . Since `tail` is now an array of characters, we need some
    means to re-join the single letters into a compact string. The argument of `join`
    represents a separator between the single characters. We don't want any, so we
    pass an empty string.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉ES6，这里有一个简要的解释。第二行被称为**解构**赋值字符串；我们将字符串解释为一个字符数组，将第一个字符分割为第一个字符，并将所有其他字符放入`tail`中。这是将数组的不同部分分配给多个变量的更快的方法。可能看起来神秘的另一点是`join('')`。由于`tail`现在是一个字符数组，我们需要一些方法将单个字母重新连接成一个紧凑的字符串。`join`的参数表示单个字符之间的分隔符。我们不想要任何分隔符，所以传递一个空字符串。
- en: In the next chapter, you will find more recipe for filters and cover other real
    use cases.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将找到更多关于过滤器的用例，并涵盖其他实际用途。
- en: Debugging your application with mustaches (for example, a JSON filter)
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`mustaches`（例如`JSON`过滤器）调试应用程序
- en: In the previous recipe, we had a complete overview of filters and we said that
    Vue comes with no built-in filters except for an equivalent of the JSON  filter.
    This filter was very useful and, while its considered not really orthodox to debug
    with it, sometimes it just makes your life easier. Now we have it straight away without
    even writing it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的用例中，我们全面了解了过滤器，并说Vue除了`JSON`过滤器的等效功能之外没有内置过滤器。这个过滤器非常有用，虽然使用它来调试并不是真正正统的做法，但有时它确实能让生活更轻松。现在我们可以直接使用它而不需要自己编写。
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: To see it in action, we can simply display the value of an object in our Vue
    instance.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到实际效果，我们可以在Vue实例中简单显示一个对象的值。
- en: 'Write the following JavaScript:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下JavaScript：
- en: '[PRE45]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This just creates a `cat` object in our code with a string inside.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是在我们的代码中创建了一个包含字符串的 `cat` 对象。
- en: 'Write the following HTML:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下HTML：
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Run your app and notice how the `cat` object is outputted in all it's beauty,
    just like `JSON.stringify` .
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序并注意到 `cat` 对象以所有其美丽的形式输出，就像 `JSON.stringify` 一样。
- en: How it works...
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理如下...
- en: Cat will display the content of the `cat` object. In the old Vue, to get this
    result we had to write `{{ cat | json }}` .
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cat` 将显示 `cat` 对象的内容。在旧的Vue中，要获得这个结果，我们必须写成 `{{ cat | json }}`。'
- en: A thing to be wary of is loops in our objects. If our object contains a circular
    reference, and you wrap it in mustaches, this will not work. These objects are
    more common than you would think. HTML elements, for example, are JavaScript objects
    that contain references to a parent node; the parent node in turn contains a reference
    to its children. Any such tree structure would cause the mustaches to print an
    infinite description of the object. When you actually do it, Vue simply throws
    an error and refuses to work. The error you would see in the console is actually
    thrown by the internal method used to print the  `JSON.stringify`  object.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 需要小心的一件事是我们对象中的循环。如果我们的对象包含循环引用，并且用花括号括起来，这将不起作用。这些对象比你想象的更常见。例如，HTML元素是包含对父节点的引用的JavaScript对象；父节点反过来包含对其子节点的引用。任何这样的树结构都会导致花括号打印对象的无限描述。当你实际这样做时，Vue只是抛出一个错误并拒绝工作。你在控制台中看到的错误实际上是由用于打印
    `JSON.stringify`对象的内部方法抛出的。
- en: A practical situation in which using mustaches could be useful is when the same
    value is changed in several places, or when you want to quickly check the content
    of a variable. Mustaches can be useful even for demonstrational purposes, as it's
    clear from the usage you will see in this book.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用花括号的一个实际情况是当同一个值在多个位置被改变时，或者当你想快速检查变量的内容时。花括号甚至可以用于演示目的，正如你在本书中将看到的用法那样。
- en: X-raying your application with Vue developer tools
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Vue开发者工具对应用进行透视
- en: Using mustaches is a quick way to display the content of an object. However
    it has some limitations; one of them outlined in the previous recipe is that,
    out of the box, it breaks when dealing with objects that contain circular references.
    A tool that doesn't present this limitation when inspecting internal variables
    and that sports many more debugging features is Vue developer tools. There's a
    Chrome extension that will help you at every step of development, visualizing
    the state of your components, where they are in the page, and more. It's also
    deeply integrated with **Vuex** (covered in later recipes) and has a time machine
    feature that lets you rewind the event flow directly from the browser.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用花括号是显示对象内容的一种快捷方式。然而，它也有一些限制；其中一个在前面的示例中详细说明了，就是它默认情况下无法处理包含循环引用的对象。一个不会出现这个限制并且具有更多调试功能的工具是Vue开发者工具。有一个Chrome扩展程序，可以在开发的每一步中帮助您，可视化组件的状态，它们在页面中的位置以及更多。它还与
    **Vuex**（在后面的示例中介绍）深度集成，并具有一个时间机器功能，可以直接从浏览器中倒回事件流。
- en: Getting Ready
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To install it, you just have to download the extension from the Chrome Web
    Store in the extensions category. Just look for V ue.js devtools  and you''ll
    find it right away, press the **ADD TO CHROME**  button, and you''re set to go:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，只需在Chrome Web Store的扩展类别中下载扩展。只需搜索Vue.js devtools即可找到它，点击**添加到Chrome**按钮，然后您就可以开始使用了：
- en: '![](img/Image00014.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00014.jpg)'
- en: Unfortunately you won't be able to use it in some configurations; particularly
    it currently doesn't seem to work in `iframe` environments and JSFiddle is one
    of them, so to see it you have to at least use the *one page approach*  outlined
    in the *Choosing a development environment* recipe.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，您将无法在某些配置中使用它；特别是它目前似乎无法在 `iframe` 环境和JSFiddle中工作，所以为了看到它，您至少要使用在*选择开发环境*示例中概述的*one
    page approach*。
- en: .
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: How to do it...
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 怎么做...
- en: Access the Developer Tools of Chrome (Usually with *c* *md* + *opt* + *I* or
    *Ctrl* + *Shift* + *I* ) and you will see a new tab at the end that says Vue .
    Clicking it will bring forth the developer tools.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问Chrome开发者工具（通常使用 *c* *md* + *opt* + *I* 或 *Ctrl* + *Shift* + *I* ），你会看到一个新的标签页说
    Vue。点击它将呈现出开发者工具。
- en: To make it work for pages opened via the `file://` protocol, you need to check
    Allow access to file URLs  for this extension in Chrome's extension management
    panel.![](img/Image00015.jpg)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其能够在通过`file://`协议打开的页面上运行，您需要在Chrome的扩展管理面板中检查允许访问文件URL以便为该扩展程序添加权限。![](img/Image00015.jpg)
- en: You will be presented with a hierarchical tree of components laid out in your
    page and by selecting them you will be able to see all the variables in depth
    and in real time.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个按层次结构排列在页面上的组件树，通过选择它们，您将能够实时深入地查看所有的变量。
- en: 'Click on the various objects in the three to see details:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击树中的各个对象以查看详细信息：
- en: '![](img/Image00016.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00016.jpg)'
- en: 'Also, you will see a useful button: the inspect DOM  button (the eye) will
    scroll the page to where the element is and will show you the DOM representation
    in the Chrome developer tools. Furthermore, when you click on a component (root
    in the illustration) you will have a variable like `$vm0` available to be used
    in the console. For example, you can execute methods or inspect variables.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还将看到一个有用的按钮：检查DOM按钮（眼睛）将滚动页面到元素的位置，并在Chrome开发人员工具中显示DOM表示。此外，当您单击一个组件（详见插图中的根组件）时，您将在控制台中可以使用一个名为`$vm0`的变量。例如，您可以执行方法或检查变量。
- en: 'Click on the root component and write the following in the console to explore
    the  `$vm0.docsUrl`  property:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击根组件，并在控制台中输入以下内容以探索`$vm0.docsUrl`属性：
- en: '![](img/Image00017.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00017.jpg)'
- en: Upgrading to Vue.js 2
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级到Vue.js 2
- en: If you need to upgrade your Vue app to version 2, most of your code is good
    to go. There are a couple of features though that need some modifications. Some
    are simple renaming, some are more involved.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要将Vue应用程序升级到2版本，大部分代码都可以正常使用。但是，有几个功能需要进行一些修改。有些是简单的重命名，有些则比较复杂。
- en: How to do it...
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: 'To give your migration a head start; Chris Fitz (a member of the Vue core team)
    created a little helper app that will scan your code and guide you in the migration:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您的迁移开始，Chris Fitz（Vue核心团队成员）创建了一个小助手应用程序，它将扫描您的代码并指导您进行迁移：
- en: 'Install Vue Migration Helper with the following npm command:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用以下npm命令安装Vue Migration Helper:'
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Navigate to your app folder.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您的应用程序文件夹。
- en: 'Run the program with the following command:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE48]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: All the lines in which a change is necessary will be highlighted. Once you are
    finished updating, or if you still have doubts, you should take a look at the
    official documentation migration page at [https://rc.vuejs.org/guide/migration.html](https://rc.vuejs.org/guide/migration.html)
    .
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行更改的所有行将被突出显示。更新完成后，或者如果您仍然有疑问，您应该查看官方文档迁移页面[https://rc.vuejs.org/guide/migration.html](https://rc.vuejs.org/guide/migration.html)。
- en: How it works...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: Reading through the documentation will help you understand the critical points
    that need to be updated. Here I will provide you a rationale for some of the most
    challenging modifications.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读文档将帮助您了解需要更新的关键点。在这里，我将为您提供一些最具挑战性修改的基本原理。
- en: Deprecation of $broadcast, $dispatch, and the events option
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: $broadcast、$dispatch和events选项的弃用
- en: Both methods `$broadcast`  and `$dispatch`  are now merged in the `$emit` method
    with the same syntax as the old version. Unfortunately, replacing every instance
    of `$broadcast` and `$dispatch` with `$emit` is not guaranteed to always work
    because the pattern used to manage events is a little different now.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`$broadcast`和`$dispatch`现在已与旧版本相同的语法合并到`$emit`方法中。不幸地是，将每个`$broadcast`和`$dispatch`实例都替换为`$emit`并不保证总是有效，因为现在用于管理事件的模式有些不同。
- en: In Vue 1, you had events follow a path either downward (for `$broadcast` ) or
    upward (for `$dispatch` ), and horizontally (for `$emit` ) through the hierarchical
    tree.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 1中，事件沿着层次结构树向下（对于`$broadcast`）或向上（对于`$dispatch`）以及水平（对于`$emit`）的路径传播。
- en: To be honest, I never liked having two (three if you count the old `$emit` )
    methods for emitting events. It was confusing even in the smallest contexts because
    you had to ask yourself *is this event for parents or children?*  Most of the
    time it was not that important of a distinction, you just wanted your method to
    fire. But there is no such thing as a free lunch; we have to add a moving part
    to our system to make everything work in the new paradigm.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，我从来都不喜欢有两种（如果算上旧的 `$emit` ，则是三种）方法来触发事件。即使在最小的上下文中，它也很令人困惑，因为你必须问自己“这个事件是给父级还是子级的？”大部分情况下，这个区分并不重要，你只是想要调用你的方法。但是，不会有免费的午餐；为了使一切在新的范式下运行，我们必须添加一个移动部件到系统中。
- en: Now all events should pass through one or more central hubs. The role of this
    central hubs can be taken by a Vue instance since they implement the necessary
    interface.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有事件都应该通过一个或多个中央枢纽传递。这个中央枢纽的角色可以由一个Vue实例来承担，因为它们实现了必要的接口。
- en: 'When emitting an event consumed by `v-on` , you''re good to go by replacing
    `$broadcast` with `$emit` , since the event doesn''t have to travel far. On the
    other hand, if you are defining an interface for a component in terms of events,
    you will have to say goodbye to the events option since it will not work anymore.
    This is the direct consequence of having all the events passing through a hub--the
    events option wouldn''t know where to register all the events. This is the trade
    off for having a single emitting method: it fires in every direction but only
    in a precise piping.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发一个`v-on`消费的事件时，你只需要用`$emit`替换`$broadcast`，因为事件不需要传递很远。另一方面，如果你在事件方面定义一个组件的接口，你将不得不告别事件选项，因为它将不再起作用。这是通过所有事件通过一个中央枢纽传递的直接结果
    - 事件选项将不知道在哪里注册所有事件。这是只有一个发射方法的代价：它向所有方向触发，但只在一个精确的管道中触发。
- en: 'Let''s say you have a dedicated empty Vue instance that will act as an event
    hub:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个专门的空的Vue实例作为事件中心：
- en: '[PRE49]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you are writing a teapot component and you want to register the brew event,
    you will write in the created hook something like the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个茶壶组件，并且你想要注册brew事件，你可以在created钩子中写入以下内容：
- en: '[PRE50]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And with the HTML:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: HTML如下：
- en: '[PRE51]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Every time the `brew` event is emitted with `eventBus.$emit('brew')` , the console
    will output a message.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 每当使用`eventBus.$emit('brew')`触发`brew`事件时，控制台将输出一条消息。
- en: As you can see, this example is not very scalable. You cannot register a lot
    of events in the created hook and then expect to easily keep track of what they
    do and in which hub they are registered. For these more involved scenarios, the
    suggested way to proceed is to use Vuex, introduced in later recipes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个示例不太可扩展。你不能在created钩子中注册很多事件，然后期望轻松跟踪它们的功能以及它们在哪个中央枢纽中注册。对于这些更复杂的场景，建议的做法是使用后面介绍的Vuex。
- en: Any component you'll write can act as an event hub. You also have the API methods
    `$off` which deletes listeners, and `$once` , which listens for an event but only
    once.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的任何组件都可以充当事件中心。你还可以使用API方法`$off`来删除监听器，以及`$once`来监听事件，但只监听一次。
- en: Deprecation of array filters
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组过滤器的弃用
- en: If you had a lot of filtered `v-for` lists, I have bad news for you. Even if
    in the wild the most common use for filters was with `v-for` , the community chose
    to remove this feature. The reason is mainly because having a lot of filters,
    often piped together, was hard to reason about and thus to maintain.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多经过过滤的`v-for`列表，我有个坏消息告诉你。即使在实际情况中，最常见的过滤器用法是与`v-for`一起使用，社区还是选择移除了这个特性。原因主要是因为有很多过滤器，经常连在一起使用，很难理解和维护。
- en: The new recommended way to filter a list is with a computed property. Luckily
    for you, we have an entire recipe on how to do that. See the recipe *Filtering
    a list with a computed property* in the next chapter.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的过滤列表的新方法是使用计算属性。幸运的是，我们有一整个关于如何做到这一点的示例。在下一章节中查看示例*使用计算属性过滤列表*。
- en: Deprecation of Vue.config.delimiters
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.config.delimiters的弃用
- en: Custom delimiters are not at the component level. If you want, you can have
    two different components using different delimiters.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义定界符不作用于组件级别。如果需要，可以创建两个使用不同定界符的不同组件。
- en: 'This is fairly easy to upgrade and allows you to write components intended
    to be used inside other template engines:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个升级非常简单，并且允许你编写组件，以便在其他模板引擎中使用：
- en: '[PRE52]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Renaming of life cycle hooks
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期钩子的重命名
- en: 'Life cycle have now a more consistent naming that will help with remembering
    their names in the long run:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期现在有更一致的命名，能够帮助长期记住它们的名称：
- en: '| **Old hook** | **New hook** |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| **旧的钩子** | **新的钩子** |'
- en: '| `init` | `beforeCreate` |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `init` | `beforeCreate` |'
- en: '| `created` | `created` |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `created` | `created` |'
- en: '| `beforeCompile` | `created` |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `beforeCompile` | `created` |'
- en: '| `no equivalent` | `beforeMount` |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `没有等价项` | `beforeMount` |'
- en: '| `compiled` | `mounted` |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `compiled` | `mounted` |'
- en: '| `ready` | `mounted` |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `ready` | `mounted` |'
- en: '| `attached` | `no equivalent` |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `attached` | `没有等价项` |'
- en: '| `detached` | `no equivalent` |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `detached` | `没有等价项` |'
- en: '| `no equivalent` | `beforeUpdate` |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `没有等价项` | `beforeUpdate` |'
- en: '| `no equivalent` | `updated` |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `没有等价项` | `updated` |'
