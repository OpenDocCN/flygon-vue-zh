- en: Optimizing your App and Using Components to Display Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化您的应用程序并使用组件显示数据
- en: In Chapter 2, *Displaying, Looping, Searching, and Filtering Data*, we got our
    Vue app displaying our people directory, we can use this opportunity to optimize
    our code and separate it out into components. This makes the code more manageable,
    easier to understand, and makes it easier for other developers to work out the
    flow of data (or you, when you come back and look at your code in a few months!).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章“显示、循环、搜索和过滤数据”中，我们让Vue应用程序显示了我们的人员目录，我们可以利用这个机会来优化我们的代码并将其分离成组件。这样可以使代码更易于管理，更容易理解，并且使其他开发人员能够更容易地了解数据流程（或者在几个月后再次查看代码时，您自己也能更容易理解）。
- en: 'This chapter is going to cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Optimizing our Vue.js code by reducing the repetition, and logically organizing
    our code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过减少重复代码和逻辑组织代码来优化我们的Vue.js代码
- en: How to create Vue components and use them with Vue
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建Vue组件并在Vue中使用它们
- en: How to use props and slots with components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在组件中使用props和slots
- en: Utilizing events to transfer data between components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用事件在组件之间传递数据
- en: Optimizing the code
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化代码
- en: 'As we wrote the code while we were figuring out the problem, there comes a
    point when you need to take a step back and look at your code to optimize it.
    This could include reducing the number of variables and methods or creating methods,
    to reduce repeating functionality. Our current Vue app looks like the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在解决问题时编写代码时，有一个时刻你需要退后一步，看看你的代码并对其进行优化。这可能包括减少变量和方法的数量或创建方法以减少重复功能。我们当前的Vue应用程序如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Looking at the preceding code, there are some improvements we can make. These
    include:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面的代码，我们可以进行一些改进。这些改进包括：
- en: Reducing the number of filter variables and grouping logically
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少过滤变量的数量并进行逻辑分组
- en: Combining the format functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合格式化函数
- en: Reducing the number of hard-coded variables and properties
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少硬编码变量和属性的数量
- en: Re-ordering methods into a more logical order
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将方法重新排序为更合理的顺序
- en: We'll cover these points individually so we have a clean code base for building
    components with.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个讨论这些要点，以便我们有一个干净的代码库来构建组件。
- en: Reducing the number of filter variables and grouping logically
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少过滤变量的数量并进行逻辑分组
- en: 'The filtering currently uses up three variables, `filterField`, `filterQuery`,
    and `filterUserState`. The only thing that currently links these variables is
    the name, rather than being in an object of their own to link them systematically.
    Doing this avoids any ambiguity as to whether they are related to the same component
    or just coincidentally the same. In the data object, create a new object titled
    `filter` and move each variable inside:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的过滤器使用了三个变量`filterField`，`filterQuery`和`filterUserState`。目前唯一将这些变量联系在一起的是名称，而不是它们自己的对象以系统地将它们链接在一起。这样做可以避免任何关于它们是否与同一个组件相关或仅仅是巧合的歧义。在数据对象中，创建一个名为`filter`的新对象，并将每个变量移动到其中：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To access the data, update any references of `filterField` to `this.filter.field`.
    Note the extra dot, denoting it is a key of the filter object. Don''t forget to
    update `filterQuery` and `filterUserState` references as well. For example, the
    `isActiveFilterSelected` method would become:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数据，请将`filterField`的所有引用更新为`this.filter.field`。注意额外的点，表示它是过滤器对象的一个键。还要记得更新`filterQuery`和`filterUserState`的引用。例如，`isActiveFilterSelected`方法将变为：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will also need to update the `v-model` and `v-show` attributes in your view—there
    are five occurrences of the various variables.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在视图中更新`v-model`和`v-show`属性-有五个不同变量的出现。
- en: While updating the filtering variables, we can take this opportunity to remove
    one. With our current filtering, we can only have one filter active at a time.
    This means the `query` and `userState` variables are only being used at any one
    time, which gives us the opportunity to combine these two variables. To do so,
    we'll need to update the view and application code to cater for this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新过滤变量的同时，我们可以利用这个机会删除一个变量。根据我们当前的过滤方式，一次只能有一个过滤器处于活动状态。这意味着`query`和`userState`变量在任何时候只被使用一次，这给我们合并这两个变量的机会。为此，我们需要更新视图和应用程序代码以适应这种情况。
- en: Remove the `userState` variable from your filter data object and update any
    occurrence of `filter.userState` in your view to `filter.query`. Now do a *find
    and replace* in your Vue JavaScript code for `filter.userState`, again replacing
    it with `filter.query`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从过滤数据对象中删除`userState`变量，并将视图中的任何`filter.userState`出现更新为`filter.query`。现在，在Vue
    JavaScript代码中进行*查找和替换*，将`filter.userState`替换为`filter.query`。
- en: 'Viewing your app in the browser, it will appear to initially work, being able
    to filter users by the field. However, if you filter by status, then switch to
    any other field, the query field won''t show. This is because using the radio
    buttons sets the value to a Boolean which, when trying to convert to lowercase
    for the query field, fails to do so. To tackle this, we can convert whatever value
    is in the `filter.query` variable to a string using the native JavaScript `String()`
    function. This ensures that our filtering function can work with any filtering
    input:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看应用程序，最初似乎可以工作，可以按字段过滤用户。但是，如果按状态过滤，然后切换到任何其他字段，查询字段将不会显示。这是因为使用单选按钮将值设置为布尔值，当尝试将其转换为小写以进行查询字段时，无法执行此操作。为了解决这个问题，我们可以使用原生JavaScript的`String()`函数将`filter.query`变量中的任何值转换为字符串。这确保我们的过滤函数可以与任何过滤输入一起使用：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Adding this to our code now ensures our query data is usable no matter what
    the value. The issue this now creates is when the user is switching between fields
    to filter. If you select the Active user and chose a radio button, the filtering
    works as expected, however, if you now switch to Email, or another field, the
    input box is prepopulated with either `true` or `false`. This instantly filters
    and will often return no results. This also occurs when switching between two
    text filtering fields, which is not the desired effect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将此添加到我们的代码中，确保我们的查询数据无论值如何都可以使用。现在创建的问题是，当用户在字段之间切换进行过滤时。如果选择活动用户并选择一个单选按钮，则过滤按预期工作，但是，如果现在切换到电子邮件或另一个字段，则输入框将预填充为`true`或`false`。这会立即进行过滤，并且通常不会返回任何结果。当在两个文本过滤字段之间切换时，也会发生这种情况，这不是期望的效果。
- en: What we want is, whenever the select box is updated, the filter query should
    clear. Whether it is the radio buttons or input box, selecting a new field should
    reset the filter query, this ensures a new search can begin.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望的是，每当选择框更新时，过滤查询都应该清除。无论是单选按钮还是输入框，选择新字段都应该重置过滤查询，这样可以开始新的搜索。
- en: This is done by removing the link between the select box and the `filter.field`
    variable and creating our own method to handle the update. We then trigger the
    method when the select box is changed. This method will then clear the `query`
    variable and set the `field` variable to the select box value.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过删除选择框与`filter.field`变量之间的链接，并创建我们自己的方法来处理更新来完成的。然后，在选择框更改时触发该方法。该方法将清除`query`变量并将`field`变量设置为选择框的值。
- en: Remove the `v-model` attribute on the select box and add a new `v-on:change` attribute.
    We will pass a method name into this that will fire every time the select box
    is updated.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择框上删除`v-model`属性，并添加一个新的`v-on:change`属性。我们将在其中传递一个方法名，每次选择框更新时都会触发该方法。
- en: '`v-on` is a new Vue binding that we''ve not encountered before. It allows you
    to bind actions from elements to Vue methods. For example, `v-on:click` is one
    that is used the most commonly - which allows you to bind a `click` function to
    the element. We''ll cover more on this in the next section of the book.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-on`是一个我们之前没有遇到过的新的Vue绑定。它允许您将元素的操作绑定到Vue方法。例如，`v-on:click`是最常用的一种，它允许您将`click`函数绑定到元素上。我们将在本书的下一节中详细介绍这个。'
- en: 'Where v-bind can be `abbreviated` to just a colon, `v-on` can be shortened
    to an `@` symbol, allowing you to use `@click=""`, for example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-bind`可以缩写为冒号，`v-on`可以缩写为`@`符号，允许您使用`@click=""`，例如：'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This attribute is firing the `changeFilter` method on every update and passing
    it the `$event` data of the change. This default Vue event object contains a lot
    of information that we could utilize, but the `target.value` data is the key we
    are after.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性在每次更新时触发`changeFilter`方法，并传递`$event`更改的数据。此默认的Vue事件对象包含了许多我们可以利用的信息，但我们关注的是`target.value`数据。
- en: 'Create a new method in your Vue instance that accepts the event parameter and
    updates both the `query` and `field` variables. The `query` variable needs to
    be cleared, so set it to an empty string, whereas the `field` variable can be
    set to the value of the select box:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Vue实例中创建一个新的方法，接受事件参数并更新`query`和`field`变量。`query`变量需要被清除，所以将其设置为空字符串，而`field`变量可以设置为选择框的值：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Viewing your application now should clear whatever the filter query is, while
    still operating as expected.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看您的应用程序应该清除过滤查询，同时仍然按预期运行。
- en: Combining the format functions
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合格式化函数
- en: Our next optimization will be to combine the `formatBalance` and `formatDate` methods
    in our Vue instance. This would then allow us to scale our format functions without
    bloating the code with several methods with similar functionality. There are two
    ways to approach a format style function—we can either auto-detect the format
    of the input or pass the desired format option in as a second option. Both have
    their pros and cons, but we'll walk through both.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个优化将是在Vue实例中合并`formatBalance`和`formatDate`方法。这将允许我们扩展格式化函数，而不会用几个具有类似功能的方法使代码臃肿。有两种方法可以处理格式化样式函数-我们可以自动检测输入的格式，也可以将所需的格式选项作为第二个选项传递。两者都有其优缺点，但我们将逐步介绍两种方法。
- en: Autodetection formatting
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动检测格式化
- en: 'Autodetection of the variable type, when passed into a function, is great for
    cleaner code. In your view, you could invoke the function and pass the one parameter
    you wish to format. For example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当传入函数时，自动检测变量类型对于更清晰的代码非常有用。在视图中，您可以调用该函数并传递一个要格式化的参数。例如：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The method would then contain a `switch` statement and format the variable based
    on the `typeof` value. A `switch` statement can evaluate a single expression and
    then execute different code based on the output. `Switch` statements can be very
    powerful as they allow clauses to be built up—utilizing several different bits
    of code based on the result. More can be read about `switch` statements on MDN.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该方法将包含一个`switch`语句，并根据`typeof`值格式化变量。`switch`语句可以评估单个表达式，然后根据输出执行不同的代码。`switch`语句非常强大，因为它允许构建子句-根据结果利用几个不同的代码片段。有关`switch`语句的更多信息可以在MDN上阅读。
- en: '`Switch` statements are a great alternative to `if` statements if you are comparing
    the same expression. You are also able to have several cases for one block of
    code and even include a default if none of the previous cases was met. As an example
    of one in use, our format method might look like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要比较相同的表达式，`switch`语句是`if`语句的一个很好的替代方案。您还可以为一个代码块设置多个情况，并在之前的情况都不满足时包含一个默认情况。作为使用示例，我们的格式化方法可能如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The important thing to note is the `break;` lines. These finish each `switch`
    case. If a break was omitted, the code would carry on and execute the following
    case—which sometimes is the desired effect.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项是`break;`行。这些结束了每个`switch` case。如果省略了break，代码将继续执行下一个case，这有时是期望的效果。
- en: Autodetecting the variable type and formatting is a great way of simplifying
    your code. However, for our app, it is not a suitable solution as we are formatting
    the date, which when outputting the `typeof` results in a string, and would not
    be identifiable from other strings we may wish to format.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 自动检测变量类型和格式化是简化代码的好方法。然而，对于我们的应用程序来说，这不是一个合适的解决方案，因为我们正在格式化日期，当输出`typeof`结果时，它会变成一个字符串，并且无法从我们可能希望格式化的其他字符串中识别出来。
- en: Passing in a second variable
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传入第二个变量
- en: 'The alternative to the preceding autodetection is to pass the second variable
    into the `format` function. This gives us greater flexibility and scalability
    should we wish to format other fields. With the second variable, we can either
    pass in a fixed string that matches a preselected list in our `switch` statement
    or we could pass in the field itself. An example of the fixed string approach
    in the view would be:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面自动检测的替代方法是将第二个变量传递给`format`函数。这样做可以提供更大的灵活性和可扩展性，以便我们可以格式化其他字段。有了第二个变量，我们可以传入一个固定的字符串，与我们`switch`语句中的预选列表匹配，或者我们可以传入字段本身。在视图中使用固定字符串方法的一个示例是：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This would work perfectly and would be great if we had several different fields
    that all needed to be formatted like `balance` currently does, but there seems
    to be some slight repetition in using the `balance` key and `currency` format.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法完全适用，并且如果我们有几个不同的字段都需要像`balance`一样进行格式化，那就太好了，但是在使用`balance`键和`currency`格式时似乎有一些轻微的重复。
- en: As a compromise, we are going to pass the `person` object as the first parameter,
    so we can access all the data, and the name of the field as the second parameter.
    We will then use this for both identifying the format method required and to return
    the specific data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了妥协，我们将把`person`对象作为第一个参数传递，这样我们就可以访问所有的数据，将字段的名称作为第二个参数。然后我们将使用这个参数来识别所需的格式化方法并返回特定的数据。
- en: Creating the method
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建方法
- en: 'In your view, replace both the `formatDate` and `formatBalance` functions with
    a singular format one, passing in the `person` variable as the first parameter,
    and the field enclosed quotes as the second:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的视图中，用一个格式化函数替换`formatDate`和`formatBalance`函数，将`person`变量作为第一个参数传入，并将字段用引号括起来作为第二个参数：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a new format method inside your Vue instance, which accepts two parameters: `person`
    and `key`. As the first step, retrieve the field using the person object and the
    `key` variable:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue实例中创建一个新的格式化方法，接受两个参数：`person`和`key`。作为第一步，使用person对象和`key`变量检索字段：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have also created a second variable inside the function titled `output`—this
    will be what is returned at the end of the function and is set to the `field`
    by default. This ensures that if our formatting key does not match the one passed
    in, the untouched field data is returned—we do, however, convert the field to
    a string and trim any whitespace from the variable. Running the app now will return
    the fields without any formatting.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在函数内部创建了一个名为`output`的第二个变量，这将在函数结束时返回，并默认设置为`field`。这样可以确保如果我们的格式化键与传入的键不匹配，将返回未经处理的字段数据，但我们会将字段转换为字符串并修剪变量中的任何空格。现在运行应用程序将返回没有任何格式化的字段。
- en: 'Add a `switch` statement, setting the expression to be just the `key`. Add
    two cases to the `switch` statement—one being `balance` and the other `registered`.
     As we do not wish for anything to happen to our input when it does not match
    a case, there is no need for us to have a `default` statement:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`switch`语句，将表达式设置为仅为`key`。在`switch`语句中添加两个情况，一个是`balance`，另一个是`registered`。由于我们不希望在输入不匹配情况时发生任何事情，所以我们不需要`default`语句：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We now just need to copy the code from our original formatting functions into
    the individual cases:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将原始格式化函数的代码复制到各个情况中：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This format function is now a lot more flexible. We can add more `switch` cases
    should we need to cater for more fields (process the `name` field, for example)
    or we can add new cases to existing code. An example of this would be if our data
    contained a field that detailed the date on which the user `deactivated` their
    account, we could easily display it in the same format as registered:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个格式化函数现在更加灵活。如果我们需要处理更多字段（例如处理“name”字段），我们可以添加更多的`switch`情况，或者我们可以在现有代码中添加新的情况。例如，如果我们的数据包含一个字段，详细说明用户“停用”帐户的日期，我们可以轻松地以与注册相同的格式显示它：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Reducing the number of hard-coded variables and properties, and reducing redundancy
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少硬编码变量和属性的数量，减少冗余
- en: When looking at the Vue JavaScript, it is quickly evident that it can be optimized
    by introducing global variables and setting more local variables in the functions
    to make it more readable. We can also use existing functionality to stop repeating
    ourselves.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看Vue JavaScript时，很快就会发现通过引入全局变量并在函数中设置更多的局部变量可以对其进行优化，使其更易读。我们还可以使用现有功能来避免重复。
- en: 'The first optimization is in our `filterRow()` method where we check whether `filter.field`
    is active. This is also repeated in the `isActiveFilterSelected` method we use
    to show and hide our radio buttons. Update the `if` statement to use this method
    instead, so the code is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个优化是在我们的`filterRow()`方法中，我们检查`filter.field`是否处于活动状态。这也在我们用于显示和隐藏单选按钮的`isActiveFilterSelected`方法中重复。更新`if`语句以使用此方法，代码如下：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code has the `this.filter.field === ''isActive''` code removed
    and replaced with the `isActiveFilterSelected()` method. It should now look like
    this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码已删除`this.filter.field === 'isActive'`代码，并替换为`isActiveFilterSelected()`方法。现在它应该是这样的：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While we''re in the `filterRow` method, we can reduce the code by storing the
    `query` and `field` as variables at the start of the method. `result` is also
    not the right keyword for this, so let''s change it to `visible`. First, create
    and store our two variables at the start and rename `result` to `visible`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`filterRow`方法中时，我们可以通过在方法开始时将`query`和`field`存储为变量来减少代码。`result`也不是这个的正确关键字，所以让我们将其更改为`visible`。首先，在开始处创建和存储我们的两个变量，并将`result`重命名为`visible`：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Replace all instances in that function of the variables, for example, the first
    part of the method would look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数中替换所有变量的实例，例如，方法的第一部分将如下所示：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Save your file and open the app in the browser to ensure your optimizations
    haven't broken the functionality.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并在浏览器中打开应用程序，以确保您的优化没有破坏功能。
- en: 'The last stage is to reorder the methods into an order that makes sense to
    you. Feel free to add comments to separate out the different method types—for
    example, ones that relate to CSS classes or filtering. I have also removed the `activeStatus`
    method, as we are able to utilize our `format` method to *format* the output of
    this field. After the optimizations, the JavaScript code now looks like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将方法按照你认为合理的顺序重新排序。可以随意添加注释来区分不同类型的方法，例如与CSS类或过滤相关的方法。我还删除了`activeStatus`方法，因为我们可以利用我们的`format`方法来*格式化*此字段的输出。优化后，JavaScript代码现在如下所示：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating Vue components
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Vue组件
- en: Now we're confident our code is cleaner, we can move on to making Vue components
    for the various parts of our app. Put aside your code for now and open a new document
    while you get to grips with components.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对代码的整洁性有信心了，我们可以开始为应用程序的各个部分创建Vue组件。暂时放下你的代码，打开一个新文档，同时熟悉组件的使用。
- en: Vue components are extremely powerful and a great addition to any Vue app. They
    allow you to make packages of reusable code that include their own data, methods,
    and computed values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Vue组件非常强大，是任何Vue应用程序的重要组成部分。它们允许你创建可重用代码的包，包括它们自己的数据、方法和计算值。
- en: 'For our app, we have the opportunity to create two components: one for each
    person and one for the filtering section of our app. I would encourage you to
    always look at breaking your app into components where possible—this helps group
    your code into related functions.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们有机会创建两个组件：一个用于每个人，一个用于我们应用程序的过滤部分。我鼓励你在可能的情况下始终考虑将应用程序拆分为组件，这有助于将代码分组到相关的功能中。
- en: Components look like mini Vue instances as each one has its own data, methods,
    and computed objects—along with some component-specific options that we will cover
    shortly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 组件看起来像是迷你的Vue实例，因为每个组件都有自己的数据、方法和计算属性，还有一些特定于组件的选项，我们将很快介绍。
- en: 'When a component is registered, you create a custom HTML element to use in
    your view, for example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组件被注册时，你可以创建一个自定义的HTML元素在你的视图中使用，例如：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When naming your component, you can use kebab-case (hyphens), PascalCase (no
    punctuation, but each word is capitalized) or camelCase (similar to Pascal but
    the first word is not capitalized). Vue components are not restricted by, or associated
    with, the W3C web components/custom element rules, but it is good practice to
    follow this convention of using kebab-case.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名组件时，你可以使用短横线分隔的kebab-case（连字符）、没有标点符号但每个单词首字母大写的PascalCase或类似PascalCase但第一个单词首字母不大写的camelCase。Vue组件不受W3C
    Web组件/自定义元素规则的限制或关联，但按照使用kebab-case的约定是一个好习惯。
- en: Creating and initializing your component
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和初始化你的组件
- en: Vue components are registered using the `Vue.component(tagName, options)` syntax.
    Each component must have an associated tag name. The `Vue.component` registration **must**
    happen before you initialize your Vue instance. As a minimum, each component should
    have a `template` property—denoting what should be displayed when the component
    is used. Templates must always have a single wrapping element; this is so the
    custom HTML tag can be replaced with the parent container.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Vue组件使用`Vue.component(tagName, options)`语法进行注册。每个组件必须有一个关联的标签名。`Vue.component`注册**必须**在初始化Vue实例之前发生。作为最低要求，每个组件应该有一个`template`属性，表示在使用组件时应该显示什么内容。模板必须始终有一个包装元素；这样自定义的HTML标签可以被父容器替换。
- en: 'For example, you couldn''t have the following as your template:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不能将以下内容作为你的模板：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you do pass a template of this format, Vue will throw an error in the browser's
    JavaScript console warning you.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递了这种格式的模板，Vue将在浏览器的JavaScript控制台中抛出错误警告。
- en: 'Create a Vue component yourself, with a simple fixed template:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 自己创建一个简单的固定模板的Vue组件：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this component declared, it would now give us a `<my-component></my-component>`
    HTML tag to use in our view.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了这个组件后，它现在会给我们一个`<my-component></my-component>` HTML标签，可以在我们的视图中使用。
- en: 'You can also specify components on the Vue instance itself. This would be used
    if you had multiple Vue instances on one site and wished to contain a component
    to one instance. To do this, create your component as a simple object and assign
    the `tagName` within the `components` object of your Vue instance:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Vue实例本身上指定组件。如果您在一个站点上有多个Vue实例，并希望将组件限制在一个实例中，可以使用一个简单的对象创建组件，并在Vue实例的`components`对象中分配`tagName`：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For our app though, we are going to stick with the `Vue.component()` method
    of initializing our components.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将继续使用`Vue.component()`方法来初始化我们的组件。
- en: Using your component
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用您的组件
- en: 'In your view, add your custom HTML element component:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的视图中，添加您的自定义HTML元素组件：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Viewing this in the browser should replace the `<my-component>` HTML tag with
    a `<div>` and a hello message.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看，应该将`<my-component>` HTML标签替换为`<div>`和一个hello消息。
- en: 'There may be some cases where a custom HTML tag won''t be parsed and accepted
    - these cases tend to be in `<table>`, `<ol>`, `<ul>`, and `<select>` elements.
    If this is the case, you can use the `is=""` attribute on a standard HTML element:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一些情况下，自定义HTML标签不会被解析和接受-这些情况往往出现在`<table>`、`<ol>`、`<ul>`和`<select>`元素中。如果是这种情况，您可以在标准HTML元素上使用`is=""`属性：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using component data and methods
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件数据和方法
- en: As Vue components are self-contained elements of your Vue app, they each have
    their own data and functions. This helps when re-using components on the same
    page, as the information is self-contained per instance of a component. `methods`
    and `computed` functions are declared the same as you would on the Vue app, however,
    the data key should be a function that returns an object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Vue组件是Vue应用程序的自包含元素，它们各自具有自己的数据和函数。这在同一页面上重复使用组件时非常有用，因为信息是每个组件实例自包含的。`methods`和`computed`函数的声明方式与在Vue应用程序上相同，但是数据键应该是一个返回对象的函数。
- en: The data object of a component must be a function. This is so that each component
    has its own self-contained data, rather than getting confused and sharing data
    between different instances of the same component. The function must still return
    an object as you would in your Vue app.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的数据对象必须是一个函数。这样每个组件都有自己独立的数据，而不会混淆并共享不同实例的相同组件之间的数据。该函数仍然必须返回一个对象，就像在Vue应用程序中一样。
- en: 'Create a new component called `balance`, add a `data` function and `computed`
    object to your component and an empty `<div>` to the `template` property for now:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`balance`的新组件，为您的组件添加一个`data`函数和`computed`对象，并为`template`属性添加一个空的`<div>`：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, add a key/value pair to your `cost` data object with an integer and add
    the variable to your template. Add the `<balance></balance>` custom HTML element to
    your view and you should be presented with your integer:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`cost`数据对象中添加一个键/值对，并将变量添加到模板中。在视图中添加`<balance></balance>`自定义HTML元素，您应该看到您的整数：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As with our Vue instance in Chapter 1, *Getting Started with Vue.js*, add a
    function to the `computed` object that appends a currency symbol to the integer
    and ensures there are two decimal places. Don't forget to add the currency symbol
    to your data function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与第1章中的Vue实例一样，在`computed`对象中添加一个函数，将货币符号附加到整数上，并确保有两位小数。不要忘记将货币符号添加到您的数据函数中。
- en: 'Update the template to output the computed value instead of the raw cost:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模板以输出计算值而不是原始成本：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a basic example of a component, however, it is quite restricted with
    the fixed `cost` on the component itself.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的组件示例，但是它在组件本身上有固定的`cost`。
- en: Passing data to your component – props
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向组件传递数据-props
- en: Having the balance as a component is great, but not very good if the balance
    is fixed. Components really come into their own when you add the ability to pass
    in arguments and properties via HTML attributes. In the Vue world, these are called
    **props**. Props can be either static or variable. In order for your component
    to expect these properties, you need to create an array on the component by using
    the `props` property.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将balance作为一个组件是很好的，但如果balance是固定的，那就不太好了。当您通过HTML属性传递参数和属性时，组件真正发挥作用。在Vue世界中，这些被称为**props**。Props可以是静态的或变量的。为了使您的组件期望这些属性，您需要使用`props`属性在组件上创建一个数组。
- en: 'An example of this would be if we wanted to make a `heading` component:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是我们想要创建一个`heading`组件：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The component would then be used in the view like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，组件将在视图中使用如下：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With props, we don't need to define the `text` variable in the data object,
    as defining it in the props array automatically makes it available for use in
    the template. The props array can also take further options, allowing you to define
    the type of input expected, whether it is required or a default value to use if
    omitted.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用props，我们不需要在数据对象中定义`text`变量，因为在props数组中定义它会自动使其在模板中可用。props数组还可以接受进一步的选项，允许您定义期望的输入类型，以及是否需要输入或省略时使用的默认值。
- en: 'Add a prop to the balance component so we can pass the cost as an HTML attribute.
    Your view should now look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为balance组件添加一个prop，以便我们可以将cost作为HTML属性传递。您的视图现在应该如下所示：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now add the cost prop to the component in the JavaScript, and remove
    the fixed value from our data function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在JavaScript中为组件添加cost prop，并从数据函数中删除固定值：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Running this in our browser, however, will throw an error in our JavaScript
    console. This is because, natively, props being passed in are interpreted as strings.
    We can address this in two ways; we can either convert our prop to a number in
    our `formatCost()` function or, alternatively, we can use the `v-bind:` HTML attribute
    to tell Vue to accept the input for what it is.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在浏览器中运行此代码将在JavaScript控制台中引发错误。这是因为，本地情况下，传递的props被解释为字符串。我们可以通过两种方式解决这个问题；我们可以在`formatCost()`函数中将我们的prop转换为数字，或者我们可以使用`v-bind:`HTML属性告诉Vue接受输入为它是什么。
- en: 'If you remember, we used this technique with our filters for the `true` and
    `false` values—allowing them to be used as Boolean instead of strings. Add `v-bind:`
    in front of your `cost` HTML attribute:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得，我们在`true`和`false`值的过滤器中使用了这种技术-允许它们作为布尔值而不是字符串使用。在您的`cost`HTML属性前面添加`v-bind:`：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is an extra step we can do to ensure Vue knows what kind of input to expect
    and informs other users of your code as to what they should be passing to the
    component. This can be done in the component itself and, along with the format,
    allows you to specify default values along with whether the prop is required or
    not.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个额外的步骤可以确保Vue知道要期望什么样的输入，并通知其他用户您的代码应该传递什么。这可以在组件本身中完成，并且可以与格式一起，允许您指定默认值以及是否需要传递prop。
- en: 'Convert your `props` array to an object, with `cost` as the key. If you are
    just defining the field type, you can use the Vue shorthand for declaring this
    by setting the value as the field type. These can be String, Number, Boolean,
    Function, Object, Array, or Symbol. As our cost attribute should be a number,
    add that as the key:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的`props`数组转换为一个对象，以`cost`作为键。如果您只是定义字段类型，可以使用Vue的简写方式来声明，将值设置为字段类型。这些类型可以是String、Number、Boolean、Function、Object、Array或Symbol。由于我们的cost属性应该是一个数字，所以将其添加为键：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It would be nice if, rather than throwing an error when nothing is defined,
    our component rendered `$0.00`. We can do this by setting the default to just
    `0`. To define a default we need to convert our prop into an object itself - containing
    a `type` key that has the value of `Number`. We can then define another `default` key
    and set the value to `0`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有定义任何内容，组件渲染为`$0.00`会更好。我们可以通过将默认值设置为`0`来实现这一点。要定义默认值，我们需要将我们的属性转换为一个对象本身
    - 包含一个`type`键，其值为`Number`。然后，我们可以定义另一个`default`键，并将值设置为`0`：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Rendering the component in the browser should show whatever value is passed
    into the cost attribute—but removing this will render `$0.00`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中渲染组件应该显示传递到cost属性的任何值，但是如果删除这个属性，将会渲染为“$0.00”。
- en: 'To recap, our component looks like :'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们的组件如下：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We should be able to expand on this example when we make the`person` component
    of our listing app.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们制作列表应用程序的`person`组件时，我们应该能够在此示例上进行扩展。
- en: Passing data to your component – slots
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向组件传递数据 - 插槽
- en: There are times when you may need to pass chunks of HTML to your component that
    are not stored in a property or that you want to format before appearing in the
    component. Rather than trying to pre-format in a computed variable or similar,
    you can use slots with your component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能需要将HTML块传递给组件，这些HTML块不存储在属性中，或者您希望在组件中显示之前进行格式化。与其尝试在计算变量或类似变量中进行预格式化，不如使用组件的插槽。
- en: Slots are like placeholders and allow you to place content between the opening
    and closing tags of your component and determine where they are going to display.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽就像占位符，允许您在组件的开头和结尾标签之间放置内容，并确定它们将显示在哪里。
- en: A perfect example of this would be a modal window. These normally have several
    tags and often consist of a lot of HTML to copy and paste if you wish to use it
    in your application multiple times. Instead, you can create a `modal-window` component
    and pass your HTML with a slot.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完美的例子是模态窗口。这些通常有几个标签，并且通常由大量的HTML组成，如果您希望在应用程序中多次使用它，就需要复制和粘贴。相反，您可以创建一个`modal-window`组件，并使用插槽传递您的HTML。
- en: 'Create a new component titled `modal-window`. This accepts one prop of `visible`,
    which accepts a Boolean value and is `false` by default. For the template, we''ll
    use the HTML from the *Bootstrap modal* as a good example of how a component using
    slots can easily simplify your application. To ensure the component is styled,
    make sure you include the bootstrap *asset files* in your document:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`modal-window`的新组件。它接受一个名为`visible`的属性，默认为`false`，接受一个布尔值。对于模板，我们将使用*Bootstrap
    modal*中的HTML作为一个很好的示例，说明使用插槽的组件如何轻松简化您的应用程序。为了确保组件被样式化，请确保在文档中包含bootstrap的*asset文件*：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will be using the visible prop to determine whether the modal window is
    open or not. Add a `v-show` attribute to your outer container that accepts the
    `visible` variable:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用visible属性来确定模态窗口是否打开。在外部容器中添加一个`v-show`属性，接受`visible`变量：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add your `modal-window` component to the app, specifying `visible` to be `true`
    for now, so we can understand and see what is going on:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的`modal-window`组件添加到应用程序中，暂时将`visible`设置为`true`，以便我们可以理解和看到发生了什么：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We now need to pass some data to our modal box. Add a heading and some paragraphs
    between the two tags:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向我们的模态框传递一些数据。在两个标签之间添加一个标题和一些段落：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Pressing refresh in the browser won''t do anything, as we need to tell the
    component what to do with the data. Inside your template, add a `<slot></slot>`
    HTML tag where you want your content to appear. Add it to the `div` with the `modal-body`
    class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中按刷新按钮不会有任何反应，因为我们需要告诉组件如何处理数据。在模板中，在您希望内容出现的位置添加一个`<slot></slot>`HTML标签。将其添加到具有`modal-body`类的`div`中：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Viewing your app will now reveal the content you passed in inside the modal
    window. Already, the app is looking cleaner with this new component.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看您的应用程序将在模态窗口中显示您传递的内容。通过这个新组件，应用程序看起来更清晰。
- en: Viewing the Bootstrap HTML, we can see there is space for a header, body, and
    footer. We can identify these sections with named slots. This allows us to pass
    specific content to specific areas of our component.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Bootstrap的HTML，我们可以看到有一个头部、主体和底部的空间。我们可以使用命名插槽来标识这些部分。这样，我们就可以将特定的内容传递到组件的特定区域。
- en: 'Create two new `<slot>` tags in the header and footer of the modal window.
    Give these new ones a name attribute, but leave the existing one empty:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在模态窗口的头部和底部创建两个新的`<slot>`标签。给这些新的标签添加一个name属性，但保留现有的空标签：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In our app, we can now specify what content goes where by specifying a `slot`
    attribute in the HTML. This can either go on a specific tag or a container around
    several tags. Any HTML without a `slot` attribute will also default to your unnamed
    slot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们现在可以通过在HTML中指定`slot`属性来指定内容放在哪里。这可以放在特定的标签上，也可以放在几个标签周围的容器上。任何没有`slot`属性的HTML也将默认为无名插槽：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can now specify and direct our content to specific places.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以指定并将我们的内容定向到特定的位置。
- en: The last thing you can do with slots is specified a default value. For example,
    you may want to display the buttons in the footer most of the time, but want to
    have the ability to replace them if desired. With a `<slot>`, any content placed
    between the tags will be displayed unless overwritten when specifying the component
    in your app.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽的最后一件事是指定默认值。例如，您可能希望大部分时间在页脚显示按钮，但如果需要，可以替换它们。使用`<slot>`，在标签之间放置的任何内容都将显示，除非在应用程序中指定组件时进行覆盖。
- en: Create a new slot titled `buttons`,  and place the buttons in the footer inside.
    Try replacing them with some other content.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`buttons`的新插槽，并将按钮放在底部。尝试用其他内容替换它们。
- en: 'The template becomes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 模板变为：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And the HTML:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: HTML如下：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Although we won't be utilizing slots with our people listing app, it's good
    to be aware of the capabilities of a Vue component. If you wished to use a modal
    box like this, you can set the visibility to a variable that is false by default.
    You can then add a button with a click method that changes the variable from `false`
    to `true`—displaying the modal box.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会在人员列表应用程序中使用插槽，但了解Vue组件的功能是很好的。如果您希望使用这样的模态框，您可以将可见性设置为默认为false的变量。然后，您可以添加一个具有点击方法的按钮，将变量从`false`更改为`true`，从而显示模态框。
- en: Creating a repeatable component
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可重复使用的组件
- en: The beauty of components is being able to use them multiple times in the same
    view. This gives you the ability to have one single "source of truth" for the
    layout of that data. We're going to make a repeatable component for our people
    list and a separate component for the filtering section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的美妙之处在于可以在同一个视图中多次使用它们。这使您能够为该数据的布局拥有一个单一的“真实来源”。我们将为人员列表创建一个可重复使用的组件，并为过滤部分创建一个单独的组件。
- en: 'Open your people listing code you created in the last couple of chapters and
    create a new component titled `team-member`. Don''t forget to define the component
    before your Vue app is initialized. Add a `prop` to the component to allow the
    person object to be passed in. For validation purposes, only specify that it can
    be an `Object`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您在前几章中创建的人员列表代码，并创建一个名为`team-member`的新组件。不要忘记在Vue应用程序初始化之前定义组件。为组件添加一个`prop`，以允许传递person对象。为了验证目的，只需指定它可以是一个`Object`：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We now need to integrate our template into the component, which is everything
    inside (and including) the `tr` in our View.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将模板整合到组件中，即在我们的视图中（包括）`tr`内的所有内容。
- en: 'The template variable in the component just accepts a normal string without
    new lines, so we need to do one of the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 组件中的模板变量只接受没有换行符的普通字符串，因此我们需要执行以下操作之一：
- en: inline our HTML template—great for small templates but in this case will sacrifice
    readability
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联我们的HTML模板-对于小模板非常好，但在这种情况下会牺牲可读性
- en: add new lines with the `+` string concatenation—great for one or two lines,
    but would bloat our JavaScript
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`+`字符串连接添加新行-适用于一两行，但会使我们的JavaScript膨胀
- en: create a template block—Vue gives us the option to use external templates that
    are defined in the view using the `text/x-template` syntax and an ID
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板块-Vue允许我们使用在视图中使用`text/x-template`语法和ID定义的外部模板
- en: As our template is quite big, we are going to choose the third option of declaring
    our template at the end of our view.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模板相当大，我们将选择第三个选项，在视图末尾声明我们的模板。
- en: 'In your HTML, outside of your app, create a new script block and add a `type`
    and `ID` attribute:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的HTML中，在您的应用程序之外，创建一个新的脚本块，并添加`type`和`ID`属性：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can then move our person template into this block and remove the `v-for`
    attribute—we''ll still use that in the app itself:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将人员模板移动到此块中，并删除`v-for`属性-我们仍将在应用程序本身中使用它：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We now need to update the view to use the `team-member` component instead of
    the fixed code. To make our view cleaner and easier to understand, we are going
    to utilize the `<template>` HTML attribute mentioned earlier. Create a `<template>`
    tag and add the `v-for` loop we had before. To avoid confusion, update the loop
    to use `individual` as the variable for each person. They can be the same, but
    it makes the code easier to read if the variables, components, and props have
    different names. Update the `v-for` to be `v-for="individual in people"`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新视图，使用`team-member`组件代替固定代码。为了使我们的视图更清晰易懂，我们将利用前面提到的`<template>`HTML属性。创建一个`<template>`标签，并添加我们之前使用的`v-for`循环。为避免混淆，更新循环以使用`individual`作为每个人的变量。它们可以相同，但如果变量、组件和属性具有不同的名称，代码更容易阅读。将`v-for`更新为`v-for="individual
    in people"`：
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Inside the `template` tags of your view, add a new instance of the `team-member`
    component, passing the `individual` variable to the `person` prop. Don''t forget
    to add `v-bind:` to the person prop, otherwise, the component will interpret it
    as a fixed string with the value of the individual:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的视图的`template`标签内，添加一个新的`team-member`组件实例，将`individual`变量传递给`person`属性。不要忘记在person属性前添加`v-bind:`，否则组件将将其解释为一个固定字符串，其值为individual的值：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We now need to update the component to use the template we have declared using
    the `template` property and the ID of the script block as the value:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新组件，使用我们声明的模板作为`template`属性和脚本块的ID作为值：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Viewing the app in the browser will create several errors in the JavaScript
    console. This is because we are referencing several methods that are no longer
    available - as they are on the parent Vue instance, not on the component. If you
    want to verify that your component is working, change the code to only output
    the name of the person, and press refresh:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看应用程序将在JavaScript控制台中创建多个错误。这是因为我们引用了一些不再可用的方法-因为它们在父Vue实例上，而不是在组件上。如果您想验证组件是否正常工作，请将代码更改为仅输出人员的名称，并按刷新：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Creating component methods and computed functions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件方法和计算函数
- en: We now need to create the methods we had created on the Vue instance on the
    child component, so they are available to use. One thing we could do is cut and
    paste the methods from the parent into the child in the hope they would work;
    however, those methods rely on parent properties (such as filtering data) and
    we also have the opportunity to utilize `computed` properties, which cache the
    data and can speed up your app.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在子组件上创建我们在Vue实例上创建的方法，以便可以使用它们。我们可以将方法从父组件剪切并粘贴到子组件中，希望它们能够正常工作；然而，这些方法依赖于父组件的属性（如过滤数据），我们还有机会利用`computed`属性，它可以缓存数据并加快应用程序的速度。
- en: For now, remove the `v-show` attribute from the `tr` element—as this involves
    the filtering, and that will be covered once we have our rows displaying correctly.
    We'll step through the errors and resolve them one at a time to help you understand
    problem-solving with Vue.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时从`tr`元素中删除`v-show`属性，因为这涉及到过滤，而这将在我们正确显示行后进行讨论。我们将逐步解决错误，并逐个解决它们，以帮助您理解使用Vue进行问题解决。
- en: CSS class functions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS类函数
- en: 'The first error we encounter when viewing the application in the browser is:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看应用程序时，我们遇到的第一个错误是：
- en: Property or method "balanceClass" is not defined
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 属性或方法“balanceClass”未定义。
- en: The first error is with regards to both the `balanceClass` and `activeClass`
    functions we use. Both of these functions add CSS classes based on the data of
    the person, which does not change once the component has been rendered.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个错误涉及到我们使用的`balanceClass`和`activeClass`函数。这两个函数根据人员的数据添加CSS类，一旦组件被渲染，这些数据就不会改变。
- en: Because of this, we are able to use the caching found in Vue. Move the methods
    across to the component but put them in a new `computed` object, instead of the
    `methods` one.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用Vue中的缓存。将方法移到组件中，但将它们放在一个新的`computed`对象中，而不是`methods`对象中。
- en: 'With components, a new instance is created every time it is called, so we can
    rely on the `person` object we passed in via a `prop` and no longer need to pass
    the `person` into the function. Remove the parameter from the function and the
    view—also update any reference to `person` *inside* the function to `this.person`
    to reference the object stored on the component:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组件，每次调用时都会创建一个新的实例，因此我们可以依赖于通过`prop`传递的`person`对象，不再需要将`person`传递给函数。从函数和视图中删除参数，还要将函数内部对`person`的任何引用更新为`this.person`，以引用存储在组件上的对象：
- en: '[PRE54]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The part of our component template that utilizes this function should now look
    like:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数的组件模板部分现在应该如下所示：
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Formatted value functions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化值函数
- en: When it comes to moving the `format()` function to the component for formatting
    our data, we are faced with two options. We can move it like-for-like and put
    it in the `methods` object, or we can take advantage of the Vue caching and conventions
    and create a `computed` function for each value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`format()`函数移动到组件中格式化我们的数据时，我们面临两个选择。我们可以像原样移动它并将其放在`methods`对象中，或者我们可以利用Vue的缓存和约定，为每个值创建一个`computed`函数。
- en: We are building this app for scalability, so it's advisable to make computed
    functions for each value—it will also have the advantage of tidying up our template.
    Create three functions in the computed object titled `balance`, `dateRegistered`,
    and `status`. Copy the corresponding parts of the `format` function across to
    each one, updating the reference of `person` to `this.person` once more.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建可扩展性的应用程序，因此建议为每个值创建计算函数，这也有助于整理我们的模板。在计算对象中创建三个函数，分别命名为`balance`，`dateRegistered`和`status`。将`format`函数的相应部分复制到每个函数中，再次将`person`的引用更新为`this.person`。
- en: 'Where we were retrieving the field using a function parameter, you can now
    fix the value in each function. You will also need to add a data object with the
    currency symbol for the balance function—add this after the `props`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前是使用函数参数来检索字段，现在你可以在每个函数中修复该值。您还需要添加一个带有余额函数的货币符号的数据对象 - 将其添加到`props`之后：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As the `team-member` component is the only place our currency symbol is used,
    we can remove it from the Vue app itself. We can also remove the format function
    from our parent Vue instance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`team-member`组件是唯一使用货币符号的地方，我们可以将其从Vue应用程序本身中删除。我们还可以从父Vue实例中删除格式化函数。
- en: 'In total, our Vue `team-member` component should look like:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们的Vue `team-member`组件应该如下所示：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And our `team-member-template` should look fairly simple in comparison to what
    it did look like:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前相比，我们的`team-member-template`应该看起来非常简单：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And lastly, our Vue instance should look significantly smaller:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的Vue实例应该显得更小：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Viewing the app in the browser, we should be presented with our list of people
    with the correct classes added to the table cells and formatting added to the
    fields.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看应用程序，我们应该看到我们的人员列表，并在表格单元格中添加了正确的类，并在字段中添加了格式。
- en: Making the filtering work again with props
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使过滤再次起作用
- en: 'Re-add the `v-show="filterRow()"` attribute to the containing `tr` element
    in your template. As our component has the person cached on each instance, we
    no longer need to pass the person object to the method. Refreshing the page will
    give you a new error in your JavaScript console:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中的包含`tr`元素中重新添加`v-show="filterRow()"`属性。由于我们的组件在每个实例上都有缓存的person，我们不再需要将person对象传递给该方法。刷新页面将在JavaScript控制台中给出新的错误：
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This error is because our component has the `v-show` attribute, showing and
    hiding based on our filtering and properties, but not the corresponding `filterRow`
    function. As we don''t use it for anything else, we can move the method from the
    Vue instance to the component, adding it to the `methods` component. Remove the
    person parameter and update the method to use `this.person`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是因为我们的组件有`v-show`属性，根据我们的过滤和属性来显示和隐藏，但没有相应的`filterRow`函数。由于我们不在其他地方使用它，我们可以将该方法从Vue实例移动到组件中，并将其添加到`methods`组件中。删除person参数并更新方法以使用`this.person`：
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The next error in the console is:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台中的下一个错误是：
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The reason the filtering does not work is that the `filterRow` method is looking
    for `this.filter.field` and `this.filter.query` on the component, not the parent
    Vue instance where it belongs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤不起作用的原因是`filterRow`方法在组件上寻找`this.filter.field`和`this.filter.query`，而不是它所属的父Vue实例。
- en: As a quick fix, you can use `this.$parent` to reference data on the parent element—however,
    this is not recommended and should only be used in extreme circumstances or to
    quickly pass the data through.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速修复，您可以使用`this.$parent`来引用父元素上的数据 - 但是，这不是推荐的做法，只能在极端情况下或快速传递数据时使用。
- en: 'To pass the data through to the component we are going to use another prop
    - similar to how we are passing the person into the component. Fortunately, we
    had grouped our filtering data already, so we are able to pass that one object
    instead of individual properties of `query` or `field`. Create a new prop on your
    component titled `filter` and ensure you only allow an `Object` to be passed through:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据传递给组件，我们将使用另一个prop - 类似于我们如何将person传递给组件。幸运的是，我们已经将我们的过滤数据分组，所以我们可以传递一个对象而不是`query`或`field`的单个属性。在组件上创建一个名为`filter`的新prop，并确保只允许传递一个`Object`：
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can then add the prop to the `team-member` component, allowing us to pass
    the data:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将该属性添加到`team-member`组件中，从而允许我们传递数据：
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In order for our filtering to work, we need to pass in one more property- the `isActiveFilterSelected()`
    function. Create another prop, titled `statusFilter`, allowing only a `Boolean`
    to be the value (as this is what the function equates to), and pass the function
    through. Update the `filterRow` method to use this new value. Our component now
    looks like:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的过滤器工作，我们需要传入另一个属性-`isActiveFilterSelected()`函数。创建另一个prop，标题为`statusFilter`，只允许`Boolean`作为值（因为这是函数的等价值），并将函数传递进去。更新`filterRow`方法以使用这个新值。我们的组件现在看起来像这样：
- en: '[PRE65]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And the component within the View with the extra props now looks like the following.
    Note that the camel-cased prop becomes snake case (hyphenated) when used as an
    HTML attribute:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，视图中的组件带有额外的props如下所示。请注意，当作为HTML属性使用时，驼峰式的prop变为蛇形式（用连字符分隔）：
- en: '[PRE66]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Making the filters a component
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将过滤器作为一个组件
- en: We now need to make the filtering section its own component. This isn't strictly
    necessary in this scenario, but it's good practice and gives us more challenges.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将过滤部分作为一个独立的组件。在这种情况下，这并不是必需的，但这是一个好的实践，并且给我们带来了更多的挑战。
- en: The problem we face in making the filtering a component is a challenge of transferring
    filter data between the filtering component and the `team-member` component. Vue
    addresses this with custom events. These let you pass (or "emit") data to the
    parent or other components from the child component.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在将过滤器作为组件时面临的问题是在过滤组件和`team-member`组件之间传递过滤数据的挑战。Vue通过自定义事件来解决这个问题。这些事件允许您从子组件向父组件或其他组件传递（或“发射”）数据。
- en: We are going to create a filtering component which, on filtering change, passes
    the data back to the parent Vue instance. This data is already passed through
    to the `team-member` component to filter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个过滤组件，当过滤改变时，将数据传递回父Vue实例。这些数据已经通过`team-member`组件传递以进行过滤。
- en: Creating the component
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件
- en: As with the `team-member` component, declare a new `Vue.component()` in your
    JavaScript, referencing a template ID of `#filtering-template`. Create a new `<script>`
    template block in your view and give it the same ID. Replace the filtering form
    in the view with a `<filtering>` custom HTML template and put the form inside
    your `filtering-template` script block.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与`team-member`组件一样，在您的JavaScript中声明一个新的`Vue.component()`，引用模板ID为`#filtering-template`。在视图中创建一个新的`<script>`模板块，并给它相同的ID。用一个`<filtering>`自定义HTML模板替换视图中的过滤表单，并将表单放在`filtering-template`脚本块中。
- en: 'Your view should look like the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您的视图应该如下所示：
- en: '[PRE67]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And you should have the following in your JavaScript:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你的JavaScript中应该有以下内容：
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Resolving JavaScript errors
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决JavaScript错误
- en: 'As with the `team-member` component, you are going to experience some errors
    in your JavaScript console. These can be resolved by copying the `filter` data
    object and both the `changeFilter` and `isActiveFilterSelected` methods from the
    parent instance. We''ll leave them in both the component and parent instance for
    now, but we''ll remove the duplication later:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与`team-member`组件一样，您将在JavaScript控制台中遇到一些错误。通过复制`filter`数据对象以及父实例中的`changeFilter`和`isActiveFilterSelected`方法来解决这些错误。我们暂时将它们保留在组件和父实例中，但稍后将删除重复部分：
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Running the app will show both the filters and person listing, but the filters
    won't update the people list as they are not communicating yet.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序将显示过滤器和人员列表，但过滤器不会更新人员列表，因为它们尚未进行通信。
- en: Using custom events to change the filter field
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义事件来更改过滤字段
- en: With custom events, you can pass data back up to the parent instances using the
    `$on` and `$emit` functions. For this app, we are going to store the filtering
    data on the parent Vue instance and update it from the component. The `team-member`
    component can then read the data from the Vue instance and filter accordingly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义事件，您可以使用`$on`和`$emit`函数将数据传递回父实例。对于这个应用程序，我们将在父Vue实例上存储过滤数据，并从组件中更新它。然后，`team-member`组件可以从Vue实例中读取数据并进行相应的过滤。
- en: 'The first step is to utilize the filter object on the parent Vue instance.
    Remove the `data` object from your component and pass in the parent one via a
    prop - just as we did with the `team-member` component:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是利用父Vue实例上的filter对象。从组件中删除`data`对象，并通过prop传递父对象 - 就像我们在`team-member`组件中所做的一样：
- en: '[PRE70]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We are now going to modify the `changeFilter` function to emit the event data
    so the parent instance, so it can update the `filter` object.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改`changeFilter`函数以发出事件数据，以便父实例可以更新`filter`对象。
- en: 'Remove the existing `changeFilter` method from the `filtering` component and
    create a new one called `change-filter-field`. Within this method, we just need
    to `$emit` the name of the field selected in the drop-down menu. The `$emit` function
    takes two parameters: a key and the value. Emit a key of `change-filter-field`
    and pass the `event.target.value` as the data. When using variables with multiple
    words (For example, `changeFilterField`), ensure these are hyphenated for the
    event name (the first parameter of the `$emit` function) and the HTML attribute:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从`filtering`组件中删除现有的`changeFilter`方法，并创建一个名为`change-filter-field`的新方法。在这个方法中，我们只需要使用`$emit`来发出在下拉菜单中选择的字段的名称。`$emit`函数接受两个参数：一个键和一个值。发出一个键为`change-filter-field`的事件，并将`event.target.value`作为数据传递。当使用多个单词的变量（例如`changeFilterField`）时，请确保这些变量在事件名称（`$emit`函数的第一个参数）和HTML属性中使用连字符：
- en: '[PRE71]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In order to then pass the data to the changeFilter method on our parent Vue
    instance, we need to add a new prop to our `<filtering>` element. This uses `v-on`
    and binds to the custom event name. It then has the parent method name as the
    attribute value. Add the attribute to your element:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据传递给父Vue实例上的changeFilter方法，我们需要在<filtering>元素中添加一个新的prop。这使用`v-on`并绑定到自定义事件名称。然后将父方法名称作为属性值。将属性添加到您的元素中：
- en: '[PRE72]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This attribute preceding tells Vue to trigger the `changeFilter` method when
    a `change-filter-field` event is emitted. We can then tweak our method to accept
    the parameter as the value:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性告诉Vue在发出`change-filter-field`事件时触发`changeFilter`方法。然后，我们可以调整我们的方法来接受参数作为值：
- en: '[PRE73]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This then clears the filters and updates the field value, which then ripples
    down to our components via props.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后清除过滤器并更新字段值，然后通过props传递给我们的组件。
- en: Updating the filter query
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新过滤器查询
- en: To emit the query field, we are going to use a new Vue key that we have not
    used before, called `watch`. The `watch` function tracks a data property and can
    run methods based on the output. The other thing it is able to do is to emit events.
    As both, our text field and radio buttons are set to update the field.query variable,
    we will create a new `watch` function on this.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发出查询字段，我们将使用一个之前未使用过的新Vue键，称为`watch`。`watch`函数跟踪数据属性并根据输出运行方法。它还能够发出事件。由于我们的文本字段和单选按钮都设置为更新field.query变量，所以我们将在此上创建一个新的`watch`函数。
- en: 'Create a new `watch` object after the methods on your component:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的方法之后创建一个新的`watch`对象：
- en: '[PRE74]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The key is the variable you wish to watch. As ours contains a dot, it needs
    to be wrapped in quotes. Within this function, create a new `$emit` event of `change-filter-query` that
    outputs the value of `filter.query`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是您希望监视的变量。由于我们的变量包含一个点，所以需要用引号括起来。在这个函数中，创建一个新的`$emit`事件`change-filter-query`，输出`filter.query`的值：
- en: '[PRE75]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We now need to bind this method and custom event to the component in the view,
    so it is able to pass the data to the parent instance. Set the value of the attribute
    to `changeQuery`—we''ll make a method to handle this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将这个方法和自定义事件绑定到视图中的组件，以便它能够将数据传递给父实例。将属性的值设置为`changeQuery`-我们将创建一个处理此操作的方法：
- en: '[PRE76]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'On the parent Vue instance, make a new method, titled `changeQuery`, that simply
    updates the `filter.query` value based on the input:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在父Vue实例中，创建一个名为`changeQuery`的新方法，简单地根据输入更新`filter.query`的值：
- en: '[PRE77]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Our filtering is now working again. Both updating the select box and the input
    box (or radio buttons) will now update our person list. Our Vue instance is significantly
    smaller and our templates and methods are contained with separate components.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过滤现在又可以工作了。更新选择框和输入框（或单选按钮）现在都会更新我们的人员列表。我们的Vue实例变得更小了，我们的模板和方法都包含在单独的组件中。
- en: The last step is to avoid the repetition of the `isActiveFilterSelected()` method,
    as this is only used once on the `team-member` component, but several times on
    the `filtering` component. Remove the method from the parent Vue instance, the
    prop from the `team-member` HTML element, and replace the `statusFilter` variable
    in the `filterRow` method within the `team-member` component with the contents
    of the function being passed through.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是避免在`team-member`组件上重复使用`isActiveFilterSelected()`方法，因为这个方法只在`team-member`组件上使用一次，但在`filtering`组件上使用多次。从父Vue实例中删除该方法，从`team-member`
    HTML元素中删除prop，并将`filterRow`方法中的`statusFilter`变量替换为传递的函数的内容。
- en: 'The final JavaScript now looks like:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的JavaScript代码现在如下所示：
- en: '[PRE78]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And the view is now:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 视图现在如下所示：
- en: '[PRE79]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Over the last three chapters, you have learned how to initialize a new Vue instance,
    what the meaning behind computed, method, and data objects are, and how to list
    out data from an object and manipulate it to be displayed correctly. You have
    also learned how to make components and what benefits there are to keeping your
    code clean and optimized.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的三章中，您已经学会了如何初始化一个新的Vue实例，computed、method和data对象的含义，以及如何列出对象中的数据并对其进行正确显示的操作。您还学会了如何创建组件以及保持代码清洁和优化的好处。
- en: In the next section of the book, we are going to introduce Vuex, something which
    helps us store and manipulate stored data better.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的下一节中，我们将介绍Vuex，它可以帮助我们更好地存储和操作存储的数据。
