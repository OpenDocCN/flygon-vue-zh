- en: Chapter 3. Components – Understanding and Using
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。组件-理解和使用
- en: In the previous chapter, you learned how Vue.js works. You saw behind the scenes
    and even made a slight debug of the core Vue.js code. You learned some of Vue's
    key concepts. You also learned and tried different ways of installing Vue.js.
    We have bootstrapped the applications; we will develop and enhance from this chapter
    on. We have also seen how to debug and to test our applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了Vue.js的工作原理。你了解了幕后情况，甚至对Vue.js核心代码进行了轻微的调试。你学习了一些Vue的关键概念。你还学习并尝试了不同的安装Vue.js的方式。我们已经启动了应用程序；从本章开始，我们将开发和增强它。我们还学会了如何调试和测试我们的应用程序。
- en: 'In the first chapter, we talked about components and even created some. In
    this chapter, we will use components in our applications and see some interesting
    directives in action. That being said, in this chapter, we are going to do the
    following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们谈论了组件，甚至创建了一些。在本章中，我们将在我们的应用程序中使用组件，并看到一些有趣的指令在其中的作用。也就是说，在本章中，我们将做以下事情：
- en: Revisit the components topic and review what components are
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新讨论组件主题并回顾组件的定义
- en: Create components for our applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建组件
- en: Learn what single-file components are
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习什么是单文件组件
- en: Learn how to achieve reactive CSS transitions with special attributes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用特殊属性实现响应式CSS过渡
- en: Revisiting components
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新讨论组件
- en: 'As you surely remember from the previous chapters, components are special parts
    of the Vue application that have their own scope of data and methods. Components
    can be used and reused throughout the application. In the previous chapter, you
    learned that a component is created by using the `Vue.extend({...})` method and
    registered using the `Vue.component()` syntax. So, in order to create and use
    a component, we would write the following JavaScript code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在之前的章节中肯定记得的，组件是Vue应用程序的特殊部分，具有自己的数据和方法范围。组件可以在整个应用程序中被使用和重复使用。在上一章中，你学到了组件是通过使用`Vue.extend({...})`方法创建的，并且使用`Vue.component()`语法进行注册。因此，为了创建和使用一个组件，我们需要编写以下JavaScript代码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we will use `hello-component` inside the HTML:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在HTML中使用`hello-component`：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Both initialization and registration can be written as a single `Vue.component`
    invocation with corresponding options:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化和注册都可以写成单个`Vue.component`调用，带有相应的选项：
- en: '`Vue.component(''hello-component'', { template: ''<h1>Hello</h1>'' });`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vue.component(''hello-component'', { template: ''<h1>Hello</h1>'' });`'
- en: Benefits of using components
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件的好处
- en: There are some things that we need to learn before going deep into the components
    and rewrite our applications using them. In this section, we will cover things
    such as handling `data` and `el` properties inside a component, component templates,
    scope, and preprocessors.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解组件并重写应用程序之前，有一些东西我们需要学习。在本节中，我们将涵盖处理组件内的`data`和`el`属性、组件模板、作用域和预处理器等内容。
- en: Declaring templates in HTML
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在HTML中声明模板
- en: In our previous example, we created a Vue component with a template written
    as a string. It's actually easy and nice because we have everything we need inside
    our component. Now imagine our component with a more complex HTML structure. Writing
    a complex HTML string template is error-prone, ugly, and against best practices.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们创建了一个Vue组件，模板是以字符串形式编写的。这实际上很容易和不错，因为我们在组件内有我们需要的一切。现在想象一下我们的组件具有更复杂的HTML结构。编写复杂的HTML字符串模板容易出错，丑陋，并且违反最佳实践。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By best practices, I mean clean and maintainable code. Complex HTML written
    as a string is anything but maintainable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最佳实践，我指的是清晰和可维护的代码。将复杂的HTML写成字符串是不可维护的。
- en: Vue allows declaring templates inside an HTML file within a special `<template>`
    tag!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Vue允许在特殊的`<template>`标签内声明模板！
- en: 'So, to rewrite our example, we will declare an HTML tag template with the corresponding
    markup inside:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了重写我们的示例，我们将声明一个带有相应标记的HTML标签模板：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And then, inside our component, instead of the HTML string, we will just use
    the ID of the template:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的组件内部，我们将只使用模板的ID，而不是HTML字符串：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our whole code will look like the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的整个代码将如下所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we had only used the `template` attribute for the
    component. Let's move on and see how the `data` and `el` attributes should be
    treated inside a component.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只使用了组件的`template`属性。让我们继续看看`data`和`el`属性在组件内部应该如何处理。
- en: Handling data and el properties inside a component
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理组件内的数据和el属性
- en: 'As already mentioned, the component''s syntax is the same as the Vue instance''s
    syntax, but it must extend the Vue instead of calling it directly. With this premise,
    it seems correct to create a component like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，组件的语法与Vue实例的语法相同，但必须扩展Vue而不是直接调用它。基于这一前提，创建一个组件似乎是正确的：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But this would lead to a scope leak. Every instance of `HelloComponent` would
    share the same `data` and `el`. And this is not exactly what we want. That is
    why Vue explicitly demands to declare these properties as functions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但这会导致作用域泄漏。每个`HelloComponent`实例将共享相同的`data`和`el`。这并不是我们想要的。这就是为什么Vue明确要求将这些属性声明为函数的原因：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Even if you make a mistake and declare the `data` or the `el` properties as
    an object or an element, Vue will kindly warn you:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您犯了错误，并将`data`或`el`属性声明为对象或元素，Vue也会友好地警告您：
- en: '![Handling data and el properties inside a component](../Images/image00260.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![处理组件内的数据和el属性](../Images/image00260.jpeg)'
- en: Vue's warning when using data as an object instead of a function inside of a
    Vue component
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue组件内将数据作为对象而不是函数使用时，Vue会友好地警告
- en: Scope of the components
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件的作用域
- en: As already mentioned, all components have their own scope that is inaccessible
    by other components. Nevertheless, the global application scope is accessible
    by all the registered components. You can see the components' scope as local and
    the application scope as global scopes. It's the same. However, using the parent's
    data inside a component is not straightforward. You have to explicitly indicate
    inside a component which parent's data properties should be accessed using the
    `prop` attribute and bind them to the component instance using the `v-bind` syntax.
    Let's see how it works on our `HelloComponent` example.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有组件都有自己的作用域，其他组件无法访问。然而，全局应用程序作用域可被所有注册的组件访问。您可以将组件的作用域视为局部作用域，将应用程序作用域视为全局作用域。它是一样的。然而，在组件内部使用父级的数据并不直观。您必须在组件内明确指示应该使用`prop`属性访问哪些父级数据属性，并使用`v-bind`语法将它们绑定到组件实例。让我们看看它在我们的`HelloComponent`示例中是如何工作的。
- en: 'Let''s start by declaring `HelloComponent` with data that contains the attribute
    `msg`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从声明包含属性`msg`的数据的`HelloComponent`开始：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s create a `Vue` instance with some data inside it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个带有一些数据的`Vue`实例：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside our HTML, let''s create a template and apply it to the component using
    the template''s ID:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML中，让我们创建一个模板并将其应用到具有模板ID的组件上：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to see the component on the page, we should invoke it inside the HTML
    of our `app` container:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在页面上看到组件，我们应该在`app`容器的HTML中调用它：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you open the page in the browser, you will only see **`Hello`**; the `user`
    data property is still not bound to the component:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开页面，您只会看到**`Hello`**；`user`数据属性仍然没有绑定到组件：
- en: '![Scope of the components](../Images/image00261.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![组件的作用域](../Images/image00261.jpeg)'
- en: The parent's data property is not yet bound to our Vue component
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 父级的数据属性尚未绑定到我们的Vue组件
- en: 'In order to bind the data from the parent Vue application, we have to do the
    following two things:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据绑定到父Vue应用程序，我们必须做以下两件事：
- en: Indicate this property inside of the `prop` attribute of a component
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件的`prop`属性中指示此属性
- en: 'Bind it to the `hello-component` invocation:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其绑定到`hello-component`调用：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Refresh the page and you will see how it now presents you with a greeting:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面，您将看到它现在向您呈现问候语：
- en: '![Scope of the components](../Images/image00262.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![组件的范围](../Images/image00262.jpeg)'
- en: After the correct binding of the parent's `data` property to the component,
    everything works as expected.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确绑定父级的`data`属性到组件之后，一切都按预期运行。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Actually, the `v-bind:user` syntax can be shortcut just by using the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`v-bind:user`语法可以通过以下方式进行快捷操作：
- en: '`:user<hello-component **:user="user"**></hello-component>`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`:user<hello-component **:user="user"**></hello-component>`'
- en: Components inside other components
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件内部的组件
- en: 'The beauty of the components is that they can be used and reused inside other
    components as Lego bricks and blocks! Let''s build another component; let''s call
    it **greetings,** which will be composed of two sub-components: the form asking
    for the user''s name and our `hello` component.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的美妙之处在于它们可以像乐高积木和积木一样在其他组件内部被使用和重复使用！让我们构建另一个组件；让我们称之为**greetings**，它将由两个子组件组成：一个要求用户姓名的表单和我们的`hello`组件。
- en: 'In order to do this, let''s declare the template for the form and our already
    familiar `hello` template:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们声明表单的模板和我们已经熟悉的`hello`模板：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we will register two Vue components based on these templates:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将基于这些模板注册两个Vue组件：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we will create our greetings template that will use both `form` and
    `hello` components. Do not forget that we have to bind the `user` property on
    the components invocation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建我们的greetings模板，它将使用`form`和`hello`组件。不要忘记我们必须在组件调用时绑定`user`属性：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, we can create our greetings component and use the greetings
    template inside it. Let''s initialize, which `data` function with the name of
    the user in this component:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以创建我们的greetings组件，并在其中使用greetings模板。让我们初始化，使用此组件中用户的`data`函数：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside our main application container, we will now invoke the greetings component:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主应用程序容器内，我们现在将调用greetings组件：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Do not forget to initialize the Vue application:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记初始化Vue应用程序：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the page in the browser. You should see something like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开页面。您应该看到类似以下的内容：
- en: '![Components inside other components](../Images/image00263.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![组件内部的组件](../Images/image00263.jpeg)'
- en: The page built from various Vue components
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由各种Vue组件构建的页面
- en: Try to change the name in the input. You are expecting it to change also in
    the greetings header because we bound it to it. But strangely, it doesn't change.
    Well, this is actually the normal behavior. By default, all props follow one-way
    data binding. This means that if the data changes within the parent's scope, these
    changes are propagated to the child component, but not vice versa. It is done
    this way in order to prevent children components from accidentally mutating the
    parent state. It is, however, possible to force children components to communicate
    with their parents by invoking events. Check the Vue documentation at [https://vuejs.org/guide/components.html#Custom-Events](https://vuejs.org/guide/components.html#Custom-Events)
    .
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在输入框中更改名称。您期望它在问候标题中也发生变化，因为我们将其绑定到了它。但奇怪的是，它并没有改变。嗯，这实际上是正常的行为。默认情况下，所有属性都遵循单向数据绑定。这意味着如果在父级范围内更改数据，这些更改会传播到子组件，但反之则不会。这样做是为了防止子组件意外地改变父状态。但是，可以通过调用事件来强制子组件与其父组件通信。请查看Vue文档[https://vuejs.org/guide/components.html#Custom-Events](https://vuejs.org/guide/components.html#Custom-Events)。
- en: In our case, we can bind a user model to our form `input` component and emit
    the `input` event every time the user types in the input box. We achieve it by
    using the `v-on:input` modifier, just like it is described in this section at
    [https://vuejs.org/guide/components.html#Form-Input-Components-using-Custom-Events](https://vuejs.org/guide/components.html#Form-Input-Components-using-Custom-Events)
    .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们可以将用户模型绑定到我们的表单`input`组件，并在用户在输入框中输入时发出`input`事件。我们通过使用`v-on:input`修饰符来实现这一点，就像在[https://vuejs.org/guide/components.html#Form-Input-Components-using-Custom-Events](https://vuejs.org/guide/components.html#Form-Input-Components-using-Custom-Events)中描述的那样。
- en: 'Thus, we have to pass `v-model:user` to `form-component`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须将`v-model:user`传递给`form-component`：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, `form-component` should accept the `value` prop and emit the `input`
    event:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`form-component`应该接受`value`属性并发出`input`事件：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The input box inside the `form-component` template should bind the `v-on:input` and
    the `onInput` method to the `v-on:input` modifier:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`form-component`模板中的输入框应将`v-on:input`和`onInput`方法绑定到`v-on:input`修饰符：'
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Actually, prior to Vue 2.0, this kind of two-way synchronization between components
    and their parents was possible by explicitly telling the property being bound
    to **sync** using the `.sync` modifier: `<form-component :user.sync="user"></form-component>`
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在Vue 2.0之前，可以通过显式告知使用`.sync`修饰符绑定的属性来实现组件与其父级之间的双向同步：`<form-component :user.sync="user"></form-component>`
- en: 'Refresh the page. Now you can change the name inside the input and it is immediately
    propagated to the parent''s scope, and thus to other children components that
    rely on this property:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面。现在您可以更改输入框中的名称，并立即传播到父级范围，从而传播到依赖该属性的其他子组件：
- en: '![Components inside other components](../Images/image00264.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![组件内部的其他组件](../Images/image00264.jpeg)'
- en: Binding properties with the .sync modifier allows two-way data binding between
    parent and children components
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.sync`修饰符绑定属性允许父级和子级组件之间的双向数据绑定
- en: You can find the complete code for this example in the JSFiddle at [https://jsfiddle.net/chudaol/1mzzo8yn/](https://jsfiddle.net/chudaol/1mzzo8yn/)
    .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在JSFiddle中找到此示例的完整代码[https://jsfiddle.net/chudaol/1mzzo8yn/](https://jsfiddle.net/chudaol/1mzzo8yn/)。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Before the Vue 2.0 release, there was one more data-binding modifier, `.once`.
    With this modifier, the data would be bound only once, and any other changes would
    not affect the state of components. Compare the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 2.0发布之前，还有一个数据绑定修饰符`.once`。使用此修饰符，数据将仅绑定一次，任何其他更改都不会影响组件的状态。比较以下内容：
- en: '`<form-component **:user="user"**></form-component>`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`<form-component **:user="user"**></form-component>`'
- en: '`<form-component **:user.sync="user"**></form-component>`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`<form-component **:user.sync="user"**></form-component>`'
- en: '`<form-component **:user.once="user"**></form-component>`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`<form-component **:user.once="user"**></form-component>`'
- en: Rewriting the shopping list with simple components
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用简单组件重写购物清单
- en: Now that we already know a lot about components, let's rewrite our shopping
    list application using them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对组件有了很多了解，让我们使用它们来重写我们的购物清单应用程序。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'For the rewriting of the application, we will use this version of the shopping
    list application as a base: [https://jsfiddle.net/chudaol/vxfkxjzk/3/](https://jsfiddle.net/chudaol/vxfkxjzk/3/)
    .'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写应用程序时，我们将使用这个版本的购物清单应用程序作为基础：[https://jsfiddle.net/chudaol/vxfkxjzk/3/](https://jsfiddle.net/chudaol/vxfkxjzk/3/)。
- en: 'We have already done it previously, when we started talking about components.
    But at that time, we used string templates inside the components'' options. Let''s
    do it now using templates as we have just learned to do. Let''s just have a look
    at the interface and identify the components again:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经做过了，当我们开始讨论组件时。但那时，我们在组件选项中使用了字符串模板。现在让我们使用刚学会的模板来做。让我们再看一下界面，并再次识别组件：
- en: '![Rewriting the shopping list with simple components](../Images/image00265.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用简单组件重写购物清单](../Images/image00265.jpeg)'
- en: Our shopping list application will have four components
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的购物清单应用程序将有四个组件
- en: 'Thus, I suggest that our shopping list application consists of the following
    four components:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我建议我们的购物清单应用程序由以下四个组件组成：
- en: '`AddItemComponent`: The component responsible for adding a new item to the
    shopping list'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddItemComponent`：负责向购物清单添加新项目的组件'
- en: '`ItemComponent`: The component responsible for the rendering of the new item
    in the shopping list'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemComponent`：负责在购物清单中呈现新项目的组件'
- en: '`ItemsComponent`: The component responsible for rendering and managing the
    list of `ItemComponent`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemsComponent`：负责渲染和管理`ItemComponent`列表的组件'
- en: '`ChangeTitleComponent`: The component responsible for changing the title of
    the list'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChangeTitleComponent`：负责更改列表标题的组件'
- en: Defining templates for all the components
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为所有组件定义模板
- en: Let's create templates for these components assuming that the components themselves
    are already defined and registered.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这些组件已经定义并注册，让我们为这些组件创建模板。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**`CamelCase VS kebab-case`** You have probably noticed that while we declare
    variables describing components in CamelCase (`var HelloComponent=Vue.extend({...})`),
    we name them in kebab-case: `Vue.component(''hello-component'', {...})`. We do
    this because of the case-insensitive HTML attribute nature. Thus, our components
    for the shopping list application will be called as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**`驼峰命名法 VS 短横线命名法`** 您可能已经注意到，当我们声明描述组件的变量时使用驼峰命名法（`var HelloComponent=Vue.extend({...})`），但我们在短横线命名法中命名它们：`Vue.component(''hello-component'',
    {...})`。我们这样做是因为HTML属性不区分大小写的特性。因此，我们购物清单应用程序的组件将被称为：'
- en: '`add-item-component`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`add-item-component`'
- en: '`item-component`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`item-component`'
- en: '`items-component`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`items-component`'
- en: '`change-title-component`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`change-title-component`'
- en: Have a look at how our markup was previously ( [https://jsfiddle.net/chudaol/vxfkxjzk/3/](https://jsfiddle.net/chudaol/vxfkxjzk/3/)
    ).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我们之前的标记是怎样的（[https://jsfiddle.net/chudaol/vxfkxjzk/3/](https://jsfiddle.net/chudaol/vxfkxjzk/3/)）。
- en: 'Let''s rewrite it using templates and components'' names. In this part, we
    will just worry about the presentation layer, leaving the data binding and actions
    handling for a future implementation. We just copy and paste the HTML part of
    the application and distribute it over our components. Our four templates will
    look something like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用模板和组件名称重写它。在这部分，我们只关心呈现层，将数据绑定和操作处理留给将来实现。我们只需复制粘贴应用程序的HTML部分，并将其分发到我们的组件上。我们的四个模板将看起来像下面这样：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Thus, our main components'' markup will consist of some components:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的主要组件标记将由一些组件组成：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the majority of each template is a plain copy and paste of the
    corresponding HTML code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个模板的大部分内容都是对应HTML代码的简单复制粘贴。
- en: However, there are some significant differences. The list item template, for
    example, is slightly changed. You have already learned and used the `v-for` directive
    previously. In the previous examples, we used this directive with HTML elements
    such as `<li>`. Now you see that it can also be used with Vue custom components.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些显著的不同之处。例如，列表项模板略有改变。您已经学习并在以前使用了`v-for`指令。在以前的示例中，我们将此指令与`<li>`等HTML元素一起使用。现在您可以看到它也可以与Vue自定义组件一起使用。
- en: You might have also noticed a small difference in the change title template.
    Now it has a value bound to it and emits the `onInput` method bound to the `v-on:input`
    modifier. As you have learned in the previous section, children components cannot
    directly affect directly a parent's data, which is why we have to use the events
    system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到更改标题模板中的一个小差异。现在它有一个绑定的值，并发出`onInput`方法绑定到`v-on:input`修饰符。正如您在上一节中学到的，子组件不能直接影响父组件的数据，这就是为什么我们必须使用事件系统的原因。
- en: Defining and registering all the components
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和注册所有组件
- en: 'Have a look at the JavaScript code in our previous shopping list application:
    [https://jsfiddle.net/chudaol/c8LjyenL/](https://jsfiddle.net/chudaol/c8LjyenL/)
    . Let''s add the code that creates Vue components. We will use the IDs of already
    defined templates for their `template` attribute. Also, do not forget about the
    `props` attribute to pass the properties from the parent application. Thus, we
    add the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我们以前的购物清单应用程序中的JavaScript代码：[https://jsfiddle.net/chudaol/c8LjyenL/](https://jsfiddle.net/chudaol/c8LjyenL/)。让我们添加创建Vue组件的代码。我们将使用已定义模板的ID作为它们的`template`属性。还要不要忘记`props`属性，以从父应用程序传递属性。因此，我们添加以下代码：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, in `props` of each component, we have passed different data
    attributes—only those that specifically concern the component. We have also moved
    the `newItem` attribute to the `data` attribute of `add-item-component`. In `change-title-component`,
    we have added the `onInput` method that emits the input event, so the title in
    the parent component is affected by whatever the user types in the input box.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在每个组件的`props`中，我们传递了不同的数据属性，只涉及到该组件的属性。我们还将`newItem`属性移动到`add-item-component`的`data`属性中。在`change-title-component`中，我们添加了`onInput`方法，该方法发出输入事件，因此父组件中的标题受到用户在输入框中输入的任何内容的影响。
- en: Open the HTML file in the browser. The interface is exactly the same as it was
    earlier! The complete code of what we have done in this section can be found in
    the JSFiddle at [https://jsfiddle.net/chudaol/xkhum2ck/1/](https://jsfiddle.net/chudaol/xkhum2ck/1/)
    .
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开HTML文件。界面与之前完全相同！我们在本节中所做的所有代码可以在JSFiddle中找到：[https://jsfiddle.net/chudaol/xkhum2ck/1/](https://jsfiddle.net/chudaol/xkhum2ck/1/)。
- en: Exercise
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Although our application looks exactly as it was looking earlier, its functionality
    was lost. Not only does it not add items, but it also shows the ugly error in
    the devtools console.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的应用程序看起来与之前一样，但其功能已经丢失。它不仅不添加项目，而且还在devtools控制台中显示了丑陋的错误。
- en: Please use the events emitting system to bring the adding items functionality
    back.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用事件发射系统将添加项目的功能带回来。
- en: A possible solution for this exercise can be found in the Appendix, *Solutions
    to Exercises.*
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的一个可能解决方案可以在附录*练习解决方案*中找到。
- en: Single-file components
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单文件组件
- en: We know from the old best practices that it is always good to separate HTML
    from CSS and JavaScript files. Some modern frameworks such as React are relaxing
    and gradually wiping out this rule. Nowadays, you will not be shocked by looking
    at the small file or the component that contains its own markup, style, and application
    code inside it. Actually, for small components, we even find it more convenient
    to have such architecture. Vue also allows defining everything related to the
    same component in the same file. This kind of component is known as a single-file
    component.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从旧的最佳实践中，我们知道将HTML与CSS和JavaScript文件分开总是一个好主意。一些现代框架如React正在放松并逐渐取消这一规则。如今，看到包含自己标记、样式和应用代码的小文件或组件并不会让你感到震惊。实际上，对于小组件来说，我们甚至发现这样的架构更加方便。Vue也允许在同一个文件中定义与同一组件相关的所有内容。这种组件被称为单文件组件。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意：
- en: A single-file Vue component is a file with a `.vue` extension. The application
    that contains such components can be built using the `webpack vue` configuration.
    To scaffold an app with such a configuration, the easiest way is to use `vue-cli`
    ( [https://github.com/vuejs-templates/webpack](https://github.com/vuejs-templates/webpack)).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单文件Vue组件是一个扩展名为`.vue`的文件。包含这些组件的应用程序可以使用`webpack vue`配置构建。使用这种配置搭建应用程序的最简单方法是使用`vue-cli`（[https://github.com/vuejs-templates/webpack](https://github.com/vuejs-templates/webpack)）。
- en: 'A Vue component can have up to three sections in it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Vue组件可以包含最多三个部分：
- en: '`<script>`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<script>`'
- en: '`<template>`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<template>`'
- en: '`<style>`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<style>`'
- en: Each of these sections is responsible for exactly what you are thinking. Put
    into the `<template>` tag whatever the HTML template should be responsible for,
    put into the `<script>` tag the JavaScript code responsible for the Vue component,
    methods, data, props, and so on. The `<style>` tag shall contain the CSS style
    for the given component.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分中的每一个都负责你所想的确切内容。在`<template>`标签中放入HTML模板应该负责的内容，在`<script>`标签中放入Vue组件的JavaScript代码、方法、数据、props等。`<style>`标签应该包含给定组件的CSS样式。
- en: Do you remember our `hello-component`? Have a look at it in the JSFiddle at
    [https://jsfiddle.net/chudaol/mf82ts9a/2/](https://jsfiddle.net/chudaol/mf82ts9a/2/)
    .
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们的`hello-component`吗？在[https://jsfiddle.net/chudaol/mf82ts9a/2/](https://jsfiddle.net/chudaol/mf82ts9a/2/)的JSFiddle中看一下它。
- en: 'Start by scaffolding the app using the `webpack-simple` configuration with
    `vue-cli`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用`vue-cli`使用`webpack-simple`配置搭建应用程序：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To rewrite it as a Vue component, we create our `HelloComponent.vue` file and
    add the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其重写为Vue组件，我们创建我们的`HelloComponent.vue`文件并添加以下代码：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that we do not need to specify the template in our JavaScript component
    definition. Being a single-file component, it is implicit that the template that
    should be used is the one defined in this file. You might also have noticed that
    we use ES6 style in here. Also, do not forget that the `data` attribute should
    be a function and not an object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要在JavaScript组件定义中指定模板。作为单文件组件，隐含的是应该使用的模板是在此文件中定义的模板。您可能也注意到我们在这里使用了ES6风格。另外，不要忘记`data`属性应该是一个函数而不是一个对象。
- en: 'In our main script, we have to create the Vue app and instruct it to use `HelloComponent`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主脚本中，我们必须创建Vue应用程序并指示它使用`HelloComponent`：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our `index.html` markup will not change. It will still invoke `hello-component`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`index.html`标记不会改变。它仍然会调用`hello-component`：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we just need to install `npm` dependencies (if you still haven''t done
    so) and build the application:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要安装`npm`依赖项（如果你还没有这样做）并构建应用程序：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once you do it, your browser will automatically open the `localhost:8080` page!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做了，你的浏览器将自动打开`localhost:8080`页面！
- en: Check the complete code in the [chapter3/hello](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter3/hello)
    folder.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在[chapter3/hello](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter3/hello)文件夹中查看完整的代码。
- en: You can also test, modify, retest, and check the `hello` component in the webpackbin
    at [http://www.webpackbin.com/N1LbBIsLb](http://www.webpackbin.com/N1LbBIsLb)
    .
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[http://www.webpackbin.com/N1LbBIsLb](http://www.webpackbin.com/N1LbBIsLb)的webpackbin中测试、修改、重新测试和检查`hello`组件。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Webpackbin is a nice service to run and test applications built with Webpack.
    It is a very nice tool even though it's still in beta. As it's still young, it
    still has some minor issues. For instance, if you try to download the package
    of the entire project, it will not build.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Webpackbin是一个很好的服务，可以运行和测试使用Webpack构建的应用程序。尽管它仍处于测试阶段，但它是一个非常好的工具。由于它还很年轻，所以仍然存在一些小问题。例如，如果您尝试下载整个项目的软件包，它将无法构建。
- en: Plugins for IDEs
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDE的插件
- en: 'Vue creators and contributors thought about developers and developed plugins
    for a large set of modern IDEs. You can find them at [https://github.com/vuejs/awesome-vue#syntax-highlighting](https://github.com/vuejs/awesome-vue#syntax-highlighting)
    . If you are like me and use WebStorm IDE by IntelliJ, follow these instructions
    to install the Vue support plugin:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的创建者和贡献者考虑到了开发人员，并为一系列现代IDE开发了插件。您可以在[https://github.com/vuejs/awesome-vue#syntax-highlighting](https://github.com/vuejs/awesome-vue#syntax-highlighting)找到它们。如果您像我一样使用的是IntelliJ的WebStorm
    IDE，请按照以下说明安装Vue支持插件：
- en: Go to **`Preferences`** | **`P`****`lugins`**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**`Preferences`** | **`P`****`lugins`**。
- en: Click on **`Browse repositories`**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**`浏览存储库`**。
- en: Type `vue` in the search box.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`vue`。
- en: 'Select **`Vue.js`** and click on the **`Install`** button:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**`Vue.js`**，然后点击**`Install`**按钮：
- en: '![Plugins for IDEs](../Images/image00266.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![IDE的插件](../Images/image00266.jpeg)'
- en: Installing the Vue plugin for webstorm IDE
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 安装WebStorm IDE的Vue插件
- en: Style and scope
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式和范围
- en: 'It is pretty obvious that the template and the script of the component belong
    only to it. However, the same does not apply to style. Try, for example, to add
    a `style` tag to our `hello` component and add the CSS rule for the `<h1>` tag
    to have the red color:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，模板和组件的脚本只属于它。然而，样式并不适用于相同的规则。例如，尝试向我们的`hello`组件添加`style`标签，并添加CSS规则，使`<h1>`标签变成红色：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, when the page is refreshed, it is quite expected that the color of the
    **`Hello!`** header changes to red. Now try to add the `<h1>` tag to the main
    `index.html` file. You might be surprised, but it will also be red:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当页面刷新时，可以预期`Hello!`标题的颜色会变成红色。现在尝试将`<h1>`标签添加到主`index.html`文件中。你可能会感到惊讶，但它也会是红色的：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Style and scope](../Images/image00267.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![样式和范围](../Images/image00267.jpeg)'
- en: All the <h1> tags have the style that we defined inside a component
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`<h1>`标签都具有我们在组件内定义的样式
- en: 'To make the style be attached only to the scope of the component, we need to
    indicate the attribute `scoped` to the `<style>` tag:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使样式只附加到组件的范围内，我们需要在`<style>`标签中指定`scoped`属性：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Look at the page and you'll see that only the **`Hello!`** text is red, the
    other `h1` has its default style.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 看看页面，你会发现只有`Hello!`文本是红色的，其他的`h1`都是默认样式。
- en: Hot-reloading
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热重载
- en: You might have noticed that now I no longer ask you to refresh the page but
    to look at the page. This is because the page is automatically refreshed on each
    change when the application is bootstrapped using `vue-cli` Webpack scaffolding
    approach. The magic happens thanks to the `vue-hot-reload` API that watches the
    application's files and tells the browser to automatically reload every time something
    has changed! Yay!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，现在我不再要求您刷新页面，而是要求您查看页面。这是因为在使用`vue-cli`Webpack脚手架方法引导应用程序时，每次更改时页面都会自动刷新。这个魔法是由`vue-hot-reload`
    API实现的，它监视应用程序的文件，并告诉浏览器在每次有变化时自动重新加载！耶！
- en: Preprocessors
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理器
- en: If you are into preprocessors, you are more than welcome to use them in your
    `.vue` components. This is possible due to `vue-loader` that allows using Webpack
    loaders.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢预处理器，欢迎在您的`.vue`组件中使用它们。这是由于`vue-loader`允许使用Webpack加载程序。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more about `vue-loaders` and preprocessors in the tutorial at [http://vue-loader.vuejs.org/en/](http://vue-loader.vuejs.org/en/)
    .
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在教程中找到有关`vue-loader`和预处理器的更多信息[http://vue-loader.vuejs.org/en/](http://vue-loader.vuejs.org/en/)。
- en: HTML preprocessors
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML预处理器
- en: 'In order to be able to use a preprocessor in a single-file Vue components,
    just add the `lang` attribute to the `<template>` tag! Do not forget to install
    the corresponding node module:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在单文件Vue组件中使用预处理器，只需在`<template>`标签中添加`lang`属性！不要忘记安装相应的节点模块：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using `jade`, for example, in our `hello` component''s template, would be as
    easy as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的`hello`组件模板中使用`jade`将会非常简单：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: CSS preprocessors
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS预处理器
- en: 'The same logic applies to the CSS preprocessors. Let''s see how to use, for
    example, a sass preprocessor:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的逻辑也适用于CSS预处理器。让我们看看如何使用，例如，sass预处理器：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Like in the previous example, do not forget to install the corresponding loader
    for this to work: `npm install sass-loader node-sass --save-dev`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在前面的例子中一样，不要忘记安装相应的加载程序才能使其工作：`npm install sass-loader node-sass --save-dev`
- en: JavaScript preprocessors
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript预处理器
- en: It is also possible to use any JavaScript preprocessors. Like in the two previous
    examples, just use the `lang` attribute to specify the preprocessor to use. And
    do not forget to install it via `npm`!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用任何JavaScript预处理器。就像在前面的两个例子中一样，只需使用`lang`属性指定要使用的预处理器。并且不要忘记通过`npm`安装它！
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Rewriting our shopping list application with single-file components
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单文件组件重写我们的购物清单应用程序
- en: 'Now that we already know so much about components and how to use them, and
    also know nice techniques to make our code easier to write, let''s get back to
    our shopping list and rewrite it as single-file component''s Vue application.
    To have an easy setup, we can use `vue-cli` with Webpack configuration. Actually,
    we''ve already done it in [Chapter 2](part0027.xhtml#aid-PNV61 "Chapter 2. Fundamentals
    – Installing and Using"), *Fundamentals - Installing and Using*. So, just find
    this application and be prepared to start working on it. If you cannot find it,
    you can easily create it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了组件以及如何使用它们，还知道了使我们的代码更容易编写的好技巧，让我们回到我们的购物清单，并将其重写为单文件组件的Vue应用程序。为了简单设置，我们可以使用带有Webpack配置的`vue-cli`。实际上，我们已经在[第2章](part0027.xhtml#aid-PNV61
    "第2章。基础知识-安装和使用")*基础知识-安装和使用*中完成了。所以，只需找到这个应用程序，并准备开始工作。如果找不到，您可以轻松创建它：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Ensure that your `index.html` file looks like the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的`index.html`文件看起来像下面这样：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And your `main.js` file should look like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`main.js`文件应该看起来像下面这样：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We are now ready to create our components and to populate our application with
    them. Of course, you remember that our shopping list has essentially four components:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备创建我们的组件并用它们填充我们的应用程序。当然，您记得我们的购物清单基本上有四个组件：
- en: '`AddItemComponent`: The component responsible for adding a new item to the
    shopping list'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddItemComponent`：负责向购物清单添加新项目的组件'
- en: '`ItemComponent`: The component responsible for the rendering of the new item
    in the shopping list items list'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemComponent`：负责在购物清单项目列表中呈现新项目的组件'
- en: '`ItemsComponent`: The component responsible for the rendering and managing
    the list of `ItemComponent`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemsComponent`：负责渲染和管理`ItemComponent`列表的组件'
- en: '`ChangeTitleComponent`: The component responsible for changing the title of
    the list'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChangeTitleComponent：负责更改列表标题的组件
- en: 'Let''s create all of them in the `components` folder. To start with, just include
    three empty sections `(<template>`, `<script>`, and `<style>`) in each of them
    and invoke them in the correct places within the main `App.vue` component. Please
    put something into the template that will allow us to visibly identify the different
    components on the page. So, the code of all our four components will look like
    the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`components`文件夹中创建它们。首先，只需在每个组件中包含三个空的部分`(<template>`、`<script>`和`<style>`)，并在主`App.vue`组件中的正确位置调用它们。请在模板中放入一些内容，以便我们可以在页面上清楚地识别不同的组件。因此，我们所有四个组件的代码将如下所示：
- en: '![Rewriting our shopping list application with single-file components](../Images/image00268.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![使用单文件组件重写我们的购物清单应用程序](../Images/image00268.jpeg)'
- en: The code for all four components of the shopping list application
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 购物清单应用程序的所有四个组件的代码
- en: Now open the `App.vue` component. This is our main component that will assemble
    all the components together.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`App.vue`组件。这是我们的主要组件，将所有组件组装在一起。
- en: Remove everything from the `<template>`, `<script>`, and `<style>` tags. We
    will now start to build our application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从`<template>`、`<script>`和`<style>`标签中删除所有内容。我们现在将开始构建我们的应用程序。
- en: First of all, we must import the components that will be used by `App.vue` (in
    this case, all of them).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须导入`App.vue`将使用的组件（在本例中，全部）。
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not forget that, as we are using ES2015 in this application, we can use import/export
    and all the other beautiful ES2015 things.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，由于我们在这个应用程序中使用了ES2015，我们可以使用import/export和所有其他美丽的ES2015功能。
- en: 'Inside the `<script>` tag, let''s import the components and export the object
    that will contain the imported components and data function that returns the shopping
    list''s items:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<script>`标签内，让我们导入组件并导出包含导入组件和返回购物清单项目的数据函数的对象：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Our template can basically be the same as the template that we have built in
    the shopping list application using simple components. Let's just remove everything
    concerning the models and data binding for now. First, insert the component responsible
    for adding items, then the component containing all the items, and then, in the
    footer, the component responsible for changing the title.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板基本上可以与使用简单组件构建的购物清单应用程序中的模板相同。让我们暂时删除有关模型和数据绑定的所有内容。首先，插入负责添加项目的组件，然后是包含所有项目的组件，然后在页脚中，负责更改标题的组件。
- en: 'Our template will then look like the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的模板将如下所示：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You still remember that the names of the components'' variables are CamelCased,
    and when they are used inside the template, they should be invoked using kebab-case,
    right? Good, let''s see how it looks in the browser:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得组件变量的名称是驼峰式的，当它们在模板内部使用时，应该使用kebab-case进行调用，对吧？好的，让我们看看它在浏览器中的样子：
- en: '![Rewriting our shopping list application with single-file components](../Images/image00269.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![使用单文件组件重写我们的购物清单应用程序](../Images/image00269.jpeg)'
- en: Shopping list application built of single-file components
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单文件组件构建的购物清单应用程序
- en: Doesn't seem that beautiful, right? Let's fill each of the components with their
    templates.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不太美观，对吧？让我们为每个组件填充它们的模板。
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'We will continue using Bootstrap''s CSS style for this application. Include
    it globally in the `index.html` file: `<link rel="stylesheet" href=" https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在这个应用程序中使用Bootstrap的CSS样式。在`index.html`文件中全局包含它：`<link rel="stylesheet"
    href=" https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">`
- en: AddItemComponent
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加ItemComponent
- en: 'Open `AddItemComponent.vue`. Let''s fill its `<template>`. It will look like
    the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`AddItemComponent.vue`。让我们填充它的`<template>`。它将如下所示：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you look at the page in your browser, you can already see that it changed
    and became more recognizable as our shopping list application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中查看页面，你会发现它已经改变，变得更加像我们的购物清单应用程序。
- en: Configuring ItemComponent and ItemsComponent
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置ItemComponent和ItemsComponent
- en: 'Let''s now move to the `ItemComponent`. We will just copy and paste the HTML
    from the simple component example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到`ItemComponent`。我们只需复制并粘贴简单组件示例中的HTML：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s also add some `scoped` style for this component. This component''s specific
    style is the style that has to do with the `<li>`, `<span>`, and class `.removed`.
    Let''s copy and paste them into this component:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还为这个组件添加一些`scoped`样式。这个组件的特定样式是与`<li>`、`<span>`和类`.removed`有关的样式。让我们将它们复制并粘贴到这个组件中：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now open `ItemsComponents`. As you remember, it is a list of the `ItemComponent`
    elements. Even if you do not remember, I guess that the plural characteristics
    of the name of this component suggests this. In order for it to be able to use
    the `ItemComponent`, it must import it and register in the `components` property.
    So, let''s modify the script first:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`ItemsComponents`。你记得，它是`ItemComponent`元素的列表。即使你不记得，我猜这个组件名称的复数特征就表明了这一点。为了能够使用`ItemComponent`，它必须导入并在`components`属性中注册。所以，让我们先修改脚本：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now you can use `item-component` in `<template>`! Do you still remember how
    to iterate with `vue.js`? Of course you do! That is why you are opening the `<template>`
    tag right now and writing the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在`<template>`中使用`item-component`了！你还记得如何在`vue.js`中进行迭代吗？当然记得！这就是为什么你现在打开`<template>`标签并编写以下代码：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you check the page now, you'll be surprised to see that things actually do
    not work. The web console is full of errors. Can you figure out why?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在检查页面，你会惊讶地发现事情实际上并没有工作。网页控制台充满了错误。你能想出原因吗？
- en: Do you remember that when children components want to have access to the parent's
    data, they must declare "props" on the component initialization? This is exactly
    what we've forgotten about on the declaration of both `ItemsComponent` and `ItemComponent`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得当子组件想要访问父组件的数据时，它们必须在组件初始化时声明“props”吗？这正是我们在`ItemsComponent`和`ItemComponent`的声明中忘记的事情。
- en: 'First of all, within `App.vue`, bind items to the `items-component` invocation:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`App.vue`中，将items绑定到`items-component`调用：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then add the `props` attribute to `ItemsComponent`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`props`属性添加到`ItemsComponent`中：
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now go back to `ItemComponent` and add the `props` property:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`ItemComponent`并添加`props`属性：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Check the page now. Now it indeed contains the list of items and has a look
    and feel almost the same as it had when we first created it. Check the full code
    for this section in the [chapter3/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter3/shopping-list)
    folder.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查页面。现在它确实包含了物品列表，并且在我们第一次创建它时几乎具有相同的外观和感觉。在[chapter3/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter3/shopping-list)文件夹中检查此部分的完整代码。
- en: Exercise
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Finish the shopping list application so that it has the same functionality as
    before.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 完成购物清单应用程序，使其具有与以前相同的功能。
- en: There's not so much left and I'm sure you will be done with it in less than
    half an hour. The possible solution to this exercise can be found in the [Appendix](part0083.xhtml#aid-2F4UM1
    "Chapter 10. Solutions to Exercises"), *Solutions to Exercises.*
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的不多了，我相信你会在不到半个小时内完成它。这个练习的可能解决方案可以在[附录](part0083.xhtml#aid-2F4UM1 "Chapter 10. Solutions
    to Exercises")中找到，*练习的解决方案*。
- en: Rewriting the Pomodoro application with single-file components
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单文件组件重写番茄钟应用程序
- en: I hope you still remember and possibly even use the Pomodoro application that
    we developed in the first chapter of this book.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你还记得并可能甚至使用了我们在本书第一章开发的番茄钟应用程序。
- en: I would like to revisit it now and to do the same exercise we did in the previous
    section—define the components of the application and rewrite it using these components.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在想重新审视它，并做与上一节相同的练习——定义应用程序的组件并使用这些组件重写它。
- en: 'Let''s have a look at our Pomodoro application. And now I am going to spoil
    you: I''ll include a screenshot that already contains the kittens that are being
    shown during the resting time using [http://thecatapi.com/api](http://thecatapi.com/api):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的番茄钟应用程序。现在我要给你一个惊喜：我将包含一个屏幕截图，其中包含在休息时间显示的小猫，使用[http://thecatapi.com/api](http://thecatapi.com/api)：
- en: '![Rewriting the Pomodoro application with single-file components](../Images/image00270.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![使用单文件组件重写番茄钟应用程序](../Images/image00270.jpeg)'
- en: The Pomodoro application in its Rest! state
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 番茄钟应用程序处于休息状态
- en: 'There are some easily identifiable components:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些容易识别的组件：
- en: The component of the controls (start, pause, end), let's name it `**ControlsComponent**`
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制组件（开始，暂停，结束）的组件，让我们称之为`**ControlsComponent**`
- en: The component of the time countdown, `**CowntdownComponent**`
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倒计时组件，`**CowntdownComponent**`
- en: The component of the title of the current state (**`Work!`**/**`Rest!`**), `**StateTitleComponent**`
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前状态的标题组件（**`Work!`**/**`Rest!`**），`**StateTitleComponent**`
- en: The component of the kittens rendering that depends on the state (working or
    resting), `**KittensComponent**` (this is my favorite one!)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取决于状态（工作或休息）的小猫渲染组件`**KittensComponent**`（这是我最喜欢的！）
- en: 'Now, please stop staring at the kitten and let''s start implementing our Pomodoro
    application using single-file components! Some first steps to scaffold the application
    are as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请停止盯着小猫，让我们开始使用单文件组件来实现我们的番茄钟应用程序！一些用于搭建应用程序的第一步如下：
- en: Start by opening the scaffolded Pomodoro application from the previous chapter
    or create a new application based on the Webpack template.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开前一章中的脚手架式番茄钟应用程序，或者基于Webpack模板创建一个新的应用程序。
- en: Run `npm install` and `npm run dev` in the `application` folder.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`application`文件夹中运行`npm install`和`npm run dev`。
- en: 'Ensure that your `index.html` looks like the following:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的`index.html`看起来像下面这样：
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Ensure that your `main.js` file looks like the following:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的`main.js`文件看起来像下面这样：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Open your browser to the page `localhost:8080`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的浏览器到页面`localhost:8080`。
- en: Then, like in the previous example, go to the `components` folder and create
    all the necessary `.vue` components.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，就像在之前的例子中一样，转到`components`文件夹并创建所有必要的`.vue`组件。
- en: Go to `App.vue`, and import and register all the created components.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`App.vue`，并导入和注册所有创建的组件。
- en: In the `<template>` section of each of the components, put something that will
    uniquely identify it so that we can easily recognize it when checking the page.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个组件的`<template>`部分，放入一些可以唯一标识它的东西，这样我们在检查页面时可以轻松识别它。
- en: 'You will almost certainly come to the structure and the initial code, which
    looks something like the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎肯定会看到结构和初始代码，看起来像下面这样：
- en: '![Rewriting the Pomodoro application with single-file components](../Images/image00271.jpeg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: 使用单文件组件重写番茄钟应用程序
- en: The very initial state of the Pomodoro application implemented with single-file
    components
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单文件组件实现的番茄钟应用程序的最初状态
- en: Now, let's assume that our components are ready to use and let's place them
    where they belong into the application's layout, accordingly.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们的组件已经准备好使用，让我们将它们放在应用程序的布局中应该放置的位置。
- en: 'I will just slightly remind you how the whole application''s markup looked earlier:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是稍微提醒一下整个应用程序的标记之前是什么样子的：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You've probably noticed that I removed some parts that are responsible for the
    class bindings or actions handlers. Do not worry. Remember Scarlett O'Hara in *Gone
    with the Wind*? She used to say,
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我删除了一些负责类绑定或操作处理程序的部分。不要担心。还记得《飘》中的斯嘉丽·奥哈拉吗？她过去常说，
- en: '*"I can''t think about that right now. I''ll think about that tomorrow."*'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我现在不能考虑那个。我明天再想。”
- en: '( [http://goo.gl/InYm8e](http://goo.gl/InYm8e) ). Scarlett O''Hara was a wise
    woman. Be like Scarlett O''Hara. For now, we will focus merely on the `<template>`
    tag for our `App.vue`. Everything else will come later and we will think about
    it then. Now we can basically copy and paste this HTML snippet and replace the
    sections that we identify, such as the components with their kebab-case names.
    So, the template in `App.vue` will look like the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: （[http://goo.gl/InYm8e](http://goo.gl/InYm8e)）。斯嘉丽·奥哈拉是一个聪明的女人。像斯嘉丽·奥哈拉一样。目前，我们将只关注`App.vue`的`<template>`标签。其他的东西以后再说。现在我们基本上可以复制并粘贴这个HTML片段，并替换我们识别出来的部分，比如组件和它们的kebab-case名称。因此，`App.vue`中的模板将如下所示：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A bit smaller, huh? Check your browser with your app opened. Not very beautiful
    and for sure has nothing to do with our Pomodoro application, but... it works!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有点小了，对吧？打开你的应用程序的浏览器检查一下。不是很漂亮，肯定与我们的番茄钟应用程序无关，但是...它起作用！
- en: '![Rewriting the Pomodoro application with single-file components](../Images/image00272.jpeg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: 使用单文件组件重写番茄钟应用程序
- en: Pomodoro application bootstrapped as a single-file components application
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 番茄钟应用程序作为单文件组件应用程序引导
- en: What should we do now? Copy the corresponding markup to their component's `<template>`
    sections. Please do this tiny copy and paste by yourself, let it be a small home
    exercise. However, if you want to check yourself, take a look at the [chapter3/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter3/pomodoro)
    folder. That's it for now! All the data bindings and interesting stuff will come
    in the next chapter. So do not close the book. However, do not forget to take
    some Pomodoro pauses.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们该怎么办？将相应的标记复制到它们组件的`<template>`部分。请自己进行这个小小的复制粘贴，让它成为一个小小的家庭练习。但是，如果你想检查一下自己，可以看一下[chapter3/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter3/pomodoro)文件夹。目前就是这样了！所有的数据绑定和有趣的东西将在下一章中出现。所以不要关闭这本书。但是，不要忘记休息一下。
- en: Reactive binding of CSS transitions
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS过渡的响应式绑定
- en: Just before the *transition* to the next chapter, which will talk a lot about
    different types of data binding, I would like to give you just a tiny flavor of
    something interesting that is possible to bind. I know that you pay a lot of attention
    to the words, my dear reader. So, you've already found the word transition two
    times until now, and you have probably guessed that we can actually bind CSS transitions
    to the data changes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在*转到下一章之前，我们将详细讨论不同类型的数据绑定，我想给你一点有趣的味道，即可以绑定的一些有趣的东西。我知道你非常关注文字，亲爱的读者。所以，到目前为止，你已经发现了两次过渡这个词，你可能已经猜到我们实际上可以将CSS过渡绑定到数据变化上。
- en: 'So, imagine that you have an element that should only be shown if the `data`
    attribute `show` is `true`. This is easy, right? You already know the `v-if` directive:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，想象一下，如果您有一个元素，只有在`data`属性`show`为`true`时才应该显示。这很容易，对吧？您已经了解了`v-if`指令：
- en: '[PRE53]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Thus, whenever the `show` attribute is changed, this `<div>` behaves accordingly.
    Imagine that on hiding/showing, you would like to apply some CSS transition. With
    Vue you can use the special `transition` wrapper component to specify the transition
    to use on data changing:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当`show`属性发生变化时，这个`<div>`就会相应地行为。想象一下，在隐藏/显示时，您希望应用一些CSS过渡。使用Vue，您可以使用特殊的`transition`包装组件来指定数据更改时要使用的过渡：
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After that, you just have to define CSS rules for the `fade-enter`, `fade-leave`,
    `fade-enter-active`, and `fade-leave-active` classes. Check the official Vue documentation
    page regarding these classes at [https://vuejs.org/v2/guide/transitions.html#Transition-Classes](https://vuejs.org/v2/guide/transitions.html#Transition-Classes)
    .
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您只需为`fade-enter`、`fade-leave`、`fade-enter-active`和`fade-leave-active`类定义CSS规则。查看有关这些类的官方Vue文档页面[https://vuejs.org/v2/guide/transitions.html#Transition-Classes](https://vuejs.org/v2/guide/transitions.html#Transition-Classes)。
- en: 'Let''s see how it works in our `kittens` component example. Let''s start by
    adding the `v-if` directive to the `kittens-component` inside `App.vue`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在我们的`kittens`组件示例中它是如何工作的。首先，让我们在`App.vue`中的`kittens-component`中添加`v-if`指令：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Also, we should add the `data` function in the `<script>` tag of `App.vue`
    (let''s also make it global so that we can modify it from the devtools console):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们应该在`App.vue`的`<script>`标签中添加`data`函数（还要使其全局，以便我们可以从devtools控制台修改它）：
- en: '[PRE56]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Look at the browser: everything seems unchanged. Open the devtools console
    and type the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 查看浏览器：一切似乎没有改变。打开devtools控制台，输入以下内容：
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You''ll see that the `kittens` component will disappear from the page. If you
    type the following, it will appear again:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到`kittens`组件将从页面中消失。如果您输入以下内容，它将再次出现：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Tip
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I hope you haven't forgotten to include Bootstrap's CSS in the main `index.html`
    file. Without it, you'll see no appearing/disappearing at all because our `<div>` tag
    has no information nor any class applied to it:  `<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">`
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您没有忘记在主`index.html`文件中包含Bootstrap的CSS。如果没有，您将看不到任何出现/消失，因为我们的`<div>`标签既没有信息也没有应用任何类：`<link
    rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">`
- en: 'However, we are talking about the *CSS* tr*ansitions* and not about simply
    hiding/showing stuff. Now let''s apply the CSS `fade` transition to our `kittens`
    component. Just add a wrapper component `transition` with a name attribute `fade`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们正在谈论*CSS*过渡，而不是简单地隐藏/显示东西。现在让我们将CSS`fade`过渡应用到我们的`kittens`组件上。只需添加一个带有名称属性`fade`的包装组件`transition`：
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now if we define nice rules to the correct classes, we''ll see a nice CSS transition.
    Let''s do it. Add the following CSS rules inside the `<style>` tag:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们为正确的类定义良好的规则，我们将看到一个漂亮的CSS过渡。让我们来做吧。在`<style>`标签内添加以下CSS规则：
- en: '[PRE60]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Look at the page again. Open the console and type `data.kittens = false` and
    `data.kittens = true` again. Now you can see a nice `fade` transition happening
    on each data change. In the next chapter, we will talk more about transitions
    in Vue.js and apply them to our applications.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看页面。打开控制台，输入`data.kittens = false`和`data.kittens = true`。现在您可以看到在每次数据更改时发生漂亮的`fade`过渡。在下一章中，我们将更多地讨论Vue.js中的过渡，并将其应用到我们的应用程序中。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned about Vue components and how to use them. You
    saw how to create and register them using a classic approach (application that
    uses HTML, CSS, and JavaScript) and you also saw how easy it is to create and
    manipulate them using a single-file components approach. Things to retain:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Vue组件以及如何使用它们。您看到了如何使用经典方法（使用HTML、CSS和JavaScript的应用程序）创建和注册它们，还看到了使用单文件组件方法创建和操作它们是多么容易。需要记住的事情：
- en: While variables are created using CamelCased format, in order to be able to
    use components inside templates, you must apply the corresponding kebab-cased
    format, for example, `MyBeautifulComponent` -> `my-beautiful-component`
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然变量是使用驼峰格式创建的，但为了能够在模板内部使用组件，你必须应用相应的短横线格式，例如，`MyBeautifulComponent` -> `my-beautiful-component`
- en: 'Attributes `data` and `el` inside the component must be functions and not objects:
    `{data: function () {}}`'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '组件内部的属性`data`和`el`必须是函数而不是对象：`{data: function () {}}`'
- en: 'If you want the style of the component not to leak to the global scope, add
    a `scoped` attribute to it: `<style scoped></style>`'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不希望组件的样式泄漏到全局范围，请给它添加一个`scoped`属性：`<style scoped></style>`
- en: We have also rewritten our applications using single-file components and touched
    on the data binding to the CSS transitions slightly.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用单文件组件重写了我们的应用程序，并稍微涉及了数据绑定到CSS过渡。
- en: In the next chapter, we will dive deeply into all the types of data binding,
    including CSS and JavaScript transitions. We will bring our applications back
    to life using data binding. Last but not least, we will see more cats!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨所有类型的数据绑定，包括CSS和JavaScript过渡。我们将使用数据绑定使我们的应用程序重焕生机。最后但并非最不重要的是，我们将看到更多的猫！
