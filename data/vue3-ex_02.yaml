- en: '*Chapter 2*: Building a Vue 3 Progressive Web App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：构建Vue 3渐进式Web应用'
- en: In this chapter, we will look at how to create a GitHub **progressive web app**
    (**PWA**) with Vue 3\. As we build the project, we will examine the inner workings
    of a Vue app by looking at the basic building blocks in depth. We will create
    Vue apps with components and, as we create them, we will look at the parts that
    make up a component and how they work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Vue 3创建GitHub **渐进式Web应用**（**PWA**）。在构建项目的过程中，我们将深入了解Vue应用的内部工作原理，查看基本构建块。我们将使用组件创建Vue应用，并在创建过程中，我们将查看组件的组成部分以及它们的工作原理。
- en: We will also use more advanced features such as directives, when we need to
    do so. Directives let us manipulate the **Document Object Model** (**DOM**) without
    cluttering up a component's code. They provide us with a clean way to access DOM
    elements and work with them in a reusable way. This helps make testing easier
    and helps us to modularize our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要时，我们还将使用更高级的功能，比如指令。指令让我们能够操纵**文档对象模型**（**DOM**）而不会使组件的代码混乱。它们为我们提供了一种干净的方式来访问DOM元素并以可重用的方式处理它们。这有助于简化测试，并帮助我们模块化我们的代码。
- en: Vue 3 comes with many built-in directives that we will use. In the previous
    chapter, we saw a brief overview of these. In this chapter, we will go into more
    detail to see how they work. These directives provide easy-to-use abstractions
    to make many things easier for us and are a basic feature of Vue 3 that we can't
    live without.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3带有许多内置指令，我们将使用它们。在上一章中，我们简要概述了这些指令。在本章中，我们将更详细地了解它们的工作原理。这些指令提供了易于使用的抽象，使许多事情对我们来说更容易，并且是Vue
    3的基本特性，我们无法离开它们。
- en: We will use components to display the data we want, which will take in inputs
    via props so that we can get the proper data and display it. In each component,
    we will add our own methods and make use of some component lifecycle methods.
    To reduce repetition of code, we use mixins to abstract out commonly used features
    in components and incorporate them into our components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用组件来显示我们想要的数据，它们将通过props接收输入，以便我们可以获取适当的数据并显示它。在每个组件中，我们将添加自己的方法，并利用一些组件生命周期方法。为了减少代码的重复，我们使用混入来抽象出组件中常用的功能，并将它们合并到我们的组件中。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Basic theory on components and PWAs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件和PWA的基本理论
- en: Introducing the GitHub portfolio app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍GitHub作品集应用程序
- en: Creating the PWA
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建PWA
- en: Serving the PWA
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供PWA服务
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter02](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter02).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter02](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter02)找到。
- en: Basic theory on components and PWAs
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件和PWA的基本理论
- en: Before we begin with building our Vue app, let's first get familiar with components
    and PWA. Vue 3 lets us build frontend web apps with components. With them, we
    can divide our app into small, reusable parts that are composed together to make
    a big app. This composition is done by nesting. To make different parts of the
    app compose together, we can pass data between them. Components can be taken from
    libraries and can also be created by us.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建Vue应用之前，让我们先熟悉一下组件和PWA。Vue 3允许我们使用组件构建前端Web应用。通过组件，我们可以将应用程序分成小的、可重用的部分，然后将它们组合在一起形成一个大应用程序。这种组合是通过嵌套实现的。为了使应用程序的不同部分组合在一起，我们可以在它们之间传递数据。组件可以来自库，也可以由我们自己创建。
- en: A component consists of several parts; it includes a template, a script, and
    styles. The template is what is rendered on the screen. It has **HyperText Markup
    Language** (**HTML**) elements, directives, and components. Components and HTML
    elements can have props and event listeners added to them. Props are used to pass
    data from a parent component to a child component.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 组件由几个部分组成；它包括模板、脚本和样式。模板是在屏幕上呈现的内容。它包含**超文本标记语言**（**HTML**）元素、指令和组件。组件和HTML元素可以添加属性和事件监听器。属性用于从父组件传递数据到子组件。
- en: '**Event listeners** let us listen to events emitted from a child component
    to a parent component. Events may be emitted with a payload, with data included
    in it. This enables us to have child component-to-parent component communication.
    With both things put together, we have a complete system to communicate between
    parent and child components.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件监听器**让我们可以监听从子组件到父组件发出的事件。事件可以携带有效负载，其中包含数据。这使我们能够实现子组件到父组件的通信。将这两者结合起来，我们就有了一个完整的系统，可以在父子组件之间进行通信。'
- en: Any non-trivial app will have multiple components that need to communicate with
    each other.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何非平凡的应用程序都会有多个需要相互通信的组件。
- en: PWAs are special web apps that can be installed on the user's computer, and
    the browser manages these installed apps. They differ from regular web apps as
    they let us access some computer hardware natively. When we visit a PWA in our
    browsers, we can choose to install the PWA and can then reach our app from the
    app store.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: PWAs是特殊的网络应用程序，可以安装在用户的计算机上，浏览器管理这些安装的应用程序。它们与常规网络应用程序不同，因为它们让我们可以原生地访问一些计算机硬件。当我们在浏览器中访问PWA时，我们可以选择安装PWA，然后可以从应用商店中打开我们的应用程序。
- en: PWAs don't require special bundling or distribution procedures. This means they
    are deployed just like any other web app to a server. Many modern browsers—such
    as Mozilla Firefox, Google Chrome, Apple Safari, and Microsoft Edge—support PWAs.
    This means that we can install the apps with them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: PWAs不需要特殊的捆绑或分发程序。这意味着它们可以像任何其他网络应用程序一样部署到服务器上。许多现代浏览器——如Mozilla Firefox、Google
    Chrome、Apple Safari和Microsoft Edge——都支持PWAs。这意味着我们可以使用它们安装应用程序。
- en: Special characteristics of PWAs include the ability to work for every user,
    regardless of browser choice. They are also responsive, which means they work
    on any device, such as desktop, laptop, tablet, or mobile devices. Initial loading
    is also fast since they are supposed to be cached on first load.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PWAs的特殊特性包括能够为每个用户工作，无论浏览器选择如何。它们还具有响应式，这意味着它们可以在任何设备上工作，例如台式机、笔记本电脑、平板电脑或移动设备。初始加载也很快，因为它们应该在第一次加载时被缓存。
- en: They are also supposed to work regardless of whether there's connectivity to
    the internet. Service workers run in the background to let us use PWAs offline
    or on low-quality networks. This is also another benefit of the caching available
    to PWAs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也应该能够在没有互联网连接的情况下工作。服务工作者在后台运行，让我们可以在离线或低质量网络上使用PWAs。这也是PWAs可用的缓存的另一个好处。
- en: Even though PWAs are run from the browser, they act like apps. They have app-like
    style interactions and navigation. Whatever is displayed is also always up to
    date, since the service worker runs in the background to update the data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PWAs是从浏览器中运行的，但它们的行为就像应用程序一样。它们具有类似应用程序的交互和导航样式。显示的内容也始终是最新的，因为服务工作者在后台运行以更新数据。
- en: Security is a further important benefit of PWAs. They can only be served over
    **HTTP Secure** (**HTTPS**), so outsiders can't snoop on the connection. This
    way, we know the connection hasn't been tampered with.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PWAs的另一个重要好处是安全性。它们只能通过**HTTP安全**（**HTTPS**）提供，因此外部人员无法窥视连接。这样，我们就知道连接没有被篡改。
- en: Push notifications are also available with PWAs so that they can engage with
    the user and notify them of updates.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: PWA还支持推送通知，以便与用户互动并通知他们更新。
- en: They can also be linked from a **Uniform Resource Locator** (**URL**), and a
    PWA doesn't require an installation process before we can use it—installation
    is strictly optional. When we install it, it provides a home screen icon on our
    browser so that we can click on it and start using it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以从**统一资源定位符**（**URL**）链接，并且PWA在我们可以使用它之前不需要安装过程——安装是完全可选的。安装后，它会在我们的浏览器上提供一个主屏幕图标，这样我们就可以点击它并开始使用它。
- en: Vue 3 has a `@vue/cli-plugin-pwa` plugin to let us add PWA abilities into our
    Vue 3 project without doing any manual configuration. We just run one command
    and have all the files and configuration added for us automatically. With this
    plugin, we can develop our PWA with Vue 3, and the included service worker will
    run in production. Now that we have this out of the way, we are going to look
    at how to create reusable components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3有一个`@vue/cli-plugin-pwa`插件，让我们可以在Vue 3项目中添加PWA功能，而无需进行任何手动配置。我们只需运行一个命令，所有文件和配置就会自动添加给我们。有了这个插件，我们可以使用Vue
    3开发我们的PWA，并且包含的服务工作者将在生产中运行。既然我们已经解决了这个问题，我们将看看如何创建可重用的组件。
- en: Introducing the GitHub portfolio app
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍GitHub作品集应用程序
- en: The main project of this chapter is a GitHub portfolio app. It is a PWA, which
    means it has all the features listed in the *Basic theory on components and PWAs*
    section of this chapter. These features are provided automatically by the `@vue/cli-plugin-pwa`
    plugin. We can add the code we need, to add the service workers and any other
    required configuration with one command. This way, we don't have to configure
    everything all by ourselves from scratch when we create our Vue project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要项目是一个GitHub作品集应用程序。它是一个PWA，这意味着它具有本章*组件和PWA的基本理论*部分列出的所有功能。这些功能是由`@vue/cli-plugin-pwa`插件自动提供的。我们可以通过一个命令添加我们需要的代码，以添加服务工作者和任何其他所需的配置。这样，当我们创建Vue项目时，我们就不必从头开始自己配置所有东西了。
- en: 'To get started with our app project, we will create it using Vite. We go into
    the folder where we want our project to be, and then run Vite to create the Vue
    3 app project. To do this, we run the following commands with **Node Package Manager**
    (**npm**):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的应用项目，我们将使用Vite来创建它。我们进入我们想要项目的文件夹，然后运行Vite来创建Vue 3应用项目。为此，我们使用**Node
    Package Manager**（**npm**）运行以下命令：
- en: 'The first command, shown in the following code snippet, runs npm to install
    the Vue **command-line interface** (**CLI**) globally:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个命令，在下面的代码片段中显示，运行npm全局安装Vue **命令行界面**（**CLI**）：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We run the Vue CLI to create our Vue 3 project. Our project folder name is
    `vue-example-ch2-github-app`. The following command is needed to create the project
    folder with all the files and settings added so that we don''t have to add them
    ourselves. This command goes to the project folder we just created and chooses
    the Vue 3 project when asked:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们运行Vue CLI来创建Vue 3项目。我们的项目文件夹名称是`vue-example-ch2-github-app`。需要运行以下命令来创建项目文件夹，并添加所有文件和设置，以便我们不必自己添加它们。这个命令进入我们刚创建的项目文件夹，并在询问时选择Vue
    3项目：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we run the following command to run the development server so that we
    can see the project in the browser and refresh the app preview when we write our
    code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们运行以下命令来运行开发服务器，这样我们就可以在浏览器中看到项目，并在编写代码时刷新应用程序预览：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, we can run the following commands with **Yet Another Resource
    Negotiator** (**YARN**):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用**另一种资源协商器**（**YARN**）运行以下命令：
- en: 'We run `yarn global add` to install the Vue CLI globally, as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们运行`yarn global add`来全局安装Vue CLI，如下所示：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To create the Vue 3 project, we run the following command and choose the Vue
    3 project when asked:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建Vue 3项目，我们运行以下命令，并在被询问时选择Vue 3项目：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we run the following command to run the development server so that we
    can see the project in the browser and refresh the app preview when we write our
    code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们运行以下命令来启动开发服务器，这样我们就可以在浏览器中看到项目，并在编写代码时刷新应用程序预览：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All the preceding commands are the same, as in they both create the project
    the same way; it's just a matter of which package manager we want to use to create
    our Vue 3 project. At this point, the project folder will have the required files
    for our Vue 3 project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述命令都是相同的，它们都以相同的方式创建项目；只是我们想要使用哪个包管理器来创建我们的Vue 3项目的问题。此时，项目文件夹将包含我们的Vue 3项目所需的文件。
- en: Our GitHub portfolio app is a progressive web app, and we can create this app
    easily with an existing Vue CLI plugin. Once we have created the project, we can
    start creating our Vue 3 PWA.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GitHub作品集应用是一个渐进式Web应用程序，我们可以使用现有的Vue CLI插件轻松创建这个应用程序。创建项目后，我们可以开始创建我们的Vue
    3 PWA。
- en: Creating the PWA
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建PWA
- en: First, we need an easy way to access GitHub data via its **Representational
    State Transfer** (**REST**) **application programming interface** (**API**). Fortunately,
    an developer named *Octokit* has made a JavaScript client that lets us access
    the GitHub REST API with an access token that we create. We just need to import
    the package from the **content distribution network** (**CDN**) that it is served
    from to get access to the GitHub REST API from our browser. It also has a Node
    package that we can install and import. However, the Node package only supports
    Node.js apps, so it can't be used in our Vue 3 app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一种简单的方式通过其**表述状态转移**（**REST**）**应用程序编程接口**（**API**）访问GitHub数据。幸运的是，一位名为*Octokit*的开发人员制作了一个JavaScript客户端，让我们可以使用我们创建的访问令牌访问GitHub
    REST API。我们只需要从**内容分发网络**（**CDN**）导入该包，就可以从浏览器中访问GitHub REST API。它还有一个Node包，我们可以安装和导入。然而，Node包只支持Node.js应用程序，因此无法在我们的Vue
    3应用程序中使用。
- en: Vue 3 is a client-side web framework, which means that it mainly runs on the
    browser. We shouldn't confuse packages that only run on Node with packages that
    support the browser, otherwise we will get errors when we use unsupported packages
    in the browser.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3是一个客户端Web框架，这意味着它主要在浏览器上运行。我们不应该混淆只在Node上运行的包和支持浏览器的包，否则当我们在浏览器中使用不受支持的包时，就会出现错误。
- en: To get started, we make a few changes to the existing files. First, we remove
    the styling code from `index.css`. We are focused on the functionality of our
    app for this project and not so much on the styles. Also, we rename the title
    tag's inner text to `GitHub App` in the `index.html` file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们对现有文件进行一些更改。首先，我们从`index.css`中删除样式代码。在这个项目中，我们专注于应用程序的功能，而不是样式。此外，我们将`index.html`文件中的标题标签内文本重命名为`GitHub
    App`。
- en: 'Then, to make our built app a PWA, we must run another command to add the service
    worker, to incorporate things such as hardware access support, installation, and
    support for offline usage. To do this, we use the `@vue/cli-plugin-pwa` plugin.
    We can add this by running the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了使我们构建的应用成为PWA，我们必须运行另一个命令来添加服务工作者，以整合诸如硬件访问支持、安装和离线使用支持等功能。为此，我们使用`@vue/cli-plugin-pwa`插件。我们可以通过运行以下命令来添加这个插件：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will add all the files and configurations we need to incorporate to make
    our Vue 3 project a PWA project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加我们需要整合的所有文件和配置，使我们的Vue 3项目成为PWA项目。
- en: Vue CLI creates a Vue project that uses single-file components and uses **ECMAScript
    6** (**ES6**) modules for most of our app. When we build the project, these are
    bundled together into files that are served on the web server and run on the browser.
    A project created with Vue CLI consists of `main.js` as its entry point, which
    runs all the code that is needed to create our Vue app.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Vue CLI创建了一个使用单文件组件并对大部分应用程序使用**ECMAScript 6**（**ES6**）模块的Vue项目。当我们构建项目时，这些文件被捆绑在一起，然后在Web服务器上提供并在浏览器上运行。使用Vue
    CLI创建的项目以`main.js`作为入口点，它运行创建Vue应用所需的所有代码。
- en: 'Our `main.js` file should contain the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main.js`文件应包含以下代码：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This file is located at the root of the `src` folder, and Vue 3 will automatically
    run this when the app first loads or refreshes. The `createApp` function will
    create the Vue 3 app by passing in the entry-point component. The entry-point
    component is the component that is first run when we first load our app. In our
    project, we imported `App` and passed it into `createApp`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件位于`src`文件夹的根目录，Vue 3将在应用程序首次加载或刷新时自动运行此文件。`createApp`函数将通过传入入口点组件来创建Vue 3应用程序。入口点组件是我们首次加载应用程序时首先运行的组件。在我们的项目中，我们导入了`App`并将其传递给`createApp`。
- en: Also, the `index.css` file is imported from the same folder. This has the global
    styles of our app, which is optional, so if we don't want any global styles, we
    can omit it. The `registerServiceWorker.js` file is then imported. An import with
    the filename only means that the code in the file is run directly, rather than
    us importing anything from the module.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`index.css`文件是从同一文件夹导入的。这是我们应用程序的全局样式，这是可选的，所以如果我们不想要任何全局样式，我们可以省略它。然后导入`registerServiceWorker.js`文件。仅使用文件名导入意味着文件中的代码直接运行，而不是我们从模块中导入任何内容。
- en: 'The `registerServiceWorker.js` file should contain the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`registerServiceWorker.js`文件应包含以下代码：'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is what we created when we ran `vue add pwa`. We call the `register` function
    to register the service worker if the app is in `production` mode. When we run
    the `npm run build` command, the service worker will be created, and we can use
    the service worker that is created to let users access features—such as caching
    and hardware access—from the built code that we serve. The service worker is only
    created in `production` mode since we don't want anything to be cached in the
    development environment. We always want to see the latest data displayed so that
    we can create code and debug it without being confused by the caching.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行`vue add pwa`时创建的。如果应用程序处于`production`模式，我们调用`register`函数来注册服务工作者。当我们运行`npm
    run build`命令时，服务工作者将被创建，我们可以使用创建的服务工作者让用户从我们提供的构建代码中访问功能，例如缓存和硬件访问。服务工作者仅在`production`模式下创建，因为我们不希望在开发环境中缓存任何内容。我们始终希望看到显示最新数据，以便我们可以创建代码并调试它，而不会被缓存所困扰。
- en: One more thing we need to do is to remove the `HelloWorld.vue` component from
    the `src/components` folder, since we don't need this in our app. We will also
    remove any reference to the `HelloWorld` component in `App.vue` later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的另一件事是从`src/components`文件夹中删除`HelloWorld.vue`组件，因为我们的应用程序不需要这个。我们稍后还将删除`App.vue`中对`HelloWorld`组件的任何引用。
- en: 'Now that we have made the edits to the existing code files, we can create the
    new files. To do this, we carry out the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对现有代码文件进行了编辑，我们可以创建新文件。为此，我们执行以下步骤：
- en: In the `components` folder, we add a `repo` folder; and in the `repo` folder,
    we add an `issue` folder. In the `repo` folder, we add the `Issues.vue` component
    file.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹中，我们添加了一个`repo`文件夹；在`repo`文件夹中，我们添加了一个`issue`文件夹。在`repo`文件夹中，我们添加了`Issues.vue`组件文件。
- en: In the `components/repo/issue` folder, we add the `Comments.vue` file. `Issues.vue`
    is used to display the issues of a GitHub code repository. `Comments.vue` is used
    to display the comments that are added to an issue of the code repository.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components/repo/issue`文件夹中，我们添加`Comments.vue`文件。`Issues.vue`用于显示GitHub代码存储库的问题。`Comments.vue`用于显示添加到代码存储库问题的评论。
- en: In the `components` folder itself, we add the `GitHubTokenForm.vue` file to
    let us enter and store the GitHub token.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹本身，我们添加`GitHubTokenForm.vue`文件以便我们输入和存储GitHub令牌。
- en: We also add the `Repos.vue` file to the same folder to display the code repositories
    of the user that the GitHub access token refers to. Then, finally, we add the
    `User.vue` file to the `components` folder to let us display the user information.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将`Repos.vue`文件添加到相同的文件夹中，以显示GitHub访问令牌所指向的用户的代码存储库。最后，我们将`User.vue`文件添加到`components`文件夹中，以便显示用户信息。
- en: Create a `mixins` folder in the `src` folder to add a mixin, to let us create
    the Octokit GitHub client with the GitHub access token.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建一个`mixins`文件夹以添加一个mixin，让我们使用GitHub访问令牌创建Octokit GitHub客户端。
- en: We add the `octokitMixin.js` file to the `mixins` folder to add the empty mixin.
    Now, we leave them all empty, as we are ready to add the files.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`octokitMixin.js`文件添加到`mixins`文件夹中以添加空的mixin。现在，我们将它们全部留空，因为我们准备添加文件。
- en: Creating the GitHub client for our app
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建GitHub客户端
- en: We start the project by creating the GitHub `Client` object that we will use
    throughout the app.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建GitHub `Client`对象来启动项目，该对象将在整个应用程序中使用。
- en: 'First, in the `src/mixins/octokitMixin.js` file, we add the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`src/mixins/octokitMixin.js`文件中，我们添加以下代码：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding file is a mixin, which is an object that we merge into components
    so that we can use it correctly in our components. Mixins have the same structure
    as components. The `methods` property is added so that we can create methods that
    we incorporate into components. To avoid naming conflicts, we should avoid naming
    any method with the name `createOctokitClient` in our components, otherwise we
    may get errors or behaviors that we don't expect. The `createOctokitClient()`
    method uses the Octokit client to create the client by getting the `github-token`
    local storage item and then setting that as the `auth` property. The `auth` property
    is our GitHub access token.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件是一个mixin，它是一个我们合并到组件中以便我们可以在组件中正确使用它的对象。Mixin具有与组件相同的结构。添加`methods`属性以便我们可以创建并合并到组件中的方法。为了避免命名冲突，我们应该避免在我们的组件中命名任何方法为`createOctokitClient`，否则我们可能会得到意外的错误或行为。`createOctokitClient()`方法使用Octokit客户端通过获取`github-token`本地存储项来创建客户端，然后将其设置为`auth`属性。`auth`属性是我们的GitHub访问令牌。
- en: 'The `Octokit` constructor comes from the `octokit-rest.min.js` file that we
    add from [https://github.com/octokit/rest.js/releases?after=v17.1.0](https://github.com/octokit/rest.js/releases?after=v17.1.0).
    We find the `v16.43.1` heading, click on **Assets**, download the `octokit-rest.min.js`
    file, and add it to the `public` folder. Then, in `public/index.html`, we add
    a `script` tag to reference the file. We should have the following code in the
    `index.html` file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Octokit`构造函数来自我们从[https://github.com/octokit/rest.js/releases?after=v17.1.0](https://github.com/octokit/rest.js/releases?after=v17.1.0)添加的`octokit-rest.min.js`文件。我们找到`v16.43.1`标题，点击**Assets**，下载`octokit-rest.min.js`文件，并将其添加到`public`文件夹中。然后，在`public/index.html`中，我们添加一个`script`标签来引用该文件。我们应该在`index.html`文件中有以下代码：'
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding a display for issues and comments
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加问题和评论的显示
- en: 'Then, in the `src/components/repo/issue/Comments.vue` file, we add the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`src/components/repo/issue/Comments.vue`文件中，我们添加以下代码：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this component, we have a `template` section and a `script` section. The
    `script` section has our logic to get the comments from an issue. The `name` property
    has the name of our component. We reference our component with this name in our
    other components, if needed. The `props` property has the props that the component
    accepts, as shown in the following code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，我们有一个`template`部分和一个`script`部分。`script`部分包含了从问题中获取评论的逻辑。`name`属性包含了我们组件的名称。我们可以在其他组件中使用这个名称来引用我们的组件。`props`属性包含了组件接受的props，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The component takes the `owner`, `repo`, and `issueNumber` props. We use an
    object to define the props so that we can validate the type easily with the `type`
    property. The type for `owner` and `repo` has the value `String`, so they must
    be strings. The `issueNumber` property has the type value set to `Number`, so
    it must be a number.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件接受`owner`、`repo`和`issueNumber`三个props。我们使用一个对象来定义props，这样我们可以通过`type`属性轻松验证类型。`owner`和`repo`的类型值为`String`，因此它们必须是字符串。`issueNumber`属性的类型值设置为`Number`，因此它必须是一个数字。
- en: The `required` property is set to `true`, which means that the `prop` must be
    set when we use the `Comments` component in another component.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`required`属性被设置为`true`，这意味着当我们在另一个组件中使用`Comments`组件时，必须设置这个`prop`。'
- en: The `data()` method is used to return an object that has the initial values
    of reactive properties. The `comments` reactive property is set to an empty array
    as its initial value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`data()`方法用于返回一个具有响应式属性初始值的对象。`comments`响应式属性的初始值设置为空数组。'
- en: The `mixins` property lets us set the mixins that we want to incorporate into
    our app. Since `octokitMixin` has a `methods` property, whatever is inside will
    be added into the `methods` property of our component so that we can call the
    components directly, as we will do in the `methods` property of this component.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`mixins`属性让我们设置要合并到我们应用程序中的mixin。由于`octokitMixin`有一个`methods`属性，其中的内容将被添加到我们组件的`methods`属性中，以便我们可以直接调用组件，就像我们将在这个组件的`methods`属性中所做的那样。'
- en: 'We incorporate our mixin into our component object, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将mixin合并到我们的组件对象中，如下所示：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `methods` property, we have one method in our `Comments` component.
    We use the `getIssueComments()` method to get the comments of an issue. The code
    for this is shown in the following snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`methods`属性中，我们的`Comments`组件有一个方法。我们使用`getIssueComments()`方法来获取问题的评论。其代码如下所示：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need the `owner`, `repo`, and `issueNumber` properties. The `owner` parameter
    is the username of the user who owns the repository, the `repo` parameter is the
    repository name, and the `issueNumber` parameter is the issue number of the issue.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`owner`、`repo`和`issueNumber`属性。`owner`参数是拥有存储库的用户的用户名，`repo`参数是存储库名称，`issueNumber`参数是问题的问题编号。
- en: We check for the types of each to make sure that they are what we expect before
    we make a request to get the issue, with the `octokit.issue.listComments()` method.
    The Octokit client is created by the `createOctokitClient()` method of our mixin.
    The `listComments()` method returns a promise that resolves the issue with the
    comments data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查每个类型，以确保它们是我们期望的类型，然后才使用`octokit.issue.listComments()`方法发出获取问题的请求。Octokit客户端是通过我们的mixin的`createOctokitClient()`方法创建的。`listComments()`方法返回一个解析带有评论数据的问题的promise。
- en: After that, we have the `watch` property to add our watchers. The keys of the
    properties are the names of the props that we are watching. Each object has an
    `immediate` property, which makes the watchers start watching as soon as the component
    loads. The `handler` methods have the handlers that are run when the prop value
    changes or when the component loads, since we have the `immediate` property set
    to `true.`
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有 `watch` 属性来添加我们的监视器。属性的键是我们正在监视的 props 的名称。每个对象都有一个 `immediate` 属性，它使监视器在组件加载时立即开始监视。`handler`
    方法具有在 prop 值更改或组件加载时运行的处理程序，因为我们将 `immediate` 属性设置为 `true`。
- en: We pass in the required values from the properties of this, along with `val`
    to call the `getIssueComments()` method. The `val` parameter has the latest value
    of whatever prop that we are watching. This way, we always get the latest comments
    if we have values of all the props set.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从此处的属性中传入所需的值，以及 `val` 来调用 `getIssueComments()` 方法。`val` 参数具有我们正在监视的任何 prop
    的最新值。这样，如果我们设置了所有 prop 的值，我们总是可以获得最新的评论。
- en: In the template, we load the comments by referencing the `comments` reactive
    property. The values are set by the `getIssueComments()` method that is run in
    the watcher. With the `v-for` directive, we loop through each item and render
    the values. The `c.user.login` property has the username of the user who posted
    the comment, and `c.body` has the body of the comment.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们通过引用 `comments` 响应式属性来加载评论。值是由在监视器中运行的 `getIssueComments()` 方法设置的。使用
    `v-for` 指令，我们循环遍历每个项目并呈现值。`c.user.login` 属性具有发布评论的用户的用户名，`c.body` 具有评论的正文。
- en: 'Next, we add the following code to the `src/components/Issues.vue` file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将以下代码添加到 `src/components/Issues.vue` 文件中：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code adds a component for displaying the issues. We have similar
    code in the `Comments.vue` component. We use the same `octokitMixin` mixin to
    incorporate the `createOctokitClient()` method from the mixin.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为显示问题添加了一个组件。在 `Comments.vue` 组件中我们有类似的代码。我们使用相同的 `octokitMixin` 混合来整合来自混合的
    `createOctokitClient()` 方法。
- en: The difference is that we have the `getRepoIssues()` method to get the issues
    for a given GitHub repository instead of the comments of a given issue, and we
    have two props instead of three. The `owner` and `repo` props are both strings,
    and we make them required and validate their types in the same way.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于我们有 `getRepoIssues()` 方法来获取给定 GitHub 存储库的问题，而不是给定问题的评论，并且我们有两个 props 而不是三个。`owner`
    和 `repo` props 都是字符串，并且我们以相同的方式将它们设置为必需的并验证它们的类型。
- en: 'In the `data()` method, we have the `issues` array, which is set when we call
    `getRepoIssues`. This is shown in the following code snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `data()` 方法中，我们有 `issues` 数组，当我们调用 `getRepoIssues` 时设置。这在以下代码片段中显示：
- en: src/components/Issues.vue
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/Issues.vue
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `octokit.issues.listForRepo()` method returns a promise that resolves the
    issues for a given repository. The `showIssue` reactive property lets us toggle
    whether to show the issues or not.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`octokit.issues.listForRepo()` 方法返回一个解析给定存储库的问题的 promise。`showIssue` 响应式属性让我们切换是否显示问题。'
- en: 'We also have methods to get the GitHub issues, as illustrated in the following
    code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有获取 GitHub 问题的方法，如下面的代码片段所示：
- en: src/components/Issues.vue
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/Issues.vue
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `showIssues` reactive property is controlled by the **Show issues** button.
    We use the `v-if` directive to show the issues when the `showIssues` reactive
    property is `true`. The outer `div` tag is used for checking the length property
    of issues so that we only show the **Show issues** button and the issues list
    when the length is greater than `0`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`showIssues` 响应式属性由 **显示问题** 按钮控制。我们使用 `v-if` 指令在 `showIssues` 响应式属性为 `true`
    时显示问题。外部的 `div` 标签用于检查问题的长度属性，这样当长度大于 `0` 时，我们只显示 **显示问题** 按钮和问题列表。'
- en: 'The method is triggered by the watchers, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法由观察者触发，如下所示：
- en: src/components/Issues.vue
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/Issues.vue
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `components` property, we put the `IssueComments` component we imported
    (the one we created earlier) into our component object. If we put the component
    in the `components` property, it is then registered in the component and we can
    use it in the template.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`属性中，我们将导入的`IssueComments`组件（之前创建的组件）放入我们的组件对象中。如果我们将组件放入`components`属性中，那么它将在组件中注册，我们可以在模板中使用它。
- en: 'Next, we add the template into the file, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们按如下方式将模板添加到文件中：
- en: src/components/Issues.vue
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/Issues.vue
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we use the `v-for` directive, we need to include the `key` prop so that
    the entries are displayed correctly, for Vue 3 to keep track of them. The value
    of `key` must be a unique ID. We reference the `IssueComments` component we registered
    in the template and pass in the `props` to it. The `:` symbol is short for the
    `v-bind` directive, to indicate that we are passing props to a component instead
    of setting an attribute.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`v-for`指令时，需要包括`key`属性，以便正确显示条目，以便Vue 3跟踪它们。`key`的值必须是唯一的ID。我们在模板中引用了我们注册的`IssueComments`组件，并向其传递了`props`。`:`符号是`v-bind`指令的简写，表示我们正在向组件传递props，而不是设置属性。
- en: Letting users access GitHub data with a GitHub token
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让用户使用GitHub令牌访问GitHub数据
- en: 'Next, we work on the `src/components/GitHubTokenForm.vue` file, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`src/components/GitHubTokenForm.vue`文件上进行工作，如下所示：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have a form that has an input to let us enter the GitHub access token. This
    way, we can save it when we submit the form. Also, we have the input, with type
    `submit`. The `value` attribute of it is shown as the text for the **Submit**
    button. We also have a button that lets us clear the token. The `@submit.prevent`
    directive lets us run the `saveToken` submit handler and call `event.preventDefault()`
    at the same time. The `@` symbol is short for the `v-on` directive, which listens
    to the submit event emitted by the form.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个表单，其中有一个输入框，让我们输入GitHub访问令牌。这样，我们可以在提交表单时保存它。此外，我们还有一个类型为`submit`的输入框。它的`value`属性显示为**提交**按钮的文本。我们还有一个按钮，可以让我们清除令牌。`@submit.prevent`指令让我们运行`saveToken`提交处理程序，并同时调用`event.preventDefault()`。`@`符号是`v-on`指令的简写，它监听表单发出的提交事件。
- en: The text input has a `v-model` directive to bind the input value to the `githubToken`
    reactive property. To make our input accessible for screen readers, we have a
    label with a `for` attribute that references the ID of the input. The text between
    the tags is displayed in the label.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 文本输入框具有`v-model`指令，将输入值绑定到`githubToken`响应式属性。为了使我们的输入对屏幕阅读器可访问，我们有一个带有`for`属性的标签，引用输入框的ID。标签之间的文本显示在标签中。
- en: Once the form is submitted, the `saveToken()` method runs to save the inputted
    value to local storage with the `github-token` string as the key. The `created()`
    method is a lifecycle hook that lets us get the value from local storage. The
    item with the `github-token` key is accessed to get the saved token.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表单提交后，`saveToken()`方法将运行，将输入的值保存到本地存储中，键为`github-token`字符串。`created()`方法是一个生命周期钩子，让我们可以从本地存储中获取值。通过访问具有`github-token`键的项目，可以获取保存的令牌。
- en: The `clearToken()` method clears the token and is run when we click on the **Clear
    token** button.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearToken()`方法用于清除令牌，并在单击**清除令牌**按钮时运行。'
- en: 'Next, we add the following code to the `src/components/Repos.vue` component:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将以下代码添加到`src/components/Repos.vue`组件中：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We make a request to the `/user/repos` endpoint of the GitHub REST API with
    the `octokit.request()` method. Once again, the `octokit` object is created with
    the same mixin that we used before. We register the `Issues` component so that
    we can use it to display the issues of the code repository. We loop through the
    `repos` reactive property, which is assigned the values from the `octokit.request()`
    method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`octokit.request()`方法向GitHub REST API的`/user/repos`端点发出请求。再次，`octokit`对象是使用之前使用的相同的mixin创建的。我们注册`Issues`组件，以便我们可以使用它来显示代码存储库的问题。我们循环遍历`repos`响应式属性，该属性被分配了`octokit.request()`方法的值。
- en: The data is rendered in the template. The `r.owner.login` property has the username
    of the owner of the GitHub repository, and the `r.name` property has the repository
    name. We pass both values as props to the `Issues` component so that the `Issues`
    component loads the issues of the given repository.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在模板中呈现。`r.owner.login`属性具有GitHub存储库所有者的用户名，`r.name`属性具有存储库名称。我们将这两个值作为props传递给`Issues`组件，以便`Issues`组件加载给定存储库的问题。
- en: 'Similarly, in the `src/components/User.vue` file, we write the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在`src/components/User.vue`文件中，我们编写以下代码：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `scoped` keyword means the styles are only applied to the current component.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped`关键字意味着样式仅应用于当前组件。'
- en: This component is used to display the user information that we can access from
    the GitHub access token. We use the same mixin to create the `octokit` object
    for the Octokit client. The `request()` method is called to get the user data
    by making a request to the user endpoint.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件用于显示我们可以从GitHub访问令牌访问的用户信息。我们使用相同的mixin为Octokit客户端创建`octokit`对象。通过调用`request()`方法，向用户端点发出请求以获取用户数据。
- en: Then, in the template, we show the user data by using the `avatar_url` property.
    The `username.login` property has the username of the owner of the token, the
    `userData.followers` property has the number of followers of the user, and the
    `userData.plan.name` property has the plan name.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在模板中，我们使用`avatar_url`属性显示用户数据。`username.login`属性具有令牌所有者的用户名，`userData.followers`属性具有用户的关注者数量，`userData.plan.name`属性具有计划名称。
- en: Then, finally, to put the whole app together, we use the `GitHubTokenForm`,
    `User`, and `Repo` components in the `App.vue` component. The `App.vue` component
    is the `root` component that is loaded when we load the app.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了将整个应用程序放在一起，我们在`App.vue`组件中使用`GitHubTokenForm`，`User`和`Repo`组件。`App.vue`组件是加载应用程序时加载的`root`组件。
- en: 'In `src/App.vue` file, we write the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/App.vue`文件中，我们编写以下代码：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We register all three components by putting them in the `components` property
    to register them. Then, we use all of them in the template.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将它们放在`components`属性中注册所有三个组件来注册它们。然后，我们在模板中使用它们。
- en: 'Now, we should see the following screen:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该看到以下屏幕：
- en: '![Figure 2.1 – List of repositories'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 - 仓库列表'
- en: '](image/Figure_2.1_B14405.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.1_B14405.jpg)'
- en: Figure 2.1 – List of repositories
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - 仓库列表
- en: 'We see a list of repositories displayed, and if there are any issues recorded
    for them, we see the **Show issues** button, which lets us see any issues for
    the given repository. This can be seen in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到显示的存储库列表，如果有为它们记录的问题，我们会看到**显示问题**按钮，让我们看到给定存储库的任何问题。这可以在以下截图中看到：
- en: '![Figure 2.2 – Show issues button'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 - 显示问题按钮'
- en: '](image/Figure_2.2_B14405.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.2_B14405.jpg)'
- en: Figure 2.2 – Show issues button
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - 显示问题按钮
- en: We can click **Hide issues** to hide them. If there are any comments, then we
    should see them below the issues.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击**隐藏问题**来隐藏它们。如果有任何评论，那么我们应该在问题下面看到它们。
- en: Serving the PWA
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供PWA
- en: 'Now that we have built the app, we can serve it so that we can install it in
    our browser. Let''s begin, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了应用程序，我们可以提供它，以便我们可以在浏览器中安装它。让我们开始，如下所示：
- en: 'To build the app, we run the following command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建该应用程序，我们运行以下命令：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can use the `browser-sync` package, which we install by running the following
    command:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`browser-sync`包，通过运行以下命令来安装它：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding command will install a web server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将安装一个Web服务器。
- en: We can go into the `dist` folder, which has the built files, and run `browser-sync`
    to serve the PWA.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以进入`dist`文件夹，其中包含构建的文件，并运行`browser-sync`来提供PWA。
- en: Now, to run the app, we need to get the GitHub authentication token from our
    GitHub account. If you don't have a GitHub account, then you will have to sign
    up for one.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要运行应用程序，我们需要从我们的GitHub帐户获取GitHub身份验证令牌。如果您没有GitHub帐户，那么您将不得不注册一个。
- en: Once we have created an account, then we can get the token. To get the token,
    log in to your GitHub account.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个帐户，那么我们就可以获得令牌。要获取令牌，请登录到您的GitHub帐户。
- en: Go to [https://github.com/settings/tokens](https://github.com/settings/tokens).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://github.com/settings/tokens](https://github.com/settings/tokens)。
- en: Once the page is loaded, click on the **Personal access tokens** link.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面加载完成后，点击**个人访问令牌**链接。
- en: Click **Generate new token** to generate a token. Once it's created, copy the
    token down somewhere so that we can use it by entering it in our app.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**生成新令牌**以生成令牌。一旦创建，将令牌复制到某个地方，以便我们可以通过在应用程序中输入它来使用它。
- en: 'We should see something like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似这样的东西：
- en: '![Figure 2.3 – The screen for getting the token'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – 获取令牌的屏幕'
- en: '](image/Figure_2.3_B14405.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.3_B14405.jpg)'
- en: Figure 2.3 – The screen for getting the token
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 获取令牌的屏幕
- en: Once you have the token, go back to the app we created, which is loaded in the
    browser.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您获得了令牌，返回到我们在浏览器中加载的应用程序。
- en: Enter the token into the **GitHub Token** input, click **Save token**, and then
    refresh the page. If there are any repositories and associated issues and comments,
    then they should show in the page.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将令牌输入到**GitHub Token**输入中，点击**保存令牌**，然后刷新页面。如果有任何存储库以及相关问题和评论，它们应该显示在页面中。
- en: Once we are in the browser, we should see a plus (**+**) sign on the right side
    of the URL bar. This button lets us install the PWA.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们在浏览器中，我们应该在URL栏的右侧看到一个加号（**+**）标志。这个按钮让我们安装PWA。
- en: Once we install it, we should see it on the home screen. We can go to the `chrome://apps`
    URL to see the app we just installed, as shown in the following screenshot:![Figure
    2.4 – The GitHub repository listing in our PWA
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们安装它，我们应该在主屏幕上看到它。我们可以转到`chrome://apps` URL，以查看我们刚刚安装的应用程序，如下截图所示：![图2.4
    – 我们PWA中的GitHub存储库列表
- en: '](image/Figure_2.4_B14405.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.4_B14405.jpg)'
- en: Figure 2.4 – The GitHub repository listing in our PWA
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 我们PWA中的GitHub存储库列表
- en: If you're using Chrome or any other Chromium browser such as Edge, you can press
    *F12* to open the developer console.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是Chrome或任何其他Chromium浏览器，如Edge，您可以按下*F12*打开开发者控制台。
- en: Click on the **Application** tab and then the **Service Workers** link on the
    left side to let us test the service worker, as illustrated in the following screenshot:![Figure
    2.5 – The Service Workers section of the Application tab
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用程序**选项卡，然后点击左侧的**服务工作者**链接，让我们测试服务工作者，如下截图所示：![图2.5 – 应用程序选项卡中的服务工作者部分
- en: '](image/Figure_2.5_B14405.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.5_B14405.jpg)'
- en: Figure 2.5 – The Service Workers section of the Application tab
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 应用程序选项卡中的服务工作者部分
- en: We can check the **Offline** checkbox to simulate how it acts when it is offline.
    Checking the **Update on reload** will reload the app with the latest data fetched
    when we refresh the page. The URL should be the same as the one your app is running
    on. This is the service worker that is registered by our GitHub PWA.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以选中**离线**复选框，模拟它在离线时的行为。选中**重新加载时更新**将在刷新页面时重新加载应用程序，并获取最新的数据。URL应该与您的应用程序运行的URL相同。这是我们的GitHub
    PWA注册的服务工作者。
- en: The **Unregister** link will unregister the service worker. It should be re-registered
    when we run our app again.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注销**链接将注销服务工作者。当我们再次运行应用程序时，应该重新注册它。'
- en: We are now done with creating our progressive web app with Vue 3\. We can install
    it with browsers and then use it like any other app on our device.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了使用Vue 3创建我们的渐进式Web应用程序。我们可以在浏览器中安装它，然后像设备上的任何其他应用程序一样使用它。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: By building a GitHub PWA, we learned how to create components that can be reused.
    We also looked at how to add props to let us pass data from a parent component
    to a child component. In the child component, we validate the props by checking
    the data type and specifying whether a prop is required. This way, we can easily
    see when a prop has a value that is unexpected.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建GitHub PWA，我们学会了如何创建可重用的组件。我们还研究了如何添加props，以便从父组件向子组件传递数据。在子组件中，我们通过检查数据类型并指定prop是否必需来验证props。这样，我们可以轻松地看到prop是否具有意外的值。
- en: We also looked at how to use watchers to watch for changes with reactive property
    values. Watchers can be added to watch for changes in any reactive property. We
    can watch the data that is being changed locally, and also the value of props.
    They are both reactive, so they will both trigger the watcher methods. We can
    run asynchronous code within a watcher, which is something that can't be done
    with computed properties.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了如何使用观察者来监视响应式属性值的变化。观察者可以添加以监视任何响应式属性的变化。我们可以监视本地被改变的数据，也可以监视props的值。它们都是响应式的，因此它们都会触发观察者方法。我们可以在观察者中运行异步代码，这是计算属性无法做到的。
- en: Also, we had a look at lifecycle hooks of components. Each component also has
    its own lifecycle hooks. We can add our own code to the lifecycle methods, to
    run code when we want to run them. There are lifecycle hooks for all parts of
    a component lifecycle, including the beginning stage when it is loaded, through
    to when it is updated and destroyed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还研究了组件的生命周期钩子。每个组件也有自己的生命周期钩子。我们可以向生命周期方法中添加我们自己的代码，以便在需要时运行代码。组件生命周期的各个阶段都有生命周期钩子，包括加载时的开始阶段，更新和销毁。
- en: Finally, we learned how to convert our Vue 3 web app into a PWA with a command-line
    plugin. We can add a plugin to our Vue project to create a PWA. With it, a service
    worker will be registered in our app to handle different connection types and
    caching.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学会了如何使用命令行插件将我们的Vue 3 web应用程序转换为PWA。我们可以向我们的Vue项目添加插件来创建PWA。通过它，服务工作者将在我们的应用程序中注册，以处理不同的连接类型和缓存。
- en: In the next chapter, we will create a slider puzzle with Vue 3, with automated
    tests to test each part of our app.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Vue 3创建一个滑块拼图，并编写自动化测试来测试应用程序的每个部分。
