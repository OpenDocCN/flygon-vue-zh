- en: '*Chapter 7*: Creating a Shopping Cart System with GraphQL'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：使用GraphQL创建购物车系统'
- en: In the previous chapter, we built a travel booking system with Vue 3 and Express.
    This was the first project where we built from scratch our own backend that is
    used by the frontend. Having our own backend lets us do a lot more stuff that
    we can't do otherwise—for example, we can save the data that we like in the database
    that we created ourselves. Also, we added our own authentication system to authenticate
    the admin user. On the admin frontend, we protect our routes with the `beforeEnter`
    route guard, which checks for the authentication token before the admin user can
    log in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Vue 3和Express构建了一个旅行预订系统。这是我们从头开始构建自己的后端的第一个项目，该后端被前端使用。拥有自己的后端让我们能够做更多的事情，否则我们无法做到，例如，我们可以将喜欢的数据保存在我们自己创建的数据库中。此外，我们为管理员用户添加了自己的身份验证系统。在管理员前端，我们使用`beforeEnter`路由守卫保护我们的路由，在管理员用户登录之前检查身份验证令牌。
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下主题：
- en: Introducing the GraphQL **application programming interface** (**API**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍GraphQL应用程序编程接口（API）
- en: Creating a GraphQL API with Express
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express创建GraphQL API
- en: Creating the admin frontend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建管理员前端
- en: Creating the customer frontend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建客户前端
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter's project can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter07](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter07).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章项目的代码可以在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter07](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter07)找到。
- en: Introducing the GraphQL API
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍GraphQL API
- en: In the last chapter, we created a backend with Express. The endpoint accepts
    JSON data as input and returns JSON data as a response. However, it can take any
    JSON data, which the backend may not expect. Also, there is no easy way to test
    our API endpoints without the frontend. This is something that we can solve with
    GraphQL APIs. **GraphQL** is a special query language that makes communication
    easier between the client and server. GraphQL APIs have a built-in data structure
    validation. Each property has a data type, which can be a simple or complex type,
    consisting of many properties with simple data types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Express创建了一个后端。该端点接受JSON数据作为输入，并返回JSON数据作为响应。然而，它可以接受任何JSON数据，后端可能不会预期。此外，没有一种简单的方法可以在没有前端的情况下测试我们的API端点。这是我们可以用GraphQL
    API解决的问题。GraphQL是一种特殊的查询语言，使客户端和服务器之间的通信更加容易。GraphQL API具有内置的数据结构验证。每个属性都有一个数据类型，可以是简单或复杂类型，由许多具有简单数据类型的属性组成。
- en: We can also test GraphQL APIs with GraphiQL, which is a web page that lets us
    make our own GraphQL API requests easily. Since there is a data type validation
    for each request, it can provide an autocomplete feature, according to the definition
    of the GraphQL API schema. The schema provides us with all the data type definitions
    that are used with queries and mutations. Queries are requests that let us query
    for data with our GraphQL API, while mutations are GraphQL requests that let us
    change data in some way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用GraphiQL测试GraphQL API，这是一个网页，让我们轻松地进行自己的GraphQL API请求。由于每个请求都有数据类型验证，它可以根据GraphQL
    API模式的定义提供自动完成功能。该模式为我们提供了与查询和变异一起使用的所有数据类型定义。查询是让我们使用GraphQL API查询数据的请求，而变异是让我们以某种方式更改数据的GraphQL请求。
- en: We define queries and mutations explicitly with a schema string. The queries
    and mutations take input types as data types for the input data, and return data
    with the specified output data types. Therefore, we will never be in any doubt
    about the structure of the data that we have to send to make a GraphQL request
    and will never have to guess as to what kind of data a request will return.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用模式字符串明确定义查询和变异。查询和变异将输入类型作为输入数据的数据类型，并使用指定的输出数据类型返回数据。因此，我们永远不会对我们必须发送的数据的结构产生任何疑问，也永远不必猜测请求将返回什么类型的数据。
- en: GraphQL API requests are mostly just regular **HyperText Transfer Protocol**
    (**HTTP**) requests, except that they have a special structure. All requests go
    to the `/graphql` endpoint by default, and we send queries or mutations as a string
    value of the `query` property in the JSON requests. The variable values are sent
    with the `variable` parameter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API请求基本上只是常规的**超文本传输协议**（**HTTP**）请求，只是它们具有特殊的结构。所有请求默认都发送到`/graphql`端点，并且我们将查询或变异作为JSON请求中`query`属性的字符串值发送。变量值与`variable`参数一起发送。
- en: The queries and mutations are named, and all the queries and mutations are sent
    to the resolver functions with the same names in the code, instead of to route
    handlers. The functions then take the arguments specified by the schema, after
    which we can get the request data and do what we want with it in our resolver
    function code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查询和变异是有名称的，并且所有查询和变异都以相同的名称发送到解析器函数中的代码，而不是路由处理程序。然后函数根据模式指定的参数获取请求数据，并在解析器函数代码中对其进行处理。
- en: With Vue 3 apps, we can use specialized GraphQL API clients to make GraphQL
    API request creation easier. All we have to do to make a request is pass in a
    string for the queries and mutations, along with the variables that go with the
    queries and mutations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vue 3应用程序，我们可以使用专门的GraphQL API客户端来更轻松地创建GraphQL API请求。我们只需传入一个字符串来进行查询和变异，以及与查询和变异相关的变量。
- en: In this chapter, we will create a shopping cart system with an admin frontend
    and a customer frontend with Vue 3\. We will then create a backend with Express
    and the `express-graphql` library that takes GraphQL API requests and stores data
    in a SQLite database.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Vue 3创建一个带有管理前端和客户前端的购物车系统。然后，我们将使用Express和`express-graphql`库创建一个后端，该后端接收GraphQL
    API请求并将数据存储在SQLite数据库中。
- en: Setting up the shopping cart system project
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置购物车系统项目
- en: To create the vacation booking project, we had to create subprojects for the
    frontend, the admin frontend, and the backend. To create the frontend and admin
    frontend projects, we will use Vue CLI. To create the backend project, we will
    use the `express-generator` global package.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建度假预订项目，我们必须为前端、管理前端和后端创建子项目。为了创建前端和管理前端项目，我们将使用Vue CLI。为了创建后端项目，我们将使用`express-generator`全局包。
- en: 'To set up this chapter''s project, we execute the following steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置本章的项目，我们执行以下步骤：
- en: First, we create a folder to house all the projects, and name it `shopping-cart`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个文件夹来存放所有项目，并将其命名为`shopping-cart`。
- en: We then create `admin-frontend`, `frontend`, and `backend` folders inside the
    main folder.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在主文件夹内创建`admin-frontend`，`frontend`和`backend`文件夹。
- en: Next, we go into the `admin-frontend` folder and run `npx vue create` to add
    the scaffolding code for the Vue project to the `admin-frontend` folder.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们进入`admin-frontend`文件夹，并运行`npx vue create`来为`admin-frontend`文件夹添加Vue项目的脚手架代码。
- en: If we are asked to create the project in the current folder, we select `Y`,
    and then when we're asked to choose the Vue version of the project, we choose
    `Vue 3`. Likewise, we run Vue CLI the same way with the `frontend` folder.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们被要求在当前文件夹中创建项目，我们选择`Y`，然后当被要求选择项目的Vue版本时，我们选择`Vue 3`。同样，我们以`frontend`文件夹的方式运行Vue
    CLI。
- en: To create the Express project, we run the Express application generator app.
    To run it, we go into the `backend` folder and then run `npx express-generator`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建Express项目，我们运行Express应用程序生成器应用程序。要运行它，我们进入`backend`文件夹，然后运行`npx express-generator`。
- en: This command will add all the files that are required for our project to the
    `backend` folder. If you get an error, try running the `express-generator` package
    as an administrator.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将把所有需要的文件添加到`backend`文件夹中。如果出现错误，请尝试以管理员身份运行`express-generator`包。
- en: Now that we have finished setting up the project, we can start working on the
    code. Next, we will start with creating the GraphQL backend.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了项目的设置，我们可以开始编写代码了。接下来，我们将开始创建GraphQL后端。
- en: Creating a GraphQL API with Express
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express创建GraphQL API
- en: To start the shopping cart system project, we first create a GraphQL API with
    Express. We start with the backend since we need it for both frontends. To get
    started, we have to add a few libraries that are needed to manipulate the SQLite
    database and add authentication to our app. Also, we need the library to enable
    **Cross-Origin Resource Sharing** (**CORS**) in our app.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始购物车系统项目，我们首先要使用Express创建一个GraphQL API。我们从后端开始，因为我们需要它用于两个前端。要开始，我们必须添加一些需要用于操作SQLite数据库并向我们的应用程序添加身份验证的库。此外，我们需要启用应用程序中的**跨域资源共享**（**CORS**）的库。
- en: CORS is a way to let us make requests from the browser to an endpoint hosted
    in a different domain from where the frontend is hosted.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: CORS是一种让我们能够从浏览器向不同域中托管的端点发出请求的方法，与前端托管的域不同。
- en: 'To make our Express app accept GraphQL requests, we use the `graphql` and `express-graphql`
    libraries. To install both, we run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的Express应用程序接受GraphQL请求，我们使用`graphql`和`express-graphql`库。要安装两者，我们运行以下命令：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After installing the packages, we are ready to work on the code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完包后，我们就可以开始编写代码了。
- en: Working with resolver functions
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用解析器函数
- en: 'First, we work on the resolver functions. To add them, we first add a `resolvers`
    folder into the `backend` folder. Then, we can work on the resolver for authentication.
    In the `resolvers` folder, we create an `auth.js` file and write the following
    code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要处理解析器函数。为了添加它们，我们首先在`backend`文件夹中添加一个`resolvers`文件夹。然后，我们可以为身份验证编写解析器。在`resolvers`文件夹中，我们创建一个`auth.js`文件，并编写以下代码：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `login` method is a resolver function. It takes the `user object` property
    with the `username` and `password` properties, and we use these to check for the
    credentials. We check if the username is `'admin'` and the password is `'password'`.
    If the credentials are correct, then we issue the token. Otherwise, we throw an
    error, which will be returned as an error response by the `/graphql` endpoint.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`方法是一个解析器函数。它接受具有`username`和`password`属性的`user object`属性，我们使用这些属性来检查凭据。我们检查用户名是否为`''admin''`，密码是否为`''password''`。如果凭据正确，我们就发出令牌。否则，我们抛出一个错误，这将作为`/graphql`端点的错误响应返回。'
- en: Adding resolvers for the order logic
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为订单逻辑添加解析器
- en: 'We next add the resolvers for the order logic. In the `resolvers` folder, we
    add the `orders.js` file. Then, we work on the resolver function to get the order
    data. The order data has information about the order itself and also about what
    has been bought by the customer. To add the resolvers, we write the following
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为订单逻辑添加解析器。在`resolvers`文件夹中，我们添加`orders.js`文件。然后，我们开始编写解析器函数以获取订单数据。订单数据包含有关订单本身以及客户购买的商品的信息。为了添加解析器，我们编写以下代码：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We open the database with the `sqlite3.Database` constructor, with the path
    to the database. Then, we return a promise that queries all the orders with the
    items that the custom bought. The orders are in the `orders` table. The store
    inventory items are stored in the `shop_items` table, and we have the `order_shop_items`
    table to link the order and the items bought.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sqlite3.Database`构造函数打开数据库，指定数据库路径。然后，我们返回一个查询所有订单及客户购买商品的承诺。订单存储在`orders`表中。商店库存商品存储在`shop_items`表中，我们有`order_shop_items`表来链接订单和购买的商品。
- en: 'We make a `select` query with the `db.all` method to get all the data, and
    we join all the related tables with an `inner join` to get the related data in
    the other tables. In the callback, we write the following code to loop through
    the rows to create the `order` object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`db.all`方法进行`select`查询以获取所有数据，并使用`inner join`连接所有相关表以获取其他表中的相关数据。在回调中，我们编写以下代码来循环遍历行以创建`order`对象：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This lets us remove duplicate order entries in the rows. The key is the `order_id`
    value, and the value is the order data itself. Then, we get all order values with
    the `Object.values` method. We assign the returned array to the `orderArr` variable.
    Then, we loop through the `orderArr` array to get all the shop items that were
    ordered from the original row's array with the `filter` method, to look up the
    items by `order_id`. We call `map` to extract the shop item data of the order
    from the row.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以删除行中的重复订单条目。键是`order_id`值，值是订单数据本身。然后，我们使用`Object.values`方法获取所有订单值。我们将返回的数组分配给`orderArr`变量。然后，我们循环遍历`orderArr`数组，使用`filter`方法从原始行的数组中获取所有已订购的商店商品，以通过`order_id`查找商品。我们调用`map`从行中提取订单的商店商品数据。
- en: We call `resolve` on the data to return it as a response from the `/graphql`
    endpoint. In the first few lines of the callback, we call `reject` when `err`
    is truthy so that we can return the error to the user, if there is one.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数据上调用`resolve`，以便从`/graphql`端点返回它作为响应。在回调的前几行中，当`err`为真时，我们调用`reject`，以便如果有错误，我们可以将错误返回给用户。
- en: Finally, we call `db.close()` to close the database once we're done. We can
    do this at the end, since we used `db.serialize` to run all the statements in
    the `serialize` callback in a series so that the **Structured Query Language**
    (**SQL**) code could be run in sequence.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`db.close()`来关闭数据库。我们可以在最后这样做，因为我们使用`db.serialize`来运行`serialize`回调中的所有语句，以便**结构化查询语言**（**SQL**）代码可以按顺序运行。
- en: Adding an order
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加订单
- en: 'We add a resolver function to add an order. To do this, we write the following
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个解析器函数来添加订单。为此，我们编写以下代码：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We get the request payload for the order, with the variables we destructured
    within the argument. We open the database the same way, and we start with the
    same promise code and the `db.serialize` call, but inside it we create a prepared
    statement with the `db.prepare` method. We issue an `INSERT` statement to add
    the data to the order entry.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取订单的请求有效负载，其中包括我们在参数中解构的变量。我们以相同的方式打开数据库，并且我们从相同的承诺代码和`db.serialize`调用开始，但在其中我们使用`db.prepare`方法创建一个准备好的语句。我们发出`INSERT`语句以将数据添加到订单条目中。
- en: Then, we call `run` with the variable values we want to insert, to run the SQL
    statement. Prepared statements are good since all the variable values we passed
    into `db.run` are sanitized to prevent SQL injection attacks. Then, we call `finalize`
    to commit the transaction.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用要插入的变量值调用`run`来运行SQL语句。准备好的语句很好，因为我们传递给`db.run`的所有变量值都经过了清理，以防止SQL注入攻击。然后，我们调用`finalize`来提交事务。
- en: Next, we get the ID value of the row that has just been inserted into the `orders`
    table with the `db.all` call, with the `SELECT` statement. In the callback of
    the `db.all` method, we get the returned data and destructure `orderId` from the
    returned data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`db.all`调用和`SELECT`语句获取刚刚插入到`orders`表中的行的ID值。在`db.all`方法的回调中，我们获取返回的数据并从返回的数据中解构`orderId`。
- en: Then, we create another prepared statement to insert the data for the shop items
    that were bought into the `order_shop_items` table. We just insert `order_id`
    and `shop_item_id` to link the order to the shop item bought.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建另一个准备好的语句，将购买的商店物品的数据插入到`order_shop_items`表中。我们只是插入`order_id`和`shop_item_id`来将订单与购买的商店物品关联起来。
- en: We loop through the `orderedItems` array and call `run` to add the entries,
    and we call `finalize` to finalize all the database transactions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环遍历`orderedItems`数组并调用`run`来添加条目，然后我们调用`finalize`来完成所有数据库事务。
- en: Finally, we call `resolve` to return a success response to the client.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`resolve`向客户端返回成功响应。
- en: 'To finish off this file, we add the `removeOrder` resolver to let us remove
    orders from the database. To do this, we write the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个文件，我们添加`removeOrder`解析器，让我们能够从数据库中删除订单。为此，我们编写以下代码：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We call `db.serialize` and `db.prepare` in the same way as we did before. The
    only difference is that we are issuing `DELETE` statements to delete everything
    with the given `order_id` in the `order_shop_items` and `orders` tables. We need
    to delete items from the `order_shop_items` table first since the order is still
    being referenced there.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与之前相同的方式调用`db.serialize`和`db.prepare`。唯一的区别是，我们正在发出`DELETE`语句来删除`order_shop_items`和`orders`表中具有给定`order_id`的所有内容。我们需要先从`order_shop_items`表中删除项目，因为订单仍然在那里被引用。
- en: Once we get rid of all the references of the order outside the `orders` table,
    we can delete the order itself in the `orders` table.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们清除了`orders`表之外对订单的所有引用，我们就可以在`orders`表中删除订单本身。
- en: Getting the shop items
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取商店物品
- en: 'We create a `shopItems.js` file in the `resolvers` folder to hold the resolver
    functions for getting and setting the shop items. First, we start with a resolver
    function to get all the shop items. To do this, we write the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`resolvers`文件夹中创建一个`shopItems.js`文件，用于保存获取和设置商店物品的解析器函数。首先，我们从一个解析器函数开始获取所有商店物品。为此，我们编写以下代码：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We call `db.serialize` and `db.all`, as we did before. We just get all the `shop_items`
    entries with the query and we call `resolve` to return the selected data as a
    response to the client.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像之前一样调用`db.serialize`和`db.all`。我们只是用查询获取所有的`shop_items`条目，然后调用`resolve`将选定的数据作为响应返回给客户端。
- en: Adding a resolver function to add a shop item
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个解析器函数来添加商店物品
- en: 'We will now add a resolver function to add a shop item. To do this, we write
    the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个解析器函数来添加商店物品。为此，我们编写以下代码：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We issue an `INSERT` statement to insert an entry, with the values destructured
    from the parameter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发出`INSERT`语句来插入一个条目，其中的值是从参数中解构出来的。
- en: 'Finally, we add the `removeShopItem` resolver by writing the following code
    to let us remove an entry from the `shop_items` table by its ID:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过编写以下代码添加`removeShopItem`解析器，让我们能够根据其ID从`shop_items`表中删除条目：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Mapping resolvers to queries and mutations
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将解析器映射到查询和变异
- en: 'We need to map the resolvers to queries and mutations so that we can call them
    when making GraphQL API requests. To do this, we go to the `app.js` file and add
    a few things. We will also add some middleware so that we can enable cross-domain
    communication and token checks for some requests. To do this, we start by writing
    the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将解析器映射到查询和变异，以便在进行GraphQL API请求时调用它们。为此，我们转到“app.js”文件并添加一些内容。我们还将添加一些中间件，以便我们可以启用跨域通信和对某些请求进行令牌检查。为此，我们首先编写以下代码：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We import everything we need with the `require` function. We can replace all
    the stuff at the top of the file with the preceding code block. We import the
    resolvers, the CORS middleware, the GraphQL library items, and the `jsonwebtoken`
    module.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用“require”函数导入所需的所有内容。我们可以用前面的代码块替换文件顶部的所有内容。我们导入解析器、CORS中间件、GraphQL库项和“jsonwebtoken”模块。
- en: 'Next, we create the schema for our GraphQL API by calling the `buildSchema`
    function. To do this, we write the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用“buildSchema”函数为我们的GraphQL API创建模式。为此，我们编写以下代码：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The full schema definition can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter07/backend/app.js](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter07/backend/app.js).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的模式定义可以在[https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter07/backend/app.js](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter07/backend/app.js)找到。
- en: We have the `type` keyword to define a data type for a response, and we have
    the `Response` and `Token` types to use as the response. The `express-graphql`
    library will check the structure of the response against what is specified in
    the data type, so whatever query or mutation that returns data with the `Response`
    type should have a `status string` property. This is optional since we don't have
    an exclamation mark after the string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有“type”关键字来定义响应的数据类型，我们有“Response”和“Token”类型用作响应。“express-graphql”库将检查响应的结构是否符合数据类型中指定的内容，因此任何返回具有“Response”类型的查询或变异都应该有一个“status
    string”属性。这是可选的，因为字符串后面没有感叹号。
- en: The `input` keyword lets us define an `input` type. An `input` type is used
    for specifying the data structure of request payloads. They are defined the same
    way as `output` types with a list of properties, with their data type after the
    colon.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: “input”关键字让我们定义了一个“input”类型。一个“input”类型用于指定请求有效载荷的数据结构。它们与“output”类型的定义方式相同，具有一系列属性，冒号后面是它们的数据类型。
- en: We can nest one data type in another, as we did with the `ordered_items` property
    in the `OrderOutput` type. We specify that it holds an array of objects with the
    `ShopItemOutput` data type. Likewise, we specify a similar data type for the `ordered_items`
    property in the `Order` data type. The square brackets indicate that the data
    type is an array.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个数据类型嵌套在另一个数据类型中，就像我们在“OrderOutput”类型的“ordered_items”属性中所做的那样。我们指定它包含一个具有“ShopItemOutput”数据类型的对象数组。同样，我们为“Order”数据类型中的“ordered_items”属性指定了类似的数据类型。方括号表示数据类型是一个数组。
- en: '`Query` and `Mutation` are special data types that let us add the resolver
    names before the colon and the data type of the output after the colon. The `Query`
    type specifies the queries, and the `Mutation` type specifies the mutations.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: “Query”和“Mutation”是特殊的数据类型，它们让我们在冒号前添加解析器名称，在冒号后添加输出的数据类型。“Query”类型指定查询，“Mutation”类型指定变异。
- en: 'Next, we specify the `root` object with all the resolvers added to it, by writing
    the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过编写以下代码指定了带有所有解析器的“root”对象：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We just put all the resolvers we imported into the `root` object and we spread
    all the entries into the `root` object to merge them all into one object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将导入的所有解析器放入“root”对象中，并将所有条目展开到“root”对象中，以将它们合并为一个对象。
- en: 'Then, we add `authMiddleware` to add an authentication check for some GraphQL
    requests. To do this, we write the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加`authMiddleware`以对一些GraphQL请求进行身份验证检查。为此，我们编写以下代码：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We get the `query` property from the JSON request payload to check which query
    or mutation the GraphQL request is invoking. Then, we get the `authorization`
    header with the `req.get` method. Next, we define a `requiresAuth` Boolean variable
    to check if the client is making requests that invoke the restricted queries or
    mutations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从JSON请求有效负载中获取“query”属性，以检查GraphQL请求调用的查询或变异。然后，我们使用“req.get”方法获取“authorization”标头。接下来，我们定义一个“requiresAuth”布尔变量，以检查客户端是否正在发出调用受限制的查询或变异的请求。
- en: If that is `true`, we call `jwt.verify` to verify the token with the secret.
    If it's valid, then we call `next` to proceed to the `/graphql` endpoint. Otherwise,
    we return a `401` response. If a `query` or `mutation` property doesn't need authentication,
    then we just call `next` to proceed to the `/graphql` endpoint.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为`true`，我们调用`jwt.verify`以使用密钥验证令牌。如果有效，则调用`next`继续到“/graphql”端点。否则，我们返回`401`响应。如果“query”或“mutation”属性不需要身份验证，则只需调用`next`继续到“/graphql”端点。
- en: Adding the middleware
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加中间件
- en: 'Next, we add all the middleware we need to enable cross-domain communication,
    and add the `/graphql` endpoint to accept GraphQL requests. To do this, we write
    the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了所有需要的中间件以启用跨域通信，并添加了“/graphql”端点以接受GraphQL请求。为此，我们编写以下代码：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We write the following line of code to enable cross-domain communication:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写以下代码行以启用跨域通信：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following line of code lets us accept JSON requests, which we also need
    for accepting GraphQL requests:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行使我们能够接受JSON请求，这也是我们接受GraphQL请求所需的：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following line of code adds the authentication check to restricted GraphQL
    queries:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行将身份验证检查添加到受限制的GraphQL查询中：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding line of code must be added before the following code block:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块之前必须添加上述代码行：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This way, the authentication check is done before the GraphQL request can be
    made. Finally, the following code block adds a `/graphql` endpoint to let us accept
    GraphQL requests:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，身份验证检查将在进行GraphQL请求之前完成。最后，以下代码块添加了一个“/graphql”端点，以便我们接受GraphQL请求：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `grapgqlHTTP` function returns a middleware after we pass in a bunch of
    options. We set the schema for the GraphQL API. The `rootValue` property has an
    object with all the resolvers. The resolver names should match the names specified
    in the `Query` and `Mutation` types. The `graphiql` property is set to `true`
    so that we can use the GraphiQL web app available when we go to the `/graphql`
    page in the browser.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`grapgqlHTTP`函数在传入一堆选项后返回一个中间件。我们为GraphQL API设置模式。`rootValue`属性具有包含所有解析器的对象。解析器名称应与“Query”和“Mutation”类型中指定的名称匹配。将`graphiql`属性设置为`true`，以便在浏览器中转到“/graphql”页面时可以使用GraphiQL
    Web应用程序。'
- en: To test authenticated endpoints, we can use the `ModHeader` extension available
    with Chrome and Firefox to add the authentication header with the token to the
    request headers. Then, we can test authenticated GraphQL requests easily.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试经过身份验证的端点，我们可以使用Chrome和Firefox提供的`ModHeader`扩展程序，将身份验证标头与令牌添加到请求标头中。然后，我们可以轻松测试经过身份验证的GraphQL请求。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: The extension can be downloaded from [https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en](https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en)
    for Chromium browsers and [https://addons.mozilla.org/en-CA/firefox/addon/modheader-firefox/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search](https://addons.mozilla.org/en-CA/firefox/addon/modheader-firefox/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search)
    for Firefox.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该扩展可以从[https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en](https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en)下载到Chromium浏览器，[https://addons.mozilla.org/en-CA/firefox/addon/modheader-firefox/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search](https://addons.mozilla.org/en-CA/firefox/addon/modheader-firefox/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search)下载到Firefox浏览器。
- en: 'The following screenshot shows what the GraphiQL interface looks like. We also
    have the `ModHeader` extension to let us add the headers required to make authenticated
    requests at the top right of the screen:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了GraphiQL界面的外观。我们还有`ModHeader`扩展，让我们可以在屏幕右上角添加所需的标头以进行身份验证请求：
- en: '![Figure 7.1 – GraphiQL with ModHeader extension'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 带有ModHeader扩展的GraphiQL'
- en: '](image/Figure_7.1_B14405.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.1_B14405.jpg)'
- en: Figure 7.1 – GraphiQL with ModHeader extension
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 带有ModHeader扩展的GraphiQL
- en: 'Next, we create a `db.sql` script to let us create the database we need to
    use, by writing the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`db.sql`脚本，让我们可以通过编写以下代码创建我们需要使用的数据库：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We create the tables that we used in the resolvers script. `TEXT` lets us store
    text in a column; `INTEGER` lets us store integers; `FOREIGN KEY` specifies a
    foreign key that references a column specified in the table and column after `REFERENCES`;
    `NOT NULL` makes a column required; `DROP TABLE IF EXISTS` drops a table, if it
    exists; `CREATE TABLE` creates a table; `PRIMARY KEY` specifies the primary key
    column.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了在解析器脚本中使用的表。`TEXT`让我们在列中存储文本；`INTEGER`让我们存储整数；`FOREIGN KEY`指定引用表和列后的外键；`NOT
    NULL`使列成为必需的；`DROP TABLE IF EXISTS`删除表（如果存在）；`CREATE TABLE`创建表；`PRIMARY KEY`指定主键列。
- en: Creating a SQLite database
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建SQLite数据库
- en: To create and manipulate a SQLite database, we use the **DB Browser for SQLite**
    (**DB4S**) program, which we can download from [https://sqlitebrowser.org/](https://sqlitebrowser.org/).
    This program works with Windows, Mac, and Linux. Then, we can click on **New Database**
    and save the `db.sqlite` database in the `backend` folder so that the backend
    can access the database. Then, in the **Execute SQL** tab, we paste in the script
    to add the tables to the database. For changes for the database to be written
    to disk, you have to save them. To do this, click on the **File** menu and then
    click on **Write Changes**. We can also press the *Ctrl* + *S* keyboard combination
    to save the changes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**DB Browser for SQLite**（**DB4S**）程序来创建和操作SQLite数据库，我们可以从[https://sqlitebrowser.org/](https://sqlitebrowser.org/)下载。该程序适用于Windows、Mac和Linux。然后，我们可以点击**New
    Database**，将`db.sqlite`数据库保存在`backend`文件夹中，以便后端可以访问数据库。然后，在**Execute SQL**选项卡中，我们粘贴脚本以向数据库添加表。要将数据库更改写入磁盘，必须保存它们。要做到这一点，点击**File**菜单，然后点击**Write
    Changes**。我们也可以按下*Ctrl* + *S*键组合来保存更改。
- en: 'Finally, in `package.json`, we change the `start` script by writing the following
    code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`package.json`中，我们通过编写以下代码来更改`start`脚本：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We switch `nodemon` so that the app will restart when we change the code and
    save it. We run `npm I –g nodemon` to install `nodemon` globally.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们切换`nodemon`，这样当我们更改代码并保存时，应用程序将重新启动。我们运行`npm I –g nodemon`来全局安装`nodemon`。
- en: Now that we are done with the backend, we can move on to the frontend so that
    we have a complete shopping cart system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了后端，可以继续进行前端，以便拥有完整的购物车系统。
- en: Creating the admin frontend
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建管理员前端
- en: Now that we have the backend app done, we can move on to working on the frontend.
    Since we have already created the Vue 3 project earlier for the admin frontend
    in the `admin-frontend` folder, we just have to install packages that we need
    and then work on the code. We need the `graphql-request` GraphQL package and the
    GraphQL client library, and the VeeValidate, Vue Router, Axios, and Yup packages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了后端应用程序，我们可以继续处理前端。由于我们之前已经在`admin-frontend`文件夹中为管理员前端创建了Vue 3项目，我们只需安装我们需要的包，然后开始编写代码。我们需要`graphql-request`
    GraphQL包和GraphQL客户端库，以及VeeValidate、Vue Router、Axios和Yup包。
- en: 'To install them, we run the following command in the `admin-frontend` folder:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它们，我们在`admin-frontend`文件夹中运行以下命令：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After installing the packages, we can start working on the code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完包后，我们可以开始编写代码。
- en: Working with components
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理组件
- en: 'First, we start working on the components. In the `components` folder, we add
    the `TopBar` component into the `components/TopBar.vue` file to hold the route
    links and the **Log Out** button by writing the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始处理组件。在`components`文件夹中，我们通过编写以下代码将`TopBar`组件添加到`components/TopBar.vue`文件中，以容纳路由链接和**退出**按钮：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We add the Vue Router `router-link` components to let the admin user click on
    them to go to different pages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了Vue Router `router-link`组件，让管理员用户点击它们以转到不同的页面。
- en: The **Log Out** button runs the `logOut` method when it is clicked to clear
    local storage with `localStorage.clear` and redirects back to the login page with
    `this.$router.push`. The `/` path will map to the login page, as we will see later.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**退出**按钮在点击时运行`logOut`方法，以清除本地存储并使用`this.$router.push`重定向回登录页面。`/`路径将映射到登录页面，我们稍后会看到。'
- en: 'Next, in the `src/plugins` folder, we add the `router.js` file. To do this,
    we write the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`src/plugins`文件夹中，我们添加`router.js`文件。为此，我们编写以下代码：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We added the `beforeEnter` route guard to check if the authentication token
    is stored in local storage. If it is stored already and we are going to an authenticated
    route, then we proceed to the page by calling `next` with no arguments. Otherwise,
    we redirect back to the login page by calling `next` with an object with the `fullPath`
    property set to `'/'`. If there is any error, we also go back to the login page.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`beforeEnter`路由守卫来检查身份验证令牌是否存储在本地存储中。如果已经存储，并且我们要前往经过身份验证的路由，那么我们通过调用`next`而不带参数来继续到页面。否则，我们通过调用带有`fullPath`属性设置为`'/'`的对象的`next`来重定向回登录页面。如果有任何错误，我们也会返回到登录页面。
- en: Next, we have the `routes` array with the route mappings. We map the path to
    the component so that when we type in the **Uniform Resource Locator** (**URL**)
    in the browser or click a router link on the page, we go to the page we mapped
    to. We add the `beforeEnter` route guard to the route that requires authentication.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有路由映射的`routes`数组。我们将路径映射到组件，这样当我们在浏览器中输入**统一资源定位符**（**URL**）或单击页面上的路由链接时，我们就会转到我们映射到的页面。我们在需要身份验证的路由上添加`beforeEnter`路由守卫。
- en: Then, we call `createRouter` to create the `router` object, and we call `createWebHashHistory`
    to use hash mode. With hash mode, the hostname and the rest of the URL will be
    separated by a `#` sign. We also add the `routes` array into the object we pass
    into `createRouter`, to add the route mappings.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`createRouter`来创建`router`对象，并调用`createWebHashHistory`来使用哈希模式。使用哈希模式，主机名和URL的其余部分将由`#`符号分隔。我们还将`routes`数组添加到传递给`createRouter`的对象中，以添加路由映射。
- en: Then, we export the `router` object so that we can add it to our app later.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们导出`router`对象，以便稍后将其添加到我们的应用程序中。
- en: 'Next, we create the login page component. To do this, we create the `views`
    folder, add the `Login.vue` file to it, and then write the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建登录页面组件。为此，我们创建`views`文件夹，将`Login.vue`文件添加到其中，然后编写以下代码：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We add the `Form` component with the `validationSchema` prop set to the `yup`
    schema. We listen for the `submit` event, which is emitted when all the fields
    are valid, and we click the **Submit** button. The `submitForm` method will have
    the form field values we entered, and the `Field` component lets us create a form
    field.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Form`组件添加到`validationSchema`属性设置为`yup`模式。我们监听`submit`事件，当所有字段都有效时会触发该事件，然后点击**提交**按钮。`submitForm`方法将包含我们输入的表单字段值，`Field`组件让我们创建一个表单字段。
- en: '`ErrorMessage` displays the error message with the form field. If the `name`
    prop values of `Field` and `ErrorMessage` match, then any form validation for
    the field with the given name will be automatically displayed. The `placeholder`
    attribute lets us add a form placeholder, and the `type` attribute sets the `form`
    input type.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorMessage`显示带有表单字段的错误消息。如果`Field`和`ErrorMessage`的`name`属性值匹配，那么任何给定名称的字段的表单验证都将自动显示。`placeholder`属性让我们添加表单占位符，`type`属性设置`form`输入类型。'
- en: 'Next, we add the script portion of our component. To do this, we write the
    following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加组件的脚本部分。为此，我们编写以下代码：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We create the GraphQL client object with the `GraphQLClient` constructor. This
    takes the GraphQL endpoint URL and various options that we can pass in. We will
    use it to pass in the required request headers in components that require authentication.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`GraphQLClient`构造函数创建GraphQL客户端对象。它接受GraphQL端点URL和各种我们可以传递的选项。我们将在需要身份验证的组件中传递所需的请求标头。
- en: The `schema` variable holds the `yup` validation schema, which has the `name`
    and `password` fields. Both fields are strings and they are both required, as
    indicated by the method calls. The property names must match the `name` prop value
    of the `Field` and `ErrorMessage` components for the validation to trigger for
    the field.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`schema`变量保存了`yup`验证模式，其中包含`name`和`password`字段。两个字段都是字符串类型，都是必填的，如方法调用所示。属性名称必须与`Field`和`ErrorMessage`组件的`name`属性值匹配，以便触发字段的验证。'
- en: Adding the login logic and making our first GraphQL request
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加登录逻辑并进行第一个GraphQL请求
- en: 'Next, we add the login logic by writing the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过编写以下代码添加登录逻辑：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We register the `Form`, `Field`, and `ErrorMessage` components imported from
    the VeeValidate package. We have the `data` method, which returns an object with
    the schema so that we can use it in the template. Finally, we have the `submitForm`
    method, to get the `username` and `password` values from the `Field` components
    and make the login mutation GraphQL request.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册了从VeeValidate包导入的`Form`、`Field`和`ErrorMessage`组件。我们有`data`方法，它返回一个包含模式的对象，以便我们可以在模板中使用它。最后，我们有`submitForm`方法，用于从`Field`组件获取`username`和`password`值，并进行登录mutation
    GraphQL请求。
- en: We pass the `$username` and `$password` values into the parentheses to pass
    them into our mutation. The values will be obtained from the `variablesvariables`
    object, which we pass into the `graphQLClient.request` method. If the request
    is successful, we then get back the token from the request. Once we get the token,
    we put it in `localStorage.setItem` to put it into local storage.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`$username`和`$password`值传递到括号中，以便将它们传递到我们的mutation中。这些值将从我们传递给`graphQLClient.request`方法的`variables`对象中获取。如果请求成功，我们将从请求中获取令牌。一旦获取到令牌，我们将其放入`localStorage.setItem`中以将其放入本地存储。
- en: The `gql` tag is a function that lets us convert the string into a query JSON
    object that can be sent to the server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`gql`标签是一个函数，它让我们将字符串转换为可以发送到服务器的查询JSON对象。'
- en: 'If the login request failed, we then display an alert. The following screenshot
    shows the login screen:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果登录请求失败，我们会显示一个警报。以下截图显示了登录界面：
- en: '![Figure 7.2 – Admin login screen'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 - 管理员登录界面'
- en: '](image/Figure_7.2_B14405.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.2_B14405.jpg)'
- en: Figure 7.2 – Admin login screen
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - 管理员登录界面
- en: Creating the orders page
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建订单页面
- en: 'Next, we create an orders page by creating a `views/Orders.vue` file. To do
    this, we update the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过创建`views/Orders.vue`文件来创建一个订单页面。为此，我们更新以下代码：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We add `TopBar` and loop through the orders with `v-for` to render the entries.
    We also loop through `ordered_items`. We show the total price of the ordered items
    with the `calcTotal` method. We also have the **Delete Order** button, which calls
    the `deleteOrder` method when we click it. The `key` prop must be specified so
    that Vue 3 can identify the items.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`TopBar`并使用`v-for`循环遍历订单以渲染条目。我们还循环遍历`ordered_items`。我们使用`calcTotal`方法显示了订单物品的总价格。我们还有**删除订单**按钮，当我们点击它时会调用`deleteOrder`方法。必须指定`key`属性，以便Vue
    3可以识别这些条目。
- en: 'Next, we create a script with the GraphQL client by writing the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过编写以下代码使用GraphQL客户端创建脚本：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is different from the login page since we set the authorization header
    to the token we obtained from local storage. Next, we create the component object
    by writing the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这与登录页面不同，因为我们将授权标头设置为我们从本地存储中获取的令牌。接下来，我们通过编写以下代码创建组件对象：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We register the `TopBar` component with the `components` property. We have the
    `data` method to return an object with the `orders` reactive property. In the
    `beforeMount` hook, we call the `getOrders` method to get the orders when the
    component is mounting. The `calcTotal` method calculates the total price of all
    the ordered items by getting the price from all the `orderedItems` objects with
    `map` and then calling `reduce` to add all the prices together.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`components`属性注册`TopBar`组件。我们有`data`方法返回一个带有`orders`响应式属性的对象。在`beforeMount`钩子中，当组件挂载时，我们调用`getOrders`方法获取订单。`calcTotal`方法通过使用`map`从所有`orderedItems`对象中获取价格，然后调用`reduce`将所有价格相加来计算所有订单物品的总价格。
- en: The `getOrders` method makes a GraphQL query request to get all the orders.
    We specify the fields we want to get with the request. We specify the fields for
    the nested objects we also want to get, so we do the same with `ordered_items`.
    Only the fields that are specified will be returned.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOrders`方法发出GraphQL查询请求以获取所有订单。我们使用请求指定要获取的字段。我们还指定了要获取的嵌套对象的字段，因此我们也对`ordered_items`做同样的操作。只有指定的字段才会被返回。'
- en: Then, we call `graphQlClient.request` with the query to make the query request,
    and assign the data returned to the `orders` reactive property.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用查询调用`graphQlClient.request`进行查询请求，并将返回的数据分配给`orders`响应式属性。
- en: The `deleteOrder` method takes an `order` object and makes a `removeOrder` mutation
    request to the server. `orderId` is in the variables, so the correct order will
    be deleted. We call `getOrders` to get the latest orders again after deleting
    them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteOrder`方法接受一个`order`对象，并向服务器发出`removeOrder`变更请求。`orderId`在变量中，因此将删除正确的订单。我们在删除订单后再次调用`getOrders`以获取最新的订单。'
- en: 'The following screenshot shows the orders page that the admin sees:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了管理员看到的订单页面：
- en: '![Figure 7.3 – Orders page: admin view'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 - 订单页面：管理员视图'
- en: '](image/Figure_7.3_B14405.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.3_B14405.jpg)'
- en: 'Figure 7.3 – Orders page: admin view'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 - 订单页面：管理员视图
- en: Now that we have added the orders page, we will move on to add a page to let
    admins add and remove items they want to sell in the shop.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了订单页面，接下来我们将添加一个页面，让管理员可以添加和删除他们想要在商店出售的物品。
- en: Adding and removing shop items for sale
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和删除出售物品
- en: 'Next, we add a shop items page to let us add and remove shop items. To do this,
    we start with the template. We render the shop items by writing the following
    code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个商店物品页面，让我们可以添加和删除商店物品。为此，我们从模板开始。我们通过编写以下代码来渲染商店物品：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We add the `TopBar` component as we did before and we render `shopItems`, as
    we did with the orders.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像之前一样添加`TopBar`组件，并渲染`shopItems`，就像我们对订单所做的那样。
- en: 'Next, we add a dialog box with the HTML dialog element to let us add shop items.
    To do this, we write the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个带有HTML对话框元素的对话框，以便我们可以添加商店物品。为此，我们编写以下代码：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We set the `open` prop to control when the dialog box is opened, and we set
    the class to `center` so that we can apply styles to center the dialog box and
    display it above the rest of the page later.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置`open`属性来控制对话框何时打开，并将类设置为`center`，以便我们可以应用样式将对话框居中并在页面的其余部分上方显示它。
- en: Inside the dialog box, we have the form created in the same way as with the
    login page. The only difference is the fields that are in the form. At the bottom
    of the form, we have a **Cancel** button to set the `showDialog` reactive property
    to `false` to close the dialog, since it's set as the value of the `open` prop.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话框中，我们以与登录页面相同的方式创建了表单。唯一的区别是表单中的字段。在表单底部，我们有一个**取消**按钮，将`showDialog`响应属性设置为`false`以关闭对话框，因为它被设置为`open`属性的值。
- en: 'Next, we create the script with the GraphQL client and form validation schema
    (as we did before), as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建带有GraphQL客户端和表单验证模式的脚本（与之前一样），如下所示：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we add the `component options` object by writing the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过编写以下代码来添加`组件选项`对象：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We register components and create a `data` method to return the reactive properties
    we use. The `beforeMount` hook calls the `getShopItems` method to get the shop
    items from the API.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册组件并创建一个`data`方法来返回我们使用的响应属性。`beforeMount`钩子调用`getShopItems`方法以从API获取商店物品。
- en: 'Next, we add the `getShopItems` method by writing the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过编写以下代码来添加`getShopItems`方法：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We just make a `getShopItems` query request to get the data with the fields
    in the braces returned.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需发出`getShopItems`查询请求，以获取带有大括号中字段的数据。
- en: 'Next, we add the `submitForm` method to make a mutation request to add a shop
    item entry, by writing the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过编写以下代码来添加`submitForm`方法，以发出变更请求以添加商店物品条目：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We get all the form field values by destructuring the object in the parameter,
    then we call `graphQLClient.request` to make the request with the variables set
    from the destructured properties from the parameter. We convert `price` to a number
    since `price` should be a float, according to the schema we created in the backend.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过解构参数中的对象来获取所有表单字段的值，然后调用`graphQLClient.request`以使用从参数的解构属性中设置的变量进行请求。我们将`price`转换为数字，因为根据我们在后端创建的模式，`price`应该是浮点数。
- en: Once the request is done, we set `showDialog` to `false` to close the dialog
    and we call `getShopItems` again to get the shop items.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请求完成后，我们将`showDialog`设置为`false`以关闭对话框，并再次调用`getShopItems`以获取商店物品。
- en: 'The last method we''ll add is the `deleteItem` method. The code for this can
    be seen in the following snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加的最后一个方法是`deleteItem`方法。该方法的代码可以在以下代码片段中看到：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We make the `removeShopItem` mutation request to delete a shop item entry. When
    the request is done, we call `getShopItems` again to get the latest data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发出`removeShopItem`变更请求，以删除商店物品条目。请求完成后，我们再次调用`getShopItems`以获取最新数据。
- en: 'The admin''s view of the shop items page can be seen in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下截图中看到管理员视图的商店物品页面：
- en: '![Figure 7.4 – Shop items page: admin view'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – 商店物品页面：管理员视图'
- en: '](image/Figure_7.4_B14405.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.4_B14405.jpg)'
- en: 'Figure 7.4 – Shop items page: admin view'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 商店物品页面：管理员视图
- en: 'In `src/App.vue`, we write the following code to add the `router-view` component
    to show the route component content:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/App.vue`中，我们编写以下代码来添加`router-view`组件以显示路由组件内容：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `src/main.js`, we write the following code to add the router to our app:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main.js`中，我们编写以下代码来将路由器添加到我们的应用程序中：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, in `package.json`, we change the server script to serve the app from
    a different port so that it won''t conflict with the frontend. To do this, we
    write the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`package.json`中，我们将服务器脚本更改为从不同端口提供应用程序，以避免与前端发生冲突。为此，我们编写以下代码：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are now finished with the admin frontend and will move on to the final part
    of this project, which is a frontend for the customer so that they can order items.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了管理员前端，将继续进行这个项目的最后部分，即为客户创建一个前端，以便他们可以订购商品。
- en: Creating the customer frontend
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户前端
- en: Now that we have finished with the admin frontend, we finish this chapter's
    project by creating the customer's frontend. This is similar to the admin frontend
    except that there is no authentication required to use it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了管理员前端，通过创建客户前端来完成本章的项目。这与管理员前端类似，只是不需要进行身份验证。
- en: 'We start by installing the same packages that we installed for the admin frontend.
    So, we go to the `frontend` folder and run the following command to install all
    the packages:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装与管理员前端相同的包。因此，我们转到`frontend`文件夹并运行以下命令来安装所有包：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We need Vuex with the `Vuex-Persistedstate` plugin to store the shopping cart
    items. The rest of the packages are the same as for the admin frontend.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`Vuex-Persistedstate`插件来存储购物车项目。其余的包与管理员前端相同。
- en: Creating the plugins folder
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建插件文件夹
- en: 'We create a `plugins` folder in the `src` folder and add the routes by creating
    the `router.js` file in the folder and writing the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`src`文件夹中创建一个`plugins`文件夹，并通过在该文件夹中创建`router.js`文件并编写以下代码来添加路由：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we create our Vuex store by creating the `src/plugins/vuex.js` file and
    then writing the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过创建`src/plugins/vuex.js`文件来创建我们的Vuex存储，然后编写以下代码：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We call `createStore` to create the Vuex store. In the object that we pass into
    `createStore`, we have the `state` method to return the `cartItems` state initialized
    to an array. The `getters` property has an object with the `cartItemsAdded` method
    to return the `cartItems` state value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`createStore`来创建Vuex存储。在传递给`createStore`的对象中，我们有`state`方法来返回初始化为数组的`cartItems`状态。`getters`属性有一个对象，其中包含`cartItemsAdded`方法来返回`cartItems`状态值。
- en: In the `mutations` property object, we have the `addCartItem` method to call
    `state.cartItems.push` to add a `cartItem` value to the `cartItems` state. We
    get the existing cart item IDs with the `map` and `filter` method. We only want
    the numeric ones. The ID for the new cart item would be the highest one from the
    `cartItemIds` array plus `1`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mutations`属性对象中，我们有`addCartItem`方法来调用`state.cartItems.push`将`cartItem`值添加到`cartItems`状态中。我们使用`map`和`filter`方法获取现有的购物车项目ID。我们只想要数字的ID。新购物车项目的ID将是`cartItemIds`数组中最高的ID加上`1`。
- en: The `removeCartItem` method lets us call `splice` to remove a cart item by index,
    and `clearCart` resets the `cartItems` state to an empty array.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeCartItem`方法让我们调用`splice`通过索引删除购物车项目，`clearCart`将`cartItems`状态重置为空数组。'
- en: Finally, we set the `plugins` property to an object with the `createPersistedState`
    function, to create a `Vuex-Persistedstate` plugin to store the `cartItems` state
    to local storage. The `key` value is the key to store the `cartItem` values under.
    Then, we export the store so that we can add it to our app later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`plugins`属性设置为一个具有`createPersistedState`函数的对象，以创建一个`Vuex-Persistedstate`插件来将`cartItems`状态存储到本地存储中。`key`值是存储`cartItem`值的键。然后，我们导出存储，以便稍后将其添加到我们的应用程序中。
- en: Creating the order form page
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建订单表单页面
- en: 'Next, we create an order form page. This has a form to let customers enter
    their personal information and edit the cart. To create it, we create a `src/views`
    folder if one doesn''t already exist, and then we create an `OrderForm.vue` component
    file. We start by writing the following template code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个订单表单页面。这个页面有一个表单，让顾客输入个人信息并编辑购物车。为了创建它，如果还没有，我们创建一个`src/views`文件夹，然后创建一个`OrderForm.vue`组件文件。我们首先编写以下模板代码：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have similar forms to those for the admin frontend. We use the same `Form`,
    `Field`, and `ErrorMessage` components from VeeValidate.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有类似于管理员前端的表单。我们使用来自VeeValidate的相同`Form`、`Field`和`ErrorMessage`组件。
- en: We loop through the cart items with `v-for` to render them onto the screen.
    They're retrieved from local storage via `Vuex-Persistedstate` with the `cartItemsAdded`
    getter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`v-for`循环遍历购物车项目，将它们渲染到屏幕上。它们通过`Vuex-Persistedstate`和`cartItemsAdded` getter从本地存储中检索出来。
- en: 'Next, we create the script the same way by writing the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过编写以下代码以相同的方式创建脚本：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We create the GraphQL client and the validation schema, and we register the
    components in the same way as we did in the shop item page of the admin frontend.
    The only new thing is to call the `mapGetters` method to add the Vuex getters
    as a computed property of our component. We just pass in an array of strings with
    the name of the getters to map the computed properties to. Next, we add the methods
    by writing the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了GraphQL客户端和验证模式，并且我们以与管理员前端的商店项目页面相同的方式注册组件。唯一的新事物是调用`mapGetters`方法，将Vuex
    getters作为组件的计算属性添加进去。我们只需传入一个包含getter名称的字符串数组，将计算属性映射到这些getter。接下来，我们通过编写以下代码添加方法：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have the `submitOrder` method that gets the inputted data from the order
    form and makes an `addOrder` mutation request to the server. In the `variables`
    object, we need to remove `cartItemId` from each `ordered_items` object so that
    it matches the `ShopItem` schema that we created in the backend. We can't have
    extra properties that aren't included in the schema in an object we send to the
    server.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`submitOrder`方法，从订单表单中获取输入的数据，并向服务器发出`addOrder`变异请求。在`variables`对象中，我们需要从每个`ordered_items`对象中删除`cartItemId`，以使其与我们在后端创建的`ShopItem`模式匹配。我们不能在发送到服务器的对象中有不包含在模式中的额外属性。
- en: Once the request succeeds, we call `clearCart` to clear the cart, and then we
    call `thus.$router.push` to go to the success page. The `mapMutation` method maps
    the mutations to methods in our component. The `clearCart` method is the same
    as the `clearCart` Vuex store mutation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求成功，我们调用`clearCart`来清空购物车，然后调用`thus.$router.push`去到成功页面。`mapMutation`方法将变异映射到我们组件中的方法。`clearCart`方法与`clearCart`
    Vuex存储变异相同。
- en: 'The following screenshot shows the admin view of the order form:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了订单表单的管理员视图：
- en: '![Figure 7.5 – Order form: admin view'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 订单表单：管理员视图'
- en: '](image/Figure_7.5_B14405.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.5_B14405.jpg)'
- en: 'Figure 7.5 – Order form: admin view'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 订单表单：管理员视图
- en: 'Next, we create a `src/views/Shop.vue` file by writing the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过编写以下代码创建一个`src/views/Shop.vue`文件：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We render the shop items with `v-for`, as we did with the other components.
    We also have a `router-link` component to render a link on the page.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`v-for`渲染商店项目，就像我们对其他组件所做的那样。我们还有一个`router-link`组件，在页面上渲染一个链接。
- en: 'We show the number of cart items added with the `cartItemsAdded` getter. The
    `clearCart` Vuex mutation method is called when we click on **Clear Shopping Cart**.
    Next, we add the script for the component by writing the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`cartItemsAdded` getter显示添加的购物车项目数量。当我们点击**清空购物车**时，将调用`clearCart` Vuex变异方法。接下来，我们通过编写以下代码为组件添加脚本：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We create the GraphQL client the same way. In the component, we call `getShopItems`
    in the `beforeMount` hook to get the shopping cart items. We also call `mapMutations`
    to map the Vuex mutations we need into methods in our component.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以相同的方式创建GraphQL客户端。在组件中，我们在`beforeMount`钩子中调用`getShopItems`来获取购物车商品。我们还调用`mapMutations`将我们需要的Vuex变异映射到组件中的方法。
- en: 'Finally, we shrink the `img` elements to `100px` width by writing the following
    code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过编写以下代码将`img`元素缩小到`100px`宽度：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we create an order success page by creating a `src/views/Success.vue`
    file and writing the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过创建`src/views/Success.vue`文件并编写以下代码来创建一个订单成功页面：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The order success page just has some text and a link to go back to the shop's
    home page.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 订单成功页面只有一些文本和一个链接，可以返回到商店的主页。
- en: 'Next, in `src/App.vue`, we write the following code to add the `router-view`
    component to show the route pages:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`src/App.vue`中，我们编写以下代码来添加`router-view`组件以显示路由页面：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In `src/main.js`, we add the following code to add the router and Vuex store
    to our app:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main.js`中，我们添加以下代码来将路由器和Vuex存储添加到我们的应用程序：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And finally, we change the port that the app project is served from by writing
    the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过编写以下代码来更改应用项目的端口：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Our project is now complete.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目现在已经完成。
- en: We can run the frontend projects with `npm run serve` and the backend projects
    with `npm start`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`npm run serve`来运行前端项目，用`npm start`来运行后端项目。
- en: By working on the shopping cart project, we learned how to create GraphQL APIs,
    which are JSON APIs that can process GraphQL instructions via queries and mutations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过开发购物车项目，我们学会了如何创建GraphQL API，这些API是可以通过查询和变异处理GraphQL指令的JSON API。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We can easily create a GraphQL API with Express and the `express-graphql` library.
    To make GraphQL HTTP requests easily, we use the `graphql-request` JavaScript
    GraphQL client, which works in the browser. This lets us set request options such
    as headers, the query to make, and variables that go with the query easily.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地使用Express和`express-graphql`库创建GraphQL API。为了更轻松地进行GraphQL HTTP请求，我们使用了在浏览器中工作的`graphql-request`
    JavaScript GraphQL客户端。这使我们能够轻松设置请求选项，如标头、要进行的查询和与查询一起使用的变量。
- en: The `graphql-request` GraphQL client is used instead of a regular HTTP client
    to make requests to the backend from our Vue app. The `graphql-request` library
    lets us make GraphQL HTTP requests more easily than when using a regular HTTP
    client. With it, we can easily pass in GraphQL queries and mutations with variables.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`graphql-request` GraphQL客户端来向后端发出请求，而不是使用常规的HTTP客户端。`graphql-request`库让我们比使用常规的HTTP客户端更轻松地进行GraphQL
    HTTP请求。借助它，我们可以轻松地传递带有变量的GraphQL查询和变异。
- en: A GraphQL API is created with a schema that maps to resolver functions. Schemas
    let us define all the data types of our input and output data so that we don't
    have to guess which data we have to send. If we send any invalid data, then we
    will get an error telling us exactly what is wrong with the request. We also have
    to specify the data fields that we want to return with our GraphQL queries, and
    only the fields that we specified are returned. This lets us return the data that
    we need to use, making it much more efficient.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用映射到解析器函数的模式创建了GraphQL API。模式让我们定义输入和输出数据的所有数据类型，这样我们就不必猜测要发送哪些数据。如果发送任何无效数据，我们将收到一个错误，告诉我们请求出了什么问题。我们还必须指定我们想要在GraphQL查询中返回的数据字段，只有我们指定的字段才会返回。这使我们能够返回我们需要使用的数据，使其更加高效。
- en: Also, we can add authentication to a GraphQL API request with the usual token
    check before making requests to the `/graphql` endpoint.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在向`/graphql`端点发出请求之前进行常规令牌检查，为GraphQL API请求添加身份验证。
- en: We can easily test GraphQL requests with the GraphiQL interactive sandbox that
    lets us make the requests we want. To test authenticated requests, we can use
    the `ModHeader` extension to set the header so that we can make authenticated
    requests successfully.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用GraphiQL交互式沙盒轻松测试GraphQL请求，让我们可以发出想要的请求。要测试经过身份验证的请求，我们可以使用`ModHeader`扩展来设置标头，以便我们可以成功地进行经过身份验证的请求。
- en: In the next chapter, we will look at how to create a real-time chat app with
    Laravel and Vue 3.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何使用Laravel和Vue 3创建实时聊天应用程序。
