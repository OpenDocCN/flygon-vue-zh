- en: Chapter 2. Under the Hood – Tutorial Explained
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。底层-教程解释
- en: In the previous chapter, we built a simple single-page application from scratch.
    We used Vue.js to implement the application's functionality, Bootstrap to make
    it beautiful, and Firebase to manage the backend part of the application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们从头开始构建了一个简单的单页面应用程序。我们使用Vue.js来实现应用程序的功能，使用Bootstrap使其美观，并使用Firebase来管理应用程序的后端部分。
- en: 'In this chapter, we will get to know all these technologies in depth and see
    how and why they can work nicely together. We will mostly discuss Vue.js since
    this will be our number one framework to build our application. Then, we will
    touch on Bootstrap and Firebase to get a basic understanding of how powerful these
    technologies are. Having said that, in this chapter we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解所有这些技术，看看它们如何以及为什么能够很好地协同工作。我们将主要讨论Vue.js，因为这将是我们构建应用程序的首选框架。然后，我们将涉及Bootstrap和Firebase，以基本了解这些技术有多强大。话虽如此，在本章中我们将：
- en: Discuss the Vue.js framework, reactivity, and data binding. Not only will we
    cover Vue.js' basics, but we will also dig into topics such as directives, components,
    routing, and so on.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Vue.js框架、反应性和数据绑定。我们不仅将涵盖Vue.js的基础知识，还将深入探讨诸如指令、组件、路由等主题。
- en: Discuss the Bootstrap framework. We will see what is possible to achieve with
    it, discuss how it can be useful to lay out an application, and discuss how its
    components can enrich your application with useful self-contained functionality.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Bootstrap框架。我们将看到它可以实现什么，讨论它如何有助于布局应用程序，并讨论它的组件如何为您的应用程序提供有用的自包含功能。
- en: Discuss the Firebase platform. We will see what it is, what functionalities
    it provides, and how to use its API to bring those functionalities to the application.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Firebase平台。我们将看到它是什么，它提供了哪些功能，并且如何使用其API将这些功能带到应用程序中。
- en: Check how all the mentioned technologies can be combined together in order to
    achieve simplicity in the development of complex things.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所有提到的技术如何结合在一起，以实现在开发复杂事物时的简单性。
- en: Vue.js
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js
- en: 'The official Vue.js website suggests that Vue is a progressive JavaScript framework:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Vue.js网站建议Vue是一个渐进式JavaScript框架：
- en: '![Vue.js](../images/00020.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Vue.js](../images/00020.jpeg)'
- en: Screenshot from the official Vue.js website
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 来自官方Vue.js网站的截图
- en: What does that mean? In a very simplified way, I can describe Vue.js as a JavaScript
    framework that brings reactivity to web applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么？以非常简化的方式，我可以将Vue.js描述为一个为Web应用程序带来反应性的JavaScript框架。
- en: It's undeniable that each and every application has some data and some interface.
    Somehow, the interface is responsible for displaying data. Data might or might
    not change during runtime. The interface usually has to react somehow to those
    changes. The interface might or might not have some interactive elements that
    might or might not be used by the application's users. Data usually has to react
    to those interactions, and consequently, other interface elements have to react
    to the changes that have been done to the data. All of this sounds complex. Part
    of this complex architecture can be implemented on the backend side, closer to
    where data resides; the other part of it might be implemented on the frontend
    side, closer to the interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认的是，每个应用程序都有一些数据和一些界面。在某种程度上，界面负责显示数据。数据可能在运行时发生变化，也可能不会。界面通常必须以某种方式对这些变化做出反应。界面可能有一些交互元素，这些元素可能会或可能不会被应用程序的用户使用。数据通常必须对这些交互做出反应，因此，其他界面元素必须对已对数据所做的更改做出反应。所有这些听起来都很复杂。这种复杂架构的一部分可以在后端实现，靠近数据所在的地方；另一部分可能在前端实现，靠近界面。
- en: 'Vue.js allows us to simply bind data to the interface and relax. All the reactions
    that must happen between data and the interface will happen on their own. Let''s
    look at a very simple example where we will bind a message to the page title.
    Start by defining a simple HTML structure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js允许我们简单地将数据绑定到界面并放松。所有数据和界面之间必须发生的反应都将自动发生。让我们看一个非常简单的例子，我们将在页面标题上绑定一条消息。首先定义一个简单的HTML结构：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s initialize a **Vue.js** instance on this page and bind its data
    to the `<h1>` element. For this simple example, we will use a standalone `Vue.js`
    file. Download it from the Vue.js official page at [https://vuejs.org/js/vue.js](https://vuejs.org/js/vue.js).
    Import it within the `<script>` tag. Let''s now initialize a **Vue** instance.
    The minimum that a Vue.js instance needs is the **element** to be attached to
    and the `data` object. We want to attach our Vue instance to the main `<div>`
    tag with the `app` ID. Let''s also create a data object containing an entry for
    the name:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在此页面上初始化一个**Vue.js**实例，并将其数据绑定到`<h1>`元素。对于这个简单的例子，我们将使用一个独立的`Vue.js`文件。从Vue.js官方页面[https://vuejs.org/js/vue.js](https://vuejs.org/js/vue.js)下载它。在`<script>`标签中导入它。现在让我们初始化一个**Vue**实例。Vue.js实例需要的最少的是要附加到的**元素**和`data`对象。我们想要将我们的Vue实例附加到具有`app`
    ID的主`<div>`标记。让我们还创建一个包含名称条目的数据对象：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s create our Vue.js instance with this data:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这些数据创建我们的Vue.js实例：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now bind `data` to our HTML element. We will do this using double curly
    brackets (`{{}}`). Once the element has been attached to the `Vue` instance, everything
    that is inside of it becomes special—even the curly brackets. Everything that
    you put inside the double curly brackets will be interpreted and evaluated. So,
    if you put, for example, `2 + 2` inside the curly brackets, `4` will be rendered
    on the page. Just try it. Any expression, any statement will be compiled and calculated.
    Don''t be too excited though; don''t start writing chunks of JavaScript code inside
    those brackets. Let''s leave the computation to the script logic that is written
    where script resides. Use the brackets to access the data that you pass to your
    `Vue` instance. So, in our case, if you insert `{{name}}` anywhere inside your
    HTML markup, you will see the name that we passed to the `Vue` instance within
    the data object. Let''s, for example, replace the word `reader` inside the `<h1>`
    element by `{{name}}`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`data`绑定到我们的HTML元素上。我们将使用双大括号(`{{}}`)来实现这一点。一旦元素被附加到`Vue`实例上，它内部的所有内容都变得特殊
    - 即使是大括号。双大括号内的任何内容都将被解释和计算。因此，如果您在大括号内放入，例如，`2 + 2`，`4`将在页面上呈现。试一试。任何表达式，任何语句都将被编译和计算。不要太激动，不要开始在这些括号内编写大段的JavaScript代码。让我们把计算留给脚本逻辑，脚本逻辑写在脚本所在的地方。使用括号访问您传递给`Vue`实例的数据。因此，在我们的例子中，如果您在HTML标记中的任何位置插入`{{name}}`，您将看到我们在数据对象中传递给`Vue`实例的名称。例如，用`{{name}}`替换`<h1>`元素中的`reader`：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you refresh the page, you will see that the name we passed to the Vue instance
    is rendered. Try to change the `data.name` attribute in the developer tools console.
    You will see the changes immediately propagated. What we see here is a **one-way
    data binding**—the changes that happen to data are reactively propagated to the
    element to which the data is bound. Vue.js also supports **two-way data binding**;
    so, the changes that happen to the element on the page are also propagated to
    the data to which the element is bound.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面后，您会看到我们传递给Vue实例的名称被呈现出来。尝试在开发者工具控制台中更改`data.name`属性。您会立即看到更改被传播。我们在这里看到的是**单向数据绑定**
    - 数据发生的更改会被动地传播到绑定数据的元素。Vue.js还支持**双向数据绑定**；因此，页面上元素发生的更改也会传播到绑定元素的数据中。
- en: 'To achieve this, just bind the given piece of data to the element using the
    `v-model` attribute. Let''s, for example, add a text input to the page and bind
    it to the data attribute `name`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，只需使用`v-model`属性将给定的数据片段绑定到元素上。例如，让我们在页面上添加一个文本输入，并将其绑定到数据属性`name`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, once you start typing in the text input, the change is immediately propagated
    to any other element bound to this piece of data:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦您开始在文本输入中输入，更改将立即传播到绑定到此数据片段的任何其他元素：
- en: '![Vue.js](../images/00021.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Vue.js](../images/00021.jpeg)'
- en: The data changes are reactively propagated through all the bound elements
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的更改会通过所有绑定的元素进行响应式传播
- en: 'The complete code for the HTML markup and JavaScript code looks like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: HTML标记和JavaScript代码的完整代码如下：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, there is nothing difficult at all. All you need is to pass `data`
    to the `Vue` instance and bind it to the elements of your page. The Vue framework
    does everything else. In the upcoming chapters, we will find out what else is
    possible using Vue.js and how to Bootstrap a Vue.js project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这一点都不难。您只需要将`data`传递给`Vue`实例，并将其绑定到页面的元素上。Vue框架会处理其他所有事情。在接下来的章节中，我们将了解使用Vue.js还有哪些可能性，以及如何启动一个Vue.js项目。
- en: Vue project – getting started
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue项目-入门
- en: So, now that we know what Vue.js is for and what its main focus is, we would
    like to get our hands dirty and start a Vue.js project and explore all the Vue.js
    features with it. There are plenty of ways of including Vue into the project.
    Let's explore all of them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道了Vue.js的用途和主要重点，我们想要动手开始一个Vue.js项目，并探索所有Vue.js的特性。有很多种方式可以将Vue包含到项目中。让我们一起来探索它们。
- en: Including directly in script
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接包含在脚本中
- en: You can use Vue.js by just downloading it and including it within the `<script>`
    tag. Actually, we've done it in the previous section. So, if you have a project
    already running and want to use some Vue.js features, you can simply include the
    `vue.js` file and use it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过下载Vue.js并在`<script>`标签中包含它来使用Vue.js。实际上，在上一节中我们已经这样做了。因此，如果您已经运行了一个项目并想要使用一些Vue.js特性，您可以简单地包含`vue.js`文件并使用它。
- en: CDN
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CDN
- en: 'If you don''t want to bother downloading and managing Vue versions yourself,
    you can simply use the CDN version. Just include [https://unpkg.com/vue](https://unpkg.com/vue)
    script in your project and you are good to go! It will always be in sync with
    the latest Vue version:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想自己下载和管理Vue版本，可以简单地使用CDN版本。只需在项目中包含[https://unpkg.com/vue](https://unpkg.com/vue)脚本，您就可以开始了！它将始终与最新的Vue版本同步：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: NPM
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NPM
- en: 'If you are all into the Node.js development, you can simply add an `npm` dependency
    to your `package.json` file. Just run `npm install` on your project''s root:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您全身心投入Node.js开发，您可以简单地向您的`package.json`文件添加一个`npm`依赖项。只需在项目的根目录上运行`npm install`：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Vue-cli
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vue-cli
- en: 'Vue provides a nice and clean command-line interface that is perfect for bootstrapping
    new projects. First of all, you must install **vue-cli**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Vue提供了一个漂亮干净的命令行界面，非常适合启动新项目。首先，您必须安装**vue-cli**：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, you can start a fresh new project using the Vue command-line interface.
    Check out the *vue-cli* repository for the detailed documentation at [https://github.com/vuejs/vue-cli](https://github.com/vuejs/vue-cli).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用Vue命令行界面开始一个全新的项目。查看*vue-cli*存储库，获取详细文档：[https://github.com/vuejs/vue-cli](https://github.com/vuejs/vue-cli)。
- en: 'As you can see, it is possible to setup a project using different templates—starting
    from a simple single HTML page project and going to a complex webpack project
    setup. The command that should be used for scaffolding a Vue project is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，可以使用不同的模板设置项目——从简单的单个HTML页面项目开始，到复杂的webpack项目设置。用于搭建Vue项目的命令如下：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following templates are available:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模板可用：
- en: '**webpack**: This is a full-featured webpack setup with `vue-loader`. It supports
    hot reload, linting, testing, all kind of pre-processors, and so on.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webpack：这是一个具有`vue-loader`的功能齐全的webpack设置。它支持热重载、linting、测试、各种预处理器等等。
- en: '**webpack-simple**: This is a simple webpack setup that is useful for quick
    prototyping.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webpack-simple：这是一个简单的webpack设置，对于快速原型设计非常有用。
- en: '**browserify**: This is a full-featured browserify setup with vueify that also
    supports hot reload, linting, and unit testing.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: browserify：这是一个具有vueify的功能齐全的browserify设置，还支持热重载、linting和单元测试。
- en: '**browserify-simple**: This is a simple browserify setup with vueify that can
    be used for quick prototyping.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: browserify-simple：这是一个简单的具有vueify的browserify设置，可用于快速原型设计。
- en: '**simple**: This generates a simple HTML page that includes Vue.js. It is perfect
    for quick feature exploration.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: simple：这将生成一个包含Vue.js的简单HTML页面。非常适合快速功能探索。
- en: It is also possible to create custom templates. Check out the documentation
    at [https://github.com/vuejs/vue-cli#custom-templates](https://github.com/vuejs/vue-cli#custom-templates)
    and try it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以创建自定义模板。查看[https://github.com/vuejs/vue-cli#custom-templates](https://github.com/vuejs/vue-cli#custom-templates)上的文档并尝试一下。
- en: 'In this book, we will use the `webpack` template. We will include some loaders,
    and we will use linters, unit, and end-to-end testing techniques. To bootstrap
    a project using the `webpack` template, simply run the following line of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用`webpack`模板。我们将包括一些加载器，并使用linters、单元测试和端到端测试技术。要使用`webpack`模板引导项目，只需运行以下代码行：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we know how to scaffold a project with *vue-cli*, let's check what
    Vue offers besides what we already explored in the previous section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用*vue-cli*搭建项目，让我们看看除了我们在上一节中已经探索过的内容之外，Vue还提供了什么。
- en: Vue directives
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue指令
- en: Vue directives are no more than just **attributes** attached to your HTML elements.
    These directives provide some extra functionality to your template.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Vue指令只不过是附加到HTML元素的**属性**。这些指令为您的模板提供了一些额外的功能。
- en: All these directives start with the prefix `v-`. Why? Because it's *Vue*! You
    have already used some of them in the previous section. Now, we will see what
    directives exist and what you can do with them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些指令都以前缀`v-`开头。为什么？因为这是*Vue*！您已经在上一节中使用了其中一些。现在，我们将看看存在哪些指令以及您可以用它们做什么。
- en: Conditional rendering
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件渲染
- en: 'Open our Hello page and remove user''s input. Something not really beautiful
    is happening:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们的Hello页面并删除用户的输入。发生了一些不太美观的事情：
- en: '![Conditional rendering](../images/00022.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![条件渲染](../images/00022.jpeg)'
- en: '"Hello,!"'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: “你好，！”
- en: It would be interesting to render the **Hello,** name message conditionally,
    depending on the user input. If there is a name, render it; if there's no name,
    don't render.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户输入的不同条件，有可能有趣地渲染**你好，**名称消息。如果有名称，则渲染它；如果没有名称，则不渲染。
- en: 'For example, only render the **Hello,** name message if there''s a name. Directives
    `v-show` and `v-if` are used exactly for the conditional render. Open the `index.html`
    file of this example and let''s change it. Wrap the `Hello, <strong>{{name}}</strong>!`part
    into `span` and add a `v-show` attribute with the `name` value:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，只有在存在名称时才渲染**你好，**名称消息。指令`v-show`和`v-if`正是用于条件渲染的。打开此示例的`index.html`文件，让我们进行更改。将`Hello,
    <strong>{{name}}</strong>!`部分包装到`span`中，并添加一个带有`name`值的`v-show`属性：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, if you refresh the page and remove the input completely, the message will
    only say **Let''s learn Vue.js**:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您刷新页面并完全删除输入，消息将只显示**让我们学习Vue.js**：
- en: '![Conditional rendering](../images/00023.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![条件渲染](../images/00023.jpeg)'
- en: The v-show attribute allows conditional rendering
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: v-show属性允许条件渲染
- en: 'Try to replace the `v-show` directive with the `v-if` directive. The end result
    will be quite the same. Why do both exist then? Check out the developer tools''
    elements tab and try to add or remove the text in the input. You will see that
    in the case of `v-show`, the conditional span will just gain a `display:none`
    property if the condition does not verify. In the case of `v-if`, the element
    disappears completely:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试用`v-show`指令替换`v-if`指令。最终结果将是相同的。那么为什么两者都存在呢？查看开发者工具的元素选项卡，尝试添加或删除输入框中的文本。您会发现，在`v-show`的情况下，如果条件不满足，条件性span将只获得`display:none`属性。在`v-if`的情况下，元素将完全消失：
- en: '![Conditional rendering](../images/00024.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![条件渲染](../images/00024.jpeg)'
- en: Using the v-show attribute manipulates the display CSS property, whereas using
    the v-if attribute adds/removes an element completely
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用v-show属性操作显示CSS属性，而使用v-if属性会完全添加/删除一个元素
- en: When do we use either attribute? If you have a lot of elements that should be
    visible depending on some data (this data is really dynamic, so it will happen
    a lot during the runtime), I would advise using the `v-show` attribute, because
    adding or removing elements in DOM is a rather expensive operation that might
    affect the application's performance and even the DOM itself. On the other hand,
    if the elements should be conditionally rendered only once, let's say, at the
    application startup, use the `v-if` attribute. If some elements should not appear,
    they will just not be rendered. Thus, the number of elements on the page will
    be reduced. Consequently, the computational cost of the application will be also
    reduced, as, now, it has fewer elements to go through and compute.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们何时使用这两个属性？如果有很多元素应该根据一些数据可见（这些数据真的很动态，所以在运行时会经常发生），我建议使用`v-show`属性，因为在DOM中添加或删除元素是一个相当昂贵的操作，可能会影响应用程序的性能甚至DOM本身。另一方面，如果元素应该有条件地渲染一次，比如在应用程序启动时，请使用`v-if`属性。如果某些元素不应出现，它们将不会被渲染。因此，页面上的元素数量将减少。因此，应用程序的计算成本也将减少，因为现在它要经过和计算的元素更少。
- en: Text versus HTML
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本与HTML
- en: I am sure you know pretty well from the previous chapter how to bind some data
    using the mustache syntax `{{}}`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经从上一章中非常了解如何使用胡须语法`{{}}`绑定一些数据。
- en: 'Since this is a technical book about programming, we have to have a cat here
    ![Text versus HTML](../images/00025.jpeg)! A cat is pretty easy to render. Its
    Unicode is `U+1F638`; thus, we just have to add the `&#x1f638;` code to our HTML:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本关于编程的技术书籍，我们必须在这里有一只猫![文本与HTML](../images/00025.jpeg)！猫很容易渲染。它的Unicode是`U+1F638`；因此，我们只需在HTML中添加`&#x1f638;`代码：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And, surely, we will have a cat:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们会有一只猫：
- en: '![Text versus HTML](../images/00026.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![文本与HTML](../images/00026.jpeg)'
- en: Emoji cat saying hello to us
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表情猫对我们说你好
- en: It's nice, but if we want to replace the cat with a dog, we will have to use
    Google to look for another Unicode representing a dog and replace it. If at some
    point we want to replace it with a unicorn, we will have to run the same procedure.
    Moreover, just by looking at our code, we will not be able to say what we are
    actually rendering unless we know all emoji codes by `&hearts;`. It might be a
    good idea to map the names of the emojis to their codes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但是如果我们想用狗代替猫，我们将不得不使用谷歌寻找另一个代表狗的Unicode并替换它。如果在某个时候我们想用独角兽替换它，我们将不得不运行相同的过程。此外，仅仅通过查看我们的代码，我们将无法说出我们实际渲染的是什么，除非我们知道所有表情符号代码是`&hearts;`。将表情符号的名称映射到它们的代码可能是一个好主意。
- en: 'Let''s add a map of some of them. Open your HTML file and add the following
    lines of code to the `<script>` area:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些它们的地图。打开你的HTML文件，将以下代码添加到`<script>`区域：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, you can bind the values of this map to your HTML elements. Let''s try
    to do it using the mustache annotation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将此地图的值绑定到您的HTML元素。让我们尝试使用mustache注释来做到这一点：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Refresh the page. The result is not exactly the same as we expected, is it?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面。结果并不完全符合我们的预期，是吗？
- en: '![Text versus HTML](../images/00027.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![文本与HTML](../images/00027.jpeg)'
- en: The code is rendered instead of the actual cat emoji
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被呈现，而不是实际的猫表情符号
- en: 'This is happening because mustache interpolation actually interpolates text.
    Using mustache interpolation is the same as using the `v-text` directive:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为mustache插值实际上是插值文本。使用mustache插值与使用`v-text`指令是一样的：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What we actually want to render here is not the text; we want the value of
    the Unicode for the emoji being rendered as HTML! This is also possible with Vue.js.
    Just replace a `v-text` directive with the `v-html` directive:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上想要渲染的不是文本；我们想要渲染的是作为HTML呈现的表情符号的Unicode值！这在Vue.js中也是可能的。只需用`v-html`指令替换`v-text`指令：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we will get our cat back, and we know exactly what we are rendering when
    we are looking at the code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重新获得我们的猫，并且当我们查看代码时，我们确切地知道我们正在渲染什么。
- en: So, remember to use the `v-text` directive or mustache annotation for text interpolation
    and the `v-html` directive for interpolating pure HTML.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请记住使用`v-text`指令或mustache注释进行文本插值，使用`v-html`指令进行纯HTML插值。
- en: Loops
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环
- en: 'In the previous section, we put a cat on our page. In this section, I would
    like to have a whole zoo! Imagine that our zoo has a cat ![Loops](../images/00028.jpeg),
    a dog ![Loops](../images/00029.jpeg) , a monkey ![Loops](../images/00030.jpeg)
    , and, of course, a unicorn ![Loops](../images/00031.jpeg).We would like to display
    our zoo in an ordered list. Of course, you can write a simple markup that will
    look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在页面上放了一只猫。在本节中，我想要整个动物园！想象一下，我们的动物园有一只猫![循环](../images/00028.jpeg)，一只狗![循环](../images/00029.jpeg)，一只猴子![循环](../images/00030.jpeg)，当然还有一只独角兽![循环](../images/00031.jpeg)。我们想要在有序列表中显示我们的动物园。当然，您可以编写一个简单的标记，看起来像这样：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, this makes your code unreadable, and if you want to add more animals
    to your zoo or remove one of them, you would have to know all these codes by heart.
    In the previous section, we added a map for emoji animals Unicode. Let''s use
    it in our markup. You already learned that we must use a `v-html` directive so
    that the codes are interpolated as HTML. Hence, our markup will look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会使您的代码难以阅读，如果您想要向您的动物园添加更多动物或删除其中一个，您必须牢记所有这些代码。在上一节中，我们为emoji动物Unicode添加了一个地图。让我们在我们的标记中使用它。您已经学会了我们必须使用`v-html`指令，以便代码被插值为HTML。因此，我们的标记将如下所示：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It looks better, but still there''s something we could improve. Imagine if
    you want to render all the animals from the emoji world! There are plenty of them.
    For each animal, you will have to repeat the code of the list item. Every time
    you would like to reorder the list, remove some elements, or add new ones, you
    will have to deal with this markup. Wouldn''t it be nice if we just had an array
    of animals that we want to render and then somehow iterate over it and render
    what''s inside of it? Of course, it would! It is possible using the `v-for` directive.
    Create an array of animals using the following lines of code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来更好了，但仍然有一些可以改进的地方。想象一下，如果您想要渲染来自emoji世界的所有动物！有很多。对于每种动物，您都必须重复列表项的代码。每当您想重新排序列表，删除一些元素或添加新元素时，您都必须处理这个标记。如果我们只有一个要渲染的动物数组，然后以某种方式迭代它并渲染其中的内容，那不是很好吗？当然，是的！使用`v-for`指令是可能的。使用以下代码行创建一个动物数组：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Export it in the `vue data` object:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将其导出到`vue data`对象中：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you can use this array in the `v-for` directive and replace multiple `<li>`
    elements by only one:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在`v-for`指令中使用此数组，并仅用一个替换多个`<li>`元素：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result will be quite nice:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将会很好：
- en: '![Loops](../images/00032.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![循环](../images/00032.jpeg)'
- en: Emoji zoo rendered using the v-for directive
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`v-for`指令呈现的Emoji动物园
- en: Binding data
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定数据
- en: We dealt a lot with rendering different data using Vue.js in the previous section;
    so now, you are already familiar with different ways of binding it. You know how
    to interpolate data as *text* and as *HTML*, and you know how to iterate over
    arrays of data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经处理了使用Vue.js呈现不同数据的许多内容；所以现在，你已经熟悉了不同的绑定方式。你知道如何将数据插值为*文本*和*HTML*，你知道如何迭代数据数组。
- en: 'We''ve also seen that two-way data binding is achieved using the `v-model`
    directive. We used it to bind a name to the input element:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到双向数据绑定是通过`v-model`指令实现的。我们用它将名称绑定到输入元素：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `v-model` directive can only be used with the `input`, `select`, and `textarea`
    elements. It also accepts some modifiers to be used with. Modifiers are special
    keywords that affect the input in some way. There are three modifiers that can
    be used with this directive:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-model`指令只能与`input`、`select`和`textarea`元素一起使用。它还接受一些修饰符一起使用。修饰符是影响输入的特殊关键字。有三个修饰符可以与此指令一起使用：'
- en: '`.lazy`: This will only update the data on a change event (try it with our
    input and you''ll see that changes in the input will only affect other parts where
    the name is used when the *Enter* button is pressed and not on each key press)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.lazy`：这将只在更改事件上更新数据（尝试使用我们的输入，你会发现输入的更改只会影响其他部分，当按下*Enter*按钮时，而不是在每次按键时）'
- en: '`.number`: This will cast your input to number'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.number`：这将把你的输入转换为数字'
- en: '`.trim`: This will trim the user''s input'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.trim`：这将修剪用户的输入'
- en: 'It is also possible to chain the modifiers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以链接修饰符：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So now, we know nearly everything about binding data to the elements. What if
    we want to bind some data to the elements' properties? Imagine, for example, the
    dynamic value for the image's source property or class property depending on some
    data value. How could we do that?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，我们几乎了解了将数据绑定到元素的一切。如果我们想要将一些数据绑定到元素的属性呢？例如，根据某些数据值动态设置图像源属性或类属性的值。我们该怎么做呢？
- en: For this, Vue provides a `v-bind` directive. With this directive, you can bind
    whatever you want!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，Vue提供了一个`v-bind`指令。使用这个指令，你可以绑定任何你想要的东西！
- en: 'As an example, let''s show a sad picture when the name is not defined and a
    glad picture when the name is defined. For this, I''ve created two pictures, `glad.png`
    and `sad.png`, and put them into the `images` folder of my application. I will
    also export their paths into the data object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当名称未定义时，让我们显示一个悲伤的图片，当名称被定义时，让我们显示一个高兴的图片。为此，我创建了两张图片，`glad.png`和`sad.png`，并将它们放入我的应用程序的`images`文件夹中。我还将它们的路径导出到数据对象中：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, I can create an image and bind its source using `v-bind:src`, and I''ll
    provide a JavaScript expression as the value. This expression will check the value
    of the name. If it''s defined, the `glad` image will be applied, and if not, the
    `sad` image will be applied instead:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以创建一个图像，并使用`v-bind:src`绑定其源，我将提供一个JavaScript表达式作为值。这个表达式将检查名称的值。如果它被定义，将应用`glad`图像，如果没有，将应用`sad`图像：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The shortcut for the `v-bind` directive is `:`, so we can just write the following
    line of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-bind`指令的快捷方式是`:`，所以我们可以写下以下代码行：'
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is how our page looks when the value of `name` is defined:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当`name`的值被定义时，我们的页面是这样的：
- en: '![Binding data](../images/00033.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![绑定数据](../images/00033.jpeg)'
- en: Happy face image appears when the name is defined
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当名称被定义时，快乐的表情图像出现
- en: 'If you remove the name from the input field, the image will automatically change!
    Open the page and try to remove the text from the input field and add it again.
    Continue removing and adding, and you will see how fast the image is changed to
    the corresponding one. This is how the page looks when the name is undefined:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从输入字段中删除名称，图像将自动更改！打开页面，尝试从输入字段中删除文本，然后再次添加。继续删除和添加，您将看到图像如何快速更改为相应的图像。这是当名称未定义时页面的外观：
- en: '![Binding data](../images/00034.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![绑定数据](../images/00034.jpeg)'
- en: Once the input is cleaned, the image source is immediately changed
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入被清除，图像源立即更改
- en: 'Basically, you can do exactly the same with any property binding, for example,
    class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，您可以对任何属性绑定执行完全相同的操作，例如class：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can also bind properties to pass to the children components. We will see
    how to do it in the section about components.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以绑定属性以传递给子组件。我们将在有关组件的部分中看到如何执行此操作。
- en: Handling events
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理事件
- en: Besides the direct form of data binding to the elements, we want to handle some
    events because this is what our users do on the page—trigger some events so that
    they happen. They click, they hover, they submit forms—and all these events must
    be handled somehow by us. Vue provides a very nice way of attaching listeners
    to events on any DOM element and provides methods that can handle those events.
    The good thing about these methods is that they have direct access to Vue data
    using the `this` keyword. In this way, we can use methods to manipulate data,
    and since this data is reactive, all the changes will be immediately propagated
    to the elements to which this data is bound.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接将数据绑定到元素的形式之外，我们还希望处理一些事件，因为这是我们的用户在页面上所做的事情 - 触发一些事件，以便它们发生。他们点击，他们悬停，他们提交表单
    - 所有这些事件都必须以某种方式由我们处理。Vue提供了一种非常好的方法，可以将侦听器附加到任何DOM元素上，并提供可以处理这些事件的方法。这些方法的好处是它们可以使用`this`关键字直接访问Vue数据。通过这种方式，我们可以使用方法来操作数据，而由于这些数据是响应式的，所有更改将立即传播到绑定了这些数据的元素。
- en: 'In order to create a method, you just have to add a `methods` object to the
    export section of your Vue application. In order to attach this method to any
    event listener, use the `v-on` directive with the corresponding event after the
    colon. Here is an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个方法，您只需在Vue应用程序的导出部分添加一个“methods”对象。为了将此方法附加到任何事件侦听器，请在冒号后使用“v-on”指令与相应的事件。这是一个例子：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The shortcut for this directive is `@`, so we could rewrite all these directives
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令的快捷方式是`@`，因此我们可以将所有这些指令重写如下：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It should sound familiar to you. Do you remember the tutorial that we followed
    in the [Chapter 1](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 1. Please Introduce Yourself – Tutorial"), *Please Introduce Yourself
    – Tutorial*? Do you remember that we were listening on the `submit` method of
    the message, adding `form` and calling `addMessage`? Check it out. Our form with
    its `submit` directive looked like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该对您来说很熟悉。您还记得我们在[第1章](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "第1章。请介绍你自己 - 教程")中遵循的教程吗，*请介绍你自己 - 教程*？您还记得我们正在监听消息的`submit`方法，添加`form`并调用`addMessage`吗？看一下。我们的表单及其`submit`指令如下所示：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, inside the `methods` section, we actually had the `addMessage` method
    defined:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在“methods”部分，我们实际上定义了“addMessage”方法：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Does it start to make more sense now?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始更有意义了吗？
- en: 'Just to understand it better, let''s add some methods to our zoo page! Wouldn''t
    it be nice if you could compose your own zoo? Let''s add a multiple select element
    that will contain all possible options, and your zoo will be populated from something
    that you actually choose! So, let''s do the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们在我们的动物园页面上添加一些方法！如果你能组成自己的动物园，那不是很好吗？让我们添加一个多选元素，它将包含所有可能的选项，你的动物园将从你实际选择的东西中填充！所以，让我们这样做：
- en: Add more animals to our `animalCodes` map
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的`animalCodes`映射添加更多动物
- en: Add another array called `animalsForZoo`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加另一个名为`animalsForZoo`的数组
- en: Use this new array in our ordered list that displays the zoo
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显示动物园的有序列表中使用这个新数组
- en: Add a multiple `select` box composed of the keys of the `animalCodes` map
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个由`animalCodes`映射的键组成的多选`select`框
- en: Attach a `@change` listener to this select box that will call the `populateAnimalsForZoo`
    method
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个`@change`监听器附加到这个选择框，它将调用`populateAnimalsForZoo`方法
- en: Create a `populateAnimalsForZoo` method that will populate the `animalsForZoo`
    array with the selected options from our multiple select element
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`populateAnimalsForZoo`方法，它将使用从我们的多选元素中选择的选项填充`animalsForZoo`数组
- en: 'Doesn''t it sound easy? Of course, it does! Let''s get started. So, at first,
    add more animals to our `animalCodes` map:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很容易吧？当然，是的！让我们开始吧。所以，首先，向我们的`animalCodes`映射添加更多动物：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s also rethink our `animals` array and generate it out of our map. In
    this way, every time we need to add some new animal, we just add its key-value
    name-unicode to the mapping object instead of maintaining both object and array.
    So, our `animals` array will look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新思考一下我们的`animals`数组，并根据我们的映射生成它。这样，每当我们需要添加新的动物时，我们只需将其键值名称-unicode添加到映射对象中，而不是维护对象和数组。所以，我们的`animals`数组将如下所示：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we need another empty array. Let''s call it `animalsForZoo`, and let''s
    populate our zoo from this new array. Since it is empty, our zoo will also be
    empty. However, we are about to create a method that will populate this array.
    So, creating an array is easy, and don''t forget to export it in a data object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要另一个空数组。让我们称之为`animalsForZoo`，并让我们从这个新数组中填充我们的动物园。因为它是空的，我们的动物园也将是空的。然而，我们即将创建一个填充这个数组的方法。所以，创建一个数组很容易，不要忘记在数据对象中导出它：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Don''t forget to replace the usage of the `animals` array in our zoo display
    with the new `animalsForZoo` array:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记用新的`animalsForZoo`数组替换我们动物园展示中对`animals`数组的使用：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: I know that now you are worried that your zoo on the page is empty, but give
    us a couple of minutes and we will take care of that!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道现在你担心你页面上的动物园是空的，但给我们几分钟，我们会照顾好的！
- en: 'First of all, let''s create a multiple `select` element that will be populated
    based on the `animals` array:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个多选`select`元素，它将根据`animals`数组进行填充：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, finally, we will attach an event listener to our select box. Let''s attach
    a listener to the change event. Let''s tell it to call the `populateAnimalsForZoo`
    method. Our directive will look like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，我们将给我们的选择框添加一个事件监听器。让我们将监听器附加到change事件上。让我们告诉它调用`populateAnimalsForZoo`方法。我们的指令将如下所示：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The whole `select` element will obtain a new attribute:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`select`元素将获得一个新属性：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Great! But there''s no such method as `populateAnimalsForZoo`. But there''s
    us! Let''s create it. This method will just iterate through the checked options
    of the animals selected as input and push them into the `animalsForZoo` array:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！但是没有`populateAnimalsForZoo`这样的方法。但是有我们！让我们创建它。这个方法将只是遍历作为输入选择的动物的选中选项，并将它们推入`animalsForZoo`数组中：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Check out how the whole HTML and JavaScript code look after all these changes
    in the `chapter2/example1-vue-intro/index.html` file. This is how our testing
    page looks after the changes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 查看在`chapter2/example1-vue-intro/index.html`文件中所有这些更改后整个HTML和JavaScript代码的样子。这是我们在更改后的测试页面的样子：
- en: '![Handling events](../images/00035.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![处理事件](../images/00035.jpeg)'
- en: The zoo is being populated based on the user's choice
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 动物园是根据用户的选择进行填充的
- en: The page is messy, right? However, look how many things you have already learned
    just by using this page. And, admit it, it's a fun learning process! And we are
    not done with it yet.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 页面很混乱，对吧？然而，看看你已经通过使用这个页面学到了多少东西。而且，承认吧，这是一个有趣的学习过程！我们还没有完成。
- en: 'Now that you have learned how to add methods and event listeners, I will teach
    you how we could have done the exact same thing without this method and `v-bind:change`.
    Remove all the code we just added and just add `v-model` to our `select` element
    with the `animalsForZoo` value :'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何添加方法和事件监听器，我将教你如何在没有这个方法和`v-bind:change`的情况下完成完全相同的事情。删除我们刚刚添加的所有代码，只需在我们的`select`元素中添加`v-model`和`animalsForZoo`值：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, everything we have just done inside the method is handled automatically
    by Vue! Isn't it great?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们刚刚在方法中所做的一切都被Vue自动处理了！是不是很棒？
- en: Vue components
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue组件
- en: We came to this chapter having a midsize HTML page in our hands that contains
    a lot of different parts. We could have thought of more things, for example, adding
    interactivity to each animal of our zoo, adding the possibility of feeding animals,
    or having some interesting facts about each animal showing up every time you hover
    over the animal's icon. At some point, let's face it, the HTML file along with
    its JavaScript will become unmaintainable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来到这一章时手头上有一个中等大小的HTML页面，其中包含了许多不同的部分。我们可以想到更多的事情，比如为动物园中的每只动物添加互动性，添加喂养动物的可能性，或者在每次你悬停在动物图标上时显示每只动物的有趣事实。在某个时候，让我们面对现实吧，HTML文件以及它的JavaScript将变得难以维护。
- en: Can you also see that our visualization layer (HTML) works along with our logical
    layer (JavaScript)? So, they kind of form blocks, items, bricks… For example,
    we have a piece of code that is responsible for the **Hello** name section. We
    have another block that contains our zoo. Each animal in the zoo is another item.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你也能看到我们的可视化层（HTML）与我们的逻辑层（JavaScript）一起工作吗？所以，它们有点像形成了块、项目、砖块... 例如，我们有一段代码负责**Hello**名称部分。我们有另一个包含我们动物园的块。动物园中的每只动物都是另一个项目。
- en: Call these things whatever you want, but they are undeniably separated pieces
    of structure and logic that, when brought together, form the whole puzzle. If
    you build a wall from a unique piece of material and decide to change some parts
    of the wall, it will not be the easiest task.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你想怎么称呼这些东西，它们无可否认地是结构和逻辑的分离部分，当它们聚集在一起时，形成了整个拼图。如果你用一块独特的材料建造一堵墙，并决定改变墙的一些部分，这将不是一件容易的事情。
- en: 'So, imagine, you build this wall and incorporate some yellow stars, blue polygons,
    red squares, and so on into it. Then, you decide that your yellow stars should
    be black. You have to change all your stars. Then, you decide that your green
    ellipsis should be a smiling face instead. What now? Change all ellipses, but
    first you have to find all the places in the wall that contain those ellipses.
    This is your wall, try to find all ellipses in it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，想象一下，你建造了这堵墙，并将一些黄色的星星、蓝色的多边形、红色的正方形等等融入其中。然后，你决定你的黄色星星应该是黑色的。你必须改变所有的星星。然后，你决定你的绿色椭圆应该是一个笑脸。现在怎么办？改变所有的椭圆，但首先你必须找到墙上包含这些椭圆的所有位置。这是你的墙，试着找到其中的所有椭圆：
- en: '![Vue components](../images/00036.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Vue组件](../images/00036.jpeg)'
- en: The wall built as a whole piece with incorporated parts of different colors
    and forms
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 墙是作为一个整体建造的，其中包含了不同颜色和形状的部分
- en: 'Now, imagine that each piece actually resides on its individual brick. You
    can change them, add them, and remove them as much as you want. If you want to
    change the appearance of some of the wall elements, you just change this one brick
    and all the wall pieces containing this brick will change, because *all in all,
    it''s just another brick in the wall*. So, instead of having the wall full of
    incorporated strange pieces, you have four bricks, and you change them whenever
    you need to change the piece of wall that relies on that brick:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象每个部分实际上都存在于它们各自的砖块上。你可以随意更改它们，添加它们，以及移除它们。如果你想改变一些墙体元素的外观，你只需要改变这一个砖块，所有包含这个砖块的墙体部分都会改变，因为*总的来说，它只是墙上的另一块砖*。所以，与其让墙体充满各种奇怪的内嵌部件，你只需要四块砖，然后在需要改变依赖于这块砖的墙体部分时进行更改：
- en: '![Vue components](../images/00037.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Vue组件](../images/00037.jpeg)'
- en: If you need to change the appearance of an element in the wall, you just change
    the corresponding brick
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要改变墙上的一个元素的外观，你只需要改变相应的砖块
- en: 'The wall is composed of bricks. These bricks are our components. What if we
    could also have components built with HTML, CSS, and JavaScript and our application
    could be built of those components? Did I just say "what if"? There''s no "what
    if." We already have it. Vue.js supports component-based application structure.
    It''s really easy to create components with Vue.js. The only three things you
    have to do are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 墙是由砖块组成的。这些砖块就是我们的组件。如果我们还可以用HTML、CSS和JavaScript构建组件，并且我们的应用程序可以由这些组件构建呢？我刚刚说“如果”吗？没有“如果”。我们已经有了。Vue.js支持基于组件的应用程序结构。使用Vue.js创建组件非常容易。你需要做的只有三件事：
- en: Create a component, and give it a template, data, methods, and whatever you
    need to give to it.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个组件，并给它一个模板、数据、方法，以及你需要给它的任何东西。
- en: Register it in the Vue app under the `components` object.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Vue应用程序中注册它，放在`components`对象下面。
- en: Use it within the application's template.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的模板中使用它。
- en: 'For example, let''s create a component that will simply render a header element
    saying **Hello**. Let''s call it `HelloComponent`. It will only contain the template
    string:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个简单渲染一个标题元素说**Hello**的组件。让我们称之为`HelloComponent`。它只包含模板字符串：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we can register this component inside our Vue application initialization
    code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在Vue应用程序初始化代码中注册这个组件：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, this component can actually be used inside the HTML section of the Vue
    application''s element:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个组件实际上可以在Vue应用程序元素的HTML部分中使用：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So, the whole section will look something like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，整个部分看起来会是这样的：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Someone might ask, "What''s so powerful in these components?" The amount of
    written code is actually the same as if I would have just written a piece of HTML
    that does the same. What''s the point? Yes, sure, but in this example, our component
    had just one template inside. A template composed of one line only. We could have
    a huge template in there, and we could have some methods in this component and
    also its own data! Let''s, for example, add an input for the name to this component
    and the name to its data object:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会问，“这些组件有什么强大之处？”实际上，编写的代码量与我只编写了一个做同样事情的HTML代码是一样的。有什么意义呢？是的，当然，但在这个例子中，我们的组件只有一个内部模板。一个只有一行的模板。我们可以在里面放一个巨大的模板，并且我们可以在这个组件中添加一些方法和它自己的数据！比如，让我们给这个组件添加一个输入框用于输入名字，并将名字添加到它的数据对象中：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you need to reuse this component, you can do it as many times as you want:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要重复使用这个组件，你可以随意多次使用：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, you will end up with three independent components on your page:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将在你的页面上得到三个独立的组件：
- en: '![Vue components](../images/00038.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Vue组件](../images/00038.jpeg)'
- en: Using components helps avoid repeated code
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件有助于避免重复的代码
- en: These components are very nice, but there's still a big amount of code written
    within the same JavaScript code block. We declare components all in one place,
    and if there are too many of them, the application will become unmanageable again.
    Besides that, this HTML code within the template string is also not the most maintainable
    thing ever.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件非常好，但仍然有大量的代码写在同一个JavaScript代码块中。我们在一个地方声明所有组件，如果组件太多，应用程序将再次变得难以管理。此外，在模板字符串中的HTML代码也不是最可维护的东西。
- en: Well, if you are thinking so, I have some good news for you. Each component
    can be stored in its own file with its own HTML, JavaScript, and CSS code. These
    are special files with the `.vue` extension. Inside each file, there's a `<script>`
    section for the JavaScript code, a `<style>` section for the CSS code, and a`<template>`
    section for the HTML code. Isn't it convenient? Such components are called single-file
    components. Have a look at the first chapter's code—there's a main component called
    `App.vue` and there's also the `MessageCard.vue` component created by us. Isn't
    it nice?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是这样想的，我有一些好消息要告诉你。每个组件都可以存储在自己的文件中，具有自己的HTML、JavaScript和CSS代码。这些是带有`.vue`扩展名的特殊文件。在每个文件中，有一个用于JavaScript代码的`<script>`部分，一个用于CSS代码的`<style>`部分，以及一个用于HTML代码的`<template>`部分。这不是很方便吗？这些组件被称为单文件组件。看看第一章的代码——有一个名为`App.vue`的主组件，还有我们创建的`MessageCard.vue`组件。是不是很好？
- en: 'If you want to use single-file components in your application, you must scaffold
    this application using some modular bundler, for example, `webpack`. We already
    talked about `vue-cli` and how easy it is to bootstrap a Vue application using
    the `webpack` template. Let''s port the messy page with zoo to the `webpack` bundled
    application. Run the initialization and installation scripts:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的应用程序中使用单文件组件，你必须使用一些模块化捆绑工具来搭建这个应用程序，例如`webpack`。我们已经谈论过`vue-cli`以及使用`webpack`模板轻松引导Vue应用程序的方法。让我们将混乱的动物园页面移植到`webpack`捆绑应用程序中。运行初始化和安装脚本：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, open the `App.vue` file and let''s fill it up with our messy zoo application.
    The `<script>` section looks like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`App.vue`文件，让我们用混乱的动物园应用程序填充它。`<script>`部分看起来是这样的：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note the highlighted areas. I've copied the images into the `static` folder.
    Another important thing is that the data inside the component should be used as
    a function that returns an object and not as an object itself. Since the data
    object will still be one single instance across multiple components, the whole
    data object with its properties must be assembled in a dedicated function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意高亮显示的区域。我已经将图片复制到`static`文件夹中。另一个重要的事情是，组件内部的数据应该被用作返回对象的函数，而不是作为对象本身。由于数据对象仍然会成为多个组件中的一个单一实例，整个数据对象及其属性必须在一个专用函数中组装。
- en: The rest of the script is completely the same.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的其余部分完全相同。
- en: The template area of the component is pretty much the same as the HTML structure
    from the previous example. Check out the code in the `chapter2/example3-components-started`
    folder.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的模板区域与前面示例中的HTML结构基本相同。查看`chapter2/example3-components-started`文件夹中的代码。
- en: 'Let''s extract some of the functionality into the individual component. What
    do you think if we extract the zoo to its individual component? Create a `Zoo.vue`
    file in the `components` folder. Copy the template for the animals list to this
    component''s `<template>` area:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一些功能提取到各个单独的组件中。如果我们将动物园提取到单独的组件中，你觉得怎么样？在`components`文件夹中创建一个`Zoo.vue`文件。将动物列表的模板复制到这个组件的`<template>`区域：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we should tell this component that it will receive `animals`, `name`,
    and `animalCodes` properties from the parent component that will call the following
    component:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该告诉这个组件，它将从调用以下组件的父组件那里接收`animals`、`name`和`animalCodes`属性：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, open the main `App.vue` component, import the `Zoo` component, and export
    it in the `components` object:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开主`App.vue`组件，导入`Zoo`组件，并在`components`对象中导出它：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can use this component inside the template! So, replace the whole `div`
    tagthat contains our zoo with just the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在模板中使用这个组件了！所以，用以下代码替换包含我们动物园的整个`div`标签：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Check out the page! Everything works as it did earlier!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 查看页面！一切都像以前一样工作！
- en: Exercise
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Extract an animal to the individual component and call it inside the zoo within
    the `v-for` directive. Each animal has to have a small functionality that will
    display a small description when clicking its face (on `click`). I am pretty sure
    you will easily solve this exercise. If you need help, check out this chapter's
    code inside the `example4-components/zoo` directory.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将动物提取为单独的组件，并在`v-for`指令内部调用它在动物园中。每个动物都必须有一个小功能，点击它的脸（在`click`上）时会显示一个小描述。我相信你会很容易解决这个练习。如果你需要帮助，请查看`example4-components/zoo`目录中的本章代码。
- en: Vue router
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue路由器
- en: '**Single Page Applications** (**SPA**) are great. They came to make our life
    easier. And it definitely is. With a bit of JavaScript code, you can achieve all
    the functionality that had to be done on the server side before, and the whole
    page should have been replaced just to display the result of that functionality.
    It is a golden era for web developers now. However, there is a problem that SPAs
    are trying to solve—*navigation*. History API and the `pushState` method ([https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API))
    are already solving it, but it has been a long process until it became an established
    technology.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用程序**（**SPA**）很棒。它们让我们的生活变得更加轻松。而且确实如此。通过一点JavaScript代码，你可以实现以前必须在服务器端完成的所有功能，而整个页面应该被替换以显示该功能的结果。现在对于Web开发人员来说是黄金时代。然而，SPA试图解决的问题是*导航*。历史API和`pushState`方法（[https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)）已经在解决这个问题，但直到它成为一种成熟的技术，这个过程已经很长时间了。'
- en: Our users are used to controlling their *where I am and where I want to be*
    using browsers' navigation buttons. If the whole functionality is located on the
    same page, how will these buttons help with the navigation? How do you use Google
    analytics to check which page (that, in fact, is the same) is being accessed more
    by your users? The whole concept is totally different. Of course, these kinds
    of applications are a lot faster because the number of requests is significantly
    reduced, and of course, our users are grateful for that, but they are not changing
    their web surfing habits just because we changed the way we implement things.
    They still want to go *back*. They expect that if they refresh the page, the page
    will open on exactly the same place where they were right before hitting the refresh
    button. They expect that they will understand where they are just by looking at
    the page's URL and checking what's behind the slash. For example, if it's `http://mySite/store`
    then it's a store; if it's `http://mySite/settings`, then most likely I'm somewhere
    where I can check my current settings and change them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户习惯于使用浏览器的导航按钮来控制他们的“我在哪里”和“我想去哪里”。如果整个功能位于同一页上，这些按钮如何帮助导航？你如何使用Google分析来检查你的用户更多地访问哪个页面（实际上是相同的）？整个概念完全不同。当然，这些应用程序速度更快，因为请求的数量大大减少，当然，我们的用户对此表示感激，但他们并没有因为我们改变了实现方式而改变他们的网页浏览习惯。他们仍然想要“返回”。他们期望如果他们刷新页面，页面将在刷新按钮之前的确切位置打开。他们期望通过查看页面的URL并检查斜杠后面的内容来理解他们在哪里。例如，如果是`http://mySite/store`，那么这是一个商店；如果是`http://mySite/settings`，那么很可能我在某个地方可以查看我的当前设置并更改它们。
- en: There are a lot of ways to achieve navigation without having to transform single-page
    applications into multiple-page applications. You can include an extra layer of
    logic on your application and change `window.location.href` every time a different
    URL is required—this will cause the page to refresh, which is not nice. You can
    also use HTML5 `history` API. It would not be the simplest thing to maintain,
    but it might work.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以实现导航，而不必将单页面应用程序转换为多页面应用程序。你可以在应用程序上包含额外的逻辑，并在需要不同URL时更改`window.location.href`，这将导致页面刷新，这并不好。你也可以使用HTML5的`history`
    API。这可能不是最简单的维护方式，但可能有效。
- en: We all know that good developers are lazy, right? Being lazy means not solving
    problems that are already solved by someone else. This problem of navigation is
    being solved by many frameworks and libraries. Not only can you use some third-party
    libraries that help you deal with the routing in your application, but you can
    also use the mechanisms provided by the framework of your choice. Vue.js is one
    of the frameworks that offers a way of dealing with routing. You just map the
    URL path to your components and everything just works! Check out the official
    documentation of `vue-router` library at [https://router.vuejs.org/en/](https://router.vuejs.org/en/).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道好的开发者是懒惰的，对吧？懒惰意味着不解决已经有人解决的问题。导航问题正在被许多框架和库解决。你不仅可以使用一些帮助你处理应用程序中路由的第三方库，还可以使用你选择的框架提供的机制。Vue.js是提供处理路由的框架之一。你只需将URL路径映射到你的组件，一切都会正常工作！查看`vue-router`库的官方文档[https://router.vuejs.org/en/](https://router.vuejs.org/en/)。
- en: 'In order to be able to use `vue-router`, you must install it for your project:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用`vue-router`，你必须为你的项目安装它：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Optionally, `vue-router` usage can be selected on the Vue project initialization
    with `vue init`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，可以在Vue项目初始化时选择使用`vue-router`。
- en: 'Now, you can use Vue router in your application. Just tell Vue to use it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在你的应用程序中使用Vue路由器。只需告诉Vue使用它：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s create a simple routing example. We will have three components, one
    of which we consider as the `Home` component, meaning that it should be shown
    when someone navigates to the root route `/`. Let''s call the second one `Hello`
    component and the third one `Bye` component. Open the `example5-router-started`
    code files from [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained*. You will find all the described components in the `components` directory:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的路由示例。我们将有三个组件，其中一个被视为`Home`组件，意味着当有人导航到根路由`/`时应该显示它。让我们称第二个为`Hello`组件，第三个为`Bye`组件。从[第2章](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "第2章。底层-教程解释")中打开`example5-router-started`代码文件，*底层-教程解释*。你会在`components`目录中找到所有描述的组件：
- en: '![Vue router](../images/00039.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Vue router](../images/00039.jpeg)'
- en: The structure of the example application where we are going to try Vue router
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试Vue路由的示例应用程序的结构
- en: Now, we must create a `router` instance. The constructor receives the `options`
    object as a parameter. This object can contain different configurable values.
    The most important one is the array of `routes`. Each entry of this array should
    consist of an object that indicates the `path` of the route and its corresponding
    `component`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个`router`实例。构造函数接收`options`对象作为参数。这个对象可以包含不同的可配置值。最重要的是`routes`数组。这个数组的每个条目都应该包含一个指示路由的`path`和其对应`component`的对象。
- en: 'First, we will import all the needed components, and then, our `router` instance
    will look like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将导入所有需要的组件，然后，我们的`router`实例将如下所示：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you want to understand better what the `mode:` `history` option is, check
    out the documentation page at [https://router.vuejs.org/en/essentials/history-mode.html](https://router.vuejs.org/en/essentials/history-mode.html)
    that explains it in a really nice manner. Now, we have to pass the router option
    to our Vue application. This option will point to our new `router` instance:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更好地理解`mode:` `history`选项是什么，请查看文档页面[https://router.vuejs.org/en/essentials/history-mode.html](https://router.vuejs.org/en/essentials/history-mode.html)，它以非常好的方式解释了它。现在，我们必须将路由选项传递给我们的Vue应用程序。这个选项将指向我们的新`router`实例：
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, the whole application knows that we use this router. One more important
    step: we need to include the router component into the main component''s template.
    For this, it is enough to just include the `<router-view>` tag in the `App.vue`
    component''s template:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个应用程序都知道我们使用了这个路由。还有一个重要的步骤：我们需要将路由组件包含到主组件的模板中。为此，只需在`App.vue`组件的模板中包含`<router-view>`标签即可：
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Check out in more detail the `router-view` component at [https://router.vuejs.org/en/api/router-view.html](https://router.vuejs.org/en/api/router-view.html).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://router.vuejs.org/en/api/router-view.html](https://router.vuejs.org/en/api/router-view.html)中更详细地查看`router-view`组件。
- en: 'Voilà! Run the application if you haven''t done so already:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！如果你还没有运行应用程序，请运行：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Open the page at `http://localhost:8080` and check that it is displaying our
    home page component. Then, type `http://localhost:8080/hello` and `http://localhost:8080/bye`
    in the browser''s address bar. Check that the content of the page actually changes
    according to the URL path:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面`http://localhost:8080`，检查它是否显示我们的主页组件。然后，在浏览器的地址栏中输入`http://localhost:8080/hello`和`http://localhost:8080/bye`。检查页面的内容是否根据URL路径实际改变：
- en: '![Vue router](../images/00040.jpeg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Vue router](../images/00040.jpeg)'
- en: Basic routing with vue-router
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用vue-router进行基本路由
- en: 'Of course, you are already thinking about how to create a simple menu, pointing
    an anchor `<a>` element to your defined paths in the router. Don''t think too
    much. Just use a `<router-link>` component with the `to` attribute pointing to
    the path of your choice. For example, to display a simple navigational menu for
    our router example application, we could write something like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你已经在考虑如何创建一个简单的菜单，将锚点`<a>`元素指向路由器中定义的路径。不要想太多。只需使用一个带有`to`属性的`<router-link>`组件，指向您选择的路径。例如，为了在我们的路由器示例应用程序中显示一个简单的导航菜单，我们可以写出类似这样的东西：
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Alternatively, if you don''t want to write your paths all over again, you can
    reference your routes by name and use the `v-bind:to` directive or simply use
    `:to`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你不想再次编写你的路径，你可以通过名称引用你的路由，并使用`v-bind:to`指令或简单地使用`:to`：
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Check how the code looks in the `example6-router` folder.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`example6-router`文件夹中的代码是什么样子。
- en: Open the page and check whether all the links actually work! Click on them several
    times and check whether you will actually go back if you click on the browser's
    go back button. Isn't it fantastic?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面，检查所有链接是否实际上都起作用！多次点击它们，并检查是否在点击浏览器的返回按钮时实际上会返回。这不是很棒吗？
- en: Vuex state management architecture
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vuex状态管理架构
- en: Do you remember our example with the `Zoo` and `animal` components? There was
    some data that had to be propagated from the main component to the child component
    of the child component. If this grandchild component had the possibility of somehow
    changing data, this change would have to be propagated from the child component
    to its parent component and so on until data reaches the main component. Don't
    think that you would do it simply with a `v-model` binding attribute. Vue has
    some restrictions regarding binding data to the children components via `props`.
    It is strictly one way. So, if the parent component changes the data, the child
    component's bindings will be affected, but it will never happen the other way
    around. Check out Vue's official documentation in regarding this at [https://vuejs.org/v2/guide/components.html#One-Way-Data-Flow](https://vuejs.org/v2/guide/components.html#One-Way-Data-Flow).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们的`Zoo`和`animal`组件的例子吗？有一些数据必须从主组件传播到子组件的子组件。如果这个孙子组件有可能以某种方式改变数据，这种改变就必须从子组件传播到其父组件，依此类推，直到数据到达主组件。不要认为你可以简单地使用`v-model`绑定属性来做到这一点。Vue在通过`props`将数据绑定到子组件方面有一些限制。它是严格的单向的。因此，如果父组件改变了数据，子组件的绑定将受到影响，但反过来永远不会发生。查看Vue官方文档关于此的说明：[https://vuejs.org/v2/guide/components.html#One-Way-Data-Flow](https://vuejs.org/v2/guide/components.html#One-Way-Data-Flow)。
- en: 'If you don''t believe me, let''s try it. Imagine that in our zoo page example,
    we would extract the introduction part to the separate component. I am talking
    about this part of our messy zoo page:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不相信我，让我们来试试。想象一下，在我们的动物园页面示例中，我们将介绍部分提取到单独的组件中。我在谈论我们混乱的动物园页面的这部分：
- en: '![Vuex state management architecture](../images/00041.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![Vuex状态管理架构](../images/00041.jpeg)'
- en: What if we'd like to extract this part to the separate component?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将这部分提取到单独的组件中，会怎样？
- en: 'It seems easy. We have to declare a component, let''s say `Introduction`, tell
    it that it will receive the `name` property, and just copy-paste HTML from `App.vue`
    to this new component. Inside `App.vue`, we will import this new component and
    export it inside the `components` object of the Vue instance. Of course, we will
    replace the HTML that we already copied to the new component with the `<introduction>`
    tag and bind the `name` property to it. Isn''t it easy? Our `Introduction.vue`
    file will look like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很容易。我们必须声明一个组件，比如`Introduction`，告诉它将接收`name`属性，并将`App.vue`中的HTML复制粘贴到这个新组件中。在`App.vue`中，我们将导入这个新组件，并在Vue实例的`components`对象中导出它。当然，我们将用`<introduction>`标签替换已经复制到新组件的HTML，并将`name`属性绑定到它。这不是很容易吗？我们的`Introduction.vue`文件将如下所示：
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Our `App.vue` file will import, export, and call:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`App.vue`文件将导入、导出和调用：
- en: '[PRE62]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Check out this code in the code bundle of the [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained* in the `example7-events-started/zoo` folder. Run `npm install` and
    `npm run` inside this folder:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3 "第2章。底层-教程解释")的代码包中查看此代码，*底层-教程解释*在`example7-events-started/zoo`文件夹中运行`npm
    install`和`npm run`：
- en: '[PRE63]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Check out the page. It looks like it did before. Try to change the name inside
    the input. First of all, it doesn''t change in other places where it should change,
    and second, our dev tools console is full of warnings and errors:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 查看页面。它看起来和以前一样。尝试在输入框内更改名称。首先，它不会在应该更改的其他地方更改，其次，我们的开发工具控制台充满了警告和错误：
- en: '![Vuex state management architecture](../images/00042.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![Vuex状态管理架构](../images/00042.jpeg)'
- en: The name is not updated where it should have been updated, and the console is
    full of errors
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 名称没有在应该更新的地方更新，控制台充满了错误
- en: 'It seems the documentation is right: we can''t change the value of data passed
    as property to the child component. What can we do then? We can emit events and
    attach event listeners to the component, and change the data on the event. How
    do we do this? It''s simple. First of all, let''s call the property being passed
    by something that is not `name`, for example, `initialName`. Then, open the `Introduction`
    component and create a `data` function that will bind this component''s `name`
    object to `initialValueprops`. In this way, we are at least telling Vue that it
    is not our intention to try to change parent''s data from the child. So, `script`
    of the `Introduction.vue` component will look like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来文档是正确的：我们不能更改作为属性传递给子组件的数据的值。那我们该怎么办呢？我们可以发出事件并将事件监听器附加到组件，并在事件上更改数据。我们该怎么做呢？很简单。首先，让我们将被传递的属性称为不是`name`的东西，例如`initialName`。然后，打开`Introduction`组件并创建一个`data`函数，将这个组件的`name`对象绑定到`initialValueprops`。这样，我们至少告诉Vue，我们并不打算尝试从子组件更改父级的数据。因此，`Introduction.vue`组件的`script`将如下所示：
- en: '[PRE64]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We also have to change the way we bind name to the component inside `App.vue`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须改变我们在`App.vue`中将名称绑定到组件的方式：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, if you check the page, you will at least see that Vue doesn''t complain
    anymore about something illegal that we try to do. However, still, if we try to
    change the name, the changes are not propagated to the parent, which is quite
    understandable; these changes only affect the data of the component itself. Now,
    we have to attach the `event` to the `input` element. This event will call a method
    that will finally emit the event to the parent component:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你检查页面，你至少会看到Vue不再抱怨我们试图做一些非法的事情。然而，如果我们试图更改名称，更改不会传播到父级，这是可以理解的；这些更改只影响组件本身的数据。现在，我们必须将`event`附加到`input`元素。这个事件将调用一个最终将事件传递给父组件的方法：
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, the only thing we have to do is to bind the `nameChanged` event listener
    to the `<introduction>` component and call the method that will change the name
    of the `App.vue` data object:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们唯一需要做的就是将 `nameChanged` 事件监听器绑定到 `<introduction>` 组件，并调用会改变 `App.vue` 数据对象名称的方法：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Check the page. Now, everything works as before! Check the code for this solution
    inside the `example7-events/zoo` code folder for this chapter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 检查页面。现在，一切都和以前一样！检查本章的 `example7-events/zoo` 代码文件夹中的解决方案代码。
- en: Well, it was not very difficult, but do we want to emit all these events every
    time we need to update the state? And what if we have components inside the components?
    And what if we have other components inside those components? Will it be the events
    handling hell? And if we have to change something, will we have to go to all those
    components? Argh! Wouldn't it be great to have the application's data in some
    kind of centralized storage that would provide a simple API for its management
    and then we could just call this storage's methods in order to retrieve and update
    the data? Well, this is exactly what Vuex is for! Vuex is a centralized state
    management inspired by Redux. Check out its official documentation at [http://vuex.vuejs.org/en/](http://vuex.vuejs.org/en/).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不是很困难，但是我们是否想要在每次更新状态时发出所有这些事件？如果我们在组件内部有组件呢？如果我们在这些组件内部有其他组件呢？这会是事件处理的地狱吗？如果我们需要改变一些东西，我们是否需要去所有这些组件？啊！有没有一个集中式存储应用程序数据的地方，可以提供一个简单的
    API 来管理数据，然后我们只需要调用这个存储的方法来检索和更新数据？嗯，这正是 Vuex 的用途！Vuex 是受 Redux 启发的集中式状态管理。查看它的官方文档
    [http://vuex.vuejs.org/en/](http://vuex.vuejs.org/en/)。
- en: 'Now, in a nutshell, the three most important parts of a Vuex store are state,
    getters, and mutations:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，简而言之，Vuex store 的三个最重要的部分是 state、getters 和 mutations：
- en: '**State**: This is an initial state of the application, basically the data
    of the application'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**State**：这是应用程序的初始状态，基本上是应用程序的数据'
- en: '**Getters**: These are exactly what you think, functions that return data from
    the store'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Getters**：这正是你所想的，从 store 返回数据的函数'
- en: '**Mutations**: These are functions that can mutate data on the store'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mutations**：这些是可以改变 store 上的数据的函数'
- en: A store can also have actions. These things are like wrappers for mutations
    with a bit more capacity. If you want to check what are they about, refer to the
    official documentation at [http://vuex.vuejs.org/en/mutations.html](http://vuex.vuejs.org/en/mutations.html).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 store 也可以有 actions。这些东西就像是对 mutations 的包装，具有更多的功能。如果你想了解它们是什么，请参考官方文档 [http://vuex.vuejs.org/en/mutations.html](http://vuex.vuejs.org/en/mutations.html)。
- en: 'Let''s add the Vuex store to our `Zoo` application to check how it works. First
    of all, we need to install `vuex`. Open the code for [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained* from the `example8-store-started/zoo` folder and run `npm install`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 Vuex store 添加到我们的 `Zoo` 应用程序中，以检查它的工作原理。首先，我们需要安装 `vuex`。打开 [第2章](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "第2章。底层 - 教程解释") 的代码，从 `example8-store-started/zoo` 文件夹中运行 `npm install`：
- en: '[PRE68]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s create our store. Start by creating a folder named `store` with the
    `index.js` file inside. We will put all our store data inside this file. Before
    doing this, tell Vue that we will use Vuex:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的 store。首先创建一个名为 `store` 的文件夹，里面放有 `index.js` 文件。我们将把所有的 store 数据放在这个文件中。在做这之前，告诉
    Vue 我们将使用 Vuex：
- en: '[PRE69]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can create a new Vuex instance. It should receive `state`, `getters`,
    and `mutations`. Let''s define them:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个新的 Vuex 实例。它应该接收 `state`、`getters` 和 `mutations`。让我们定义它们：
- en: '[PRE70]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Nice! Now, let''s add all the data that resides in our application to the state:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！现在，让我们将我们应用程序中的所有数据添加到状态中：
- en: '[PRE71]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, if you inject the store on the Vue application initialization, all the
    components and their children will have access to the `this.$store` instance.
    Let''s inject it:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在Vue应用程序初始化时注入存储，所有组件及其子组件都将访问`this.$store`实例。让我们注入它：
- en: '[PRE72]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, if we replace all the data with computed properties from the store in
    `App.vue` (except `animalsForZoo`, which is bound as a property for our zoo),
    the application will look quite the same:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在`App.vue`中用来自存储的计算属性替换所有数据（除了`animalsForZoo`，它作为我们动物园的属性绑定），应用程序看起来将基本相同：
- en: '[PRE73]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If you open the page, nothing has changed. However, our changing name interaction
    doesn't work again!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开页面，什么都没有改变。但是，我们的更改名称交互又不起作用了！
- en: 'Let''s add `mutation` to change the name. Mutations are just methods that receive
    a state as first argument and anything you call them with as other parameters.
    So, let''s call our mutation `updateName` and pass `newName` to it as a second
    argument:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`mutation`来改变名称。Mutations只是接收状态作为第一个参数以及您调用它们的任何其他参数的方法。因此，让我们称我们的mutation为`updateName`，并将`newName`作为第二个参数传递给它：
- en: '[PRE74]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we can use this mutation to access the `this.$store.mutation` property
    inside the component responsible for updating the name—`Introduction.vue`. We
    have to just change the `onInput` method:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用此mutation来访问负责更新名称的组件`Introduction.vue`中的`this.$store.mutation`属性。我们只需更改`onInput`方法：
- en: '[PRE75]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'By the way, we can also remove the properties and pass the name directly from
    the store, just like we did in the `App.vue` component. Then, you can remove the
    `name` binding to the `introduction` component inside the `App.vue` component''s
    template. Now, you can replace the properties that are bound to the Zoo component
    by computed properties coming from the store. See how elegant the code becomes!
    For example, look at this line of code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们还可以删除属性并直接从存储中传递名称，就像我们在`App.vue`组件中所做的那样。然后，您可以在`App.vue`组件的模板中删除绑定到`introduction`组件的`name`。现在，您可以用来自存储的计算属性替换绑定到Zoo组件的属性。看看代码变得多么优雅！例如，看看这行代码：
- en: '[PRE76]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Doesn''t it look better than the following line of code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来不比以下代码行好：
- en: '[PRE77]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Check out the final code for this chapter in the `example8-store/zoo` code folder
    for [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained*. Note that we have used a very simplified version. We have not even
    used any getters. For a more sophisticated use, we would create `getters` and
    `actions`, and they would have been located in their own `actions.js` and `getters.js`
    files. We would also use `mapGetters` and `mapActions` helpers. However, for basic
    understanding, what we have done is enough. Refer to the official documentation
    to find out more about Vuex store and how to use it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在`example8-store/zoo`代码文件夹中查看本章的最终代码[第2章](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "第2章。Under the Hood – Tutorial Explained")，*Under the Hood – Tutorial Explained*。请注意，我们使用了一个非常简化的版本。我们甚至没有使用任何getters。对于更复杂的用法，我们将创建`getters`和`actions`，它们将位于它们自己的`actions.js`和`getters.js`文件中。我们还将使用`mapGetters`和`mapActions`助手。但是，对于基本的理解，我们所做的就足够了。请参考官方文档以了解有关Vuex存储及其使用方法的更多信息。
- en: Bootstrap
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap
- en: Now that we know almost everything about Vue.js, let's talk about Bootstrap.
    Check out the official Bootstrap page at [https://v4-alpha.getbootstrap.com/](https://v4-alpha.getbootstrap.com/).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们几乎了解了关于Vue.js的一切，让我们谈谈Bootstrap。查看官方Bootstrap页面[https://v4-alpha.getbootstrap.com/](https://v4-alpha.getbootstrap.com/)。
- en: '![Bootstrap](../images/00043.jpeg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap](../images/00043.jpeg)'
- en: Bootstrap—framework for responsive projects
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap—响应式项目的框架
- en: In a nutshell, Bootstrap gives you a broad set of classes that allow building
    nearly everything with any layout in an easy and effortless way.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Bootstrap为您提供了一组广泛的类，可以以简单轻松的方式构建几乎任何布局。
- en: 'Bootstrap provides with you four most important things:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap为您提供了四个最重要的东西：
- en: Easy layouts building at [https://v4-alpha.getbootstrap.com/layout/overview/](https://v4-alpha.getbootstrap.com/layout/overview/)
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://v4-alpha.getbootstrap.com/layout/overview/](https://v4-alpha.getbootstrap.com/layout/overview/)上轻松构建布局
- en: Broad range of classes to style nearly any web element at [https://v4-alpha.getbootstrap.com/content/](https://v4-alpha.getbootstrap.com/content/)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://v4-alpha.getbootstrap.com/content/](https://v4-alpha.getbootstrap.com/content/)上有广泛的类来为几乎任何web元素设置样式
- en: Self-contained components such as alerts, budges, modals, and so on at [https://v4-alpha.getbootstrap.com/components/](https://v4-alpha.getbootstrap.com/components/)
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自包含组件，如警报、徽章、模态框等，位于[https://v4-alpha.getbootstrap.com/components/](https://v4-alpha.getbootstrap.com/components/)
- en: Some utilities for styling images, figures, for positioning, styling, and adding
    borders at [https://v4-alpha.getbootstrap.com/utilities/](https://v4-alpha.getbootstrap.com/utilities/)
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些用于样式化图像、图表、定位、样式化和添加边框的实用程序位于[https://v4-alpha.getbootstrap.com/utilities/](https://v4-alpha.getbootstrap.com/utilities/)
- en: 'How to install Bootstrap? It can be installed from the CDN:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如何安装Bootstrap？它可以从CDN安装：
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This is, actually, exactly what we have in the `PleaseIntroduceYourself` application
    from [Chapter 1](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 1. Please Introduce Yourself – Tutorial"), *Please Introduce Yourself
    – Tutorial*, and in the messy zoo application from this chapter.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这正是我们在[第1章](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "第1章。请介绍你自己 - 教程")的`PleaseIntroduceYourself`应用程序中所拥有的，*请介绍你自己 - 教程*，以及在本章中混乱的动物园应用程序中。
- en: Bootstrap components
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap组件
- en: Bootstrap has a lot of components that can be used just out of the box.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap有很多组件可以直接使用。
- en: I will not talk about all of them in this chapter, because we will have several
    opportunities to discover them during the course of the book. Let's look at some
    of them just to have an idea.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会讨论它们所有，因为在本书的过程中我们会有几次机会去发现它们。让我们看一些只是为了有个概念。
- en: 'Let''s look at the alert components. As you might know, alerts are nice elements
    that appear on the page when you have successfully filled in some form. Alerts
    are also those angry red elements that tell you that you''ve done something wrong.
    What would you need to create an alert element on the page that would disappear
    after some time or give the possibility to the user to close it by clicking on
    the **x** button? You would probably create a `div`, add some class to it, and
    add a bit of JavaScript that would remove the element from the DOM tree after
    a grace period. Using Bootstrap, you just add `alert` class to your `div` and
    add another class such as `alert-warning` or `alert-info` to specify which kind
    of alert it is:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看警报组件。你可能知道，警报是在成功填写某些表单时出现在页面上的漂亮元素。警报也是那些愤怒的红色元素，告诉你做错了什么。你需要在页面上创建一个警报元素，它会在一段时间后消失，或者给用户关闭它的可能性，只需点击**x**按钮？你可能会创建一个`div`，给它添加一些类，并添加一些JavaScript，它会在一段时间后从DOM树中移除元素。使用Bootstrap，你只需将`alert`类添加到你的`div`中，并添加另一个类，比如`alert-warning`或`alert-info`来指定警报的类型：
- en: '[PRE79]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This code will produce nice alert boxes that look like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将产生漂亮的警报框，看起来像这样：
- en: '![Bootstrap components](../images/00044.jpeg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap组件](../images/00044.jpeg)'
- en: Bootstrap alerts—success, info, warning, and danger
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap警报 - 成功、信息、警告和危险
- en: 'Even a simple element like a button can be styled in hundreds of different
    ways using Bootstrap. Again, you can have buttons indicating success, danger zone,
    being informative, or just gray. There''s a possibility of grouping buttons and
    making them look like a link. The code is pretty easy:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至像按钮这样的简单元素也可以使用Bootstrap以数百种不同的方式进行样式设置。同样，您可以有表示成功、危险区域、信息性或只是灰色的按钮。还有可能将按钮分组并使其看起来像链接。代码非常简单：
- en: '[PRE80]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This code will produce buttons as shown here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将生成如下所示的按钮：
- en: '![Bootstrap components](../images/00045.jpeg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap组件](../images/00045.jpeg)'
- en: Bootstrap buttons
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap按钮
- en: icial documentation page at [https://v4-alpha.getbootstrap.com/components/buttons/](https://v4-alpha.getbootstrap.com/components/buttons/).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://v4-alpha.getbootstrap.com/components/buttons/](https://v4-alpha.getbootstrap.com/components/buttons)上的官方文档页面。'
- en: 'One of my favorite things about Bootstrap is that you might have a trivial
    element, but then you add some of the Bootstrap''s classes to it and it suddenly
    becomes clean and nice. For example, create a simple page with some `<h1>` and
    `<p>` elements:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Bootstrap我最喜欢的一点是，您可能有一个微不足道的元素，但是当您为其添加一些Bootstrap的类时，它突然变得干净而漂亮。例如，创建一个带有一些`<h1>`和`<p>`元素的简单页面：
- en: '[PRE81]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: It will look normal, simple. Now, add the `container` class to the parent `div`.
    Isn't it much nicer? Also, add the `jumbotron` class to it.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来正常，简单。现在，将`container`类添加到父`div`中。是不是好多了？还可以将`jumbotron`类添加到其中。
- en: 'The page looked like this earlier:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 页面之前看起来是这样的：
- en: '![Bootstrap components](../images/00046.jpeg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap组件](../images/00046.jpeg)'
- en: The content inside the div before adding Bootstrap classes
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加Bootstrap类之前div中的内容
- en: 'All of a sudden, the same page looks like this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 突然间，同一个页面看起来是这样的：
- en: '![Bootstrap components](../images/00047.jpeg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap组件](../images/00047.jpeg)'
- en: The content inside the div after adding Bootstra
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加Bootstra之后div中的内容
- en: Actually, if you check our `PleaseIntroduceYourself` example from [Chapter 1](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 1. Please Introduce Yourself – Tutorial"), *Please Introduce Yourself
    – Tutorial* (`chapter1/please-introuce-yourself/src/App.vue`), you will see that
    this exact class was used for the parent element.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果您检查我们从[第1章](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "第1章。请介绍你自己 - 教程")中的`PleaseIntroduceYourself`示例，*Please Introduce Yourself - Tutorial*
    (`chapter1/please-introuce-yourself/src/App.vue`), 您会发现这个确切的类被用于父元素。
- en: 'There are a lot of different components: popovers, tooltips, modals, and so
    on. We will use all of them during the course of the book.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的组件：弹出框，工具提示，模态框等等。我们将在本书的过程中使用所有这些组件。
- en: Bootstrap utilities
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap实用程序
- en: 'Do you want to have responsive floats (elements that flow to the left or to
    the right)? Just add the `float-left` and `float-right` classes to your elements,
    and you don''t have to be worried about it anymore:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要具有响应式浮动（向左或向右流动的元素）吗？只需将`float-left`和`float-right`类添加到您的元素中，您就不必再担心了：
- en: '[PRE82]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Just insert this code into your HTML page (or simply check out the `index.html`
    file in the `example11-responsive-floats` folder), open it, and resize your window.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码插入到您的HTML页面中（或者只需查看`example11-responsive-floats`文件夹中的`index.html`文件），打开它，调整窗口大小。
- en: You can easily control the sizing and spacing with simple classes. Check out
    [https://v4-alpha.getbootstrap.com/utilities/sizing/](https://v4-alpha.getbootstrap.com/utilities/sizing/)
    and [https://v4-alpha.getbootstrap.com/utilities/spacing/.](https://v4-alpha.getbootstrap.com/utilities/spacing/.)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用简单的类轻松控制大小和间距。查看[https://v4-alpha.getbootstrap.com/utilities/sizing/](https://v4-alpha.get.bootstrap.com/utilities/sizing/)和[https://v4-alpha.getbootstrap.com/utilities/spacing/.](https://v4-alpha.get.bootstrap.com/utilities/spacing/.)
- en: You can even enable flex-box behavior just by adding the `d-flex` class to your
    container. The *d* comes from *display*. With more classes attached to your flex
    element, you can control alignment and direction of your flex-box. Check it out
    at [https://v4-alpha.getbootstrap.com/utilities/flexbox/](https://v4-alpha.getbootstrap.com/utilities/flexbox/).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以通过将`d-flex`类添加到容器来启用flex-box行为。 *d*来自*display*。通过将更多类附加到您的flex元素，您可以控制flex-box的对齐和方向。在[https://v4-alpha.getbootstrap.com/utilities/flexbox/](https://v4-alpha.getbootstrap.com/utilities/flexbox/)中查看。
- en: There are a lot more utilities to explore, and we will get into most of them
    during our journey.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他实用程序可以探索，我们将在我们的旅程中了解大部分。
- en: Bootstrap layout
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap布局
- en: 'Using Bootstrap, it is easy to control the layout of your system:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bootstrap，很容易控制系统的布局：
- en: '|   | *Bootstrap includes several components and options for laying out your
    project, including wrapping containers, a powerful flexbox grid system, a flexible
    media object, and responsive utility classes.*- ([https://v4-alpha.getbootstrap.com/layout/overview/](https://v4-alpha.getbootstrap.com/layout/overview/))
    |   |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| | *Bootstrap包括几个组件和选项，用于布置您的项目，包括包装容器，强大的flexbox网格系统，灵活的媒体对象和响应式实用程序类。* -
    ([https://v4-alpha.getbootstrap.com/layout/overview/](https://v4-alpha.getbootstrap.com/layout/overview/))
    | |'
- en: '|   | --*From Bootstrap* |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| | --*来自Bootstrap* |'
- en: 'Bootstrap''s grid system is pretty powerful and easy to understand. It is just
    a row composed of columns. Everything is controlled by classes that have pretty
    self-descriptive names such as `row` and `col`. If you just give your columns
    `col` class, every column inside the `row` element will have the same size. If
    you want to have columns of different sizes, play with the fact that the row can
    be composed of 12 columns. So, if you want to make some columns, let''s say half
    of your row, give it a class **col-6**:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap的网格系统非常强大且易于理解。它只是由列组成的行。一切都由具有相当自我描述性名称的类来控制，比如`row`和`col`。如果你只给你的列`col`类，`row`元素内的每一列都会有相同的大小。如果你想要不同大小的列，可以玩一下行可以由12列组成这个事实。所以，如果你想让一些列，比方说你的一半行，给它一个类**col-6**：
- en: '[PRE83]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This code will produce results similar to this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将产生类似于这样的结果：
- en: '![Bootstrap layout](../images/00048.jpeg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap layout](../images/00048.jpeg)'
- en: Grid layout system combining row and col classes
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局系统结合了行和列类
- en: The interesting part is that if you resize your window, your layout will not
    break. It will resize accordingly. You don't have to implement any CSS black magic
    in order to achieve that! That is why Bootstrap is a big ![Bootstrap layout](../images/00049.jpeg).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果你调整窗口大小，你的布局不会破坏。它会相应地调整大小。你不必实现任何CSS黑魔法来实现这一点！这就是为什么Bootstrap是一个大的![Bootstrap
    layout](../images/00049.jpeg)。
- en: Combining Vue.js and Bootstrap
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合Vue.js和Bootstrap
- en: When we were talking about Vue, we devoted a big section to its components.
    When we talked about Bootstrap, we also talked about components. Doesn't it ring
    the same bell? Maybe we could create Vue components out of Bootstrap components?
    Maybe we can! Actually, we have already done it! Open the code of the first chapter's
    `PleaseIntroduceYourself` application. Check what we have inside the `components`
    folder. There's something that we called `MessageCard.vue`. Actually, this is
    an implemented Vue component for Card Bootstrap's component ([https://v4-alpha.getbootstrap.com/components/card/](https://v4-alpha.getbootstrap.com/components/card/))!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论Vue时，我们专门讨论了它的组件。当我们谈论Bootstrap时，我们也谈论了组件。这不是同一个概念吗？也许我们可以从Bootstrap组件创建Vue组件？也许我们可以！实际上，我们已经做到了！打开第一章的`PleaseIntroduceYourself`应用程序的代码。查看我们在`components`文件夹中有什么。有一样东西我们称之为`MessageCard.vue`。实际上，这是一个实现了Bootstrap组件的Vue组件（[https://v4-alpha.getbootstrap.com/components/card/](https://v4-alpha.getbootstrap.com/components/card/)）！
- en: 'Open the `example13-vue-bootstrap-components-started/components` folder. Let''s
    use this project as a playground to create the Vue component based on the Bootstrap
    alert component. Run `npm install` and `run`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`example13-vue-bootstrap-components-started/components`文件夹。让我们将此项目用作基于Bootstrap警报组件创建Vue组件的游乐场。运行`npm
    install`和`run`：
- en: '[PRE84]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Let's create a Vue component called `Alert`. This component will contain the
    necessary code to simulate Bootstrap's alert component behavior.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Alert`的Vue组件。该组件将包含必要的代码来模拟Bootstrap的警报组件行为。
- en: 'Create a file named `Alert.vue` inside the `components` folder and add `template`
    tags. Our alert will definitely have the `alert` class. However, its additional
    class (`alert-danger`, `alert-info`, etc.) should be something configurable. Also,
    its title and text should be something passed by bound properties from the parent
    component. Thus, the template for the alert component will look like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`文件夹内创建一个名为`Alert.vue`的文件，并添加`template`标签。我们的警报肯定会有`alert`类。但是，它的附加类（`alert-danger`，`alert-info`等）应该是可配置的。此外，它的标题和文本应该是从父组件传递的绑定属性。因此，警报组件的模板将如下所示：
- en: '[PRE85]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s implement the `additionalClass` property as a computed property that
    will be calculated based on the `type` property passed by the parent component.
    So, the script for the `Alert` component will look like this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`additionalClass`属性实现为一个计算属性，该属性将根据父组件传递的`type`属性进行计算。因此，`Alert`组件的脚本将如下所示：
- en: '[PRE86]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Then, we can call it from our main `App.vue` component:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从我们的主`App.vue`组件中调用它：
- en: '[PRE87]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You will end up with a nice alert on your page:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在页面上看到一个漂亮的警报：
- en: '![Combining Vue.js and Bootstrap](../images/00050.jpeg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![结合Vue.js和Bootstrap](../images/00050.jpeg)'
- en: We just created our Alert Vue Bootstrap component
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了我们的Alert Vue Bootstrap组件
- en: Exercise
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Enable a default value for the title of the alert component. So, if the `title`
    is not passed, it will say **Success** by default. Also, bind the `type` property
    to the component on its creation inside the `App.vue` parent component. Export
    this property as a computed property depending on some arbitrary value. For example,
    based on some random number, if it's divisible by `3`, the type should be **danger**;
    if it's divisible by `5`, the type should be **info**; and so on.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为警报组件的标题启用默认值。因此，如果未传递`title`，它将默认为**Success**。还应该在`App.vue`父组件内创建组件时将`type`属性绑定到组件上。根据一些任意值将此属性导出为计算属性。例如，基于一些随机数，如果它可以被`3`整除，类型应为**danger**；如果它可以被`5`整除，类型应为**info**；等等。
- en: Check it out yourself. Go to the `example13-vue-bootstrap-components/components`
    folder and have a look, in particular, at the `App.vue` and `components/Alert.vue`
    components.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 自己去看看。转到`example13-vue-bootstrap-components/components`文件夹，特别是`App.vue`和`components/Alert.vue`组件。
- en: Combining Vue.js and Bootstrap continued
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续结合Vue.js和Bootstrap
- en: 'So, we know how to create Vue components based on Bootstrap components. Doesn''t
    it feel like now it would be great to create all the Bootstrap components as Vue
    components and just use them in our Vue applications without having to think about
    Bootstrap classes whatsoever? Imagine Vue components such as `<button-success></button-success>`
    or `<button :type="success"></button>`. We could even create a whole library of
    Vue components based on Bootstrap! The question is, should we do it if it already
    exists? Yes, someone has already done all the work for us. These are the people
    who have done the work:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道如何基于Bootstrap组件创建Vue组件。现在感觉好像很棒，可以将所有Bootstrap组件创建为Vue组件，并在我们的Vue应用程序中使用它们，而无需考虑Bootstrap类。想象一下Vue组件，例如`<button-success></button-success>`或`<button
    :type="success"></button>`。我们甚至可以基于Bootstrap创建一个完整的Vue组件库！问题是，如果已经存在，我们应该这样做吗？是的，已经有人为我们做了所有的工作。这些人已经完成了这项工作：
- en: '![Combining Vue.js and Bootstrap continued](../images/00051.jpeg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![结合Vue.js和Bootstrap继续](../images/00051.jpeg)'
- en: Core team of bootstrap-vue
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap-vue的核心团队
- en: These nice people have developed something called Bootstrap-Vue and that's something
    that does exactly what you think—it contains a full set of Bootstrap components
    implemented as Vue.js components. Check it out at [https://bootstrap-vue.github.io/](https://bootstrap-vue.github.io/).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可爱的人们开发了一个叫做Bootstrap-Vue的东西，它确实做到了你所想的——它包含了作为Vue.js组件实现的完整的Bootstrap组件集。在[https://bootstrap-vue.github.io/](https://bootstrap-vue.github.io/)上查看它。
- en: Let's check, for example, how the alert component is implemented at [https://bootstrap-vue.github.io/docs/components/alert](https://bootstrap-vue.github.io/docs/components/alert).
    It's a little bit more detailed than our alert. The data is passed within the
    component's tags and not as properties, like in our case, which also makes it
    more flexible. We will use it a lot while developing our application throughout
    the book.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看，例如，警报组件是如何在[https://bootstrap-vue.github.io/docs/components/alert](https://bootstrap-vue.github.io/docs/components/alert)实现的。它比我们的警报详细一点。数据是通过组件的标签传递的，而不是作为属性，就像我们的情况一样，这也使它更灵活。在整本书的开发过程中，我们将经常使用它。
- en: What is Firebase?
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Firebase？
- en: 'To understand what is Firebase let''s open its website [https://firebase.google.com/](https://firebase.google.com/).
    This is what we see:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解什么是Firebase，让我们打开它的网站[https://firebase.google.com/](https://firebase.google.com/)。这是我们看到的：
- en: '![What is Firebase?](../images/00052.jpeg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![什么是Firebase？](../images/00052.jpeg)'
- en: Google Firebase landing page
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: Google Firebase首页
- en: Firebase for Google is yet another cloud service, like AWS for Amazon or Azure
    for Microsoft, a bit simpler though, because Google already has Google Cloud Platform,
    which is huge.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Google来说，Firebase只是另一个云服务，就像AWS是亚马逊的，Azure是微软的一样，不过简单一些，因为Google已经有了庞大的Google云平台。
- en: If you feel like you want to choose between Firebase and AWS, do not forget
    that you will most likely Google it. In any case, someone has already done this
    for you so here you have this question on Quora at [https://www.quora.com/Which-is-better-cloud-server-Amazon-AWS-or-Firebase](https://www.quora.com/Which-is-better-cloud-server-Amazon-AWS-or-Firebase).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得你想在Firebase和AWS之间做出选择，不要忘记你很可能会去谷歌搜索。无论如何，已经有人为你做过了，所以在Quora上有这个问题：[https://www.quora.com/Which-is-better-cloud-server-Amazon-AWS-or-Firebase](https://www.quora.com/Which-is-better-cloud-server-Amazon-AWS-or-Firebase)。
- en: I would say that it's more similar to Heroku—it allows you to easily deploy
    your applications and integrate them with analytics tools. If you have read the
    Learning Vue.js 2 book ([https://www.packtpub.com/web-development/learning-vuejs-2](https://www.packtpub.com/web-development/learning-vuejs-2)),
    then you already know how much I love Heroku. I even have Heroku socks!
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我会说它更类似于Heroku——它允许您轻松部署您的应用程序并将其与分析工具集成。如果您已经阅读了《Learning Vue.js 2》一书([https://www.packtpub.com/web-development/learning-vuejs-2](https://www.packtpub.com/web-development/learning-vuejs-2))，那么您已经知道我有多么喜欢Heroku了。我甚至有Heroku袜子！
- en: '![What is Firebase?](../images/00053.jpeg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![什么是Firebase？](../images/00053.jpeg)'
- en: My beautiful Heroku socks
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我美丽的Heroku袜子
- en: 'However, I find Google Firebase console also quite nice and simple to use.
    It also provides a backend as a service. This backend is shared for your web and
    mobile applications, which comes as a huge help when developing cross-platform
    and cross-device applications. Firebase provides the following services:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我觉得Google Firebase控制台也非常好用和简单。它还提供后端作为服务。这个后端为您的Web和移动应用程序共享，这在开发跨平台和跨设备应用程序时非常有帮助。Firebase提供以下服务：
- en: '**Authentication**: This uses Firebase API for authenticating users using different
    providers (Facebook, Google, e-mail, and so on).'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：这使用Firebase API来使用不同的提供者（Facebook、Google、电子邮件等）对用户进行身份验证。'
- en: '**Database**: This uses Firebase database API to store and retrieve your data.
    No need to choose between different database providers, and no need to establish
    connection. Just use the API out of the box.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：这使用Firebase数据库API来存储和检索数据。无需在不同的数据库提供商之间进行选择，也无需建立连接。只需直接使用API。'
- en: '**Hosting**: This hosts and deploys your application using simple shell commands.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管**：这使用简单的shell命令托管和部署您的应用程序。'
- en: '**Storage**: This hosts static files using a simple API.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：这使用简单的API托管静态文件。'
- en: 'Again, if you think about how to integrate your Vue application with Firebase
    APIs, stop thinking about it because someone has already done the job for you.
    After creating your project using the Firebase console, you can simply use a `vuefire`
    wrapper for Firebase to connect to your database and fetch your data. Check it
    out at [https://github.com/vuejs/vuefire](https://github.com/vuejs/vuefire). Actually,
    this is exactly what we did in our `PleaseIntroduceYourself` application from
    the first chapter. Check out the code that is located inside the `App.vue` component:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果您在考虑如何将您的Vue应用程序与Firebase API集成，那么请停止思考，因为已经有人为您完成了这项工作。在使用Firebase控制台创建项目后，您可以简单地使用Firebase的`vuefire`包装器来连接到您的数据库并获取数据。请访问[https://github.com/vuejs/vuefire](https://github.com/vuejs/vuefire)查看。实际上，这正是我们在第一章的`PleaseIntroduceYourself`应用程序中所做的。查看位于`App.vue`组件内的代码：
- en: '[PRE88]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Everything that is exported in the Firebase object becomes accessible via the
    `this` keyword, the same way as we access the `data` or `computed` properties.
    We will use `vuefire` in the application that we will develop throughout the book
    to better understand how it works.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase对象中导出的所有内容都可以通过`this`关键字访问，就像我们访问`data`或`computed`属性一样。我们将在整本书中开发的应用程序中使用`vuefire`来更好地理解它的工作原理。
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we familiarized ourselves with Vue.js, Bootstrap and Firebase.
    We have also analyzed tools that integrate Vue.js with Bootstrap and Vue.js with
    Firebase.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了Vue.js、Bootstrap和Firebase。我们还分析了将Vue.js与Bootstrap以及Vue.js与Firebase集成的工具。
- en: Thus, now, we are familiar with Vue.js applications that are built using single-file
    components, Bootstrap's grid system, components, and CSS helpers to make our lives
    easier and to make Google Firebase console with its possibilities.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，我们熟悉了使用单文件组件、Bootstrap的网格系统、组件和CSS辅助工具来使我们的生活更轻松，并利用Google Firebase控制台的可能性来构建Vue.js应用程序。
- en: Also, we know how to initialize Vue.js project, and use Vue directives, components,
    store and routing.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们知道如何初始化Vue.js项目，并使用Vue指令、组件、存储和路由。
- en: You also learned how to leverage Bootstrap's grid system to achieve the responsibility
    of our application's layout.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学会了如何利用Bootstrap的网格系统来实现应用程序布局的响应性。
- en: And last but not least, you learned how to use the Firebase API within the Vue
    application using `vuefire` bindings.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，您学会了如何在Vue应用程序中使用Firebase API，使用`vuefire`绑定。
- en: With the end of this chapter, the first introduction part of our journey also
    comes to an end.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，我们旅程的第一部分也告一段落。
- en: In the next chapter, we will actually dive deep inside the implementation. As
    a scuba diving tank, we will take everything that you have learned so far!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解实现细节。就像潜水氧气瓶一样，我们将带走您迄今为止学到的一切！
- en: 'So, we will start developing the application that we will build during the
    whole book until it''s ready for deployment. We will:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将开始开发整本书中将构建的应用程序，直到准备部署。我们将：
- en: Define what the application will do and its requirements
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序将要做什么及其要求
- en: Define whom we are building the application for
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们为谁构建应用程序
- en: Build basic mockups for the application
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序构建基本的模型
- en: Scaffold the application using Vue command-line interface
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue命令行界面搭建应用程序
- en: Are you as excited as much as I am? Then, let's go to the next chapter!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你和我一样兴奋吗？那么，让我们进入下一章吧！
