- en: Advanced Vue.js - Directives, Plugins, and Render Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Vue.js - 指令、插件和渲染函数
- en: 'In this chapter, we will talk about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Creating a new directive
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新指令
- en: Using WebSockets in Vue
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue中使用WebSockets
- en: Writing a plugin for Vue
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Vue编写一个插件
- en: Rendering a simple component manually
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动渲染一个简单的组件
- en: Rendering a component with children
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染带有子元素的组件
- en: Using JSX to render a component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSX来渲染一个组件
- en: Creating a functional component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个功能性组件
- en: Building a responsive table with higher-order components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高阶组件构建响应式表格
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Directives and plugins are ways to package functionality in a reusable way and
    also make it easily shareable across apps and teams; you will build a few of them
    in this chapter. Render functions are how Vue really works under the hood to turn
    templates into the Vue language and then into HTML and JavaScript again; they become
    useful if you need to optimize the performance of your apps and work in some corner
    cases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 指令和插件是以可重用的方式打包功能，并且使其在应用程序和团队之间易于共享的方式；在本章中，您将构建其中的一些。渲染函数是Vue在幕后真正工作的方式，它将模板转换为Vue语言，然后再次转换为HTML和JavaScript；如果您需要优化应用程序的性能并处理一些边缘情况，它们将变得有用。
- en: In general, you should avoid using these advanced functions when possible as
    they have been a little overused in the past. Usually, many problems can be solved
    by simply writing a good component and distributing the component itself; you
    should look at advanced features only when this is not true.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，尽量避免使用这些高级功能，因为它们在过去有点被滥用。通常，许多问题可以通过简单地编写一个良好的组件并分发组件本身来解决；只有在这种情况不成立时，才应该考虑使用高级功能。
- en: This chapter is for the slightly more experienced, and you probably won't find
    the level of step-by-step detail found in other recipes, but I have strived to
    make them complete nonetheless.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章面向略有经验的人，您可能不会在其他教程中找到的逐步详细级别，但我仍然努力使它们完整。
- en: Creating a new directive
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新指令
- en: Directives are like mini functions that you can use to quickly drop into your
    code, mainly to improve the user experience, and to add new low-level features
    to your graphic interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 指令就像迷你函数，您可以快速地将其放入您的代码中，主要是为了改善用户体验，并向图形界面添加新的低级功能。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe, although found in the advanced chapter, is really easy to complete.
    The main reason directives are *advanced* is because you should usually prefer
    composition to add functionality and style to your apps. When components won't
    cut it, use directives.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个教程在高级章节中，但实际上非常容易完成。指令被认为是*高级*的主要原因是，通常情况下，您应该更喜欢组合来添加功能和样式到您的应用程序中。当组件无法满足需求时，使用指令。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will build a `v-pony` directive that will turn any element into a pony element.
    A pony element is created with a pink background and changes color when you click
    on it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个`v-pony`指令，它将把任何元素转换为一个小马元素。小马元素创建时具有粉色背景，并在点击时更改颜色。
- en: 'The HTML code for the pony element is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 小马元素的HTML代码如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Just to show the difference, I''ve included a normal `blockquote` element.
    In our JavaScript section, write the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示区别，我包含了一个普通的`blockquote`元素。在我们的JavaScript部分，写入以下内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is how you declare a new directive. The `bind` hook is called when the
    directive is bound to the element. The only thing we are doing now is setting
    the background color. We also want to make it change color after each click. To
    do this, you have to add this code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何声明一个新指令的方式。`bind`钩子在指令绑定到元素时被调用。我们现在唯一要做的事情就是设置背景颜色。我们还希望它在每次点击后改变颜色。要做到这一点，您必须添加以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are creating an `onclick` listener that will generate a random color
    with a bias toward red and assign it as a new background color.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`onclick`监听器，它将生成一个偏向红色的随机颜色，并将其分配为新的背景颜色。
- en: 'At the end of our JavaScript, remember to create a `Vue` instance:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JavaScript结尾处，记得创建一个`Vue`实例：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can launch your application to see your directive in action:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以启动应用程序以查看指令的运行情况：
- en: '![](assets/886f331f-42ba-42b3-a41c-9991e9cf5a01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/886f331f-42ba-42b3-a41c-9991e9cf5a01.png)'
- en: Don't forget to click on the text to change the background color!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记点击文本以更改背景颜色！
- en: How it works…
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The syntax to declare a new directive is as illustrated:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 声明新指令的语法如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will register a new global directive. Inside the hooks object, you can
    define two important functions: `bind`, which you used in this recipe, and `update`,
    which is triggered every time a component contained in it is updated.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将注册一个新的全局指令。在hooks对象内，您可以定义两个重要的函数：`bind`，您在本教程中使用了它，以及`update`，每当包含在其中的组件更新时触发。
- en: 'Every hook function is called with at least three arguments:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个hook函数至少带有三个参数：
- en: '`el`: The HTML element'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`el`: HTML元素'
- en: '`binding`: Directives can receive an argument; binding is an object that will
    contain the value of the argument'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding`：指令可以接收一个参数；binding是一个包含参数值的对象'
- en: '`vnode`: the Vue internal representation of this element'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vnode`：这个元素的Vue内部表示'
- en: We used the `el` parameter to edit the appearance of our element, manipulating
    it directly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`el`参数直接编辑元素的外观。
- en: Using WebSockets in Vue
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Vue中使用WebSockets
- en: WebSockets is a new technology that enables two-way communication between the
    user and the server where the app is hosted. Before this technology, only the
    browser could initiate a request and, thus, a connection. If some update on the
    page was expected, the browser had to continuously poll the server. With WebSockets,
    this is no longer necessary; after the connection is established, the server can
    send updates only when there is a need.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets是一种新技术，它使用户和托管应用程序的服务器之间实现双向通信。在这项技术出现之前，只有浏览器可以发起请求和建立连接。如果页面上有更新，浏览器必须不断地轮询服务器。有了WebSockets，这就不再需要了；连接建立后，服务器只有在需要时才能发送更新。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You don't need any preparation for this recipe, just the basics of Vue. If you
    don't know what WebSockets are, you don't really need to, just think about them
    as a channel of continuous two-way communication between a server and browser.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，您不需要做任何准备，只需要了解Vue的基础知识。如果您不知道什么是WebSockets，您也不需要知道，只需将它们视为服务器和浏览器之间持续双向通信的通道。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: For this recipe, we need a server and a browser that will act a client. We will not
    build a server; instead, we'll use an already existing server that just echoes
    whatever you send to it via WebSockets. So, if we were to send the `Hello` message,
    the server would respond with `Hello`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们需要一个服务器和一个将充当客户端的浏览器。我们不会构建服务器；相反，我们将使用一个已经存在的服务器，它只会通过WebSockets回显您发送的任何内容。因此，如果我们发送`Hello`消息，服务器将回复`Hello`。
- en: 'You will build a chat app that will talk to this server. Write the following
    HTML code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您将构建一个聊天应用程序，它将与此服务器通信。编写以下HTML代码：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `<pre>` tag will help us render a chat. As we don't need the `<br/>` element
    to break a line, we can just use the `n` special character that means a new line.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`<pre>`标签将帮助我们呈现聊天。由于我们不需要`<br/>`元素来换行，我们可以使用`n`特殊字符，表示换行。'
- en: 'For our chat to work, we first have to declare our WebSocket in the JavaScript:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的聊天工作，我们首先必须在JavaScript中声明我们的WebSocket：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, we declare our `Vue` instance that will contain a `chat` string
    (to contain the chat so far) and a `message` string (to contain the message we
    are currently writing):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们声明将包含`chat`字符串（目前为止包含聊天内容）和`message`字符串（包含我们当前正在编写的消息）的`Vue`实例：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We still need to define the `send` method, which is called upon pressing *Enter*
    in the textbox:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要定义`send`方法，在文本框中按下*Enter*时调用：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We factored out the `appendToChat` method because we will use it to append
    all the messages we''ll receive. To do this, we must wait for the component to
    be instantiated. The `created` hook is a safe place for that:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`appendToChat`方法分解出来，因为我们将用它来附加我们将收到的所有消息。为此，我们必须等待组件被实例化。`created`挂钩是一个安全的地方：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now launch the application to chat with your personal echo chamber:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动应用程序，与您的个人回声室聊天：
- en: '![](assets/2be880b7-2320-4cd4-9d75-86d83a5fe745.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2be880b7-2320-4cd4-9d75-86d83a5fe745.png)'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To see the internals of what you have built, open the Chrome developer tools
    (![](assets/77a56c95-2c9d-4704-bc07-f38fb2e8cf62.png) | More tools | Developer
    tools or *Opt* + *Cmd* + *I*):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您构建的内容的内部，请打开Chrome开发者工具（![](assets/77a56c95-2c9d-4704-bc07-f38fb2e8cf62.png)
    | 更多工具 | 开发者工具或*Opt* + *Cmd* + *I*）：
- en: '![](assets/74ff02b5-6528-42ce-995a-2d4d27ed90e5.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/74ff02b5-6528-42ce-995a-2d4d27ed90e5.png)'
- en: 'Go to the Network tab and reload the page; you should see the `echo.websocket.orl` WebSocket,
    as seen in the screenshot. Write something and messages will appear in the frame
    tab, like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 转到网络选项卡并重新加载页面；您应该会看到`echo.websocket.orl` WebSocket，就像屏幕截图中所示。写点东西，消息将出现在帧选项卡中，就像这样：
- en: '![](assets/02d81265-937d-44e8-9208-3772eaf362c6.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/02d81265-937d-44e8-9208-3772eaf362c6.png)'
- en: The green messages are sent from you while the white messages are the ones you
    receive. You can also examine the message length (in bytes) and the exact time
    they were sent or received.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色消息是您发送的，而白色消息是您收到的。您还可以检查消息长度（以字节为单位）和发送或接收的确切时间。
- en: Writing a plugin for Vue
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Vue编写插件
- en: A plugin is a collection of utilities or a global new behavior that we want
    in our application. Vuex and vue-router are two famous examples of Vue plugins.
    A plugin can really be anything, since writing one means acting at a very low
    level. There are different kinds of plugins you can write. For this recipe, we
    will concentrate on building a directive with global properties.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是我们想要在应用程序中使用的一组实用程序或全局新行为。Vuex和vue-router是Vue插件的两个著名示例。插件实际上可以是任何东西，因为编写插件意味着在非常低的级别上进行操作。您可以编写不同类型的插件。对于这个示例，我们将集中于构建具有全局属性的指令。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will be based on *Creating a new directive*, except that we will
    add some features for global coordination.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将基于*创建一个新的指令*，只是我们将为全局协调添加一些功能。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, we will build a website for a kangaroo appreciation club.
    The layout of the home page HTML looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将为袋鼠欣赏俱乐部构建一个网站。主页HTML的布局如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can change the link to the images of kangaroos with the one you prefer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将袋鼠图片的链接更改为你喜欢的链接。
- en: 'In the JavaScript part, we instantiate an empty `Vue` instance for now:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript部分，我们目前实例化了一个空的`Vue`实例：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we open the page now, we get this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打开页面，会得到这个：
- en: '![](assets/cce76243-a432-47d4-9f5b-aa3bac83740e.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cce76243-a432-47d4-9f5b-aa3bac83740e.jpg)'
- en: Now we want to add a fun note to our website. We want the elements of the page,
    except the title, to jump at random intervals.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想在我们的网站上添加一个有趣的注释。我们希望页面的元素（除标题外）在随机时间间隔跳动。
- en: To do this, the strategy you will implement is to register all the elements
    that will need to jump in an array, and then, periodically take a random element
    and make it jump.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，您将实现的策略是在一个数组中注册所有需要跳跃的元素，然后定期选择一个随机元素并使其跳跃。
- en: 'The first thing we need to define is the jump animation in CSS:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义的第一件事是CSS中的跳跃动画：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What this does is create a class named `kangaroo` that, when applied to an element,
    makes it jump twice by translating it along the y axis.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它的作用是创建一个名为`kangaroo`的类，当应用于一个元素时，使其沿y轴跳动两次。
- en: 'Next, write a function that adds this class to a specified element in the JavaScript:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在JavaScript中编写一个将此类添加到指定元素的函数：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `jump` function adds the `kangaroo` class and then removes it when the animation
    is finished.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`jump`函数添加`kangaroo`类，然后在动画完成时将其移除。'
- en: 'We want to perform this action on a random element picked from the ones registered:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望对从注册的元素中随机选择的一个元素执行此操作：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `doOnRandomElement` function takes an action and a collection and applies
    the action to a drawn element. We then need to schedule it at random intervals:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`doOnRandomElement`函数接受一个动作和一个集合，并将该动作应用于一个绘制的元素。然后我们需要在随机间隔内安排它：'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `atRandomIntervals` function takes the specified function and calls it at
    random intervals shorter than 6 seconds.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`atRandomIntervals`函数接受指定的函数，并在小于6秒的随机间隔内调用它。'
- en: 'We now have all the functions we need to actually build a plugin that will
    make our element jump:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了实际构建一个使我们的元素跳跃的插件所需的所有功能：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Kangaroo plugin, when installed, creates an empty array; it declares a new
    directive, `kangaroo` which will register all the elements with it inside the
    array.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Kangaroo插件在安装时创建一个空数组；它声明了一个新的指令`kangaroo`，它将在数组中注册所有的元素。
- en: Then at random intervals, one random element is drawn from the array and the
    jump function is called on it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在随机间隔内，从数组中随机选择一个元素，并对其调用跳跃函数。
- en: 'To activate the plugin, we need one line before declaring the `Vue` instance
    (but after declaring `Kangaroo`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 激活插件之前，我们需要在声明`Vue`实例之前（但在声明`Kangaroo`之后）加一行：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have to choose the elements that jump, that is, everything except the title:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须选择跳跃的元素，也就是除了标题之外的所有东西：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you run your app now, you will see that an image or the text jumps just like
    a kangaroo every few seconds.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行您的应用程序，您会看到一张图片或文本每隔几秒钟像袋鼠一样跳跃。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In its essence, a Vue plugin is just a way to group some functionalities. There
    are not many restrictions and all you have to do to create a plugin is to declare
    an install function. The general syntax to do that is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，Vue插件只是一种将一些功能组合在一起的方法。没有太多的限制，创建插件的全部工作就是声明一个安装函数。要做到这一点的一般语法如下：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To use the plugin you just made, write the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用您刚刚制作的插件，请编写以下内容：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the second parameter is the optional object that gets passed to the `install`
    function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第二个参数是传递给`install`函数的可选对象。
- en: Since plugins are global entities, you should use them sparsely and only for
    features that you foresee will affect your app throughout.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于插件是全局实体，您应该节俭使用它们，只用于您预见会影响整个应用程序的功能。
- en: Rendering a simple component manually
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动渲染一个简单的组件
- en: Vue turns your HTML templates into render functions. Usually, you should stick
    to templates because they are much simpler. There are a couple of cases in which
    render functions become in handy. Here, we show a simple example in which render
    functions are useful.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Vue将您的HTML模板转换为渲染函数。通常，您应该坚持使用模板，因为它们更简单。有一些情况下，渲染函数变得很有用。在这里，我们展示了一个简单的例子，其中渲染函数很有用。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This is the first recipe on render functions. If you already understand the
    basics of Vue, you will understand everything.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于渲染函数的第一个教程。如果您已经了解了Vue的基础知识，您将会理解一切。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The first use case for render functions is whenever you just want a `Vue` instance
    that displays another component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染函数的第一个用例是每当您只想要一个显示另一个组件的`Vue`实例时。
- en: 'Write an empty HTML layout, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个空的HTML布局，如下所示：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have a Greeter component somewhere that we want to show as the main `Vue`
    instance. In the JavaScript part, add the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为Greeter的组件，我们希望将其显示为主`Vue`实例。在JavaScript部分，添加以下代码：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we have to imagine that we are taking the `Greeter` component from somewhere
    else and, since the component is nicely packaged, we don''t want to modify it.
    Instead, we will pass it to the `Vue` main instance:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须想象我们从其他地方获取了`Greeter`组件，并且由于组件已经很好地打包，我们不想修改它。相反，我们将它传递给`Vue`主实例：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we launch the application now, we will only see the `Greeter` component.
    The main `Vue` instance will only act as a wrapper.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在启动应用程序，我们只会看到`Greeter`组件。主`Vue`实例只会充当包装器。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The render function replaces the template in the `Vue` instance. When render
    is called, the passed argument is the so-called `createElement` function. We named
    it `h` for brevity. This function accepts three arguments, but for now, just note
    how the first argument we are passing (the only one we are passing) is the `Greeter`
    component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染函数替换了`Vue`实例中的模板。当调用渲染函数时，传递的参数是所谓的`createElement`函数。我们为了简洁起见将其命名为`h`。这个函数接受三个参数，但现在只需要注意我们传递的第一个参数（我们唯一传递的参数）是`Greeter`组件。
- en: In theory, you can write the component inline, inside the `h` function. In a
    real project, this is not always possible depending on the presence of the Vue
    template compiler at runtime. When you use the official Webpack template, one
    of the questions you are asked is whether you want to include the Vue template
    compiler when distributing your software.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，您可以在`h`函数内联编写组件。在实际项目中，这并不总是可能的，这取决于运行时是否存在Vue模板编译器。当您使用官方的Webpack模板时，您会被问到是否要在分发软件时包含Vue模板编译器。
- en: 'The arguments for the `createElement` function are listed here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`createElement`函数的参数在这里列出：'
- en: 'As the first argument, the only required one, you have the option to pass three
    different things:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一个参数，唯一必需的参数，您可以选择传递三种不同的东西：
- en: The options of a Vue component, like in our recipe
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue组件的选项，就像我们的教程中
- en: A string representing an HTML tag (such as `div`, `h1`, and `p`)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示HTML标签的字符串（例如`div`、`h1`和`p`）
- en: A function that returns an options object for a Vue component or a string representing
    an HTML tag
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个为Vue组件返回选项对象的函数或表示HTML标签的字符串
- en: The second argument must be an object called **Data Object**. This object is
    explained in the next recipe.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数必须是一个名为**Data Object**的对象。这个对象在下一个教程中会解释。
- en: 'The third argument is an array or a string:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个参数是一个数组或一个字符串：
- en: The array represents a list of elements, text, or components to put inside the
    component
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组表示要放在组件内的元素、文本或组件的列表
- en: You can write a string that will be rendered to text
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以编写一个字符串，它将被渲染为文本
- en: Rendering a component with children
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染具有子元素的组件
- en: In this recipe, you will build a simple web page with a few elements and components
    completely using render functions. This will give you a close-up view of how Vue
    compiles your templates and components. It may be useful if you want to build
    an advanced component and you want a full example to kick start.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将完全使用渲染函数构建一个简单的网页，其中包含一些元素和组件。这将让您近距离了解Vue如何编译您的模板和组件。如果您想要构建一个高级组件，并且希望有一个完整的示例来启动，这可能会很有用。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This is a complete recipe on how to build components through render functions.
    Usually, you don't need to do this in practice; it's recommended only for advanced
    readers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完整的关于如何通过渲染函数构建组件的示例。通常情况下，您不需要在实践中这样做；这仅建议给高级读者。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You will build a page for a plumber club. The page will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你将为一个水管工俱乐部建立一个页面。页面将如下所示：
- en: '![](assets/f1122977-a2ba-4565-8652-c6f910aee0b8.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f1122977-a2ba-4565-8652-c6f910aee0b8.png)'
- en: Whenever we write a name inside the name textbox, it will be written in the
    greeting exactly like the `v-model` directive.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在名称文本框中写入一个名称，它将会被写入问候语中，就像`v-model`指令一样。
- en: For this recipe, we are starting from the end instead of the beginning because
    usually when you have to resort to the `render` function, you have a pretty clear
    idea of what you are trying to get.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们从末尾开始而不是从开头开始，因为通常当你不得不求助于`render`函数时，你对你想要得到的东西有一个很清楚的想法。
- en: 'In the HTML side of our app, let''s start with an empty tag:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序的HTML部分中，让我们从一个空标签开始：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the JavaScript, write an empty `<div>` element in the `render` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，在`render`函数中写入一个空的`<div>`元素：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first thing we''ll put inside is the title, like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将放入的第一件事是标题，就像这样：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All the other elements and components will fit inside the array we have just
    created for the title.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他元素和组件都将适应我们刚刚为标题创建的数组。
- en: We need an `<input>` element that will take the value and display a greeting.
    For this, we can build a `Vue` component.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`<input>`元素，它将获取值并显示问候语。为此，我们可以构建一个`Vue`组件。
- en: In the following code, we are using a regular JavaScript function instead of
    an arrow function; this is because we want a reference to the component itself.
    Arrow functions don't allow you to modify the scope of `this`, while `this` depends
    on how the function is called and can be optionally bound to any variable in regular
    functions. In our case, it will be bound to the instance component.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用了一个常规的JavaScript函数，而不是箭头函数；这是因为我们想要一个对组件本身的引用。箭头函数不允许您修改`this`的作用域，而`this`取决于函数的调用方式，并且可以选择地绑定到常规函数中的任何变量。在我们的情况下，它将绑定到实例组件。
- en: 'After the title of the page, we add the following component in the same array:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面的标题之后，我们在同一个数组中添加以下组件：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The component has three options: the `render`, `data`, and `props` functions.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件有三个选项：`render`、`data`和`props`函数。
- en: 'The second parameter of the `createElement` function is to actually assign
    values to our props:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`createElement`函数的第二个参数是实际为我们的props分配值：'
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will be equivalent to writing `:exclamation="true"` when declaring the
    component.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将相当于在声明组件时写入`:exclamation="true"`。
- en: You can easily understand the `data` and `props` options of the component. Let's
    examine what we wrote in the `render` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松理解组件的`data`和`props`选项。让我们来看看我们在`render`函数中写了什么。
- en: 'In the first line of the function, we set `self = this` as a convenient way
    to refer to the component were we to add any nested functions. Then, we return
    the result of a `createElement` function (`h`) that, inside a div tag, places
    three things in the DOM. The first is the raw text `Your name is` and then two
    elements: an input and a paragraph.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的第一行，我们将`self = this`设置为一个方便的方式来引用组件，如果我们要添加任何嵌套函数。然后，我们返回`createElement`函数（`h`）的结果，它在一个div标签内将三个东西放在DOM中。第一个是原始文本`Your
    name is`，然后是两个元素：一个输入和一个段落。
- en: We don't have a direct equivalent of the `v-model` directive when working with
    render functions. Instead, we implement it manually. We bind the value to the
    name, and then we add a listener to the input event that will set the value of
    the state variable, `name`, to whatever is inside the textbox.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`render`函数时，我们没有`v-model`指令的直接等价物。相反，我们手动实现它。我们将值绑定到名称，然后添加一个监听器来监听输入事件，该事件将把状态变量`name`的值设置为文本框中的内容。
- en: We then insert a paragraph element that will compose the greeting phrase, adding
    an exclamation point based on the value of the `exclamation` prop.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们插入一个段落元素，用于组成问候语，根据`exclamation`属性的值添加感叹号。
- en: 'After the component, we can add the following, as illustrated, in the same
    array:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件之后，我们可以添加如下内容，如同在同一个数组中所示：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you have done things right, you should be able to run the application and
    see the whole page.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做得对，你应该能够运行应用程序并看到整个页面。
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this example, we've seen a glimpse of what happens behind the curtains when
    Vue compiles our templates; again, you are not advised to do this with regular
    components. Most of the time, the result will be just more verbose with little
    or no gain. On the other hand, there are a couple of cases in which writing the
    render function may actually result in better or more robust code and cover some
    functionality that is difficult to express with templates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们已经看到了Vue编译我们模板时发生的事情的一瞥；同样，不建议在常规组件中这样做。大多数情况下，结果只会更冗长，几乎没有收益。另一方面，在一些情况下，编写`render`函数实际上可能会导致更好或更健壮的代码，并涵盖一些难以用模板表达的功能。
- en: Using JSX to render a component
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSX渲染组件
- en: JSX is very popular in the React community. In Vue, you don't have to use JSX
    to build templates for your components; you can use the much more familiar HTML. JSX,
    however, is the next best thing you can do if you are forced to write a lot of
    render functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: JSX在React社区中非常受欢迎。在Vue中，你不必使用JSX来为你的组件构建模板；你可以使用更熟悉的HTML。然而，如果你被迫编写大量的`render`函数，JSX是你可以做的下一个最好的事情。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before venturing into this recipe, you better play a little with the render
    function. The previous recipes provide some exercises.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试本教程之前，最好先玩一下`render`函数。之前的教程提供了一些练习。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: JSX needs a Babel plugin to work. For this recipe, I will assume that you are
    working within the webpack template.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: JSX需要一个Babel插件才能工作。在本教程中，我将假设你是在webpack模板中工作。
- en: 'To install the babel plugin, you can run the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装babel插件，你可以运行以下命令：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inside the `.babelrc` file, add the following in the `plugins` array:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.babelrc`文件中，在`plugins`数组中添加以下内容：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run `npm install`, as usual, to actually install all the dependencies.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样运行`npm install`来安装所有依赖项。
- en: 'Now, open the `main.js` and delete everything inside. Replace it with the following
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`main.js`并删除其中的所有内容。用以下代码替换它：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The highlighted line is the weird bit if you have never seen JSX. Just note
    that we didn't use the arrow function in the `render` option in the preceding code.
    That's because we are using `this` inside and we want it to be bound to the component.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未见过JSX，那么高亮显示的那一行可能有点奇怪。请注意，在前面的代码中，我们没有在`render`选项中使用箭头函数。这是因为我们在内部使用了`this`，并且我们希望它绑定到组件上。
- en: You can already see your page working using the `npm run dev` command.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以使用`npm run dev`命令看到你的页面在工作了。
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The babel plugin will turn the JSX code into a JavaScript `render` function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Babel插件将把JSX代码转换成JavaScript的`render`函数。
- en: I wouldn't recommend using JSX with Vue. The only time I can see it being useful
    is whenever you need to intermix `render` functions with JavaScript and you need
    a quick and readable way of defining templates. Other than that, there are not
    many advantages to using JSX.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议在Vue中使用JSX。我能想到它有用的唯一时机是当您需要将`render`函数与JavaScript混合使用，并且需要一种快速且可读的方式来定义模板。除此之外，使用JSX并没有太多优势。
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's complicate the code a little bit to at least have a flavor of how JSX
    plays with props.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微复杂化代码，至少让它具有JSX与props交互的味道。
- en: 'Define a new component before the main `Vue` instance:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`Vue`实例之前定义一个新的组件：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s use this component in our `Vue` instance and pass the `msg` variable
    via props:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`Vue`实例中使用这个组件，并通过props传递`msg`变量：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The syntax is slightly different from an HTML template. In particular, note
    how props are passed and how we can use camelCase and self-closing tags.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 语法与HTML模板略有不同。特别要注意如何传递props以及如何使用驼峰命名和自闭合标签。
- en: Creating a functional component
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个功能性组件
- en: A lighter version of a component is a functional component. The functional component
    doesn't have instance variables (so no `this`) and has no state. In this recipe,
    we will write a simple functional component that takes some instructions via HTML
    and turns them into a drawing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更轻量级的组件版本是功能性组件。功能性组件没有实例变量（所以没有`this`）并且没有状态。在这个示例中，我们将编写一个简单的功能性组件，通过HTML接收一些指令并将其转换为绘图。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before attempting this recipe, you should at least become familiar with the
    render function in Vue. You can use the previous recipes to do that.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试这个示例之前，您至少应该熟悉Vue中的渲染函数。您可以使用之前的示例来做到这一点。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'When you are writing an `<svg>` element, you usually have to put data in the
    attributes of elements inside it to actually draw shapes. For example, if you
    want to draw a triangle, you have to write the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写一个`<svg>`元素时，通常需要将数据放入其中的元素的属性中以实际绘制形状。例如，如果您想要绘制一个三角形，您必须编写以下内容：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The text inside the `d` attribute is a series of instructions that make a virtual
    cursor move to draw: `M` moves the cursor to the (100, 30) coordinate inside the
    `<svg>`, then `L` traces a line up until (200, 30) and then again to the (150,
    120) coordinate. Finally, `z` closes the path we are drawing, and the result is
    always a triangle.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`d`属性中的文本是一系列指令，用于使虚拟光标移动以绘制：`M`将光标移动到`<svg>`内的(100, 30)坐标，然后`L`绘制一条线直到(200,
    30)，然后再次到(150, 120)坐标。最后，`z`关闭我们正在绘制的路径，结果总是一个三角形。'
- en: 'We would like to write a triangle with a component, but we don''t like attributes
    and we want to write in our own language, so we would write the following to get
    the same result:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想用一个组件来绘制一个三角形，但我们不喜欢属性，我们想用自己的语言来编写，所以我们将编写以下内容以获得相同的结果：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a perfect job for a functional component because there is no state to
    manage, only a translation from one component to one element.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是功能性组件的完美工作，因为没有状态需要管理，只需要将一个组件转换为一个元素。
- en: 'Your HTML layout will simply look like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您的HTML布局将简单地如下所示：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, lay out your functional component in your JavaScript:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的JavaScript中布置您的功能性组件：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You have to specify that the component will be functional with `functional:
    true`; then the render function is slightly different than usual. The first argument
    is still the `createElement` function, but the second passed is the context of
    our component.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '您必须使用`functional: true`来指定组件将是功能性的；然后渲染函数与通常略有不同。第一个参数仍然是`createElement`函数，但第二个传递的是我们组件的上下文。'
- en: We can access the text written inside the HTML of our component (the commands
    to draw) through `context.children`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`context.children`访问组件内部HTML中写的文本（绘制命令）。
- en: 'You can see that I already added an empty `<svg>` element. Inside this, there
    is an empty array of children; we will put only the `<path>` element there, which
    is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我已经添加了一个空的`<svg>`元素。在其中，有一个空的子节点数组；我们将只在那里放置`<path>`元素，如下所示：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The highlighted code creates a path element and then sets some attributes, such
    as `fill` and `stroke`. The `d` attribute takes the text from inside the component,
    makes some substitutions, and then returns it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示的代码创建了一个路径元素，然后设置了一些属性，比如`fill`和`stroke`。`d`属性获取了组件内部的文本，进行了一些替换，然后返回它。
- en: 'We just need to create the `Vue` instance in the JavaScript:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在JavaScript中创建`Vue`实例：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, loading the app, we should see a triangle, which is shown in the following
    screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，加载应用程序，我们应该看到一个三角形，如下截图所示：
- en: '![](assets/6fe42ac0-2a31-49a7-a2ac-3f4b3ef23ba4.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6fe42ac0-2a31-49a7-a2ac-3f4b3ef23ba4.png)'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Vue lets you create components that are very lightweight as they don't have
    any internal state. With this come some limitations, for example, the only place
    where we can put some logic to process user input (in the form of children of
    the element or props) is in the render function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Vue允许您创建非常轻量级的组件，因为它们没有任何内部状态。随之而来的是一些限制，例如，我们可以将一些逻辑放在渲染函数中来处理用户输入（以元素的子节点或props的形式）。
- en: 'The context we passed contains the following properties:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的上下文包含以下属性：
- en: '`props`: This is passed by the user.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`props`: 这是由用户传递的。'
- en: '`children`: This is really an array of virtual nodes, children of our component
    in the template. We don''t have the actual HTML element here but only a representation
    of it by Vue.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`children`: 这实际上是一个虚拟节点数组，在模板中是我们组件的子节点。这里我们没有实际的HTML元素，而只是Vue的表示。'
- en: '`slots`: This is a function returning the slots (can be used instead of children
    in some cases).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slots`: 这是一个返回插槽的函数（在某些情况下可以代替children使用）。'
- en: '`data`: This is the entire data object passed to the component.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`: 这是传递给组件的整个数据对象。'
- en: '`parent`: This is a reference to the parent component.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`: 这是对父组件的引用。'
- en: 'In our code, we extracted the text inside the component by doing the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们通过以下方式提取了组件内部的文本：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We are taking the array of virtual nodes contained in children and mapping
    each node to its text. Since we put only some text in our HTML, the array of nodes
    will be a singleton, with only one node: the text we entered. Therefore, in this
    particular case, doing `var a = children.map(c => someFunction(c))` is then equivalent
    of doing `var a = [someFunction(children[0])]`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在取出children中包含的虚拟节点数组，并将每个节点映射到其文本。由于我们在HTML中只放了一些文本，节点数组将是一个单例，只有一个节点：我们输入的文本。因此，在这种特殊情况下，执行`var
    a = children.map(c => someFunction(c))`等同于执行`var a = [someFunction(children[0])]`。
- en: We are not only extracting the text though, but we are also replacing some terms
    I invented to describe `svg` commands, with the real commands. The `join` function
    will sew together all the strings in the array (just one in our case) and `trim`
    will remove all the white spaces and line breaks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅提取了文本，还替换了一些我发明的术语来描述`svg`命令，用真实的命令。`join`函数将把数组中的所有字符串（在我们的情况下只有一个）拼接在一起，`trim`将删除所有空格和换行符。
- en: Building a responsive table with higher-order components
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高阶组件构建响应式表格
- en: Functional components are very good wrappers when we have to decide which component
    to actually wrap. In this recipe, you'll write a responsive table that will display
    different columns depending on the browser width.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件在我们必须决定实际包装哪个组件时是非常好的包装器。在这个示例中，您将编写一个响应式表格，根据浏览器宽度显示不同的列。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is about functional components. If you want to warm up, you can
    try and complete the previous recipe.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是关于功能组件的。如果你想热身，可以尝试并完成上一个示例。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, we will use the excellent semantic UI CSS framework. To use
    it, you have to include the CSS library as a dependency or as a `<link>` tag.
    For example, you can put the following code in the `<head>` of your HTML:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用优秀的语义化UI CSS框架。要使用它，您必须将CSS库作为依赖项或`<link>`标签包含在内。例如，您可以将以下代码放在HTML的`<head>`中：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you are using JSFiddle, the link inside should be sufficient.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用JSFiddle，内部的链接就足够了。
- en: 'Another tag you have to add to your page for it to look good on mobile is this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须添加另一个标签到您的页面上，以便在移动设备上看起来更好：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This tells the mobile browser that the width of the page is equal to the width
    of the device. If you don't put this, the mobile may assume that the page is much
    larger than the phone and, trying to display all of it, show a miniaturized version
    of your app.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉移动浏览器页面的宽度等于设备的宽度。如果您不这样做，移动设备可能会认为页面比手机大得多，并试图显示所有内容，显示您应用的缩小版本。
- en: 'We will design a table of cat breeds. You can see all the data in the Vue instance
    status. Write it in your JavaScript:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一张猫品种的表格。您可以在Vue实例状态中看到所有数据。在您的JavaScript中编写它：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We are declaring the `width` variable to change the layout of the page and since
    the width of the page is not reactive by nature, we're also installing a listener
    on `window.onresize`. For a real project, you'll probably want something a bit
    more sophisticated, but for this recipe, this will suffice.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明`width`变量来改变页面的布局，由于页面的宽度本质上不是响应式的，我们还在`window.onresize`上安装了一个监听器。对于一个真正的项目，您可能需要更复杂一些的东西，但对于这个示例，这就足够了。
- en: 'Also, note how we are using the `BreedTable` component, which we write like
    this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意我们如何使用`BreedTable`组件，我们的写法是这样的：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What our component is doing is just passing all the `context.data` and `context.children`
    to another component, which will be `DesktopTable` or `MobileTable`, depending
    on the resolution.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件所做的就是将所有的`context.data`和`context.children`传递给另一个组件，这将是`DesktopTable`或`MobileTable`，取决于分辨率。
- en: 'Our HTML layout is the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML布局如下：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `breeds` props will be passed on to the selected component in the `context.data`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`breeds`属性将传递给`context.data`中选定的组件。'
- en: 'Our desktop table will look pretty regular for a table:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的桌面表格看起来会很普通：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The classes at the top are part of semantic UI and they will make our table
    look much better. The `unstackable` class, in particular, disables the automatic
    stacking performed by CSS. We will cover more on this in the next section.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的类是语义UI的一部分，它们将使我们的表格看起来更好。特别是`unstackable`类，它禁用了CSS执行的自动堆叠。我们将在下一节中更多地介绍这个。
- en: 'For the mobile table, we''d like to edit not only the styling, but we''d also
    like to group the columns themselves. The breed will go along with the color and
    the affection with the shedding. Also, we want to express them in a compact style.
    The table head will look like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动表格，我们不仅想编辑样式，还想对列进行分组。品种将与颜色一起显示，情感与脱毛一起显示。此外，我们希望以紧凑的样式表达它们。表头将如下所示：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Instead of just spelling the coat color, we draw a little circle of that color:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅仅是拼写外套颜色，我们还画了一个小圆圈表示颜色：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Also, instead of using numbers like in the desktop table for the affection
    and shedding level, we put a heart and star rating:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与桌面表格中使用数字不同，我们为喜爱程度和脱毛程度使用了心形和星级评分：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Also, don't forget to declare the `breeds` prop like in the `DesktopTable` component.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不要忘记像`DesktopTable`组件中那样声明`breeds`属性。
- en: 'Now launch your application in a browser. You can see how the table groups
    the column when squished enough:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中启动你的应用程序。当压缩到足够小的时候，你可以看到表格是如何将列分组的：
- en: '![](assets/f412040b-98f6-40b2-a2a6-bcd040783e8a.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f412040b-98f6-40b2-a2a6-bcd040783e8a.png)'
- en: 'The following screenshot shows that numbers are replaced by hearts and star
    rating:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示数字被心形和星级评分替换：
- en: '![](assets/345c3620-753a-4e06-b1dc-4f1278ae72d8.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/345c3620-753a-4e06-b1dc-4f1278ae72d8.png)'
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A responsive page changes its layout according to the width of the browser and
    this is very important when the user is using a tablet or smartphone to browse
    the website.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式页面会根据浏览器的宽度更改其布局，当用户使用平板电脑或智能手机浏览网站时，这一点非常重要。
- en: Most of the components have to be developed only once for a responsive page,
    and only the styling is done multiple times according to different sizes. This
    can save a lot of development time if compared to having a separate site optimized
    for mobile.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组件只需开发一次，就可以为响应式页面开发，只需根据不同的尺寸多次进行样式设置。与为移动设备优化的单独网站相比，这可以节省大量开发时间。
- en: 'Normally, in a responsive page table, go from columnar to stacked, as shown in
    the following illustration:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在响应式页面表格中，会从列式布局变为堆叠布局，如下图所示：
- en: '![](assets/a65800dd-a4d1-4188-85e1-cb663f980d60.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a65800dd-a4d1-4188-85e1-cb663f980d60.png)'
- en: I never liked this approach, but the objective disadvantage is that if you make
    your table look good on one side, it will look not so good on the other. This
    is because you have to style the cells in the same way and what the responsiveness
    does is that it stacks them up.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我从来不喜欢这种方法，但客观的缺点是，如果你让你的表在一侧看起来很好，它在另一侧看起来就不那么好。这是因为你必须以相同的方式设置单元格，而响应式的作用是将它们堆叠起来。
- en: What our `BreedTable` component does is to dynamically switch between the two
    components instead of simply relying on the CSS. Since it's a functional component,
    it has the advantage of being very lightweight compared to a full-fledged component.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`BreedTable`组件所做的是在两个组件之间动态切换，而不仅仅依赖于CSS。由于它是一个功能性组件，与完整的组件相比，它具有非常轻量级的优势。
- en: In a real application, using the `onresize` event is questionable, mainly because
    of the performance hit. In a production system, the solutions for responsiveness via
    JavaScript need to be more structured. For example, consider using a timer or
    using `matchMedia`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实应用中，使用`onresize`事件是值得商榷的，主要是因为性能问题。在生产系统中，通过JavaScript实现响应式的解决方案需要更加结构化。例如，考虑使用定时器或使用`matchMedia`。
- en: As a last thing, note how the Vue instance never registers the two subcomponents;
    this is because they never appear in a template but are referenced directly in
    the code as objects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，注意Vue实例从未注册这两个子组件；这是因为它们从未出现在模板中，而是直接在代码中作为对象引用。
