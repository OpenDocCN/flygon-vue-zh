- en: Chapter 8. Let's Collaborate – Adding New Workouts Using Firebase Data Storage
    and Vue.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。让我们合作 - 使用Firebase数据存储和Vue.js添加新的锻炼
- en: In the previous chapter, we learned how to add some basic navigation to the
    Vue application using both `vue-router` and `Nuxt.js`. We have redesigned our
    ProFitOro application, transforming it into a Nuxt-based application. Now our
    application is functional, it has an authentication mechanism, and it is navigable.
    However, it still lacks one of the most important features – workouts. In this
    chapter, we are going to implement the workout management page. Do you still remember
    its requirements from [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained*?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用`vue-router`和`Nuxt.js`为Vue应用程序添加一些基本导航。我们已经重新设计了我们的ProFitOro应用程序，将其转变为基于Nuxt的应用程序。现在我们的应用程序是功能性的，它具有身份验证机制，并且可以导航。但是，它仍然缺少最重要的功能之一
    - 锻炼。在本章中，我们将实现锻炼管理页面。你还记得它在[第2章](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "第2章。底层 - 教程解释") *底层 - 教程解释*中的要求吗？
- en: 'This page should allow users to see the existing workouts in the database,
    select or deselect them to be shown up during the Pomodoro breaks, rate them,
    and even add new workouts. We are not going to implement all these features. However,
    we are going to implement enough for you to continue this application and finish
    its implementation with great success! So, in this chapter we are going to do
    the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面应该允许用户查看数据库中现有的锻炼，选择或取消选择它们在番茄钟休息期间显示，对它们进行评分，甚至添加新的锻炼。我们不打算实现所有这些功能。但是，我们将实现足够的功能让你能够继续这个应用程序，并且以巨大的成功完成它的实现！因此，在本章中，我们将做以下工作：
- en: Define a responsive layout for the workout management page, which will consist
    of two essential parts – a searchable list of all the workouts as well as the
    possibility of adding a new workout to the list
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为锻炼管理页面定义一个响应式布局，它将包括两个基本部分 - 所有锻炼的可搜索列表以及向列表中添加新锻炼的可能性
- en: Store new workouts using the Firebase database and data storage mechanism to
    store workout images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Firebase数据库和数据存储机制存储新的锻炼以及锻炼图片
- en: Use a Bootstrap modal to display every individual workout
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bootstrap模态框显示每个单独的锻炼
- en: Make our footer nicer using responsive layout and the fixed-bottom class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式布局和fixed-bottom类使我们的页脚更好看
- en: Creating layouts using Bootstrap classes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bootstrap类创建布局
- en: 'Before we start implementing a layout for our workouts page, let me remind
    you what the mockup looks like:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为锻炼页面实现布局之前，让我提醒你模拟看起来是什么样子的：
- en: '![Creating layouts using Bootstrap classes](../images/00124.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap类创建布局](../images/00124.jpeg)'
- en: This is how we have defined things initially in our mockups
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们最初在模拟中定义的东西
- en: We will do some things slightly differently - something similar to what we have
    done in the settings page. Let's create the two-column layout that will stack
    on mobile devices. So, this mockup will be valid for mobile screens but it will
    display two columns on desktop devices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做一些略有不同的事情 - 类似于我们在设置页面所做的事情。让我们创建一个在移动设备上堆叠的两列布局。因此，这个模拟将适用于移动屏幕，但在桌面设备上会显示两列。
- en: 'Let''s add two components – `WorkoutsComponent.vue` and `NewWorkoutComponent.vue`
    – inside the `components/workouts` folder. Add some dummy text to the templates
    of these new components and let''s define our two-column layout in the `workouts.vue`
    page. You certainly remember that in order to have stack columns on small devices
    and different-sized columns on other devices, we have to use the `col-*-<number>`
    notation, where `*` represents the size of the device (`sm` for small, `md` for
    medium, `lg` for large, and so on) and the number represents the size of the column,
    which might ranges from `1` to `12`. Since we want our layout to stack on small
    devices (this means that the size of the column should be `12`) and be two equal-sized
    columns on medium and large devices, I came up with the following layout definition:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`components/workouts`文件夹内添加两个组件 - `WorkoutsComponent.vue`和`NewWorkoutComponent.vue`。在这些新组件的模板中添加一些虚拟文本，并在`workouts.vue`页面中定义我们的两列布局。你肯定记得，为了在小设备上堆叠列，并在其他设备上使用不同大小的列，我们必须使用`col-*-<number>`表示法，其中`*`表示设备的大小（`sm`表示小，`md`表示中，`lg`表示大，等等），数字表示列的大小，范围从`1`到`12`。由于我们希望我们的布局在小设备上堆叠（这意味着列的大小应为`12`），并且在中大型设备上是两个大小相等的列，我想出了以下布局定义：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Don''t forget to import both the `WorkoutsComponent.vue` and `NewWorkoutComponent.vue`
    components to the `workouts.vue` page:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`WorkoutsComponent.vue`和`NewWorkoutComponent.vue`组件都导入`workouts.vue`页面：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we have a two-column responsive layout:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个两列响应式布局：
- en: '![Creating layouts using Bootstrap classes](../images/00125.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap类创建布局](../images/00125.jpeg)'
- en: Two-column responsive layout for the workout management page
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 用于训练管理页面的两列响应式布局
- en: Check the code for this implementation in the `chapter8/1/profitoro` folder.
    In particular, pay attention to the content of `components/workouts` folder and
    to the `workouts.vue` page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`chapter8/1/profitoro`文件夹中的此实现的代码。特别注意`components/workouts`文件夹的内容和`workouts.vue`页面的内容。
- en: Making the footer nice
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使页脚漂亮
- en: Aren't you tired of this hardcoded word "**Footer**" always lying around beneath
    our content?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你不厌倦这个硬编码词“**页脚**”总是在我们的内容下面吗？
- en: '![Making the footer nice](../images/00126.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![使页脚漂亮](../images/00126.jpeg)'
- en: The ugly flying hardcoded Footer always glued to our content
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 丑陋的飞行硬编码页脚总是粘在我们的内容上
- en: 'Let''s do something with it! If you check our mockups, we have three columns
    there:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对此做些什么！如果你查看我们的模型，那里有三列：
- en: One column for the copyright information
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版权信息的一列
- en: Another one for the fact of the day
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个是当天的事实
- en: And the last for the author information
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是作者信息
- en: 'You already know what to do, right? Again, we want these columns to be equally
    distributed on mediumand large-sized devices, and stack on mobile devices. Thus,
    our code will look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道该怎么做了，对吧？再次强调，我们希望这些列在中大型设备上均匀分布，并在移动设备上堆叠。因此，我们的代码将如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s keep the fact of the day section hardcoded for now. Well, now our footer
    looks a bit nicer. At least it''s not just the word "Footer" lying around:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时将“当天事实”部分硬编码。好吧，现在我们的页脚看起来好一些了。至少它不再只是“页脚”这个词在那里：
- en: '![Making the footer nice](../images/00127.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![使页脚漂亮](../images/00127.jpeg)'
- en: Our footer is not just the word Footer anymore but it's still glued to the main
    content
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页脚不再只是“页脚”这个词，但它仍然粘在主内容上
- en: 'However, it''s still stuck to the main content, which is not really nice. It
    would be great if our footer was fixed to the viewport''s bottom. It''s a common
    problem, and you will find a lot of articles on the internet asking for this question
    and providing solutions: [https://stackoverflow.com/questions/18915550/fix-footer-to-bottom-of-page](https://stackoverflow.com/questions/18915550/fix-footer-to-bottom-of-page).
    Fortunately for us, we are using Bootstrap and it comes with a series of utility
    classes for sticky top, fixed bottom, and so on.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它仍然固定在主要内容上，这并不是很好。如果我们的页脚固定在视口底部会很棒。这是一个常见的问题，在互联网上会找到很多关于这个问题的文章和解决方案：[https://stackoverflow.com/questions/18915550/fix-footer-to-bottom-of-page](https://stackoverflow.com/questions/18915550/fix-footer-to-bottom-of-page)。幸运的是，我们正在使用Bootstrap，它带有一系列用于粘性顶部、固定底部等的实用类。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In order to make your footer fixed with Bootstrap, just add this class to it:
    `fixed-bottom`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的页脚在Bootstrap中固定，只需向其添加这个类：`fixed-bottom`
- en: Once you add this class to your footer, you will see how it becomes stuck to
    the bottom of the viewport. Try to resize the viewport, moving the bottom of the
    page up and down, and you will see that our footer goes along the bottom.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将这个类添加到您的页脚中，您将看到它如何固定在视口底部。尝试调整视口大小，将页面底部上下移动，您会发现我们的页脚会跟随在底部。
- en: Check the code for this section in the `chapter8/2/profitoro` folder. The only
    change was in the `HeaderComponent.vue` component, which is located in the `components/common`
    folder.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter8/2/profitoro`文件夹中检查本节的代码。唯一的变化是`HeaderComponent.vue`组件，它位于`components/common`文件夹中。
- en: Storing new workouts using the Firebase real-time database
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Firebase实时数据库存储新的锻炼
- en: Before starting this section, check the code in the `chapter8/3/profitoro` folder.
    Both the `Workouts` and `NewWorkout` components are filled with a markup.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本节之前，请检查`chapter8/3/profitoro`文件夹中的代码。`Workouts`和`NewWorkout`组件都填充有标记。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't forget to run `npm install` and `npm run dev`!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记运行`npm install`和`npm run dev`！
- en: 'It doesn''t work yet, but it displays something:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它还没有起作用，但显示了一些东西：
- en: '![Storing new workouts using the Firebase real-time database](../images/00128.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![使用Firebase实时数据库存储新的锻炼](../images/00128.jpeg)'
- en: Workout management page with some content
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 带有一些内容的锻炼管理页面
- en: In this section, we are going to add workout objects to our workouts resource
    in the Firebase database. After that, we can finally learn how to store images
    using the Firebase data storage mechanism.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向Firebase数据库中的锻炼资源添加锻炼对象。之后，我们最终可以学习如何使用Firebase数据存储机制存储图像。
- en: 'First, let''s add Firebase bindings just like we''ve done for statistics and
    configuration objects. Open the `action.js` file and find the `bindFirebaseReferences`
    method. Here, we should add the binding for the `workouts` resource. So, this
    method now contains three bindings:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们像为统计和配置对象一样添加Firebase绑定。打开`action.js`文件，找到`bindFirebaseReferences`方法。在这里，我们应该为`workouts`资源添加绑定。因此，这个方法现在包含三个绑定：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We should also unbind them once the application is unloaded:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序卸载，我们还应该解除它们的绑定：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s also add `workoutsRef` and `workouts` attributes to our state. Last
    but not least, don''t forget to implement the mutation called `setWorkoutsRef`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还向我们的状态添加`workoutsRef`和`workouts`属性。最后但并非最不重要的是，不要忘记实现名为`setWorkoutsRef`的mutation：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, having the `workoutsRef` stored in our state, we can implement the action
    that will update it with newly created workouts. After this, we will be able to
    use this action inside the `NewWorkout` component and populate our workout database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了存储在我们状态中的`workoutsRef`，我们可以实现将其更新为新创建的锻炼的操作。之后，我们将能够在`NewWorkout`组件中使用此操作并填充我们的锻炼数据库。
- en: 'Check the Firebase documentation regarding reading and writing into the real-time
    database: [https://firebase.google.com/docs/database/web/read-and-write](https://firebase.google.com/docs/database/web/read-and-write).
    Scroll down until you find the "*new post creation*" example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Firebase关于读取和写入实时数据库的文档：[https://firebase.google.com/docs/database/web/read-and-write](https://firebase.google.com/docs/database/web/read-and-write)。向下滚动，直到找到“*新帖子创建*”示例：
- en: '![Storing new workouts using the Firebase real-time database](../images/00129.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![使用Firebase实时数据库存储新锻炼](../images/00129.jpeg)'
- en: New post creation example in Firebase database documentation
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase数据库文档中的新帖子创建示例
- en: 'Don''t you find this case extremely similar to ours? Each workout added by
    the user has its name, description, and a picture (or maybe even more than one
    picture). Workouts also belong to the users that created them. So, maybe we can
    do something very similar to this. It will also be useful to have a resource for
    `user-workouts` that contains workouts for each user. It might come in handy if
    we decide to implement the possibility for each user to delete their workouts.
    Before copying this code, let''s just agree on the workout object data structure.
    What should it contain? Since it''s coming from the `NewWorkout` component, it
    will already bring the workout''s name, description, and image URLs. Should we
    enrich it with anything else inside the action? Probably, we should add the name
    and UID of the user who added it, the date when it was created, and the rating
    attribute. This should be more than enough for now. So, our workout data structure
    will look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你不觉得这个案例和我们的非常相似吗？用户添加的每个锻炼都有其名称、描述和图片（或者甚至多张图片）。锻炼也属于创建它们的用户。所以，也许我们可以做一些非常类似的事情。如果我们决定实现每个用户删除他们的锻炼的可能性，为`user-workouts`创建一个资源可能会很有用。在复制此代码之前，让我们就锻炼对象数据结构达成一致意见。它应该包含什么？由于它来自`NewWorkout`组件，它将已经带有锻炼的名称、描述和图片URL。我们应该在`action`内丰富它吗？可能，我们应该添加添加它的用户的名称和UID，创建日期和评分属性。这应该足够了。所以，我们的锻炼数据结构将如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `name`, `description`, `username`, and `uid` attributes are strings. The
    `pictures` attribute should be an array of URL strings, `rating` should be a number
    and let's store our `date` attribute in the form of a timestamp.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`、`description`、`username`和`uid`属性都是字符串。`pictures`属性应该是URL字符串的数组，`rating`应该是一个数字，让我们以时间戳的形式存储我们的`date`属性。'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's good that we are implementing both the frontend and the backend parts,
    so we agree on a data schema between ourselves. If you ever work in a team that
    has frontend and backend developers, don't forget to agree on a data schema before
    any implementation takes place!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们正在实现前端和后端部分，所以我们在我们之间达成了数据架构的一致。如果你曾经在一个有前端和后端开发人员的团队中工作过，请不要忘记在任何实施之前达成数据架构的一致！
- en: 'So, we know that the description, name, and picture URL should be populated
    inside the `NewWorkout` component. Thus, let''s populate everything else inside
    our `action` method. In the end, it will look really similar to the Firebase example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道描述、名称和图片URL应该在`NewWorkout`组件内填充。因此，让我们在我们的`action`方法内填充其他所有内容。最后，它看起来会非常类似于Firebase示例：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note again that we are introducing a new resource called `user-workouts`. We
    can bind this resource to our state the exact same way we have done with the statistics
    and configuration user data. If we decide to implement the deletion of user resources,
    it might become handy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们正在引入一个名为`user-workouts`的新资源。我们可以以与统计和配置用户数据相同的方式将此资源绑定到我们的状态。如果我们决定实现删除用户资源，这可能会很方便。
- en: Now, let's move to our `NewWorkout` component. Here, we just need to bind some
    Vue models to the corresponding inputs and the click event to the **Submit** button.
    The click event on the **Apply** button should be bound to the `createNewWorkout`
    action, invoking it along with the corresponding data. Don't worry about the `pictures`
    yet, we will deal with them in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到我们的“NewWorkout”组件。在这里，我们只需要将一些Vue模型绑定到相应的输入和单击事件绑定到**提交**按钮。**应用**按钮上的单击事件应绑定到`createNewWorkout`动作，同时调用相应的数据。暂时不要担心`pictures`，我们将在下一节中处理它们。
- en: 'At this point, we can replace the hardcoded array of workouts in the `Workouts`
    component with the state workouts object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以用状态训练对象替换“Workouts”组件中的硬编码训练数组：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Check how your newly created workouts immediately appear in the workouts section!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 检查您新创建的训练立即出现在训练部分的方式！
- en: Check the final code for this section in the `chapter8/4/profitoro` folder.
    Pay attention to the store files (`actions.js`, `mutations.js`) and to the `NewWorkoutComponent`
    and `WorkoutsComponent` components inside the `components/workouts` folder.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`chapter8/4/profitoro`文件夹中此部分的最终代码。注意存储文件（`actions.js`，`mutations.js`）以及`components/workouts`文件夹中的`NewWorkoutComponent`和`WorkoutsComponent`组件。
- en: Storing images using the Firebase data storage
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Firebase数据存储存储图像
- en: Firebase cloud storage allows you to upload and retrieve different content (files,
    videos, images, and so on). In a very similar way, Firebase provides a way of
    accessing and managing your database, where you can access and manage your storage
    buckets. You can upload Blobs, strings in Base64, file objects, and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase云存储允许您上传和检索不同的内容（文件、视频、图像等）。同样，Firebase提供了一种访问和管理数据库的方式，您可以访问和管理存储桶。您可以上传Blob、Base64字符串、文件对象等。
- en: 'First of all, you should tell your Firebase application that you are going
    to use Google cloud storage. Thus, you need to add a `storageBucket` attribute
    to your application configuration object. Check your application''s settings on
    the Google Firebase console and copy the `storageBucket` reference to the `firebase/index.js`
    file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您应告诉您的Firebase应用程序，您将使用Google云存储。因此，您需要向应用程序配置对象添加`storageBucket`属性。在Google
    Firebase控制台上检查应用程序的设置，并将`storageBucket`引用复制到`firebase/index.js`文件中：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now your firebase application knows what storage bucket to use. Let''s also
    open the data storage tab of the Firebase console and add a folder for our workout
    images. Let''s call it…workouts:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的Firebase应用程序知道要使用哪个存储桶。让我们还打开Firebase控制台的数据存储选项卡，并为我们的训练图像添加一个文件夹。让我们称之为…训练：
- en: '![Storing images using the Firebase data storage](../images/00130.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![使用Firebase数据存储存储图像](../images/00130.jpeg)'
- en: Creating a folder called "workouts" in the Firebase data storage tab
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase数据存储选项卡中创建一个名为“workouts”的文件夹
- en: Everything is now ready to start using our cloud storage bucket.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，可以开始使用我们的云存储桶。
- en: 'First of all, we have to obtain the reference to our workouts folder so we
    can modify it. Check the Firebase API documentation regarding bucket reference
    creation: [https://firebase.google.com/docs/storage/web/create-reference](https://firebase.google.com/docs/storage/web/create-reference).
    In our case, the reference will look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须获取对我们的训练文件夹的引用，以便我们可以修改它。查看有关存储桶引用创建的Firebase API文档：[https://firebase.google.com/docs/storage/web/create-reference](https://firebase.google.com/docs/storage/web/create-reference)。在我们的情况下，引用将如下所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Where should we use it? Somehow, before storing workouts, we should store the
    picture files, obtain their cloud URLs, and assign these URLs to the workouts''
    `pictures` property. So, here is our plan:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在哪里使用它？在存储训练之前，我们应该存储图片文件，获取它们的云URL，并将这些URL分配给训练的`pictures`属性。因此，这是我们的计划：
- en: Create a method that uploads files and returns those files' download URLs
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个上传文件并返回这些文件的下载URL的方法
- en: Use this method before dispatching the `createNewWorkout` action to assign the
    URLs to the picture's property of the workout object
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`createNewWorkout`动作之前使用这个方法来为workout对象的pictures属性分配URL
- en: 'Let''s create a method that will upload a file and return its `downloadURL`.
    Check the Firebase documentation to learn how to use its API to upload files:
    [https://firebase.google.com/docs/storage/web/upload-files](https://firebase.google.com/docs/storage/web/upload-files).
    Have a look at the **Upload from a Blob or File** section. You will see that we
    should use the method "`put`" on a cloud storage reference, providing it with
    a file object. This will be a promise that is resolved with a snapshot object:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个上传文件并返回其`downloadURL`的方法。查看Firebase文档，了解如何使用其API上传文件：[https://firebase.google.com/docs/storage/web/upload-files](https://firebase.google.com/docs/storage/web/upload-files)。看一下**从Blob或文件上传**部分。你会看到我们应该在云存储引用上使用"`put`"方法，提供一个文件对象。这将是一个返回快照对象的promise：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What is this `snapshot` object? This is a representation of your file stored
    on the cloud. It contains a lot of information, but the most important for us
    is its `downloadURL` attribute. So, our promise will look quite similar to the
    example promise but it will return `snapshot.downloadURL`. So, open the `actions.js`
    file and create a new method called `uploadImage`. This method will receive a
    file object, create a child reference on our `workout` cloud folder reference
    with this file''s name, and then `put` a file and resolve with the `downloadURL`.
    So, it will look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`snapshot`对象是什么？这是存储在云上的文件的表示。它包含了很多信息，但对我们来说最重要的是它的`downloadURL`属性。因此，我们的promise看起来会和示例promise非常相似，但它将返回`snapshot.downloadURL`。因此，打开`actions.js`文件，创建一个名为`uploadImage`的新方法。这个方法将接收一个文件对象，在我们的`workout`云文件夹引用上创建一个子引用，然后`put`一个文件并返回`downloadURL`。因此，它看起来会像这样：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Don't you see a little problem here? What will happen if two different users
    submit different pictures under the same name? Then these pictures will just override
    each other. As a small exercise, think of a way to avoid this problem.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你难道没有看到一个小问题吗？如果两个不同的用户提交了不同的图片，但使用了相同的名称，那么这些图片将会互相覆盖。作为一个小练习，想想避免这个问题的方法。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Hint: Have a look at this npm package:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：看一下这个npm包：
- en: '[https://www.npmjs.com/package/uuid](https://www.npmjs.com/package/uuid)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.npmjs.com/package/uuid](https://www.npmjs.com/package/uuid)'
- en: 'So, we have our promise that uploads the file and returns its `downloadURL`.
    However, this is not yet our final action. Our final `action` method should upload
    an *array* of files, because that is what we get from our multiple file input
    – an array of file objects. Thus, our final promise will just return the result
    of all the promises and it will look as simple as the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个上传文件并返回其`downloadURL`的promise。然而，这还不是我们最终的动作。我们最终的`action`方法应该上传一个*数组*的文件，因为这是我们从多文件输入中得到的
    - 一组文件对象。因此，我们最终的promise将只返回所有promise的结果，它看起来会像下面这样简单：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This action can now be used inside the `NewWorkout` component before calling
    the `createNewWorkout` action.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在`NewWorkout`组件中调用这个动作，然后再调用`createNewWorkout`动作。
- en: 'First of all, we need to bind the `pictures` property to the file input element.
    The obvious choice would be to bind the property `pictures` to the input using
    the `v-model` directive:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将`pictures`属性绑定到文件输入元素。显而易见的选择是使用`v-model`指令将属性`pictures`绑定到输入上：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Is it so obvious though? The `v-model` directive determines the *two-way data
    binding*, but how would we set data to it? The data of the file input is either
    `FileObject` or `FileList`. How would we set it? It seems that applying two-way
    data binding to this element doesn't make sense.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此显而易见吗？`v-model`指令确定了*双向数据绑定*，但我们如何设置数据呢？文件输入的数据要么是`FileObject`，要么是`FileList`。我们该如何设置它呢？似乎对这个元素应用双向数据绑定是没有意义的。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can''t actually bind reactive data to the file inputs, but you can set
    your data inside the change event:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你不能将响应式数据绑定到文件输入，但是你可以在change事件中设置你的数据：
- en: '[https://forum.vuejs.org/t/vuejs2-file-input/633/2](https://forum.vuejs.org/t/vuejs2-file-input/633/2)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://forum.vuejs.org/t/vuejs2-file-input/633/2](https://forum.vuejs.org/t/vuejs2-file-input/633/2)'
- en: 'Thus, we have to listen to the `change` event and set our data on each change.
    Let''s bind this event to the `filesChange` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须监听`change`事件，并在每次更改时设置我们的数据。让我们将这个事件绑定到`filesChange`方法：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now let's create this method and just assign `this.pictures` to the parameter
    we receive. Well, not *just assign*, because we receive a `FileList` object which
    is not exactly an array which you can iterate over. Thus, we need to transform
    it into a simple array of `File` objects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建这个方法，只需将`this.pictures`分配给我们接收到的参数。好吧，不是*只是分配*，因为我们接收到的是一个`FileList`对象，它并不完全是一个可以迭代的数组。因此，我们需要将它转换成一个简单的`File`对象数组。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'We can use the ES6 spread operator for this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用ES6扩展运算符来做到这一点：
- en: '`filesArray = [...fileListObject]`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesArray = [...fileListObject]`'
- en: 'Thus, our `filesChange` method will look as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`filesChange`方法将如下所示：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can finally update our `onCreateNew` method. First, it should dispatch
    the `uploadImages` action and on promise resolution dispatch the `createNewWorkout`
    action, assigning the result of the promise to the `pictures` array. Now this
    method will look as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于可以更新我们的`onCreateNew`方法了。首先，它应该分发`uploadImages`动作，并在承诺解决后分发`createNewWorkout`动作，将承诺的结果分配给`pictures`数组。现在这个方法将如下所示：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Don't forget to import the `uploadImages` action. Also, create a `reset` method
    that will reset all the data to its initial state.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记导入`uploadImages`动作。另外，创建一个`reset`方法，将所有数据重置为初始状态。
- en: Create some workouts with images and enjoy the result!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一些带有图片的锻炼，并享受结果！
- en: Let's search!
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们搜索！
- en: 'So now we can create workouts and see them being displayed in the list of workouts.
    However, we have this nice search input, and it''s doing nothing: (. Nevertheless,
    we are using Vue.js so it''s really easy to implement this search. We just have
    to create a `searchTerm` data attribute and bind it to the search input and then
    filter the workouts array by this `searchTerm`. So, I will add the computed property,
    let''s call it `workoutsToDisplay`, and this property will represent a filtered
    workouts property (the one that we import from the Vuex store''s state) by its
    name, description, and username properties. So, it will give us the possibility
    of searching by all these terms:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们可以创建锻炼，并看到它们显示在锻炼列表中。然而，我们有这个不错的搜索输入，但它什么也没做：(. 尽管如此，我们正在使用Vue.js，所以实现这个搜索真的很容易。我们只需要创建一个`searchTerm`数据属性，并将其绑定到搜索输入，然后通过这个`searchTerm`过滤锻炼数组。因此，我将添加计算属性，让我们称之为`workoutsToDisplay`，这个属性将表示一个通过名称、描述和用户名属性过滤的锻炼属性（我们从Vuex存储的状态中导入的属性）。因此，它将给我们提供通过所有这些术语进行搜索的可能性：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Don''t forget to add the `searchTerm` property to the component''s data and
    bind it to the search input element:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`searchTerm`属性添加到组件的数据中，并将其绑定到搜索输入元素：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And, of course, instead of iterating over the workouts array to display the
    workout cards, we should now iterate over the `workoutsToDisplay` array. So just
    edit slightly the `v-for` directive of the card `div`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们现在应该遍历`workoutsToDisplay`数组来显示锻炼卡片，而不是遍历锻炼数组。因此，只需稍微编辑卡片`div`的`v-for`指令：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Open the page and try to search! If I search by the user''s name, only workouts
    created by this user will be displayed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面并尝试搜索！如果我按用户名搜索，只会显示由该用户创建的锻炼：
- en: '![Let''s search!](../images/00131.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![让我们搜索！](../images/00131.jpeg)'
- en: Makes sense, since I created all the existing workouts until now
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有道理，因为我创建了所有现有的锻炼直到现在
- en: 'If I search by the name of the workout, let''s say, push-up, only this workout
    will appear in the list:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我按锻炼的名称搜索，比如俯卧撑，只会出现这个锻炼：
- en: '![Let''s search!](../images/00132.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![让我们搜索！](../images/00132.jpeg)'
- en: Searching by the workout's name
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 按锻炼名称搜索
- en: We're almost done! The only thing we have to do now is to show a randomly chosen
    workout from the list of workouts instead of hardcoded data during the resting
    periods of our Pomodoro. Try to do it yourself in the `pomodoro.vue` page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快要完成了！现在我们唯一要做的就是在番茄钟的休息时段显示从锻炼列表中随机选择的锻炼，而不是硬编码的数据。尝试在`pomodoro.vue`页面中自己做到这一点。
- en: You can now create new workouts and they will immediately appear in the workouts
    section. They also appear in our main page during the Pomodoro breaks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以创建新的锻炼，并且它们将立即出现在锻炼部分。它们还会在我们的番茄钟休息期间出现在主页上。
- en: Great job! Check the code for this part in the `chapter8/5/profitoro` folder.
    Pay special attention to the new actions inside the `store/actions.js` file and
    to the `Workouts` and `NewWorkout` components inside the `components/workouts`
    folder. Check how the random workout is being selected and displayed in the `pomodoro.vue`
    page.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！检查`chapter8/5/profitoro`文件夹中此部分的代码。特别注意`store/actions.js`文件中的新操作以及`components/workouts`文件夹中的`Workouts`和`NewWorkout`组件。查看随机锻炼是如何被选择并显示在`pomodoro.vue`页面中的。
- en: Using a Bootstrap modal to show each workout
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bootstrap模态框显示每个锻炼
- en: 'Now we can see all the existing workouts on the page, which is great. However,
    our users would really like to have a look at each of the workouts in detail –
    see the workouts'' descriptions, rate them, see who has created them and when,
    and so on. It''s unthinkable to put all this information in the tiny `card` element,
    so we need to have a way of magnifying each element in order to be able to see
    its detailed information. A Bootstrap modal is a great tool that provides this
    functionality. Check the Bootstrap documentation regarding the modal API: [https://v4-alpha.getbootstrap.com/components/modal/](https://v4-alpha.getbootstrap.com/components/modal/).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在页面上看到所有现有的锻炼，这很棒。然而，我们的用户真的很想详细了解每个锻炼-查看锻炼的描述，对其进行评分，查看谁创建了它们以及何时创建的等等。在小的“卡片”元素中放置所有这些信息是不可想象的，因此我们需要一种放大每个元素以便能够查看其详细信息的方法。Bootstrap模态框是提供此功能的绝佳工具。查看Bootstrap文档有关模态API的信息：[https://v4-alpha.getbootstrap.com/components/modal/](https://v4-alpha.getbootstrap.com/components/modal/)。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that Bootstrap 4, at the time of writing, is in its alpha stage and that's
    why at some point this link might not work anymore, so just search for the relevant
    information on the official Bootstrap website.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Bootstrap 4在撰写本文时处于alpha阶段，这就是为什么在某个时候这个链接可能不再有效，所以只需在官方Bootstrap网站上搜索相关信息即可。
- en: 'Basically, we need to have an element that will trigger a modal and a modal
    markup itself. In our case, each of the small workout cards should be used as
    a modal trigger; `WorkoutComponent` will be our modal component. So, just add
    `data-toggle` and `data-target` attributes to the `card` element inside the Workouts
    component:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们需要一个触发模态的元素和模态标记本身。在我们的情况下，每个小锻炼卡都应该被用作模态触发器；`WorkoutComponent`将是我们的模态组件。因此，只需在Workouts组件内的`card`元素中添加`data-toggle`和`data-target`属性：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now let''s work on the `WorkoutComponent` component. Let''s assume that it
    will receive the following properties:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来处理`WorkoutComponent`组件。假设它将接收以下属性：
- en: name
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: description
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述
- en: username
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: datecreated
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建日期
- en: rate
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 费率
- en: pictures
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: 'Thus, we can build a very simple markup for our modal, something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以为我们的模态构建一个非常简单的标记，类似于这样：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Keep in mind that this modal needs to have the exact same ID attribute by which
    it is being targeted from the toggling element.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个模态需要具有与其从切换元素进行定位的完全相同的ID属性。
- en: 'Don''t forget to specify the required properties under the `props` attribute:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`props`属性下指定所需的属性：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now this component can be imported into the Workouts component and used there:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个组件可以被导入到Workouts组件中并在那里使用：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you click on some of the small cards now, the empty modal will open:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在点击一些小卡片，空的模态将会打开：
- en: '![Using a Bootstrap modal to show each workout](../images/00133.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap模态框显示每个锻炼](../images/00133.jpeg)'
- en: The modal works! But it's empty
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 模态有效！但是它是空的
- en: 'We definitely should still do something, so the data of the chosen element
    is propagated to the component''s data. Let''s add a method that will do this
    job and bind it to the `click` event of the `card` element:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定还应该做一些事情，以便所选元素的数据传播到组件的数据中。让我们添加一个方法来执行这项工作，并将其绑定到`card`元素的`click`事件上：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The method will just copy the workout''s data to the corresponding component''s
    data:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将只是将锻炼的数据复制到相应组件的数据中：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It looks a little bit better now!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来好多了！
- en: '![Using a Bootstrap modal to show each workout](../images/00134.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap模态框显示每个锻炼](../images/00134.jpeg)'
- en: Data binding just works!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定确实有效！
- en: It looks nice, all the data is here, but it's still not perfect. Think how we
    could improve it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，所有数据都在这里，但还不完美。想想我们如何能改进它。
- en: Exercise
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Make the date that appears on the modal''s footer human-readable. Do it in
    such a way that the footer appears like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使模态底部显示的日期可读。以这样的方式做，使底部看起来像这样：
- en: '![Exercise](../images/00135.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Exercise](../images/00135.jpeg)'
- en: Workout modal's footer with human-readable data
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼模态的底部，带有可读的数据
- en: Try to use existing tools and not reinvent the wheel.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用现有工具，而不是重新发明轮子。
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Think of the moment.js library:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 想想moment.js库：
- en: '[https://momentjs.com/](https://momentjs.com/)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://momentjs.com/](https://momentjs.com/)'
- en: Check for yourself and the final code until this moment in the `chapter8/6/profitoro`
    folder. Pay attention to the `Workouts` and `Workout` components in the `components/workout`
    folder.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 自己检查一下，直到这一刻的最终代码在`chapter8/6/profitoro`文件夹中。注意`components/workout`文件夹中的`Workouts`和`Workout`组件。
- en: It's time to apply some style
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候应用一些样式了
- en: Our application is fully functional now; it can be used right away. Of course,
    it is still not perfect. It lacks validations and some functionality, several
    requirements have not been implemented yet, and the most important thing…it lacks
    beauty! It's all gray, it doesn't have style…we are humans, we love beautiful
    things, don't we? Everyone implements styles in their own way. I strongly recommend
    that if you want to use this application, please find your own style and theme
    for it, and please implement it and share with me. I would love to see it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在已经完全功能，可以立即使用。当然，它还不完美。它缺乏验证和一些功能，一些要求尚未实现，最重要的是...它缺乏美感！它全是灰色，没有风格...我们是人类，我们喜欢美丽的东西，不是吗？每个人都以自己的方式实现风格。我强烈建议，如果你想使用这个应用程序，请找到自己的风格和主题，并实现它并与我分享。我会很乐意看到它。
- en: As for me, since I am not a designer, I asked my good friend Vanessa ([https://www.behance.net/MeegsyWeegsy](https://www.behance.net/MeegsyWeegsy))
    to create a nice design for the ProFitOro application. She did a great job! Since
    I was busy writing this book, I had no time to implement Vanessa's design, therefore
    I asked my good friend, Filipe ([https://github.com/fil090302](https://github.com/fil090302)),
    to help me with it. Filipe did a great job as well! Everything looks exactly how
    Vanessa implemented it. We have used `scss`, so it must be familiar to you since
    we've been using it already in this application as a preprocessor.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我，因为我不是设计师，我请我的好朋友Vanessa（[https://www.behance.net/MeegsyWeegsy](https://www.behance.net/MeegsyWeegsy)）为ProFitOro应用程序设计一个漂亮的设计。她做得很好！因为我忙着写这本书，所以我没有时间实现Vanessa的设计，因此我请我的好朋友Filipe（[https://github.com/fil090302](https://github.com/fil090302)）帮助我。Filipe也做得很好！一切看起来都和Vanessa实现的一样。我们使用了`scss`，所以你一定很熟悉，因为我们在这个应用程序中已经在使用它作为预处理器。
- en: 'You can reuse the existing style to override some variables in order to create
    your own theme. Please check the final code in the `chapter8/7/profitoro` folder.
    All styles are located inside the `assets/styles` directory. It has the following
    structure:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重用现有的样式来覆盖一些变量，以创建自己的主题。请在`chapter8/7/profitoro`文件夹中检查最终代码。所有样式都位于`assets/styles`目录中。它具有以下结构：
- en: '![It''s time to apply some style](../images/00136.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![是时候应用一些风格](../images/00136.jpeg)'
- en: Directory structure
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 目录结构
- en: As for the final look, here is what it looks like.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 至于最终的外观，就是这样的。
- en: 'This is the main page with the Pomodoro timer:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有Pomodoro计时器的主页面：
- en: '![It''s time to apply some style](../images/00137.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![是时候应用一些风格](../images/00137.jpeg)'
- en: Main page that contains the Pomodoro timer
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 包含Pomodoro计时器的主页面
- en: 'Here is what the Settings page looks like:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置页面的样子：
- en: '![It''s time to apply some style](../images/00138.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![是时候应用一些风格](../images/00138.jpeg)'
- en: Look and feel of the Settings page
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 设置页面的外观和感觉
- en: 'And finally, here is what the Workouts page looks like:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这就是Workouts页面的样子：
- en: '![It''s time to apply some style](../images/00139.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![是时候应用一些风格](../images/00139.jpeg)'
- en: Look and feel of the Workouts page
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Workouts页面的外观和感觉
- en: 'You will still have to implement the Statistics page – right now, it just shows
    the total amount of completed Pomodoros:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然需要实现统计页面-现在，它只显示完成的Pomodoro的总数：
- en: '![It''s time to apply some style](../images/00140.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![是时候应用一些风格](../images/00140.jpeg)'
- en: Statistics page is not fully complete, only showing the total amount of completed
    Pomodoros
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 统计页面尚未完全完成，只显示完成的Pomodoros的总数
- en: There's still some work to do, but don't you agree that we have done great work
    so far? Not only do we have a fully functioning configurable Pomodoro timer, we
    can also already use it to do small workouts during our working day. How great
    is that?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些工作要做，但你不觉得我们迄今为止做得很好吗？我们不仅拥有一个完全可配置的番茄钟计时器，还可以在工作日进行小型锻炼。这是多么棒啊！
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have finally implemented the workout management page. Now
    we can see all the workouts stored in the database and create our own workouts.
    We have learned how to use the Google Firebase data storage system and API to
    store static files and we were able to store newly created workouts in the Firebase
    real-time database. We have also learned how to use a Bootstrap modal and used
    it to display each workout in a nice modal popup.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于实现了锻炼管理页面。现在我们可以看到数据库中存储的所有锻炼，并创建我们自己的锻炼。我们学会了如何使用Google Firebase数据存储系统和API来存储静态文件，并且能够将新创建的锻炼存储在Firebase实时数据库中。我们还学会了如何使用Bootstrap模态框，并将其用于在漂亮的模态弹出窗口中显示每个锻炼。
- en: In the next chapter, we will do the most important job of every software implementation
    process – we will test what we have done so far. We will use Jest ([https://facebook.github.io/jest/](https://facebook.github.io/jest/))
    to test our application. After that, we will finally deploy our application and
    define future work. Are you ready for testing your work? Then turn the page!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进行每个软件实施过程中最重要的工作 - 我们将测试迄今为止所做的工作。我们将使用Jest ([https://facebook.github.io/jest/](https://facebook.github.io/jest/))
    来测试我们的应用程序。之后，我们将最终部署我们的应用程序并定义未来的工作。你准备好测试你的工作了吗？那就翻开下一页吧！
