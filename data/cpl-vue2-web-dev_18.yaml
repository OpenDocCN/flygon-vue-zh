- en: Large Application Patterns with Vuex
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vuex的大型应用程序模式
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Dynamically loading pages in your vue-router
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在vue-router中动态加载页面
- en: Building a simple storage for the application state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序状态构建一个简单的存储
- en: Understanding Vuex mutations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Vuex的mutations
- en: Listing your actions in Vuex
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vuex中列出你的操作
- en: Separating concerns with modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块分离关注点
- en: Building getters to help retrieve your data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建getter来帮助检索数据
- en: Testing your store
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的存储
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, you will learn how Vuex works and how to use it to support
    a scalable application. Vuex implements a pattern that is popular in frontend
    frameworks and consists of dividing the different concerns to manage a big global
    application state. The mutations are the only things that can change the state,
    so you have only one place to look for that. Much of the logic, along with all
    the asynchronous logic, is contained in the actions; finally, getters and modules
    further help to spread the cognitive load when it comes to computing the derived
    state and splitting your code into different files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习Vuex的工作原理以及如何使用它来支持可扩展的应用程序。Vuex实现了一种在前端框架中流行的模式，它包括将不同的关注点分开来管理一个大型全局应用程序状态。mutations是唯一可以改变状态的东西，所以你只需要在一个地方查找它。大部分逻辑，以及所有的异步逻辑，都包含在actions中；最后，getters和modules进一步帮助分散认知负荷，当涉及计算派生状态和将代码拆分成不同的文件时。
- en: Along with recipes, you will find grains of wisdom that I found useful when
    developing real large applications; some have to do with naming conventions and
    others with little tricks to avoid bugs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配方，你还会发现我在开发真正大型应用程序时发现有用的智慧之言；有些与命名约定有关，有些与避免错误的小技巧有关。
- en: If you complete all the recipes, you will be ready to develop big frontend applications
    with fewer bugs and seamless collaboration.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成了所有的配方，你将准备好开发大型前端应用程序，减少错误并实现无缝协作。
- en: Dynamically loading pages in your vue-router
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在vue-router中动态加载页面
- en: Soon, you will build huge Vue websites with loads of components. Loading a lot
    of JavaScript may generate wasteful and useless upfront delay.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，你将建立大量组件的大型Vue网站。加载大量JavaScript可能会产生浪费和无用的前期延迟。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires knowledge of vue-router.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要了解vue-router。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new project with `vue-cli` by making a new directory and running the
    following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建新目录并运行以下命令来使用`vue-cli`创建一个新项目：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can answer the question as you prefer, as long as you add the `vue-router`
    to the template when asked.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据自己的喜好回答问题，只要在要求时将`vue-router`添加到模板中即可。
- en: 'We will create two components: one will be our home page and it will be small
    and light, the other component will be very big and very slow to load. What we
    want to achieve is to load the home page immediately, without having to wait for
    the huge component to be downloaded by the browser.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个组件：一个将是我们的主页，它将是小而轻的，另一个组件将非常大且加载速度很慢。我们想要实现的是立即加载主页，而不必等待浏览器下载巨大的组件。
- en: 'Open the `Hello.vue` file in the `components` folder. Delete everything and
    only leave the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`components`文件夹中的`Hello.vue`文件。删除所有内容，只留下以下内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the same folder, create another file named `Massive.vue` and write the following
    inside it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个文件夹中，创建另一个名为`Massive.vue`的文件，并在其中写入以下内容：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Leave an open back tick at the last line because we have to bloat the file with
    a lot of useless data. Save and close `Massive.vue`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行留一个开放的反引号，因为我们必须用大量无用的数据膨胀文件。保存并关闭`Massive.vue`。
- en: 'In a console, go to the same directory where the file is stored and use the
    following file to put a lot of garbage into it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，转到存储文件的相同目录，并使用以下文件将大量垃圾放入其中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What this command does is append the `XXX` line to the file repeatedly 10⁶ times;
    this will add 4 million bytes to the file, making it too huge for a fast browsing
    experience.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的作用是将“XXX”行重复附加到文件中10⁶次；这将向文件添加400万字节，使其对于快速浏览体验来说太大了。
- en: 'Now we need to close the back tick we opened. Don''t try to open the file now,
    as your text editor may not be capable of opening such a big file; instead, use
    the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要关闭我们打开的反引号。不要尝试现在打开文件，因为你的文本编辑器可能无法打开这样一个庞大的文件；相反，使用以下命令：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `Massive` component is now complete.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“Massive”组件现在已经完成。
- en: 'Open the `index.js` inside the `router` folder and add the component and its route:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“router”文件夹中的“index.js”并添加组件及其路由：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After installing all the dependencies with `npm install`, we are now ready to
    launch our very large app with the `npm run dev` command.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm install`安装所有依赖项后，我们现在可以使用`npm run dev`命令启动我们非常庞大的应用程序了。
- en: 'The app will load quite fast, but that''s because it''s loading directly from
    your local storage; to simulate a more realistic scenario, open the developer
    tools at the Network tab and select network throttling. Pick something slow, such
    as GPRS or maybe good 3G, which most of us may have:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将加载得非常快，但这是因为它直接从您的本地存储加载；为了模拟更真实的情况，打开开发者工具中的网络选项卡，并选择网络限制。选择一些慢的东西，比如GPRS或者好的3G，这是我们大多数人可能拥有的：
- en: '![](assets/f48c0eb8-f26b-46a4-8776-b55eb26bb7a9.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f48c0eb8-f26b-46a4-8776-b55eb26bb7a9.png)'
- en: 'Now right-click on the refresh button and select Hard Reload to bypass the
    cache (or press *Shift* + *Cmd* + *R*):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在右键单击刷新按钮，选择硬刷新以绕过缓存（或按*Shift* + *Cmd* + *R*）：
- en: '![](assets/f2b2d058-173a-4601-bdc1-1c92008de325.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f2b2d058-173a-4601-bdc1-1c92008de325.png)'
- en: You will notice that the page doesn't load for a few minutes. You can stop the
    loading of the page by clicking on the refresh button again when it becomes an
    X.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到页面加载需要几分钟的时间。当它变成X时，你可以通过再次单击刷新按钮来停止页面的加载。
- en: 'To fix this, go back to the `index.js` file in the `router` folder. Delete
    the following line, where you import the `Massive` component:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，回到“router”文件夹中的“index.js”文件。删除以下行，其中你导入“Massive”组件：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding line is telling Webpack to include all the code contained in the
    `Massive` component in a single js bundle. Instead, we want to tell Webpack to
    keep the `Massive` component as a separate bundle and to load it only when necessary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行告诉Webpack将“Massive”组件中包含的所有代码都包含在一个单独的js捆绑包中。相反，我们希望告诉Webpack将“Massive”组件保持为一个单独的捆绑包，并且只在必要时加载它。
- en: 'Instead of directly importing the component, declare `Massive` with the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不要直接导入组件，使用以下代码声明“Massive”：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Webpack will turn this special syntax into a separate file that will be loaded
    lazily. Save and do another hard refresh with the throttling still set to slow
    speed (like GPRS to good 3G). After a few seconds, you should be able to see the
    hello page. If you want to load the `Massive` component, just add `massive` to
    the URL, but you'll be in for some waiting.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack将把这种特殊语法转换为一个单独的文件，它将被懒加载。保存并在仍然设置为慢速的限制下进行另一次硬刷新（比如GPRS到好的3G）。几秒钟后，你应该能够看到hello页面。如果你想加载“Massive”组件，只需将“massive”添加到URL中，但你将需要等待一段时间。
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now you obviously won't have such a big component in a real application, but
    you can easily see that if the `Massive` component represents all the other components
    of your app, they can quickly amount to such a big size.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在真实的应用程序中，你不会有这样一个庞大的组件，但你可以很容易地看到，如果“Massive”组件代表了你的应用程序的所有其他组件，它们很快就会累积成这样一个庞大的大小。
- en: The trick here is to load them asynchronously; Webpack will help you separate
    them into smaller bundles so that they will be loaded only if and when required.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的诀窍是异步加载它们；Webpack将帮助您将它们分成更小的包，这样它们只会在需要时加载。
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is an alternative syntax to import components lazily. It may become an
    ECMA standard in the future, so you should be aware of it. Open `index.js` inside
    the `router` directory and completely remove the import of the `Massive` component
    or the `Massive` constant line we added in this recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种替代语法可以懒惰地导入组件。这可能会成为未来的ECMA标准，所以你应该意识到这一点。打开`router`目录内的`index.js`文件，并完全删除`Massive`组件的导入，或者我们在这个示例中添加的`Massive`常量行。
- en: 'Inside the routes, try the following when specifying the component for the
    `/massive` route:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由内，当指定`/massive`路由的组件时，尝试以下操作：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will be equivalent to what we have done before because Webpack will take
    the line and instead of directly importing the code of the Massive component,
    it will create a different js file, loaded lazily.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将等同于我们之前所做的，因为Webpack将获取这行，并且不会直接导入Massive组件的代码，而是创建一个不同的js文件，懒加载加载。
- en: Building a simple storage for the application state
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序状态构建一个简单的存储
- en: In this recipe, you will understand the fundamentals of Vuex when building a
    big application. This recipe is a little unorthodox because to understand how
    Vuex's store work, we will manipulate it directly; you should never do that in
    a real application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将了解在构建大型应用程序时Vuex的基本原理。这个示例有点不正统，因为为了理解Vuex存储的工作原理，我们将直接操作它；在真实应用程序中，你永远不应该这样做。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before trying this recipe, you should know how to make components talk with
    Vuex.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试这个示例之前，您应该知道如何让组件与Vuex通信。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new project based on the Webpack template with the following command
    run in a new directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的目录中运行以下命令，基于Webpack模板创建一个新项目：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How you answer the question is not relevant. Run `npm intall` and install Vuex
    with `npm install vuex --save` or `yarn add vuex` if you use yarn.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何回答这个问题并不重要。运行`npm intall`并使用`npm install vuex --save`或者如果你使用yarn，使用`yarn
    add vuex`来安装Vuex。
- en: 'Open the  `main.js` file inside the `src` folder and add the following highlighted
    lines to finish installing Vuex:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`src`文件夹内的`main.js`文件，并添加以下突出显示的行以完成安装Vuex：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, there is no `store` module right now, so you need to create one.
    To do this, create a folder just under the `src` folder and call it `store`. Inside
    it, create a file named `index.js`. In the `main.js` file, we didn't specify to
    use the `index.js` file, but that's the default behavior when no file is specified
    but only the folder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在没有`store`模块，所以你需要创建一个。为此，在`src`文件夹下创建一个名为`store`的文件夹。在其中，创建一个名为`index.js`的文件。在`main.js`文件中，我们没有指定使用`index.js`文件，但当没有指定文件而只有文件夹时，这是默认行为。
- en: 'What we will implement is a simplified stock market. We have three assets:
    stars (STAR), lamps (LAMP), and diamonds (DIAM). We will define two routes: one
    for the STAR/LAMP market and another for the LAMP/DIAM market.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的是一个简化的股票市场。我们有三种资产：星星（STAR）、灯（LAMP）和钻石（DIAM）。我们将定义两条路线：一条用于STAR/LAMP市场，另一条用于LAMP/DIAM市场。
- en: 'Inside the `index.js` file in the store folder, write the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储文件夹中的`index.js`文件中，写入以下内容：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We are creating a new `Vuex` store that will hold our balance. Initially, we
    have 100 of each asset; in the store, the exchange rate between stars and lamps
    and between lamps and diamonds is also fixed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个新的`Vuex`存储，用于保存我们的余额。最初，我们每种资产有100个；在存储中，星星和灯之间的汇率以及灯和钻石之间的汇率也是固定的。
- en: 'Create a new component under the `components` directory, named `Market.vue`.
    It will have the following template:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`目录下创建一个名为`Market.vue`的新组件。它将具有以下模板：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`symbol1` and `symbol2` represent the two assets traded. In the JavaScript
    of this component, where we define the `sell` and `buy` methods, we operate directly
    on the global `Vuex` store:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbol1`和`symbol2`代表两种交易的资产。在这个组件的JavaScript中，我们定义了`sell`和`buy`方法，直接在全局`Vuex`存储上操作：'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should never touch the state directly like I've done here. You should always
    use mutations. Here, we are skipping the middleman to keep the recipe minimalistic.
    There's more on mutations in the next recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应该像我在这里所做的那样直接触摸状态。您应该始终使用mutations。在这里，我们跳过中间人以保持食谱的最小化。关于mutations的更多内容将在下一个食谱中介绍。
- en: 'You have to use this component in `index.js`, inside the `router` folder, in
    the following way:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在`router`文件夹中的`index.js`中以以下方式使用此组件：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we are using the `Market` component for any route that
    contains a couple of trade symbols. As a home page, we are using the STAR/LAMP
    market.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们对包含一对交易符号的任何路由使用`Market`组件。作为主页，我们使用STAR/LAMP市场。
- en: 'To display some navigation links to a different market and our current balance,
    we can edit the `App.vue` component with the following template:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示一些导航链接到不同的市场和我们当前的余额，我们可以编辑`App.vue`组件，使用以下模板：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We don't need any JavaScript for this component, so you can delete the `<script>`
    tag.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个组件，我们不需要任何JavaScript，所以可以删除`<script>`标签。
- en: 'Our app is now ready; launch it and start trading with it. The following image
    is our completed app without the styles contained in `App.vue`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在已经准备就绪；启动它并开始交易。以下图片是我们完成的应用程序，不包括`App.vue`中包含的样式：
- en: '![](assets/95c7b7aa-c82a-487c-b2a0-ef250352da04.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/95c7b7aa-c82a-487c-b2a0-ef250352da04.png)'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The balance in the bottom is like a summary of the global state. With Vuex,
    we were able to affect other components by accessing the `$store` variable that
    gets injected into every component by the Vuex plugin. You can easily imagine
    how to use this strategy in a big application when you want to basically expand
    the scope of a variable beyond the component itself.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的余额就像全局状态的摘要。通过Vuex，我们能够通过访问每个组件都被Vuex插件注入的`$store`变量来影响其他组件。当您想要基本上扩展变量的范围超出组件本身时，您可以很容易地想象如何在大型应用程序中使用这种策略。
- en: Some of the states may be local, for example, if you need some animations or
    you need some variables to show modal dialogs for the component; it's perfectly
    okay to not put these values in the store. Otherwise, having a structured centralized
    state in one place helps a lot. In the subsequent recipes, you'll use more advanced
    techniques to exploit the power of Vuex better.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一些状态可能是局部的，例如，如果您需要一些动画或者需要一些变量来显示组件的模态对话框；不将这些值放入存储中是完全可以的。否则，在一个地方拥有结构化的集中状态会帮助很多。在随后的食谱中，您将使用更高级的技术来更好地利用Vuex的力量。
- en: Understanding Vuex mutations
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Vuex的变异
- en: The proper way to mutate the state in a Vuex application is with the help of
    mutations. Mutations are a very useful abstraction to decompose state changes
    in the atomic unit. In this recipe, we will explore just that.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vuex应用程序中，变异状态的正确方法是使用mutations的帮助。变异是将状态更改分解为原子单位的非常有用的抽象。在这个食谱中，我们将探讨这一点。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe can be completed without knowing too much about Vuex, but completing
    the previous recipe first is suggested.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完成上一个食谱后，可以完成此食谱，而无需太多了解Vuex。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Add Vuex as a dependency to your project (the CDN address is `https://unpkg.com/vuex`).
    I will assume that you are using JSFiddle to follow along; otherwise, just remember
    to put `Vue.use(Vuex)` before the store code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将Vuex作为项目的依赖项添加（CDN地址为`https://unpkg.com/vuex`）。我假设您正在使用JSFiddle进行跟进；否则，请记住在存储代码之前放置`Vue.use(Vuex)`。
- en: The sample application we will build is to broadcast notifications to the users
    of the website.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的示例应用程序是向网站用户广播通知。
- en: 'The HTML layout looks as shown:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: HTML布局如下所示：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The idea is to have a textbox to write messages and the broadcasted messages
    will be displayed on the top with the most recent appearing first. The messages
    can be dismissed by clicking on the little x.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是有一个文本框来写消息，广播的消息将显示在顶部，最近的消息将首先显示。可以通过点击小x来关闭消息。
- en: 'First, let''s build a store that will hold the list of broadcasted messages
    and enumerate the possible mutations we can make to said list:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们构建一个存储库，用于保存广播消息列表并列举我们可以对该列表进行的可能变异：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, we have a list of messages; we can push one to the top of the list or we
    can remove a message by knowing its index.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一系列消息；我们可以将其中一个推送到列表的顶部，或者通过知道其索引来删除消息。
- en: 'Next, we need to write the logic of the application itself:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写应用程序本身的逻辑：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can now launch the app and start broadcasting messages to our imaginary
    users:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以启动应用程序并开始向我们虚构的用户广播消息：
- en: '![](assets/b0df8753-e8a1-468a-a5a8-9f6d4998a4ef.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b0df8753-e8a1-468a-a5a8-9f6d4998a4ef.png)'
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: I think it's important to note the names of the mutations; they are called `pushMessage`
    and `removeMessage`, but what they really do in this application is show the message
    in a stack on the screen and (fictionally) broadcast messages to users. Would
    it be better to call them `showMessage`, or `broadcastMessage` and `hideMessage`?
    No, that's because there has to be a clear separation of intent between the mutation
    itself and the particular effects of that mutation. The problem becomes clear
    when, for example, we decide to give users the ability to ignore these notifications
    or we introduce a delay before actually broadcasting the notifications. Then we
    will have a `showMessage` mutation that does not actually show a message.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为重要的是要注意变异的名称；它们被称为`pushMessage`和`removeMessage`，但在这个应用程序中它们真正做的是在屏幕上显示消息，并（虚构地）向用户广播消息。将它们称为`showMessage`或`broadcastMessage`和`hideMessage`会更好吗？不会，因为变异本身和该变异的特定效果之间必须有明确的意图分离。当我们决定让用户有能力忽略这些通知或者在实际广播通知之前引入延迟时，问题就变得清晰了。然后我们将有一个`showMessage`变异，它实际上并不显示消息。
- en: 'The computed syntax we have used is as illustrated:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的计算语法如下所示：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You don't have to explicitly use Vuex in your expression when you are importing
    Vuex as an ES6 module. You just need to write
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将Vuex作为ES6模块导入时，您不必在表达式中显式使用Vuex。您只需要写
- en: '`import { mapState } from ''Vuex''`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { mapState } from ''Vuex''`。'
- en: Then, the `mapState` function will be available.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`mapState`函数将可用。
- en: The `mapState` method takes an array of strings as a parameter, looks for a
    `state` variable in the store with the same name as the string, and creates a
    computed property with the same name. You can do this with as many variables as
    you want.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapState`方法以字符串数组作为参数，查找存储中具有相同名称的`state`变量，并创建具有相同名称的计算属性。您可以使用任意数量的变量来做到这一点。'
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you followed along on a local npm project, open the Vue developer tools
    (unfortunately Vue developer tools is not available when using JSFiddle) and you
    will see that a new mutation is issued with each message. Consider that you click
    on the little clock:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本地npm项目上跟随操作，请打开Vue开发者工具（不幸的是，在使用JSFiddle时，Vue开发者工具不可用），您将看到每条消息都会发出一个新的变异。考虑一下，您点击了小时钟：
- en: '![](assets/988d23d1-8897-430e-bf94-be7b51e37be7.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/988d23d1-8897-430e-bf94-be7b51e37be7.png)'
- en: 'You can actually undo the mutation with that, as shown in the following illustration:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以使用它来撤消变异，如下图所示：
- en: '![](assets/19f87abf-9a68-4259-8bfc-55d060a5fce4.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/19f87abf-9a68-4259-8bfc-55d060a5fce4.png)'
- en: Note how the state didn't change when clicking the time travel option; that's
    because the purple ribbon is still at the last state. To examine a different state,
    just click on the name of the mutation itself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当点击时间旅行选项时，状态并未发生变化；这是因为紫色丝带仍然停留在最后的状态。要查看不同的状态，只需点击变异名称本身。
- en: This debug mechanism is possible because mutations are always synchronous; this
    means that it's possible to take a snapshot of the state before and after the
    mutation and navigate through time. In the next recipe, you will learn how to
    use Vuex to perform asynchronous actions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调试机制是可能的，因为变异始终是同步的；这意味着可以在变异之前和之后对状态进行快照，并在时间轴上导航。在下一个食谱中，您将学习如何使用Vuex执行异步操作。
- en: Listing your actions in Vuex
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Vuex中列出您的操作
- en: All your mutations must be synchronous, so how do you do things such as waiting
    for a timeout or using Axios for an AJAX request? Actions are the next level of
    abstraction that will help you with this. Inside an action, you can commit multiple
    mutations and make asynchronous operations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您的所有变异必须是同步的，那么如何做一些等待超时或使用Axios进行AJAX请求的事情呢？操作是下一个抽象级别，将帮助您处理这些问题。在操作中，您可以提交多个变异并执行异步操作。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Mutations are the building blocks of actions, so it's highly suggested you complete
    the preceding recipe before trying this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 变异是操作的构建块，因此强烈建议您在尝试此操作之前完成前面的食谱。
- en: We will be using the setup from the *Building a simple storage for the application
    state* recipe; you can use your own as well, but in any case, this recipe is based
    on a slight modification of the official Webpack template.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用“为应用程序状态构建简单存储”食谱中的设置；您也可以使用自己的设置，但无论如何，此食谱都是基于官方Webpack模板的轻微修改。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: You will build a clone of the popular Xkcd website. Actually, it will be a wrapper
    more than a real clone, since we will reuse the panels from the website.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您将构建一个流行的Xkcd网站的克隆。实际上，它将更像是一个包装器，而不是一个真正的克隆，因为我们将重用网站上的面板。
- en: 'Create a Vue project based on the Webpack template with `vue init webpack`.
    The first thing we will do is wire up the API to the Xkcd website in the `index.js`
    inside the `config` folder. Put the following lines inside the `proxyTable` object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Webpack模板创建一个Vue项目，使用`vue init webpack`命令。我们首先要做的是在`config`文件夹中的`index.js`中将API连接到Xkcd网站。将以下行放入`proxyTable`对象中：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will redirect all the requests we make to `/comic` to the Xkcd website.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们发出的所有请求重定向到`/comic`到Xkcd网站。
- en: 'Inside `src`, make a new `store` directory and an `index.js` inside it; here,
    start building the application store:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`目录下，创建一个新的`store`目录，并在其中创建一个`index.js`文件；在这里，开始构建应用程序存储：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You should import this inside `main.js` like in previous recipes. We want to
    trace the current panel number, the link to the panel image, and the possible
    errors. The only way to modify the state is through mutations, while actions can
    perform asynchronous work.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该像以前的食谱一样在`main.js`中导入这个。我们想要跟踪当前面板编号，面板图像的链接以及可能的错误。修改状态的唯一方法是通过变异，而操作可以执行异步工作。
- en: 'When the app is loaded, we plan to display the latest comic. For this, we create
    an action:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序加载时，我们计划显示最新的漫画。为此，我们创建一个动作：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For this code to work, we need to declare the endpoint and install Axios:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此代码工作，我们需要声明端点并安装Axios：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It should be easy for you to write the corresponding mutations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您来说，编写相应的突变应该很容易：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll recycle the `Hello.vue` component and put the following template inside
    it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用`Hello.vue`组件，并在其中放入以下模板：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To make the last panel appear on loading you can use the following JavaScript
    in the component:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在加载时显示最后一个面板，您可以在组件中使用以下JavaScript：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Also, you can delete most of the `App.vue` template and leave only the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以删除大部分`App.vue`模板，只留下以下内容：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `proxyTable` object will configure the `http-proxy-middleware`. This is
    useful every time we are developing the UI of a bigger web application and we
    launch our developer server on `localhost`, but our API responds to another web
    server. This is especially relevant when we want to use CORS and we don't allow
    other websites to use our API. The Xkcd API doesn't allow `localhost` to consume
    the web service. This is why, even if we try to use the Xkcd API directly, our
    browser won't let us. The `changeOrigin` option will send the request with Xkcd
    as host, making CORS unnecessary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxyTable`对象将配置`http-proxy-middleware`。每当我们开发大型Web应用程序的UI并在`localhost`上启动开发服务器，但我们的API响应到另一个Web服务器时，这将非常有用。当我们想要使用CORS并且不允许其他网站使用我们的API时，这一点尤为重要。Xkcd
    API不允许`localhost`消耗Web服务。这就是为什么，即使我们尝试直接使用Xkcd API，我们的浏览器也不会让我们这样做。`changeOrigin`选项将以Xkcd为主机发送请求，从而使CORS变得不必要。'
- en: To call an action from a component, we used the `dispatch` function. It's also
    possible to pass the second argument, the first being the name of the action itself.
    The second argument is then passed when you define the action as the second parameter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要从组件中调用一个动作，我们使用了`dispatch`函数。还可以传递第二个参数，第一个是动作本身的名称。然后在定义动作时将第二个参数传递。
- en: A last note on the naming--it being implicit that actions are asynchronous while
    mutations are synchronous, there is no need, in my opinion, to make the asynchronicity
    in the name of the actions explicit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命名的最后说明——在我的看法中，由于动作是异步的，而突变是同步的，因此无需在动作的名称中显式地表明异步性。
- en: Separating concerns with modules
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块分离关注点
- en: When building big applications, the Vuex store can become crowded. Luckily,
    it's possible to divide the different concerns of the applications into separate
    compartments with modules.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 构建大型应用程序时，Vuex存储可能会变得拥挤。幸运的是，可以使用模块将应用程序的不同关注点分成单独的区块。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe can be a reference if you want to use modules. You are expected
    to already know enough about Vuex.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用模块，这个示例可以作为参考。您应该已经对Vuex有足够的了解。
- en: For this recipe, you will have to be a little familiar with Webpack.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您需要对Webpack有一定的了解。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will model a fully functional human body in a slightly simplified
    manner. Every organ will have a separate module.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将以稍微简化的方式对一个完全功能的人体进行建模。每个器官都将有一个单独的模块。
- en: 'Create a new Webpack template with `vue init webpack` and `npm install vuex`.
    Create a new directory with the `src/store/index.js` file in it. Inside, write
    the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vue init webpack`和`npm install vuex`创建一个新的Webpack模板。在其中创建一个包含`src/store/index.js`文件的新目录。在其中，写入以下内容：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `heart` module is like this; put it before the store declaration:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`heart`模块是这样的；将其放在存储声明之前：'
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note how the state passed inside the mutations is not the root state, but the
    local state of the module.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，传递给突变的状态不是根状态，而是模块的本地状态。
- en: 'Then comes the brain, which is divided into the left and right lobes; write
    the following before the store:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是大脑，它分为左叶叶和右叶叶；在存储之前写入以下内容：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can implement them as simple Boolean states (write them before the brain
    on which they depend):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将它们实现为简单的布尔状态（在它们所依赖的大脑之前写入）：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Setting `namespaced` to true modifies the way you can call the mutator. Since
    they are both called `toggle`, now you can specify which lobe, for example, for
    the left lobe the mutation string becomes `left/toggle`, where `left` says it
    is the key used in the brain to refer to the left lobe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将`namespaced`设置为true会修改你调用mutator的方式。因为它们都被称为`toggle`，现在你可以指定哪个叶叶，例如，对于左叶叶，变异字符串变成了`left/toggle`，其中`left`表示它是大脑中用来指代左叶叶的键。
- en: 'To see your store in action, you can create a component that uses all the mutations.
    For the brain, we can have two pictures of the lobes, like so:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你的存储在运行中的情况，你可以创建一个使用所有变异的组件。对于大脑，我们可以有两张叶叶的图片，如下所示：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will create two drawings of brain lobes in red pencil; note the use of
    the name of the modules in a nested way. The following `off` CSS rule grays the
    lobes out:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用红色铅笔创建两个大脑叶叶的图画；注意嵌套方式中模块名称的使用。以下的`off` CSS规则会使叶叶变灰：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To call the mutations, we use the aforementioned strings in the right methods:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用变异，我们在正确的方法中使用上述字符串：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also create an input textbox and call the other two mutations, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个输入文本框，并调用其他两个变异，如下所示：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This was very easy, but how do you retrieve the loved name? You can put these
    mustachios in your template:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易，但是如何检索叶叶的名称呢？你可以在你的模板中放上这些大括号：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You obviously have to declare the `partner` variable on your Vue instance:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你必须在你的Vue实例上声明`partner`变量：
- en: '![](assets/dfd584ca-c301-4db6-acda-b82b5e5b36c6.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dfd584ca-c301-4db6-acda-b82b5e5b36c6.png)'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have seen how to use modules to split your application concerns into different
    units. This ability may become important as the project grows in size.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用模块将你的应用程序关注点分成不同的单元。随着项目规模的增长，这种能力可能变得很重要。
- en: 'The common pattern is that while inside a mutation, you have direct access
    to the local state:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 常见模式是，在变异中，你可以直接访问本地状态：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In a mutation, it makes sense to have access only to the local state. The brain,
    for example, cannot change the heart and vice versa, but what about actions? If
    we declare an action inside a module, we are passed an object called context that
    looks like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在变异中，只有访问本地状态是有意义的。例如，大脑不能改变心脏，反之亦然，但动作呢？如果我们在模块内声明一个动作，我们会得到一个名为上下文的对象，看起来像这样：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, if we want to declare an action in the left lobe and we want to affect
    the heart, we have to do something like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想在左叶叶中声明一个动作，并且想要影响心脏，我们必须做类似以下的事情：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Building getters to help retrieve your data
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建getter来帮助检索你的数据
- en: You don't want to keep too much data in your state. It can be especially dangerous
    to keep duplicate or derivative data because it can be brought out of sync very
    easily. Getters help you with this without shifting the burden onto the components
    by keeping all the logic in one place.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想在你的状态中保存太多数据。保留重复或派生数据可能特别危险，因为它很容易失去同步。Getter可以帮助你做到这一点，而不会将负担转移到组件上，因为它将所有逻辑都保存在一个地方。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is for you if you already have some Vuex knowledge and want to expand
    your horizons.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经具有一些Vuex知识并且想要拓展你的视野，那么这个教程适合你。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Imagine that you are building a Bitcoin wallet. You want to give your users
    an overview of their balance, and you want them to see how many Euros it corresponds
    to.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在构建一个比特币钱包。你想给你的用户一个余额概览，并且你希望他们看到它对应多少欧元。
- en: 'Create a new Webpack template with `vue init webpack` and `npm install vuex`.
    Create a new `src/store/index.js` file and write the following inside it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“vue init webpack”和“npm install vuex”创建一个新的Webpack模板。创建一个新的“src/store/index.js”文件，并在其中写入以下内容：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code is prone to errors. The first error can be a miscalculation of the
    Euro amount if we don't get the multiplication right. The second kind of error
    can be that we tell the user the `bitcoin` and `euro` balance during a transaction,
    resulting in a stale and wrong amount for one of the two.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码容易出错。如果我们没有正确进行乘法运算，第一个错误可能是欧元金额的错误计算。第二种错误可能是在交易过程中告诉用户“比特币”和“欧元”余额，导致其中一种金额过时和错误。
- en: 'To tackle these issues, we use `getters`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们使用“getters”：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This way the `euro` amount is never in the state but always computed. Moreover,
    it is centralized in the store, so we don't need to add anything to our components.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，“欧元”金额永远不会在状态中，而是始终计算。此外，它是集中在存储中，因此我们不需要向我们的组件添加任何内容。
- en: 'Now, it''s easy to retrieve the two amounts from a template:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从模板中轻松检索两个金额：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, `&#3647 ;` is the HTML entity for the Bitcoin symbol.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“&#3647 ;”是比特币符号的HTML实体。
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Having a `getter` for derived data is always a good idea if we are not talking
    about input data. A notable feature of getters we have not yet discussed is their
    ability to interact with other getters and take an argument.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不谈论输入数据，为派生数据设置一个getter总是一个好主意。我们尚未讨论的getter的一个显着特点是它们能够与其他getter进行交互并接受参数。
- en: Accessing other getters
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问其他getter
- en: 'The second argument passed to a getter when called is the object that contains
    the other `getters`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 调用getter时传递的第二个参数是包含其他“getters”的对象：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In our recipe, we could call the `euro` getter to have some more derived data,
    like roughly how many houses we can buy with our Bitcoin given an average price
    of 150,000 euros:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以调用“euro”getter来获得一些更多的派生数据，比如我们可以用150,000欧元的平均价格大致计算出我们可以用比特币购买多少房屋：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Passing an argument
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递参数
- en: 'If a getter returns a function with an argument, that argument will be the
    argument of the getter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果getter返回一个带有参数的函数，那么该参数将成为getter的参数：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In our recipe, a practical example could specify the average cost of a house
    in the getter from the previous paragraph:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，一个实际的例子可以指定前一段中的getter中房屋的平均成本：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Testing your store
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的store
- en: In this recipe, you will write tests for a Vuex store.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将为Vuex存储编写测试。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe requires knowledge of Unit testing and End-To-End testing and little
    familiarity with Vuex.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例需要对单元测试和端到端测试有所了解，并且对Vuex有一些了解。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, I'll define some features that our store must implement; then you will
    write tests that prove that the features are present and working.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将定义我们的存储必须实现的一些功能；然后，您将编写证明这些功能存在且正常工作的测试。
- en: Software requirements
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件要求
- en: 'Our store consists of items in a to-do list, like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的存储包括待办事项列表中的项目，如下所示：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have two requirements:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个要求：
- en: We must have an `MARK_ITEM_AS_DONE` mutation that changes the `done` field from
    false to true
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个“MARK_ITEM_AS_DONE”mutation，将“done”字段从false更改为true。
- en: We must have a `downloadNew` action that downloads the latest items from our
    server and adds them to the list
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个“downloadNew”操作，从服务器下载最新项目并将其添加到列表中。
- en: Testing mutations
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试mutations
- en: 'To be able to test your mutations, you have to make them available for your
    test files. To do this, you have to extract the mutation object from your store.
    Consider something like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够测试您的mutations，您必须使它们可用于您的测试文件。为此，您必须从存储中提取mutation对象。考虑类似于这样的东西：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You have to extract it to something similar to this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须将其提取为类似于这样的东西：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This way, you can import the mutations in your test files with the following
    line:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您可以在测试文件中使用以下行导入突变：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The test for requirement number 1 can be written as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对第1个要求的测试可以编写如下：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you are using the official Webpack template, you can run your tests with
    `npm run unit`. This uses PhantomJS by default, which doesn't implement some features.
    You can either use Babel polyfills or simply go into `karma.conf.js` and write
    `Chrome` instead of `PhantomJS` in the `browsers` array. Remember to install the
    Chrome launcher with `npm install karma-chrome-launcher --save-dev`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用官方的Webpack模板，可以使用`npm run unit`运行测试。这默认使用PhantomJS，它不实现一些功能。您可以使用Babel
    polyfills，或者简单地进入`karma.conf.js`并在`browsers`数组中写入`Chrome`而不是`PhantomJS`。记得使用`npm
    install karma-chrome-launcher --save-dev`安装Chrome启动器。
- en: Testing actions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试行动
- en: '**Testing actions** means testing that the action commits the expected mutations.
    We are not interested in the mutations themselves (not in unit tests at least)
    because they are already tested separately. We might, though, need to mock some
    dependencies.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试行动**意味着测试行动是否提交了预期的突变。我们对突变本身不感兴趣（至少在单元测试中不感兴趣），因为它们已经单独测试过了。不过，我们可能需要模拟一些依赖关系。'
- en: 'To avoid any dependencies from Vue or Vuex (since we don''t need them and they
    may pollute the tests), we create a new `actions.js` file inside the `store` directory.
    Install Axios with `npm install axios`. The `actions.js` file can look like the
    following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免依赖于Vue或Vuex（因为我们不需要它们，它们可能会污染测试），我们在`store`目录中创建了一个新的`actions.js`文件。使用`npm
    install axios`安装Axios。`actions.js`文件可以如下所示：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To test for requirement number 2, we start by mocking the call to the server
    that should download the new to-do items:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试第2个要求，我们首先模拟应该下载新待办事项的服务器调用：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This will ensure that any call to the get method of `axios` will always return
    a new to-do item.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保对`axios`的`get`方法的任何调用都将始终返回一个新的待办事项。
- en: 'Then, we want to ensure that the `ADD_ITEMS` mutation is called upon dispatch:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们希望确保在调度时调用`ADD_ITEMS`突变：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While the testing of the mutations is pretty straightforward, I think the testing
    of the actions deserves some more explaining.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对突变的测试非常简单，但我认为对行动的测试需要更多的解释。
- en: Since we didn't want to depend on external services for actions, we had to mock
    the `axios` service. We used the `inject-loader`, which takes the original library
    and mocks the parts we specify with arbitrary code (the `@` symbol is a shorthand
    for `src`); in our case, we mocked the `axios` library and, precisely, the `get`
    method. We had to use the CommonJS syntax (with the `require`) because that's
    the only way to tell Webpack to use loaders in imports.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想依赖外部服务来执行操作，我们不得不模拟`axios`服务。我们使用`inject-loader`，它接受原始库并用任意代码模拟我们指定的部分（`@`符号是`src`的简写）；在我们的情况下，我们模拟了`axios`库，特别是`get`方法。我们必须使用CommonJS语法（带有`require`）因为这是告诉Webpack在导入时使用加载器的唯一方法。
- en: What we have done in the test is that we also mocked the `commit` function.
    Normally, this function calls a mutation that modifies the state. We just want
    to know if the correct mutation is called and with the right arguments. Moreover,
    we had to wrap everything in a `try` block; without it, the test would fail over
    a timeout and we'd lose the error. Instead, now we fail immediately and we can
    read, from the console, what error caused the test to fail.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们还模拟了`commit`函数。通常，这个函数调用一个修改状态的突变。我们只想知道是否调用了正确的突变，并且带有正确的参数。此外，我们必须将所有内容包装在`try`块中；如果没有它，测试将因超时而失败，我们将丢失错误。相反，现在我们立即失败，我们可以从控制台中读取导致测试失败的错误。
