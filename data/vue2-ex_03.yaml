- en: Optimizing your App and Using Components to Display Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化您的应用程序并使用组件显示数据
- en: In [Chapter 2](part0031.html#TI1E0-985bf4ae118d4f62b18ae64204cb251c), *Displaying,
    Looping, Searching, and Filtering Data*, we got our Vue app displaying our people
    directory, we can use this opportunity to optimize our code and separate it out
    into components. This makes the code more manageable, easier to understand, and
    makes it easier for other developers to work out the flow of data (or you, when
    you come back and look at your code in a few months!).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0031.html#TI1E0-985bf4ae118d4f62b18ae64204cb251c)中，*显示、循环、搜索和过滤数据*，我们让Vue应用程序显示了我们的人员目录，我们可以利用这个机会来优化我们的代码并将其分离成组件。这使得代码更易于管理，更容易理解，并且使其他开发人员能够更容易地了解数据流程（或者在几个月后再次查看代码时，您自己也能更容易理解）。
- en: 'This chapter is going to cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Optimizing our Vue.js code by reducing the repetition, and logically organizing
    our code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过减少重复和逻辑组织我们的代码来优化我们的Vue.js代码
- en: How to create Vue components and use them with Vue
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建Vue组件并在Vue中使用它们
- en: How to use props and slots with components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在组件中使用props和slots
- en: Utilizing events to transfer data between components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用事件在组件之间传递数据
- en: Optimizing the code
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化代码
- en: 'As we wrote the code while we were figuring out the problem, there comes a
    point when you need to take a step back and look at your code to optimize it.
    This could include reducing the number of variables and methods or creating methods,
    to reduce repeating functionality. Our current Vue app looks like the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在解决问题时编写代码时，有一个时刻你需要退后一步，审视你的代码以进行优化。这可能包括减少变量和方法的数量，或者创建方法来减少重复的功能。我们当前的Vue应用程序如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Looking at the preceding code, there are some improvements we can make. These
    include:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看上述代码，我们可以进行一些改进。这些包括：
- en: Reducing the number of filter variables and grouping logically
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少过滤变量的数量并进行逻辑分组
- en: Combining the format functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并格式化函数
- en: Reducing the number of hard-coded variables and properties
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少硬编码的变量和属性的数量
- en: Re-ordering methods into a more logical order
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将方法重新排序为更合理的顺序
- en: We'll cover these points individually so we have a clean code base for building
    components with.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个讨论这些要点，以便我们有一个干净的代码库来构建组件。
- en: Reducing the number of filter variables and grouping logically
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少过滤变量的数量并进行逻辑分组
- en: 'The filtering currently uses up three variables, `filterField`, `filterQuery`,
    and `filterUserState`. The only thing that currently links these variables is
    the name, rather than being in an object of their own to link them systematically.
    Doing this avoids any ambiguity as to whether they are related to the same component
    or just coincidentally the same. In the data object, create a new object titled
    `filter` and move each variable inside:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的过滤使用了三个变量`filterField`，`filterQuery`和`filterUserState`。目前唯一将这些变量联系在一起的是名称，而不是它们自己的对象以系统地将它们链接在一起。这样做可以避免任何关于它们是否与同一组件相关或仅仅是巧合的歧义。在数据对象中，创建一个名为`filter`的新对象，并将每个变量移动到其中：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To access the data, update any references of `filterField` to `this.filter.field`.
    Note the extra dot, denoting it is a key of the filter object. Don''t forget to
    update `filterQuery` and `filterUserState` references as well. For example, the
    `isActiveFilterSelected` method would become:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数据，请将`filterField`的任何引用更新为`this.filter.field`。注意额外的点，表示它是过滤器对象的键。不要忘记更新`filterQuery`和`filterUserState`的引用。例如，`isActiveFilterSelected`方法将变为：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will also need to update the `v-model` and `v-show` attributes in your view—there
    are five occurrences of the various variables.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在视图中更新`v-model`和`v-show`属性-有五个不同变量的出现。
- en: While updating the filtering variables, we can take this opportunity to remove
    one. With our current filtering, we can only have one filter active at a time.
    This means the `query` and `userState` variables are only being used at any one
    time, which gives us the opportunity to combine these two variables. To do so,
    we'll need to update the view and application code to cater for this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新过滤变量的同时，我们可以利用这个机会删除一个变量。根据我们当前的过滤，我们一次只能有一个过滤器处于活动状态。这意味着 `query` 和 `userState`
    变量在任何时候只被使用一次，这给我们合并这两个变量的机会。为了做到这一点，我们需要更新视图和应用程序代码来适应这个变化。
- en: Remove the `userState` variable from your filter data object and update any
    occurrence of `filter.userState` in your view to `filter.query`. Now do a *find
    and replace* in your Vue JavaScript code for `filter.userState`, again replacing
    it with `filter.query`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的过滤数据对象中删除 `userState` 变量，并将视图中的任何 `filter.userState` 出现更新为 `filter.query`。现在，在您的Vue
    JavaScript代码中进行*查找和替换*，将 `filter.userState` 替换为 `filter.query`。
- en: 'Viewing your app in the browser, it will appear to initially work, being able
    to filter users by the field. However, if you filter by status, then switch to
    any other field, the query field won''t show. This is because using the radio
    buttons sets the value to a Boolean which, when trying to convert to lowercase
    for the query field, fails to do so. To tackle this, we can convert whatever value
    is in the `filter.query` variable to a string using the native JavaScript `String()`
    function. This ensures that our filtering function can work with any filtering
    input:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看您的应用程序时，它将首先显示正常，可以通过字段对用户进行筛选。然而，如果您按状态筛选，然后切换到任何其他字段，查询字段将不会显示。这是因为使用单选按钮将值设置为布尔值，当尝试将其转换为小写以用于查询字段时，无法成功。为了解决这个问题，我们可以使用原生的JavaScript
    `String()` 函数将 `filter.query` 变量中的任何值转换为字符串。这确保我们的过滤函数可以处理任何过滤输入：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding this to our code now ensures our query data is usable no matter what
    the value. The issue this now creates is when the user is switching between fields
    to filter. If you select the Active user and chose a radio button, the filtering
    works as expected, however, if you now switch to Email, or another field, the
    input box is prepopulated with either `true` or `false`. This instantly filters
    and will often return no results. This also occurs when switching between two
    text filtering fields, which is not the desired effect.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这个添加到我们的代码中，确保我们的查询数据可以使用任何值。现在创建的问题是当用户在字段之间切换进行筛选时。如果您选择了活动用户并选择了一个单选按钮，过滤将按预期工作，然而，如果您现在切换到电子邮件或其他字段，输入框将预填充为
    `true` 或 `false`。这会立即进行过滤，并且通常不会返回任何结果。当在两个文本过滤字段之间切换时，也会发生这种情况，这不是期望的效果。
- en: What we want is, whenever the select box is updated, the filter query should
    clear. Whether it is the radio buttons or input box, selecting a new field should
    reset the filter query, this ensures a new search can begin.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望的是，无论是单选按钮还是输入框，每当选择框更新时，过滤查询都应该被清除。选择一个新字段应该重置过滤查询，这样可以开始一个新的搜索。
- en: This is done by removing the link between the select box and the `filter.field`
    variable and creating our own method to handle the update. We then trigger the
    method when the select box is changed. This method will then clear the `query`
    variable and set the `field` variable to the select box value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过删除选择框与 `filter.field` 变量之间的链接，并创建我们自己的方法来处理更新来完成的。然后，在选择框更改时触发该方法。该方法将清除
    `query` 变量并将 `field` 变量设置为选择框的值。
- en: Remove the `v-model` attribute on the select box and add a new `v-on:change` attribute.
    We will pass a method name into this that will fire every time the select box
    is updated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择框上删除 `v-model` 属性，并添加一个新的 `v-on:change` 属性。我们将传递一个方法名给它，每当选择框更新时都会触发该方法。
- en: '`v-on` is a new Vue binding that we''ve not encountered before. It allows you
    to bind actions from elements to Vue methods. For example, `v-on:click` is one
    that is used the most commonly - which allows you to bind a `click` function to
    the element. We''ll cover more on this in the next section of the book.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-on`是一个我们之前没有遇到过的新的Vue绑定。它允许您将元素的操作绑定到Vue方法。例如，`v-on:click`是最常用的一个 - 它允许您将`click`函数绑定到元素上。我们将在本书的下一节中详细介绍这个。'
- en: 'Where v-bind can be `abbreviated` to just a colon, `v-on` can be shortened
    to an `@` symbol, allowing you to use `@click=""`, for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在v-bind可以简写为冒号的情况下，v-on可以缩写为@符号，允许您使用@click=""，例如：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This attribute is firing the `changeFilter` method on every update and passing
    it the `$event` data of the change. This default Vue event object contains a lot
    of information that we could utilize, but the `target.value` data is the key we
    are after.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性在每次更新时触发`changeFilter`方法，并传递`$event`更改的数据。这个默认的Vue事件对象包含了很多我们可以利用的信息，但我们关注的是`target.value`数据。
- en: 'Create a new method in your Vue instance that accepts the event parameter and
    updates both the `query` and `field` variables. The `query` variable needs to
    be cleared, so set it to an empty string, whereas the `field` variable can be
    set to the value of the select box:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Vue实例中创建一个接受事件参数并更新`query`和`field`变量的新方法。`query`变量需要被清除，所以将其设置为空字符串，而`field`变量可以设置为选择框的值：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Viewing your application now should clear whatever the filter query is, while
    still operating as expected.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看您的应用程序应该清除任何过滤查询，同时仍然按预期运行。
- en: Combining the format functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合格式函数
- en: Our next optimization will be to combine the `formatBalance` and `formatDate` methods
    in our Vue instance. This would then allow us to scale our format functions without
    bloating the code with several methods with similar functionality. There are two
    ways to approach a format style function—we can either auto-detect the format
    of the input or pass the desired format option in as a second option. Both have
    their pros and cons, but we'll walk through both.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个优化将是将`formatBalance`和`formatDate`方法合并到我们的Vue实例中。这将允许我们扩展我们的格式函数，而不会用几个具有相似功能的方法膨胀代码。有两种方法可以处理格式样式函数
    - 我们可以自动检测输入的格式，或者将所需的格式选项作为第二个选项传递。两种方法都有其优缺点，但我们将逐步介绍两种方法。
- en: Autodetection formatting
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动检测格式化
- en: 'Autodetection of the variable type, when passed into a function, is great for
    cleaner code. In your view, you could invoke the function and pass the one parameter
    you wish to format. For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递给函数时，自动检测变量类型对于代码更清晰很有帮助。在您的视图中，您可以调用该函数并传递您希望格式化的一个参数。例如：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The method would then contain a `switch` statement and format the variable based
    on the `typeof` value. A `switch` statement can evaluate a single expression and
    then execute different code based on the output. `Switch` statements can be very
    powerful as they allow clauses to be built up—utilizing several different bits
    of code based on the result. More can be read about `switch` statements on MDN.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该方法将包含一个`switch`语句，并根据`typeof`值对变量进行格式化。`switch`语句可以评估单个表达式，然后根据输出执行不同的代码。`switch`语句非常强大，因为它允许构建子句
    - 根据结果利用几个不同的代码片段。有关`switch`语句的更多信息可以在MDN上阅读。
- en: '`Switch` statements are a great alternative to `if` statements if you are comparing
    the same expression. You are also able to have several cases for one block of
    code and even include a default if none of the previous cases was met. As an example
    of one in use, our format method might look like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在比较相同的表达式，那么`switch`语句是`if`语句的一个很好的替代方案。您还可以为一个代码块设置多个情况，甚至在之前的情况都不满足时包含一个默认情况。例如，我们使用的一个示例是format方法可能如下所示：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The important thing to note is the `break;` lines. These finish each `switch`
    case. If a break was omitted, the code would carry on and execute the following
    case—which sometimes is the desired effect.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项是`break;`行。这些行结束了每个`switch` case。如果省略了`break`，代码将继续执行下一个case，有时这是期望的效果。
- en: Autodetecting the variable type and formatting is a great way of simplifying
    your code. However, for our app, it is not a suitable solution as we are formatting
    the date, which when outputting the `typeof` results in a string, and would not
    be identifiable from other strings we may wish to format.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 自动检测变量类型和格式化是简化代码的好方法。然而，对于我们的应用程序来说，这不是一个合适的解决方案，因为我们正在格式化日期，而在输出`typeof`结果时，日期会被转换为字符串，并且无法与我们可能希望格式化的其他字符串区分开来。
- en: Passing in a second variable
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传入第二个变量
- en: 'The alternative to the preceding autodetection is to pass the second variable
    into the `format` function. This gives us greater flexibility and scalability
    should we wish to format other fields. With the second variable, we can either
    pass in a fixed string that matches a preselected list in our `switch` statement
    or we could pass in the field itself. An example of the fixed string approach
    in the view would be:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的自动检测相反，我们可以将第二个变量传入`format`函数中。这样做可以使我们在需要格式化其他字段时具有更大的灵活性和可扩展性。对于第二个变量，我们可以传入一个固定的字符串，与我们`switch`语句中的预选列表匹配，或者我们可以直接传入字段本身。在视图中使用固定字符串的示例如下：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This would work perfectly and would be great if we had several different fields
    that all needed to be formatted like `balance` currently does, but there seems
    to be some slight repetition in using the `balance` key and `currency` format.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有几个不同的字段都需要像`balance`一样进行格式化，那么这种方法将非常完美，但是在使用`balance`键和`currency`格式时似乎存在一些重复。
- en: As a compromise, we are going to pass the `person` object as the first parameter,
    so we can access all the data, and the name of the field as the second parameter.
    We will then use this for both identifying the format method required and to return
    the specific data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了妥协，我们将把`person`对象作为第一个参数传入，这样我们就可以访问所有的数据，将字段的名称作为第二个参数传入。然后我们将使用这个参数来确定所需的格式化方法，并返回特定的数据。
- en: Creating the method
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建方法
- en: 'In your view, replace both the `formatDate` and `formatBalance` functions with
    a singular format one, passing in the `person` variable as the first parameter,
    and the field enclosed quotes as the second:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的视图中，用一个格式化函数替换`formatDate`和`formatBalance`函数，将`person`变量作为第一个参数传入，将字段用引号括起来作为第二个参数：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new format method inside your Vue instance, which accepts two parameters: `person`
    and `key`. As the first step, retrieve the field using the person object and the
    `key` variable:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Vue实例中创建一个新的格式化方法，接受两个参数：`person`和`key`。作为第一步，使用`person`对象和`key`变量检索字段：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have also created a second variable inside the function titled `output`—this
    will be what is returned at the end of the function and is set to the `field`
    by default. This ensures that if our formatting key does not match the one passed
    in, the untouched field data is returned—we do, however, convert the field to
    a string and trim any whitespace from the variable. Running the app now will return
    the fields without any formatting.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在函数内部创建了一个名为`output`的第二个变量，这将在函数结束时返回，并默认设置为`field`。这样可以确保如果我们的格式化键与传入的键不匹配，将返回未经处理的字段数据。但是，我们会将字段转换为字符串并删除变量中的任何空格。现在运行应用程序将返回没有任何格式化的字段。
- en: 'Add a `switch` statement, setting the expression to be just the `key`. Add
    two cases to the `switch` statement—one being `balance` and the other `registered`.
     As we do not wish for anything to happen to our input when it does not match
    a case, there is no need for us to have a `default` statement:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`switch`语句，将表达式设置为`key`。在`switch`语句中添加两个case，一个是`balance`，另一个是`registered`。由于我们不希望在输入不匹配case时发生任何操作，所以我们不需要有一个`default`语句：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We now just need to copy the code from our original formatting functions into
    the individual cases:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将原始格式化函数中的代码复制到各个case中：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This format function is now a lot more flexible. We can add more `switch` cases
    should we need to cater for more fields (process the `name` field, for example)
    or we can add new cases to existing code. An example of this would be if our data
    contained a field that detailed the date on which the user `deactivated` their
    account, we could easily display it in the same format as registered:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个格式化函数现在更加灵活。如果我们需要处理更多字段（例如处理`name`字段），我们可以添加更多的`switch` case，或者我们可以在现有代码中添加新的case。例如，如果我们的数据包含一个字段，详细说明用户`停用`帐户的日期，我们可以轻松地以与注册日期相同的格式显示它：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Reducing the number of hard-coded variables and properties, and reducing redundancy
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少硬编码的变量和属性的数量，减少冗余
- en: When looking at the Vue JavaScript, it is quickly evident that it can be optimized
    by introducing global variables and setting more local variables in the functions
    to make it more readable. We can also use existing functionality to stop repeating
    ourselves.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看Vue JavaScript时，很快就会发现可以通过引入全局变量并在函数中设置更多的局部变量来进行优化，以使其更易读。我们还可以使用现有功能来避免重复。
- en: 'The first optimization is in our `filterRow()` method where we check whether `filter.field`
    is active. This is also repeated in the `isActiveFilterSelected` method we use
    to show and hide our radio buttons. Update the `if` statement to use this method
    instead, so the code is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个优化是在我们的`filterRow()`方法中，我们检查`filter.field`是否处于活动状态。这也在我们用于显示和隐藏单选按钮的`isActiveFilterSelected`方法中重复出现。更新`if`语句以使用此方法，代码如下：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code has the `this.filter.field === ''isActive''` code removed
    and replaced with the `isActiveFilterSelected()` method. It should now look like
    this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码已删除`this.filter.field === 'isActive'`代码，并替换为`isActiveFilterSelected()`方法。现在它应该是这样的：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While we''re in the `filterRow` method, we can reduce the code by storing the
    `query` and `field` as variables at the start of the method. `result` is also
    not the right keyword for this, so let''s change it to `visible`. First, create
    and store our two variables at the start and rename `result` to `visible`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`filterRow`方法中时，我们可以通过在方法开始时将`query`和`field`存储为变量来减少代码。`result`也不是正确的关键字，所以让我们将其更改为`visible`。首先，在开头创建和存储我们的两个变量，并将`result`重命名为`visible`：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Replace all instances in that function of the variables, for example, the first
    part of the method would look like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 替换该函数中所有变量的所有实例，例如，方法的第一部分将如下所示：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save your file and open the app in the browser to ensure your optimizations
    haven't broken the functionality.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并在浏览器中打开应用程序，以确保优化不会破坏功能。
- en: 'The last stage is to reorder the methods into an order that makes sense to
    you. Feel free to add comments to separate out the different method types—for
    example, ones that relate to CSS classes or filtering. I have also removed the `activeStatus`
    method, as we are able to utilize our `format` method to *format* the output of
    this field. After the optimizations, the JavaScript code now looks like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将方法重新排序，使其对您有意义。可以随意添加注释来区分不同类型的方法，例如与CSS类或过滤相关的方法。我还删除了`activeStatus`方法，因为我们可以利用我们的`format`方法来*格式化*此字段的输出。优化后，JavaScript代码现在如下所示：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating Vue components
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Vue组件
- en: Now we're confident our code is cleaner, we can move on to making Vue components
    for the various parts of our app. Put aside your code for now and open a new document
    while you get to grips with components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对代码的清理更有信心，我们可以继续为应用程序的各个部分创建Vue组件。暂时放下您的代码，打开一个新文档，同时熟悉组件。
- en: Vue components are extremely powerful and a great addition to any Vue app. They
    allow you to make packages of reusable code that include their own data, methods,
    and computed values.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Vue组件非常强大，是任何Vue应用程序的重要组成部分。它们允许您创建可重用代码的包，包括它们自己的数据、方法和计算值。
- en: 'For our app, we have the opportunity to create two components: one for each
    person and one for the filtering section of our app. I would encourage you to
    always look at breaking your app into components where possible—this helps group
    your code into related functions.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们有机会创建两个组件：一个用于每个人，一个用于我们应用程序的过滤部分。我鼓励您在可能的情况下始终考虑将应用程序拆分为组件，这有助于将代码分组为相关的功能。
- en: Components look like mini Vue instances as each one has its own data, methods,
    and computed objects—along with some component-specific options that we will cover
    shortly. Components are also extremely useful when it comes to creating an app
    with different pages and sections—this will be covered in [Chapter 8](part0135.html#40NRU0-985bf4ae118d4f62b18ae64204cb251c), *Introducing
    Vue-Router and Loading URL-Based Components*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 组件看起来像是小型的Vue实例，因为每个组件都有自己的数据、方法和计算属性对象，还有一些特定于组件的选项，我们很快就会介绍。当涉及到创建具有不同页面和部分的应用程序时，组件也非常有用，这将在第8章《介绍Vue-Router和加载基于URL的组件》中介绍。
- en: 'When a component is registered, you create a custom HTML element to use in
    your view, for example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册一个组件时，您需要创建一个自定义的HTML元素来在视图中使用，例如：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When naming your component, you can use kebab-case (hyphens), PascalCase (no
    punctuation, but each word is capitalized) or camelCase (similar to Pascal but
    the first word is not capitalized). Vue components are not restricted by, or associated
    with, the W3C web components/custom element rules, but it is good practice to
    follow this convention of using kebab-case.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名组件时，可以使用短横线命名法（连字符）、帕斯卡命名法（没有标点符号，但每个单词首字母大写）或驼峰命名法（类似于帕斯卡命名法，但第一个单词首字母小写）。Vue组件不受W3C
    Web组件/自定义元素规则的限制或关联，但按照使用短横线命名法的惯例是一个好的做法。
- en: Creating and initializing your component
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和初始化您的组件
- en: Vue components are registered using the `Vue.component(tagName, options)` syntax.
    Each component must have an associated tag name. The `Vue.component` registration **must**
    happen before you initialize your Vue instance. As a minimum, each component should
    have a `template` property—denoting what should be displayed when the component
    is used. Templates must always have a single wrapping element; this is so the
    custom HTML tag can be replaced with the parent container.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Vue组件使用`Vue.component(tagName, options)`语法进行注册。每个组件必须有一个关联的标签名。`Vue.component`的注册**必须**在初始化Vue实例之前发生。至少，每个组件应该有一个`template`属性
    - 表示在使用组件时应该显示什么。模板必须始终有一个包装元素；这样自定义的HTML标签才能被父容器替换。
- en: 'For example, you couldn''t have the following as your template:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不能将以下内容作为你的模板：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you do pass a template of this format, Vue will throw an error in the browser's
    JavaScript console warning you.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递了这种格式的模板，Vue会在浏览器的JavaScript控制台中抛出一个错误警告你。
- en: 'Create a Vue component yourself, with a simple fixed template:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 自己创建一个简单的固定模板的Vue组件：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this component declared, it would now give us a `<my-component></my-component>`
    HTML tag to use in our view.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个声明的组件，现在我们可以在视图中使用`<my-component></my-component>` HTML标签了。
- en: 'You can also specify components on the Vue instance itself. This would be used
    if you had multiple Vue instances on one site and wished to contain a component
    to one instance. To do this, create your component as a simple object and assign
    the `tagName` within the `components` object of your Vue instance:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在Vue实例本身上指定组件。如果你在一个站点上有多个Vue实例，并希望将一个组件限制在一个实例中，可以使用这种方法。为此，将你的组件创建为一个简单的对象，并在Vue实例的`components`对象中分配`tagName`：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For our app though, we are going to stick with the `Vue.component()` method
    of initializing our components.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们的应用程序，我们将继续使用`Vue.component()`方法来初始化我们的组件。
- en: Using your component
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用你的组件
- en: 'In your view, add your custom HTML element component:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的视图中，添加你的自定义HTML元素组件：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Viewing this in the browser should replace the `<my-component>` HTML tag with
    a `<div>` and a hello message.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看时，应该将`<my-component>` HTML标签替换为一个`<div>`和一个hello消息。
- en: 'There may be some cases where a custom HTML tag won''t be parsed and accepted
    - these cases tend to be in `<table>`, `<ol>`, `<ul>`, and `<select>` elements.
    If this is the case, you can use the `is=""` attribute on a standard HTML element:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，自定义的HTML标签可能无法被解析和接受 - 这些情况通常出现在`<table>`、`<ol>`、`<ul>`和`<select>`元素中。如果是这种情况，你可以在标准HTML元素上使用`is=""`属性：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using component data and methods
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件数据和方法
- en: As Vue components are self-contained elements of your Vue app, they each have
    their own data and functions. This helps when re-using components on the same
    page, as the information is self-contained per instance of a component. `methods`
    and `computed` functions are declared the same as you would on the Vue app, however,
    the data key should be a function that returns an object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Vue组件是Vue应用程序中独立的元素，它们各自拥有自己的数据和函数。这在同一页上重复使用组件时非常有用，因为信息是每个组件实例自包含的。`methods`和`computed`函数的声明方式与在Vue应用程序中相同，但是数据键应该是一个返回对象的函数。
- en: The data object of a component must be a function. This is so that each component
    has its own self-contained data, rather than getting confused and sharing data
    between different instances of the same component. The function must still return
    an object as you would in your Vue app.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的数据对象必须是一个函数。这样每个组件都有自己独立的数据，而不会在同一个组件的不同实例之间混淆和共享数据。这个函数仍然必须返回一个对象，就像在Vue应用程序中一样。
- en: 'Create a new component called `balance`, add a `data` function and `computed`
    object to your component and an empty `<div>` to the `template` property for now:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`balance`的新组件，为您的组件添加一个`data`函数和`computed`对象，并暂时将一个空的`<div>`添加到`template`属性中：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, add a key/value pair to your `cost` data object with an integer and add
    the variable to your template. Add the `<balance></balance>` custom HTML element to
    your view and you should be presented with your integer:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向您的`cost`数据对象添加一个键/值对，其中包含一个整数，并将变量添加到您的模板中。在您的视图中添加`<balance></balance>`自定义HTML元素，您应该看到一个整数：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As with our Vue instance in [Chapter 1](part0023.html#LTSU0-985bf4ae118d4f62b18ae64204cb251c), *Getting
    Started with Vue.js*, add a function to the `computed` object that appends a currency
    symbol to the integer and ensures there are two decimal places. Don't forget to
    add the currency symbol to your data function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[第1章](part0023.html#LTSU0-985bf4ae118d4f62b18ae64204cb251c)中的Vue实例一样，添加一个函数到`computed`对象，将货币符号附加到整数上，并确保有两位小数。不要忘记将货币符号添加到您的data函数中。
- en: 'Update the template to output the computed value instead of the raw cost:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模板，输出计算后的值而不是原始成本：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a basic example of a component, however, it is quite restricted with
    the fixed `cost` on the component itself.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个组件的基本示例，但它在组件本身上的`cost`是固定的。
- en: Passing data to your component – props
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向组件传递数据 - props
- en: Having the balance as a component is great, but not very good if the balance
    is fixed. Components really come into their own when you add the ability to pass
    in arguments and properties via HTML attributes. In the Vue world, these are called
    **props**. Props can be either static or variable. In order for your component
    to expect these properties, you need to create an array on the component by using
    the `props` property.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将余额作为一个组件是很好的，但如果余额是固定的，那就不太好了。当您通过HTML属性传递参数和属性时，组件真正发挥作用。在Vue世界中，这些被称为**props**。Props可以是静态的或变量的。为了让您的组件期望这些属性，您需要使用`props`属性在组件上创建一个数组。
- en: 'An example of this would be if we wanted to make a `heading` component:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个`heading`组件，可以这样做：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The component would then be used in the view like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该组件将在视图中使用如下：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With props, we don't need to define the `text` variable in the data object,
    as defining it in the props array automatically makes it available for use in
    the template. The props array can also take further options, allowing you to define
    the type of input expected, whether it is required or a default value to use if
    omitted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用props，我们不需要在数据对象中定义`text`变量，因为在props数组中定义它会自动使其在模板中可用。props数组还可以接受进一步的选项，允许您定义所期望的输入类型，是否需要输入或省略时使用的默认值。
- en: 'Add a prop to the balance component so we can pass the cost as an HTML attribute.
    Your view should now look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 向balance组件添加一个prop，以便我们可以将成本作为HTML属性传递。您的视图现在应该是这样的：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now add the cost prop to the component in the JavaScript, and remove
    the fixed value from our data function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在JavaScript中将cost prop添加到组件中，并从我们的data函数中删除固定值：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Running this in our browser, however, will throw an error in our JavaScript
    console. This is because, natively, props being passed in are interpreted as strings.
    We can address this in two ways; we can either convert our prop to a number in
    our `formatCost()` function or, alternatively, we can use the `v-bind:` HTML attribute
    to tell Vue to accept the input for what it is.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在浏览器中运行这个模板会在JavaScript控制台中抛出一个错误。这是因为，原生地，传入的props被解释为字符串。我们可以通过两种方式解决这个问题；要么在`formatCost()`函数中将我们的prop转换为数字，要么使用`v-bind:`
    HTML属性告诉Vue接受输入的内容。
- en: 'If you remember, we used this technique with our filters for the `true` and
    `false` values—allowing them to be used as Boolean instead of strings. Add `v-bind:`
    in front of your `cost` HTML attribute:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得，我们在`true`和`false`值的过滤器中使用了这种技术-允许它们作为布尔值而不是字符串使用。在`cost` HTML属性前面添加`v-bind:`：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is an extra step we can do to ensure Vue knows what kind of input to expect
    and informs other users of your code as to what they should be passing to the
    component. This can be done in the component itself and, along with the format,
    allows you to specify default values along with whether the prop is required or
    not.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取额外的步骤来确保Vue知道要期望什么样的输入，并通知其他用户您的代码应该传递什么。这可以在组件本身中完成，并且除了格式之外，还允许您指定默认值以及属性是否为必需的。
- en: 'Convert your `props` array to an object, with `cost` as the key. If you are
    just defining the field type, you can use the Vue shorthand for declaring this
    by setting the value as the field type. These can be String, Number, Boolean,
    Function, Object, Array, or Symbol. As our cost attribute should be a number,
    add that as the key:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的`props`数组转换为一个对象，其中`cost`作为键。如果您只是定义字段类型，可以使用Vue的简写方式来声明，将值设置为字段类型。这些可以是字符串、数字、布尔值、函数、对象、数组或符号。由于我们的成本属性应该是一个数字，所以将其添加为键：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It would be nice if, rather than throwing an error when nothing is defined,
    our component rendered `$0.00`. We can do this by setting the default to just
    `0`. To define a default we need to convert our prop into an object itself - containing
    a `type` key that has the value of `Number`. We can then define another `default` key
    and set the value to `0`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的组件在未定义任何内容时不抛出错误，而是渲染`$0.00`，那将很好。我们可以通过将默认值设置为`0`来实现这一点。要定义默认值，我们需要将我们的prop转换为一个对象本身-包含一个`type`键，其值为`Number`。然后，我们可以定义另一个`default`键，并将值设置为`0`：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Rendering the component in the browser should show whatever value is passed
    into the cost attribute—but removing this will render `$0.00`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中渲染组件应该显示传递到成本属性的任何值，但是如果删除此属性，将显示“$0.00”。
- en: 'To recap, our component looks like :'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们的组件如下：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We should be able to expand on this example when we make the`person` component
    of our listing app.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们制作列表应用程序的`person`组件时，我们应该能够在此示例上进行扩展。
- en: Passing data to your component – slots
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向组件传递数据-插槽
- en: There are times when you may need to pass chunks of HTML to your component that
    are not stored in a property or that you want to format before appearing in the
    component. Rather than trying to pre-format in a computed variable or similar,
    you can use slots with your component.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能需要将HTML块传递给组件，这些HTML块不存储在属性中，或者您希望在组件中显示之前进行格式化。与其尝试在计算变量或类似变量中进行预格式化，不如在组件中使用插槽。
- en: Slots are like placeholders and allow you to place content between the opening
    and closing tags of your component and determine where they are going to display.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽就像占位符，允许您在组件的开头和结尾标签之间放置内容，并确定它们将显示在哪里。
- en: A perfect example of this would be a modal window. These normally have several
    tags and often consist of a lot of HTML to copy and paste if you wish to use it
    in your application multiple times. Instead, you can create a `modal-window` component
    and pass your HTML with a slot.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完美的例子是模态窗口。这些通常有几个标签，并且通常由大量的HTML组成，如果您希望在应用程序中多次使用它，则需要复制和粘贴。相反，您可以创建一个`modal-window`组件，并通过插槽传递您的HTML。
- en: 'Create a new component titled `modal-window`. This accepts one prop of `visible`,
    which accepts a Boolean value and is `false` by default. For the template, we''ll
    use the HTML from the *Bootstrap modal* as a good example of how a component using
    slots can easily simplify your application. To ensure the component is styled,
    make sure you include the bootstrap *asset files* in your document:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`modal-window`的新组件。它接受一个名为`visible`的属性，默认为`false`，接受一个布尔值。对于模板，我们将使用*Bootstrap
    modal*中的HTML作为一个很好的示例，说明使用插槽的组件如何简化你的应用程序。为了确保组件被样式化，请确保在文档中包含bootstrap的*asset文件*：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will be using the visible prop to determine whether the modal window is
    open or not. Add a `v-show` attribute to your outer container that accepts the
    `visible` variable:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用visible属性来确定模态窗口是否打开。在外部容器中添加一个`v-show`属性，接受`visible`变量：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add your `modal-window` component to the app, specifying `visible` to be `true`
    for now, so we can understand and see what is going on:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的`modal-window`组件添加到应用程序中，暂时将`visible`设置为`true`，这样我们就可以理解和看到发生了什么：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We now need to pass some data to our modal box. Add a heading and some paragraphs
    between the two tags:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向模态框传递一些数据。在两个标签之间添加一个标题和一些段落：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Pressing refresh in the browser won''t do anything, as we need to tell the
    component what to do with the data. Inside your template, add a `<slot></slot>`
    HTML tag where you want your content to appear. Add it to the `div` with the `modal-body`
    class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中按下刷新按钮不会有任何反应，因为我们需要告诉组件如何处理数据。在模板中，添加一个`<slot></slot>`的HTML标签，用于显示内容。将其添加到具有`modal-body`类的`div`中：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Viewing your app will now reveal the content you passed in inside the modal
    window. Already, the app is looking cleaner with this new component.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看你的应用程序，将会在模态窗口中显示你传递的内容。通过这个新的组件，应用程序看起来更加清晰。
- en: Viewing the Bootstrap HTML, we can see there is space for a header, body, and
    footer. We can identify these sections with named slots. This allows us to pass
    specific content to specific areas of our component.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Bootstrap的HTML，我们可以看到有一个头部、主体和底部的空间。我们可以使用命名插槽来标识这些部分。这样我们就可以将特定的内容传递到组件的特定区域。
- en: 'Create two new `<slot>` tags in the header and footer of the modal window.
    Give these new ones a name attribute, but leave the existing one empty:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在模态窗口的头部和底部创建两个新的`<slot>`标签。给这些新的标签添加一个name属性，但保留现有的标签为空：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In our app, we can now specify what content goes where by specifying a `slot`
    attribute in the HTML. This can either go on a specific tag or a container around
    several tags. Any HTML without a `slot` attribute will also default to your unnamed
    slot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们现在可以通过在HTML中指定一个`slot`属性来指定内容放在哪里。这可以放在特定的标签或包围几个标签的容器上。任何没有`slot`属性的HTML也将默认为无名插槽：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can now specify and direct our content to specific places.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以指定并将我们的内容定向到特定的位置。
- en: The last thing you can do with slots is specified a default value. For example,
    you may want to display the buttons in the footer most of the time, but want to
    have the ability to replace them if desired. With a `<slot>`, any content placed
    between the tags will be displayed unless overwritten when specifying the component
    in your app.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽的最后一件事是指定一个默认值。例如，您可能希望大部分时间在底部显示按钮，但如果需要，可以替换它们。使用`<slot>`，在标签之间放置的任何内容都将显示，除非在应用程序中指定组件时被覆盖。
- en: Create a new slot titled `buttons`,  and place the buttons in the footer inside.
    Try replacing them with some other content.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`buttons`的新插槽，并将按钮放在底部。尝试用其他内容替换它们。
- en: 'The template becomes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 模板变为：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And the HTML:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: HTML变为：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Although we won't be utilizing slots with our people listing app, it's good
    to be aware of the capabilities of a Vue component. If you wished to use a modal
    box like this, you can set the visibility to a variable that is false by default.
    You can then add a button with a click method that changes the variable from `false`
    to `true`—displaying the modal box.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会在人员列表应用程序中使用插槽，但了解Vue组件的功能是很好的。如果你希望使用这样的模态框，你可以将可见性设置为默认为false的变量。然后，你可以添加一个具有点击方法的按钮，将变量从`false`更改为`true`-显示模态框。
- en: Creating a repeatable component
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可重复使用的组件
- en: The beauty of components is being able to use them multiple times in the same
    view. This gives you the ability to have one single "source of truth" for the
    layout of that data. We're going to make a repeatable component for our people
    list and a separate component for the filtering section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的美妙之处在于能够在同一个视图中多次使用它们。这使得你可以为该数据的布局拥有一个单一的“真实来源”。我们将为人员列表创建一个可重复使用的组件，并为过滤部分创建一个单独的组件。
- en: 'Open your people listing code you created in the last couple of chapters and
    create a new component titled `team-member`. Don''t forget to define the component
    before your Vue app is initialized. Add a `prop` to the component to allow the
    person object to be passed in. For validation purposes, only specify that it can
    be an `Object`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你在前几章中创建的人员列表代码，并创建一个名为`team-member`的新组件。不要忘记在Vue应用程序初始化之前定义组件。为组件添加一个`prop`，允许传入人员对象。为了验证目的，只指定它可以是一个`Object`：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We now need to integrate our template into the component, which is everything
    inside (and including) the `tr` in our View.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们的模板整合到组件中，这是我们视图中的（包括）`tr`内的所有内容。
- en: 'The template variable in the component just accepts a normal string without
    new lines, so we need to do one of the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 组件中的模板变量只接受一个没有换行符的普通字符串，所以我们需要做以下其中一种：
- en: inline our HTML template—great for small templates but in this case will sacrifice
    readability
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联我们的HTML模板-非常适用于小型模板，但在这种情况下会牺牲可读性。
- en: add new lines with the `+` string concatenation—great for one or two lines,
    but would bloat our JavaScript
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`+`字符串连接添加新行-非常适用于一两行，但会使我们的JavaScript变得臃肿
- en: create a template block—Vue gives us the option to use external templates that
    are defined in the view using the `text/x-template` syntax and an ID
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板块-Vue允许我们使用在视图中使用`text/x-template`语法和ID定义的外部模板的选项
- en: As our template is quite big, we are going to choose the third option of declaring
    our template at the end of our view.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模板相当大，我们将选择第三个选项，在我们的视图末尾声明我们的模板。
- en: 'In your HTML, outside of your app, create a new script block and add a `type`
    and `ID` attribute:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的HTML中，在你的应用程序之外，创建一个新的脚本块，并添加`type`和`ID`属性：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can then move our person template into this block and remove the `v-for`
    attribute—we''ll still use that in the app itself:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将人员模板移到这个块中，并删除`v-for`属性-我们仍然会在应用程序本身中使用它：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We now need to update the view to use the `team-member` component instead of
    the fixed code. To make our view cleaner and easier to understand, we are going
    to utilize the `<template>` HTML attribute mentioned earlier. Create a `<template>`
    tag and add the `v-for` loop we had before. To avoid confusion, update the loop
    to use `individual` as the variable for each person. They can be the same, but
    it makes the code easier to read if the variables, components, and props have
    different names. Update the `v-for` to be `v-for="individual in people"`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新视图，使用`team-member`组件代替固定的代码。为了使我们的视图更清晰易懂，我们将利用之前提到的`<template>` HTML属性。创建一个`<template>`标签，并添加我们之前使用的`v-for`循环。为了避免混淆，将循环更新为使用`individual`作为每个人的变量。它们可以相同，但如果变量、组件和props具有不同的名称，代码会更容易阅读。将`v-for`更新为`v-for="individual
    in people"`：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Inside the `template` tags of your view, add a new instance of the `team-member`
    component, passing the `individual` variable to the `person` prop. Don''t forget
    to add `v-bind:` to the person prop, otherwise, the component will interpret it
    as a fixed string with the value of the individual:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图的`template`标签中，添加一个新的`team-member`组件实例，将`individual`变量传递给`person` prop。不要忘记在person
    prop前添加`v-bind:`，否则组件将将其解释为一个固定字符串，其值为individual：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We now need to update the component to use the template we have declared using
    the `template` property and the ID of the script block as the value:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新组件，使用我们声明的模板作为`template`属性和脚本块的ID作为值：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Viewing the app in the browser will create several errors in the JavaScript
    console. This is because we are referencing several methods that are no longer
    available - as they are on the parent Vue instance, not on the component. If you
    want to verify that your component is working, change the code to only output
    the name of the person, and press refresh:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看应用程序将在JavaScript控制台中创建多个错误。这是因为我们引用了一些不再可用的方法 - 因为它们在父Vue实例上，而不是在组件上。如果您想验证组件是否工作，请将代码更改为仅输出人员的名称，然后按刷新：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Creating component methods and computed functions
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件方法和计算函数
- en: We now need to create the methods we had created on the Vue instance on the
    child component, so they are available to use. One thing we could do is cut and
    paste the methods from the parent into the child in the hope they would work;
    however, those methods rely on parent properties (such as filtering data) and
    we also have the opportunity to utilize `computed` properties, which cache the
    data and can speed up your app.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在子组件上创建我们在Vue实例上创建的方法，以便可以使用它们。我们可以做的一件事是将父组件中的方法剪切并粘贴到子组件中，希望它们能够工作；然而，这些方法依赖于父组件的属性（如过滤数据），我们还有机会利用`computed`属性，它可以缓存数据并加快应用程序的速度。
- en: For now, remove the `v-show` attribute from the `tr` element—as this involves
    the filtering, and that will be covered once we have our rows displaying correctly.
    We'll step through the errors and resolve them one at a time to help you understand
    problem-solving with Vue.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从`tr`元素中删除`v-show`属性 - 因为这涉及到过滤，而这将在我们的行正确显示后进行讨论。我们将逐步解决错误，并逐个解决，以帮助您理解使用Vue进行问题解决。
- en: CSS class functions
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS类函数
- en: 'The first error we encounter when viewing the application in the browser is:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看应用程序时，我们遇到的第一个错误是：
- en: Property or method "balanceClass" is not defined
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 属性或方法“balanceClass”未定义
- en: The first error is with regards to both the `balanceClass` and `activeClass`
    functions we use. Both of these functions add CSS classes based on the data of
    the person, which does not change once the component has been rendered.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个错误涉及到我们使用的`balanceClass`和`activeClass`函数。这两个函数根据人员的数据添加CSS类，一旦组件被渲染，这些数据就不会改变。
- en: Because of this, we are able to use the caching found in Vue. Move the methods
    across to the component but put them in a new `computed` object, instead of the
    `methods` one.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用Vue中的缓存。将方法移到组件中，但将它们放在一个新的`computed`对象中，而不是`methods`对象中。
- en: 'With components, a new instance is created every time it is called, so we can
    rely on the `person` object we passed in via a `prop` and no longer need to pass
    the `person` into the function. Remove the parameter from the function and the
    view—also update any reference to `person` *inside* the function to `this.person`
    to reference the object stored on the component:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件时，每次调用都会创建一个新的实例，因此我们可以依赖通过`prop`传递的`person`对象，不再需要将`person`传递给函数。从函数和视图中删除参数，并将函数内部对`person`的任何引用更新为`this.person`，以引用存储在组件上的对象：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The part of our component template that utilizes this function should now look
    like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数的组件模板部分现在应该如下所示：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Formatted value functions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化值函数
- en: When it comes to moving the `format()` function to the component for formatting
    our data, we are faced with two options. We can move it like-for-like and put
    it in the `methods` object, or we can take advantage of the Vue caching and conventions
    and create a `computed` function for each value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`format()`函数移动到组件中格式化我们的数据时，我们面临两个选择。我们可以按照原样移动它并将其放在`methods`对象中，或者我们可以利用Vue的缓存和约定，为每个值创建一个`computed`函数。
- en: We are building this app for scalability, so it's advisable to make computed
    functions for each value—it will also have the advantage of tidying up our template.
    Create three functions in the computed object titled `balance`, `dateRegistered`,
    and `status`. Copy the corresponding parts of the `format` function across to
    each one, updating the reference of `person` to `this.person` once more.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建这个应用程序以实现可扩展性，因此建议为每个值创建计算函数，这也有助于整理我们的模板。在计算对象中创建三个函数，分别命名为`balance`、`dateRegistered`和`status`。将`format`函数的相应部分复制到每个函数中，再次将`person`的引用更新为`this.person`。
- en: 'Where we were retrieving the field using a function parameter, you can now
    fix the value in each function. You will also need to add a data object with the
    currency symbol for the balance function—add this after the `props`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用函数参数检索字段的地方，现在可以在每个函数中修复该值。您还需要在`props`之后添加一个包含货币符号的数据对象，以供余额函数使用：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As the `team-member` component is the only place our currency symbol is used,
    we can remove it from the Vue app itself. We can also remove the format function
    from our parent Vue instance.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`team-member`组件是我们唯一使用货币符号的地方，我们可以将其从Vue应用程序本身中删除。我们还可以从父Vue实例中删除格式化函数。
- en: 'In total, our Vue `team-member` component should look like:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们的Vue `team-member`组件应该如下所示：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And our `team-member-template` should look fairly simple in comparison to what
    it did look like:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前相比，我们的`team-member-template`应该看起来相对简单：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And lastly, our Vue instance should look significantly smaller:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的Vue实例应该显得更小：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Viewing the app in the browser, we should be presented with our list of people
    with the correct classes added to the table cells and formatting added to the
    fields.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看应用程序，我们应该看到我们的人员列表，并在表格单元格中添加了正确的类，并在字段中添加了格式。
- en: Making the filtering work again with props
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使过滤器与props再次正常工作
- en: 'Re-add the `v-show="filterRow()"` attribute to the containing `tr` element
    in your template. As our component has the person cached on each instance, we
    no longer need to pass the person object to the method. Refreshing the page will
    give you a new error in your JavaScript console:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中的包含`tr`元素中重新添加`v-show="filterRow()"`属性。由于我们的组件在每个实例上都有缓存的person对象，所以我们不再需要将person对象传递给该方法。刷新页面将在JavaScript控制台中给出一个新的错误：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This error is because our component has the `v-show` attribute, showing and
    hiding based on our filtering and properties, but not the corresponding `filterRow`
    function. As we don''t use it for anything else, we can move the method from the
    Vue instance to the component, adding it to the `methods` component. Remove the
    person parameter and update the method to use `this.person`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是因为我们的组件有`v-show`属性，根据我们的过滤器和属性来显示和隐藏，但没有相应的`filterRow`函数。由于我们不在其他地方使用它，我们可以将该方法从Vue实例移动到组件中，将其添加到`methods`组件中。删除person参数并更新方法以使用`this.person`：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The next error in the console is:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台中的下一个错误是：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The reason the filtering does not work is that the `filterRow` method is looking
    for `this.filter.field` and `this.filter.query` on the component, not the parent
    Vue instance where it belongs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤不起作用的原因是`filterRow`方法在组件上寻找`this.filter.field`和`this.filter.query`，而不是它所属的父Vue实例。
- en: As a quick fix, you can use `this.$parent` to reference data on the parent element—however,
    this is not recommended and should only be used in extreme circumstances or to
    quickly pass the data through.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速修复，你可以使用`this.$parent`来引用父元素上的数据，但是这不被推荐，只应在极端情况下或快速传递数据时使用。
- en: 'To pass the data through to the component we are going to use another prop
    - similar to how we are passing the person into the component. Fortunately, we
    had grouped our filtering data already, so we are able to pass that one object
    instead of individual properties of `query` or `field`. Create a new prop on your
    component titled `filter` and ensure you only allow an `Object` to be passed through:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据传递给组件，我们将使用另一个prop - 类似于我们如何将person传递给组件。幸运的是，我们已经将我们的过滤器数据分组了，所以我们可以传递一个对象而不是`query`或`field`的单个属性。在你的组件上创建一个新的prop，命名为`filter`，并确保只允许传递一个`Object`：
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can then add the prop to the `team-member` component, allowing us to pass
    the data:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将这个prop添加到`team-member`组件中，以便我们可以传递数据：
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In order for our filtering to work, we need to pass in one more property- the `isActiveFilterSelected()`
    function. Create another prop, titled `statusFilter`, allowing only a `Boolean`
    to be the value (as this is what the function equates to), and pass the function
    through. Update the `filterRow` method to use this new value. Our component now
    looks like:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的过滤器工作，我们需要传入另一个属性-`isActiveFilterSelected()`函数。创建另一个prop，命名为`statusFilter`，只允许值为`Boolean`（因为这是函数的返回值），并将函数传递进去。更新`filterRow`方法以使用这个新值。我们的组件现在如下所示：
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And the component within the View with the extra props now looks like the following.
    Note that the camel-cased prop becomes snake case (hyphenated) when used as an
    HTML attribute:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，视图中的组件带有额外的props，如下所示。请注意，当作为HTML属性使用时，驼峰式的prop变成了蛇形式（用连字符分隔）：
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Making the filters a component
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将过滤器作为一个组件
- en: We now need to make the filtering section its own component. This isn't strictly
    necessary in this scenario, but it's good practice and gives us more challenges.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将过滤器部分作为一个独立的组件。在这种情况下，这并不是必需的，但这是一个好的实践，并且给我们带来了更多的挑战。
- en: The problem we face in making the filtering a component is a challenge of transferring
    filter data between the filtering component and the `team-member` component. Vue
    addresses this with custom events. These let you pass (or "emit") data to the
    parent or other components from the child component.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在将过滤器作为组件时面临的问题是在过滤器组件和`team-member`组件之间传递过滤器数据的挑战。Vue通过自定义事件来解决这个问题。这些事件允许你将数据传递（或"emit"）给父组件或其他组件。
- en: We are going to create a filtering component which, on filtering change, passes
    the data back to the parent Vue instance. This data is already passed through
    to the `team-member` component to filter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个过滤组件，当过滤器发生变化时，将数据传递回父Vue实例。这些数据已经通过`team-member`组件传递给过滤器。
- en: Creating the component
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件
- en: As with the `team-member` component, declare a new `Vue.component()` in your
    JavaScript, referencing a template ID of `#filtering-template`. Create a new `<script>`
    template block in your view and give it the same ID. Replace the filtering form
    in the view with a `<filtering>` custom HTML template and put the form inside
    your `filtering-template` script block.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与“team-member”组件一样，在您的JavaScript中声明一个新的`Vue.component()`，引用模板ID为`#filtering-template`。在视图中创建一个新的`<script>`模板块，并给它相同的ID。将视图中的过滤表单替换为`<filtering>`自定义HTML模板，并将表单放在`filtering-template`脚本块中。
- en: 'Your view should look like the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您的视图应该如下所示：
- en: '[PRE65]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And you should have the following in your JavaScript:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的JavaScript中应该有以下内容：
- en: '[PRE66]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Resolving JavaScript errors
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决JavaScript错误
- en: 'As with the `team-member` component, you are going to experience some errors
    in your JavaScript console. These can be resolved by copying the `filter` data
    object and both the `changeFilter` and `isActiveFilterSelected` methods from the
    parent instance. We''ll leave them in both the component and parent instance for
    now, but we''ll remove the duplication later:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与“team-member”组件一样，您将在JavaScript控制台中遇到一些错误。通过复制父实例中的`filter`数据对象以及`changeFilter`和`isActiveFilterSelected`方法来解决这些错误。我们现在将它们保留在组件和父实例中，但稍后将删除重复部分：
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Running the app will show both the filters and person listing, but the filters
    won't update the people list as they are not communicating yet.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序将显示过滤器和人员列表，但是过滤器尚未与人员列表进行通信，因此不会更新。
- en: Using custom events to change the filter field
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义事件来更改过滤字段
- en: With custom events, you can pass data back up to the parent instances using the
    `$on` and `$emit` functions. For this app, we are going to store the filtering
    data on the parent Vue instance and update it from the component. The `team-member`
    component can then read the data from the Vue instance and filter accordingly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义事件，您可以使用`$on`和`$emit`函数将数据传递回父实例。对于这个应用程序，我们将在父Vue实例上存储过滤数据，并从组件中更新它。然后，`team-member`组件可以从Vue实例中读取数据并进行相应的过滤。
- en: 'The first step is to utilize the filter object on the parent Vue instance.
    Remove the `data` object from your component and pass in the parent one via a
    prop - just as we did with the `team-member` component:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是利用父Vue实例上的过滤器对象。从组件中删除`data`对象，并通过prop传递父对象 - 就像我们在`team-member`组件中所做的那样：
- en: '[PRE68]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We are now going to modify the `changeFilter` function to emit the event data
    so the parent instance, so it can update the `filter` object.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改`changeFilter`函数以发出事件数据，以便父实例可以更新`filter`对象。
- en: 'Remove the existing `changeFilter` method from the `filtering` component and
    create a new one called `change-filter-field`. Within this method, we just need
    to `$emit` the name of the field selected in the drop-down menu. The `$emit` function
    takes two parameters: a key and the value. Emit a key of `change-filter-field`
    and pass the `event.target.value` as the data. When using variables with multiple
    words (For example, `changeFilterField`), ensure these are hyphenated for the
    event name (the first parameter of the `$emit` function) and the HTML attribute:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从“filtering”组件中删除现有的“changeFilter”方法，并创建一个名为“change-filter-field”的新方法。在这个方法中，我们只需要通过`$emit`方法将下拉菜单中选择的字段的名称传递出去。`$emit`函数接受两个参数：一个键和一个值。使用多个单词的变量（例如`changeFilterField`）时，确保事件名称（`$emit`函数的第一个参数）和HTML属性使用连字符分隔：
- en: '[PRE69]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In order to then pass the data to the changeFilter method on our parent Vue
    instance, we need to add a new prop to our `<filtering>` element. This uses `v-on`
    and binds to the custom event name. It then has the parent method name as the
    attribute value. Add the attribute to your element:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据传递给父Vue实例上的changeFilter方法，我们需要在我们的`<filtering>`元素中添加一个新的prop。这使用`v-on`绑定到自定义事件名称。然后将父方法名称作为属性值。将属性添加到您的元素中：
- en: '[PRE70]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This attribute preceding tells Vue to trigger the `changeFilter` method when
    a `change-filter-field` event is emitted. We can then tweak our method to accept
    the parameter as the value:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的属性告诉Vue在发出`change-filter-field`事件时触发`changeFilter`方法。然后我们可以调整我们的方法来接受该参数作为值：
- en: '[PRE71]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This then clears the filters and updates the field value, which then ripples
    down to our components via props.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后清除过滤器并更新字段值，然后通过props传递给我们的组件。
- en: Updating the filter query
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新过滤器查询
- en: To emit the query field, we are going to use a new Vue key that we have not
    used before, called `watch`. The `watch` function tracks a data property and can
    run methods based on the output. The other thing it is able to do is to emit events.
    As both, our text field and radio buttons are set to update the field.query variable,
    we will create a new `watch` function on this.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发出查询字段，我们将使用一个之前没有使用过的新的Vue键，称为`watch`。`watch`函数跟踪数据属性并可以根据输出运行方法。它还能够发出事件。由于我们的文本字段和单选按钮都设置为更新`field.query`变量，所以我们将在此上创建一个新的`watch`函数。
- en: 'Create a new `watch` object after the methods on your component:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的方法之后创建一个新的`watch`对象：
- en: '[PRE72]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The key is the variable you wish to watch. As ours contains a dot, it needs
    to be wrapped in quotes. Within this function, create a new `$emit` event of `change-filter-query` that
    outputs the value of `filter.query`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是你想要监视的变量。由于我们的变量包含一个点，所以需要用引号括起来。在这个函数中，创建一个名为`change-filter-query`的新的`$emit`事件，输出`filter.query`的值：
- en: '[PRE73]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We now need to bind this method and custom event to the component in the view,
    so it is able to pass the data to the parent instance. Set the value of the attribute
    to `changeQuery`—we''ll make a method to handle this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将这个方法和自定义事件绑定到视图中的组件上，以便能够将数据传递给父实例。将属性的值设置为`changeQuery` - 我们将创建一个处理此方法的方法：
- en: '[PRE74]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'On the parent Vue instance, make a new method, titled `changeQuery`, that simply
    updates the `filter.query` value based on the input:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在父Vue实例上创建一个名为`changeQuery`的新方法，它只是根据输入更新`filter.query`的值：
- en: '[PRE75]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Our filtering is now working again. Both updating the select box and the input
    box (or radio buttons) will now update our person list. Our Vue instance is significantly
    smaller and our templates and methods are contained with separate components.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过滤器现在又可以工作了。更新选择框和输入框（或单选按钮）将会更新我们的人员列表。我们的Vue实例变得更小了，我们的模板和方法都包含在独立的组件中。
- en: The last step is to avoid the repetition of the `isActiveFilterSelected()` method,
    as this is only used once on the `team-member` component, but several times on
    the `filtering` component. Remove the method from the parent Vue instance, the
    prop from the `team-member` HTML element, and replace the `statusFilter` variable
    in the `filterRow` method within the `team-member` component with the contents
    of the function being passed through.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是避免在`team-member`组件上重复使用`isActiveFilterSelected()`方法，因为这个方法只在`team-member`组件上使用一次，但在`filtering`组件上使用多次。从父Vue实例中删除该方法，从`team-member`
    HTML元素中删除该prop，并将`team-member`组件中的`filterRow`方法中的`statusFilter`变量替换为通过的函数的内容。
- en: 'The final JavaScript now looks like:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的JavaScript代码如下：
- en: '[PRE76]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'And the view is now:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的视图是：
- en: '[PRE77]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Over the last three chapters, you have learned how to initialize a new Vue instance,
    what the meaning behind computed, method, and data objects are, and how to list
    out data from an object and manipulate it to be displayed correctly. You have
    also learned how to make components and what benefits there are to keeping your
    code clean and optimized.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的三章中，您已经学会了如何初始化一个新的Vue实例，computed、method和data对象背后的含义，以及如何列出对象中的数据并对其进行正确显示的操作。您还学会了如何创建组件以及保持代码整洁和优化的好处。
- en: In the next section of the book, we are going to introduce Vuex, something which
    helps us store and manipulate stored data better.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一节中，我们将介绍Vuex，它可以帮助我们更好地存储和操作存储的数据。
