- en: Basic Vue.js Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js的基本功能
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Learning how to use computed properties
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用计算属性
- en: Filtering a list with a computed property
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算属性对列表进行筛选
- en: Sorting a list with a computed property
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算属性对列表进行排序
- en: Formatting currencies with filters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器格式化货币
- en: Formatting dates with filters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器格式化日期
- en: Displaying and hiding an element conditionally
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据条件显示和隐藏元素
- en: Adding styles conditionally
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据条件添加样式
- en: Adding some fun to your app with CSS transitions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过CSS过渡为您的应用程序增添一些乐趣
- en: Outputing raw HTML
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出原始HTML
- en: Creating a form with checkboxes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有复选框的表单
- en: Creating a form with radio buttons
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有单选按钮的表单
- en: Creating a form with a select element
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有选择元素的表单
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, you will find all the building blocks needed to develop a fully
    functional, interactive, self-contained Vue application. In the first recipe,
    you will create computed properties that encapsulate the logic you can use to
    create a more semantic application; you will then explore some more text formatting
    with filters and the `v-html` directive. You will create a graphically appealing
    application with the help of conditional rendering and transitions. Finally, we
    will build some form elements such as checkboxes and radio buttons.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将找到开发完全功能、交互式、独立的Vue应用程序所需的所有构建块。在第一个示例中，您将创建计算属性，这些属性封装了用于创建更语义化应用程序的逻辑；然后，您将使用过滤器和`v-html`指令进一步探索一些文本格式化。您将使用条件渲染和过渡创建一个图形吸引人的应用程序。最后，我们将构建一些表单元素，例如复选框和单选按钮。
- en: From now on, all recipes will be written exclusively with ES6\. At the time
    of this writing, if you are using Chrome 9x and JSFiddle to follow along, they
    should work seamlessly; if you are integrating this code into a bigger project,
    remember to use Babel (for more information, check out the *Using Babel to compile
    from ES6*  recipe in [Chapter 8](text00390.html) , *Organize + Automate + Deploy
    = Webpack* ).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，所有示例都将专门使用ES6编写。在撰写本文时，如果您使用Chrome 9x和JSFiddle进行跟随，它们应该能够无缝运行；如果您将此代码集成到一个更大的项目中，请记得使用Babel（有关更多信息，请参见第8章中的*使用Babel编译ES6*示例，*组织+自动化+部署=Webpack*）。
- en: Learning how to use computed properties
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何使用计算属性
- en: Computed properties are data in Vue components that depend on some calculation
    on other, more primitive data. When this primitive data is reactive, the computed
    properties are up-to-date and reactive themselves. In this context, primitive
    is a relative term. You can certainly build computed properties based on other
    computed properties.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性是Vue组件中依赖于其他更原始数据的某些计算的数据。当这些原始数据是响应式的时，计算属性会自动更新并响应式地更新。在这个上下文中，原始数据是一个相对的概念。您当然可以基于其他计算属性构建计算属性。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before venturing to prepare this recipe, be sure to familiarize yourself with
    the `v-model` directive and the `@event` notation. You can complete the *React
    to events like clicks and keystrokes* recipe in the preceding chapter if you are
    unsure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始准备这个示例之前，请确保熟悉`v-model`指令和`@event`表示法。如果您不确定，可以在前一章中完成*对点击和按键等事件做出反应*示例。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'A simple example will clarify what a computed property is:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子将清晰地说明计算属性是什么：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running this example will display two input fields: one for the name and one
    for the surname, and one button specifically to save the surname. Examining the
    JavaScript code will reveal that while the name is declared in the data section
    of our object, the surname is declared at the beginning, external to our Vue instance.
    This implies that it will not be picked up by Vue as a reactive variable. We can
    check that while editing; the name affects the computed value, editing the surname
    does not, even if the surname variable itself is actually changed, as we can check
    in the browser console:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例将显示两个输入字段：一个用于名字，一个用于姓氏，以及一个专门保存姓氏的按钮。检查JavaScript代码将发现，虽然名字是在对象的数据部分声明的，但姓氏是在Vue实例之外的开头声明的。这意味着它不会被Vue识别为反应性变量。我们可以通过编辑来检查，名字会影响计算值，而编辑姓氏则不会，即使姓氏变量本身实际上发生了变化，我们可以在浏览器控制台中检查到：
- en: 'Run the app on JSFiddle; you will see both `John`  and `Snow`  in the input
    fields and, as a result of `computedFullName` , you will see the following:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JSFiddle上运行应用程序；你会在输入字段中看到`John`和`Snow`，并且由于`computedFullName`的结果，你会看到以下内容：
- en: '![](img/Image00018.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00018.jpg)'
- en: 'Type `Johnny` instead of `John` and you will see the computed property changing
    in real time. This is because the variable name is reactive:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`John`替换为`Johnny`，你会看到计算属性实时变化。这是因为变量名是响应式的：
- en: '![](img/Image00019.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00019.jpg)'
- en: 'Type `Rain` instead of `Snow` then click on Save Surname . Nothing will happen
    because the `surname` is not reactive. It will not trigger an update on the view.
    Let''s check whether it was indeed saved:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Snow`替换为`Rain`，然后点击“保存姓氏”。不会发生任何事情，因为`surname`不是响应式的。它不会触发视图的更新。让我们来检查它是否确实被保存了：
- en: '![](img/Image00020.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00020.jpg)'
- en: 'Replace `Johnny`  with `John` . The surname in the computed property instantly
    becomes "Rain". That''s because changing the first name triggered an update for
    the computed property:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`John`替换`Johnny`。计算属性中的姓氏立即变为“Rain”。这是因为更改名字触发了计算属性的更新：
- en: '![](img/Image00021.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00021.jpg)'
- en: We just experimentally verified that, although changes in variables are saved
    to memory, no view refresh is triggered when non-reactive variables are edited.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实验证实了，尽管变量的更改被保存到内存中，但当编辑非响应式变量时，并不会触发视图刷新。
- en: It is worth noting that the same limitation applies here for reactivity--if
    the variable is an array, changing the elements with bracket notation won't work,
    deleting an element without using `$remove`  won't work either. For other limitations
    of computed properties, you should check out the official documentation at [https://vuejs.org/v2/guide/computed.html](https://vuejs.org/v2/guide/computed.html)
    .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，对于反应性来说，在这里也存在相同的限制--如果变量是数组，在使用方括号表示法更改元素不起作用，不使用`$remove`删除元素也不起作用。有关计算属性的其他限制，您应该看一下官方文档[https://vuejs.org/v2/guide/computed.html](https://vuejs.org/v2/guide/computed.html)。
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the following text, by the word dependencies I refer to variables that are
    reactive and are used inside a computed property. When a dependency is changed,
    the computed property is calculated.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下文中，通过“依赖项”一词，我指的是在计算属性内部使用的反应性变量。当依赖项发生变化时，计算属性会被计算出来。
- en: Computed properties are not meant for memorizing data, but you can define a
    setter in case it makes more sense to set a value directly instead of indirectly
    manipulating it through its dependencies. Moreover, if a computed property returns
    an object, it will be a new object every time, not a modified version of the previous
    one. Lastly, the computed property will not be called if all the dependencies
    haven't changed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性不适用于记忆数据，但如果直接设置值而不是通过其依赖项间接操作值更合理的话，可以定义一个setter。而且，如果计算属性返回一个对象，每次都会是一个新对象，而不是之前版本的修改版。最后，只有所有依赖项都发生了变化，计算属性才会被调用。
- en: This caching mechanism and defining a setter are analyzed in the following sections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缓存机制和setter的定义将在以下几节中进行分析。
- en: Caching computed properties
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存计算属性
- en: While functions inside the methods option are executed every time we call them,
    functions in computed are cached based on the dependencies, which in turn are
    defined by everything reactive found inside the function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在methods选项中的函数在每次调用时都会执行，但在computed中的函数将根据依赖项进行缓存，而这些依赖项又是由函数中发现的所有响应式内容定义的。
- en: 'In the next recipe, composing computed properties is explored, but you can
    easily imagine how you can have very heavy calculations on a computed property:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将探讨组合计算属性，但您可以很容易地想象出在计算属性上进行非常繁重的计算的情况：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, you can use the same property over and over, without the need for re-evaluation
    at every usage:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以反复使用相同的属性，而无需重新计算：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every time we call this function, we just fetch the cached value of `trillionthDigitOfPi`
    ; there is no need for calculations again.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用此函数时，我们只需获取“trillionthDigitOfPi”的缓存值；不需要再次进行计算。
- en: Computed setters
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性的setter
- en: Sometimes, we have a computed property that really represents a clear object
    in our model, and it feels cleaner to simply edit it directly than to modify its
    dependencies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们有一个计算属性，它真正表示我们模型中的一个明确对象，并且直接编辑它比修改其依赖关系更加清晰。
- en: 'In the context of a table factory, we would like to specify the number of tables
    or the number of legs we will build:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格工厂的背景下，我们希望指定要构建的表格数量或腿的数量：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our state is only determined by `legCount` , and the number of tables is determined
    automatically. Create a new Vue instance:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态仅由“legCount”确定，并且表格的数量将自动确定。创建一个新的Vue实例：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To know the number of tables, we have the `tableCount`  computed property:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道表格的数量，我们有一个`tableCount`计算属性：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `get` part is, as usual, the value of the property at any time, the setter
    allows us to set the number of tables directly (and the number of legs indirectly).
    We can then write the `update` method that is triggered whenever we change the
    number of tables:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`部分通常是任何时候属性的值，setter允许我们直接设置表格的数量（以及腿的数量）。然后，我们可以编写`update`方法，该方法在更改表格数量时触发：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Filtering a list with a computed property
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算属性过滤列表
- en: With the earlier version of Vue, filters were used in the `v-for` directives
    to only extract some values. They are still called filters, but they are not used
    in this sense anymore. They are relegated to the role of post-processing for text.
    To be honest, I never really understood how to use filters in Vue 1 with lists,
    but that won't be a problem in version 2 because the only proper way to filter
    a list is to use computed properties.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本的Vue中，过滤器在`v-for`指令中用于提取一些值。它们仍然被称为过滤器，但不再以这种方式使用。它们被降级为用于文本的后处理。老实说，我从来都不真正理解如何在Vue
    1中使用过滤器来过滤列表，但在版本2中使用计算属性是过滤列表的唯一正确方式。
- en: With this recipe, you will be able to filter your list from the simplest to-do
    list to the most complex bills-of-materials of a spaceship.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 借助这个示例，您可以从最简单的待办事项列表到最复杂的太空船物料清单中对列表进行筛选。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have some familiarity with Vue lists and know the basics of computed
    properties; if you don't, the *Writing lists*  and *Learning how to use computed
    properties*  recipes will get you covered.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对Vue列表有一定的了解，并了解计算属性的基础知识；如果不了解，阅读*编写列表*和*学习如何使用计算属性*这两篇文章将帮助您了解基础知识。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤：
- en: 'To get started with this recipe, we need an example list from which to filter
    our favorite elements. Let''s suppose we work for the *ACME Research and Development
    Laboratory* , and we are in charge of reproducing some experiment in any field
    we want. We may choose an experiment from the following list:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用这个食谱，我们需要一个示例列表来筛选我们最喜欢的元素。假设我们在*ACME研究与开发实验室*工作，我们负责在任何领域复制一些实验。我们可以从以下列表中选择一个实验：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s print the list right away using a simple `<ul>` element:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个简单的`<ul>`元素立即打印出列表：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you are not a big fan of physics, you may want to filter out physics experiments
    from this list. To do this, we create a new variable that will hold only `nonPhysics`
    experiments. This variable will be a computed property:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是物理学的铁粉，你可能想从这个列表中筛选掉物理实验。为此，我们创建一个新的变量，它将只保存`nonPhysics`实验。这个变量将作为一个计算属性：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, of course, we now want the list to draw an element from here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们现在希望列表从这里绘制一个元素：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we start the program now, only the non-physics experiments are shown in the
    list:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在启动程序，只有非物理实验会出现在列表中：
- en: '![](img/Image00023.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00023.jpg)'
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: The `nonPhysics` computed property will contain a copy of our array with the
    processing specified inside. It will simply check for experiments with fields
    that are not `Physics`  and pass the new array to be rendered as a list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonPhysics`计算属性将包含带有指定处理方式的数组副本。它将简单地检查字段不是`Physics`的实验，并将新数组传递给`v-for`进行渲染。'
- en: 'As you can see, the filtering is totally arbitrary. We could take, instead
    of the word `Physics` , a word from a variable that in turn is taken from a textbox:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，过滤是完全任意的。我们可以选择从一个变量中获取一个单词，而不是`Physics`，该变量再从一个文本框中获取：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'It turns out we''d like to reproduce such experiments but we are on a budget;
    anything over 3,000,000 euro is off limits for us. Let''s build a filter for that:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们想重现这样的实验，但我们的预算有限；超过300万欧元的任何东西都在我们的限制之外。让我们创建一个过滤器：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we use this filter instead of the previous one, we still have the *Do-It-Yourself
    Particle Detector* physics experiment lying around. Since we don't like physics,
    we'd like to combine the two filters.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这个过滤器替换之前的过滤器，我们仍然可以看到*自己动手做粒子探测器*的物理实验。由于我们不喜欢物理学，我们希望结合这两个过滤器。
- en: 'In the old version of Vue, you could just pipe the two filters inside `v-for`
    ; here, we will move the computed properties we just created down in the methods
     aisle and turn them into pure functions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版的Vue中，你可以在`v-for`中同时使用两个过滤器；在这里，我们将刚刚创建的计算属性移动到方法部分，并将它们转换成纯函数：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This way, the filters are composable; we can use them both in the `v-for` in
    the following way:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，过滤器就是可组合的；我们可以在`v-for`中这样使用它们：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another way to put less logic in the HTML would be to encapsulate everything
    in a dedicated computed property:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 减少HTML中的逻辑的另一种方法是将所有内容封装在一个专用的计算属性中：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The HTML becomes as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: HTML变为如下所示：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At last, the only element remaining on the list after all this filtering is
    the *Violinist in the Metro*  and, to be fair, 3 millions is the cost of the violin,
    not of the whole experiment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在经过所有这些过滤后，列表中唯一剩下的元素是*地铁里的小提琴手*，而且公平地说，300万欧元是小提琴的成本，而不是整个实验的成本。
- en: Sorting a list with a computed property
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算属性对列表进行排序
- en: Ordering inside a `v-for` with a filter is another thing that was considered
    for removal in Vue 1 and didn't survive in the current version.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 1中，使用过滤器对`v-for`进行排序是被考虑移除的另一件事情，在当前版本中没有幸存下来。
- en: Sorting a list with a computed property offers much more flexibility and we
    can implement any custom logic for ordering. In this recipe, you will create a
    list with some numbers within; we will sort the list using them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算属性对列表进行排序提供了更大的灵活性，我们可以实现任何自定义的排序逻辑。在这个示例中，您将创建一个包含一些数字的列表；我们将使用它们对列表进行排序。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you just require some familiarity with lists and computed
    properties; you can brush up on them with the *Writing lists*  and *Learning how
    to use computed properties*  recipes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个示例，您只需要对列表和计算属性有一些熟悉；您可以通过《编写列表》和《学习如何使用计算属性》这两个示例来了解它们。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: Let's write a list of the largest dams in the world.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个世界上最大的水坝列表。
- en: 'First, we need an HTML table with three columns (Name , Country , Electricity
    ):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个包含三列（名称，国家，电力）的HTML表格：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, we need the JavaScript of the Vue instance, which, for now, only contains
    a small database of dams, their location, and how much electricity they generate:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要Vue实例的JavaScript代码，目前只包含了一组小型水坝的数据库、它们的位置以及它们产生的电力：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside the `<tbody>` tag, we put a `v-for` that will simply iterate the list
    of dams we just created:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<tbody>`标签内，我们放置了一个`v-for`，它将简单地迭代我们刚刚创建的水坝列表：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This renders to the following table:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染为以下表格：
- en: '![](img/Image00024.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00024.jpg)'
- en: 'We want to sort these dams by installed electricity power. To do this, we will
    create a computed property,  `damsByElectricity` , that will return an ordered
    set of dams:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望按照已安装的电力对这些水坝进行排序。为此，我们将创建一个计算属性`damsByElectricity`，它将返回一个有序的水坝集合：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After adding the computed property, we just have to write `damsByElectricity`
    instead of dams in the HTML. Everything else remains the same and will behave
    the same:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加计算属性后，我们只需要在HTML中写入`damsByElectricity`而不是dams。其他都保持不变，行为也相同：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: The computed property we just created,  `damsByElectricity` , will return an
    array that will be a sorted clone of `this.dams` . As always with computed properties,
    the result will be cached (or memorized); every time we need the result, if the
    original list is not changed, the function will not be called and the cached result
    will be returned.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的计算属性`damsByElectricity`将返回一个数组，它将是`this.dams`的一个排序克隆。与计算属性一样，结果将被缓存（或记住）；每次我们需要结果时，如果原始列表没有变化，函数将不会被调用，缓存的结果将被返回。
- en: 'The `sort` function accepts two parameters: two members of the list. The return
    value must be a positive number if the second member is after the first or a negative
    number if the opposite is true.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`函数接受两个参数：列表的两个成员。如果第二个成员在第一个成员之后，则返回值必须是正数；如果相反，则返回值必须是负数。'
- en: The order we obtain with `d2.electricity - d1.electricity` is descending; if
    we want an ascending order, we have to commute the two operands or multiply them
    by *-1* .
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`d2.electricity - d1.electricity`获得的顺序是降序的；如果我们想要升序的顺序，我们需要交换两个操作数或将它们乘以*-1*。
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We can expand on our list by binding a click event on a field in the table header
    to reverse the ordering so that when we click on `Electricity` , it will sort
    the dams the other way around.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将点击事件绑定到表头中的字段来扩展我们的列表，以便反转排序，这样当我们点击`Electricity`时，将以反方向对水坝进行排序。
- en: We will use conditional styling; if you are not familiar with it, you will be
    after completing the *Adding styles conditionally*  recipe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用条件样式；如果您对它不熟悉，在完成《有条件地添加样式》这个示例后，您将会了解它。
- en: 'To make it clear which way we are ordering, we should introduce two CSS classes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地表明我们的排序方式，我们应引入两个CSS类：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the content is the Unicode representation of an arrow pointing up for
    ascending and pointing down for descending.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内容是指向上的箭头的Unicode表示，表示升序，而指向下的箭头表示降序。
- en: 'First, we should keep track of the order with a variable order  that will be
    1 when ascending and -1 when descending:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该使用变量order跟踪顺序，当升序时order为1，当降序时order为-1：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The conditional styling is a simple ternary operator. Check the *Adding styles
    conditionally * recipe for more on conditional styling:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 条件样式是一个简单的三元运算符。有关条件样式的更多信息，请参阅《条件样式》中的章节：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, the `sort` method is defined as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，sort方法的定义如下：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last thing we need to do is edit the `damsByElectricity` computed property
    to take the order in to account:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是编辑damsByElectricity计算属性以考虑顺序：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This way, the order will be reversed when order is `-1` , representing an ascending
    order:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当order为-1时，顺序将被反转，表示升序：
- en: '![](img/Image00025.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00025.jpg)'
- en: Formatting currencies with filters
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器格式化货币
- en: Formatting currencies in Vue 1 was somewhat limited; we will be using the excellent
    `accounting.js` library to build a much more powerful filter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 1中，格式化货币有一定的局限性；我们将使用优秀的accounting.js库来构建一个更强大的过滤器。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The basics of filtering are explored in the *Formatting your text with filters*
     recipe; where you build a basic filter ensure that you complete that, then come
    back here.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器的基础知识在“使用过滤器格式化文本”一章中得到了探讨；在此之前，你需要构建一个基本过滤器，确保你完成了那部分，然后再回到这里。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: Add `accounting.js` to your page. Refer to [http://openexchangerates.github.io/accounting.js/](https://vuejs.org/v2/guide/computed.html)
     for more details on how to do it. If you are using JSFiddle though, you can just
    add it as an external resource to the left menu. You can add a link to CDN, which
    is serving it, for example, [https://cdn.jsdelivr.net/accounting.js/0.3.2/accounting.js](http://openexchangerates.github.io/accounting.js/)
    .
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将accounting.js添加到你的页面中。有关如何操作的更多详细信息，请参考[http://openexchangerates.github.io/accounting.js/](https://vuejs.org/v2/guide/computed.html)。不过，如果你在使用JSFiddle，你可以将其作为外部资源添加到左侧菜单。你可以添加一个CDN链接来提供资源，例如[https://cdn.jsdelivr.net/accounting.js/0.3.2/accounting.js](http://openexchangerates.github.io/accounting.js/)。
- en: 'This filter will be extremely simple:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤器非常简单：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can try it out with a one-liner in HTML:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在HTML中尝试使用一行代码：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It will default to dollars, and it will print `I have $5.00 in my pocket` .
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它将默认显示为美元，并打印"I have $5.00 in my pocket"。
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理是这样的...
- en: When you add `accounting.js` to your page in JSFiddle or manually in your page
    (or with an import ), you make object accounting available. This way, you can
    use external libraries in your filter (and everywhere else in your code).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在JSFiddle中或手动在页面中添加`accounting.js`时（或者使用`import`导入），你将使`accounting`对象可用。这样，你可以在过滤器中使用外部库（以及代码的任何其他地方）。
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Currency often ends up in tables and they need to be aligned; let''s see how
    that will work out. We begin with this HMTL table:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 货币通常出现在表格中，它们需要对齐；让我们看看如何做到这一点。我们从如下HTML表格开始：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We are iterating an inventory that, of course, we need to specify in our JavaScript:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在遍历一个库存，当然，我们需要在JavaScript中指定它：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At this point, we have a table with the prices rendered on the page, but there
    is no currency symbol, no consistency in the number of digits after the decimal
    point, and no alignment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，我们有一个价格在页面上呈现的表格，但是没有货币符号，没有小数点后的位数一致性，也没有对齐。
- en: We plan to use our filter to help us add all three of these.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划使用我们的过滤器来帮助我们添加这三个。
- en: Before moving on, the most astute readers may have noted that I used strings
    to represent the prices. Why not numbers? This is because numbers in JavaScript
    are floating points; in other words, they are not accurate because the number
    of decimal digits "floats."
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，最敏锐的读者可能会注意到我使用字符串来表示价格。为什么不用数字？这是因为JavaScript中的数字是浮点数；换句话说，它们不精确，因为小数位数是“浮动的”。
- en: If we have a kitten key chain on sale for 0.83 euros and we have a kitty 50%
    discount on that, we should sell it for 0.415 euros. Since 0.5 cents do not exist,
    we will perform some rounding.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的销售中有一个售价为0.83欧元的小猫钥匙链，并且我们对此进行50％的折扣，那么我们应该以0.415欧元的价格出售。由于不存在0.5分钱，我们将进行一些四舍五入。
- en: 'A client surfs our online shop and is amazed by our kitty discounts. He buys
    3\. If you do the math, that would result in 1.245 euros; we apply the `Math.round`
    function on it and that should result in 1.25 euros. We can check it with this
    code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个客户在我们的在线商店上浏览，并对我们关于小猫的折扣感到惊讶。他购买了3个。如果你计算一下，应该是1.245欧元；我们对其应用`Math.round`函数，应该会得到1.25欧元。我们可以用以下代码进行检查：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, consider that we code all our calculations:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请考虑到我们编码了所有的计算：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We lost one cent in the process. Imagine having a big application processing
    thousands of such transactions, or imagine that this was not a price but an exchange
    rate. Imagine you have to return this result to the backend and the calculations
    don't match up. The errors can accumulate and the final number can diverge significantly.
    This is just a small example, but there is more that can go wrong with floating
    point numbers when used with money.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中我们损失了一分钱。设想一下，如果有一个大型应用程序处理成千上万的此类交易，或者设想一下如果这不是一个价格而是一个汇率。设想一下你需要将这个结果返回给后端，并且计算结果不匹配。误差可能会累积，最终的数字可能会有很大的差异。这只是一个小例子，但是在处理货币时使用浮点数还有更多的可能出错的地方。
- en: Using strings (or integers) to represent currencies gives you the level of precision
    that you want.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串（或整数）表示货币可以给您想要的精度级别。
- en: 'Using our previous filter will introduce the dollar sign and two numbers after
    the decimal point, but we will still be short of the alignment we want. We should
    add a new style to our CSS:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前的过滤器将在小数点后引入美元符号和两个数字，但我们还是缺乏我们想要的对齐方式。我们应该为我们的CSS添加一个新的样式：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Assigning the class price to the price column will ensure alignment on the
    point. Here''s the complete code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将价格列分配给类名为price的类将确保在小数点上对齐。以下是完整的代码：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here''s the code for the JavaScript:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于JavaScript的代码：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Formatting dates with filters
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器格式化日期
- en: Sometimes you need a slightly more powerful filter than a basic one. You have
    to use similar filters many times, but every time with a slight variation. Having
    too many filters can create confusion. This example with dates will illustrate
    the problem and the solution.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要一个比基本过滤器更强大的过滤器。您必须多次使用类似的过滤器，但每次都有微小的变化。过多的过滤器可能会造成混乱。这个关于日期的示例将说明问题和解决方案。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before moving ahead, make yourself more comfortable with filters by going through
    the *Formatting your text with filters* recipe in [Chapter 1](text00026.html)
    , *Getting started with Vue.js*  *;* if you already know filters, keep reading.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，通过阅读“在第1章中使用过滤器格式化文本”这一节，使自己更加熟悉过滤器；如果您已经了解过滤器，请继续阅读。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let''s say we are curating an interactive page to learn history. We have our
    Vue instance with the following JavaScript code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在策划一个学习历史的互动页面。我们有一个包含以下内容的Vue实例和JavaScript代码：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In our data, we have a date written informally as a string in our instance
    data. Our HTML can contain a timeline of the French Revolution and, at some point,
    can contain the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据中，我们有一个以字符串形式非正式地写入的日期在我们的实例数据中。我们的HTML可以包含法国大革命的时间线，并且在某个时候可以包含以下内容：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need a filter capable of completing the sentence. For this, one possible
    library is the excellent `moment.js` and, for our purposes, we''ll choose the
    localized version: [https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.js](https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.js)
    .'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个能够完成句子的过滤器。为此，一个可能的库是优秀的`moment.js`，而且，为了我们的目的，我们选择了本地化版本：[https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.js](https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.js)。
- en: 'After adding the library, write the following filter:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了库之后，编写以下过滤器：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will display a nicely formatted date: `The Storming of the Bastille, happened
    on July 14, 1789` .
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个格式良好的日期：`The Storming of the Bastille, happened on July 14, 1789`。
- en: 'What if we want a multi-language site and we would like the date to be formatted
    in French? The `moment.js`  library is great with locales; in fact, let''s write
    the same text in French:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个多语言网站，并且希望日期以法语格式显示呢？`moment.js`库对于本地化非常好；实际上，让我们用法语写同样的文本：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have to amend our filter with the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用以下内容修改我们的过滤器：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our result is `La prise de la Bastille, survenue le 14 juillet 1789` , nice!
    We don''t want to hard-code the language in every page though. It''s much better
    to add a parameter in our filter. We want to be able to pass a variable to the
    filter with the language, like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果是`La prise de la Bastille, survenue le 14 juillet 1789`，非常好！然而，我们不想在每个页面中硬编码语言。最好的方法是在过滤器中添加一个参数。我们希望可以通过变量将语言传递给过滤器，就像这样：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To achieve this, we have to add a second parameter to the filter declaration:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们必须在过滤器声明中添加第二个参数：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This way, we can pass the language in a parameter through a variable in the
    page, for example, depending on the selected language.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以通过页面中的一个变量将语言作为参数传递了，例如，根据选择的语言而定。
- en: Displaying and hiding an element conditionally
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有条件地显示和隐藏元素
- en: Displaying and hiding an element on a web page is fundamental to some designs.
    You could have a popup, a set of elements that you want to display one at a time,
    or something that shows only when you click on a button.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有条件地显示和隐藏网页上的元素对某些设计来说是基本的。你可以有一个弹出窗口，一组你想要逐个显示的元素，或者只在点击按钮时显示的东西。
- en: In this recipe, we will use conditional display and learn about the important
    `v-if` and `v-show` directives.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用条件显示，并了解重要的`v-if`和`v-show`指令。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before venturing into this recipe, ensure that you know enough about computed
    properties or take a look at the *Filtering a list with a computed property* recipe.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入这个示例之前，请确保你对计算属性有足够的了解，或者请查看《使用计算属性过滤列表》一节。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s build a ghost that is only visible at night:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个只在夜晚可见的幽灵：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `v-show` guarantees that the `<div>` ghost will be displayed only when
    `isNight` is `true.` For example, we may write as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-show`保证只有在`isNight`为`true`时才会显示`<div>`幽灵。例如，我们可以写为：'
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will make the ghost visible. To make the example more real, we can write
    `isNight` as a computed property:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使幽灵可见。为了使示例更真实，我们可以将`isNight`作为一个计算属性来写：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you load this program in JSFiddle, you will see the ghost only after midnight
    and before 7:00\. If you really can''t wait to see the ghost, you can cheat and
    insert a time in the night, for example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在JSFiddle中加载这个程序，你将在午夜后和早上7点之前看到幽灵。如果你真的等不及要看到幽灵，你可以作弊并在夜间插入一个时间，例如：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `v-show` directive evaluates the `isNight` computed property and puts a
    `display: none`  in the element `style` attribute.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-show`指令计算`isNight`计算属性，并在元素的`style`属性中放置一个`display: none`。'
- en: This means that the element is completely rendered by Vue; it's just invisible,
    like a ghost.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着该元素完全由Vue渲染；它只是看不见，就像幽灵一样。
- en: 'The other directive for displaying elements conditionally is the `v-if` directive.
    The behavior is the same as that of `v-show` except that you won''t find the element
    in the DOM at all. When `v-if`  evaluates to `true` , the element will be added
    dynamically, no element styling involved. To try it, just replace the `v-show`
    with `v-if` :'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于条件显示元素的指令是`v-if`指令。行为与`v-show`相同，只是在DOM中找不到该元素。当`v-if`评估为`true`时，该元素将被动态添加，没有元素样式的参与。要试用它，只需将`v-show`替换为`v-if`：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In general, if it makes no difference, using `v-show` is better because it requires
    fewer resources in the long run. On the other hand, if you are not even sure that
    some elements will appear on the page, using `v-if` will let your users save some
    CPU time (you never know when your app will go viral and have millions of users;
    you can save a lot of energy by choosing the right one!).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果没有区别，使用`v-show`更好，因为从长远来看，它需要更少的资源。另一方面，如果你甚至不确定某些元素是否会出现在页面上，使用`v-if`可以让用户节省一些CPU时间（你永远不知道你的应用何时会爆红，并拥有数百万用户；通过选择正确的方式，你可以节省大量能量！）。
- en: On a side note, don't wait in front of the page until midnight. Nothing will
    happen. Computed properties are re-evaluated only when reactive properties inside
    them change. In this case, we have a `Date`  that is not reactive and, thus, will
    not trigger any update.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，在午夜之前不要等在页面前面。什么都不会发生。计算属性仅在其中的响应式属性发生更改时重新评估。在这种情况下，我们有一个非响应式的`Date`，因此不会触发任何更新。
- en: Adding styles conditionally
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有条件地添加样式
- en: One great feature of modern web page architecture is the ability to pack tons
    of display logic in CSS. This means you can have a very clean and expressive HTML
    and still create impressive interactive pages via CSS.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网页架构的一个伟大特性是可以在CSS中打包大量的显示逻辑。这意味着您可以拥有非常干净且表达力强的HTML，同时通过CSS创建令人印象深刻的交互页面。
- en: Vue is particularly good at expressing relationships between HTML and CSS and
    allows you to encapsulate complex logic in easy-to-use functions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Vue在表达HTML和CSS之间的关系方面特别擅长，并允许您将复杂的逻辑封装为易于使用的函数。
- en: In this recipe, we will explore the basics of styling with Vue.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将探讨使用Vue进行样式设置的基础知识。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: 'We will build a text area that warns you when you are reaching the maximum
    allowed number of characters:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个文本区域，当您接近允许的最大字符数时会发出警告：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The text written inside will be bound to the `memeText` variable and the `length`
    of our text is written at the end via mustaches.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所写的文本将与`memeText`变量绑定，文本的`length`将通过双大括号写在末尾。
- en: 'We want to change the background color when only 10 characters are left. For
    this, we have to bake a little CSS class `warn` :'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当仅剩下10个字符时，我们想要更改背景颜色。为此，我们必须创建一个名为`warn`的CSS类：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We will use this class on the `textarea` to signal the imminent alt on writing.
    Let''s take a look at our JavaScript:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`textarea`上使用此类来表示即将达到的写入上限。让我们看一下JavaScript代码：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is just our model; we want to add a function,  `longText` , that will
    evaluate to true whenever we reach 40 characters (10 characters away from 50):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们的模型；我们想要添加一个名为`longText`的函数，当我们达到40个字符时（距离50个字符还有10个字符）评估为true：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now everything is in place to actually add the warn style conditionally. To
    do this, we have two options: **object syntax**  and **array syntax** . Let''s
    first try with the object syntax:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切就位，来条件性地添加warn样式。为此，我们有两个选项：**对象语法**和**数组语法**。我们先尝试使用对象语法：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This means that, whenever `longText` evaluates to `true` (or in general to a
    truthy), the class warn will be added to the `textarea` .
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，每当`longText`评估为`true`（或一般为真值）时，类`warn`将被添加到`textarea`中。
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'If you try to write past the 39 characters in the text area, the background
    will turn misty rose. The general object syntax for *n* classes is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在文本区域中输入超过39个字符，背景色将变为薄雾的玫瑰色。通常，*n*个类的对象语法如下所示：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'There are, however, a couple of alternatives to this syntax. First of all,
    you don''t need to write the full object in the HTML; you can also bind to an
    object. The general way to do it is as shown:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有几种代替此语法的方法。首先，您不需要在HTML中编写完整的对象；您还可以绑定到一个对象。一般的做法如下所示：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At this point, manipulating the classes object will add or remove the warn
    class from the `<div>` . An even more clever way to bind is to a computed property
    that itself returns an object:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，操纵类对象将向`<div>`添加或移除`warn`类。一种更聪明的绑定方式是绑定到一个计算属性，该计算属性本身返回一个对象：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And, of course, it''s much easier to put some custom logic inside the computed
    property:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，将一些自定义逻辑放在计算属性中会更容易：
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Adding some fun to your app with CSS transitions
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过CSS过渡为应用程序增加一些乐趣
- en: Transitions are effects that can be applied when elements are inserted, updated,
    and removed from the DOM.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡是在元素被插入、更新和从DOM中移除时应用的效果。
- en: For this recipe, we will build a little riddle for our friends to enjoy. When
    they want to know the solution, it will appear with a fading transition.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，我们将为朋友们建立一个小谜题。当他们想知道答案时，它将以淡入效果出现。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this lesson, you should already know conditional display and conditional
    rendering. The *Displaying and hiding an element conditionally*  recipe will teach
    you how to do that.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本课程，您应该已经了解条件显示和条件渲染。 *条件显示和隐藏元素* 将教您如何做到这一点。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体操作步骤...
- en: 'Let''s set up the riddle in our HTML:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在HTML中设置谜题：
- en: '[PRE57]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The Vue instance is initialized very easily; you just have to write the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Vue实例的初始化非常简单，您只需编写以下内容：
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the CSS, we want to make clear that the `<div>` solution can be clicked
    on, and so we add the following rule:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，我们希望清楚地表明`<div>`解决方案可以被点击，因此我们添加了以下规则：
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: At this point the application works, but you will see the Dragon immediately.
    We want to add a touch of class to our riddle and make the dragon appear with
    a fading effect.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序可以工作了，但是您会立即看到Dragon。我们想为我们的谜题增添一些优雅的效果，并通过淡入效果使龙出现。
- en: 'We need two CSS classes; the first class will be applied for one tick when
    the solution appears:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个CSS类；第一个类在解决方案出现时将被应用一次：
- en: '[PRE60]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The second one will be persistent after the first one:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个类将在第一个类之后持续存在：
- en: '[PRE61]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we wrap the solution in a transition:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将解决方案包装在一个过渡中：
- en: '[PRE62]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The name of the transition is the first word of the CSS class selectors `(fade
    )` , and Vue will look for them based on whether the element is appearing or disappearing
    from the screen. If no name is specified and only `<transition>` is used, Vue
    will use the transition name,  `v`  for CSS.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡的名称是CSS类选择器的第一个单词`(fade )`，Vue将根据元素出现或从屏幕上消失来查找它们。如果未指定名称并且只使用了`<transition>`，Vue将使用过渡名称`v`作为CSS。
- en: In our case, the dragon that was previously invisible is appearing and so, 
    `fade-enter` will be applied for a tick (a tick is a cycle for refreshing the
    view, but you can think of it as a frame in an animation). This means the `<span>`
    will be effectively invisible at the beginning because the opacity will be set
    to `0` .
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，之前看不见的龙正出现了，所以`fade-enter`将在一个刻度中应用（刻度是刷新视图的一个周期，但你可以把它看作是动画中的一个帧）。这意味着在开始时`<span>`实际上是不可见的，因为透明度将被设置为`0`。
- en: After that, the `fade-enter` class will be removed and `fade-enter-active` ,
    which was attached to  `fade-enter` , is now the only class remaining. The opacity
    will go to `1` in half a second as you can see from the rules of the class. Where
    is 1 specified? It's the default value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`fade-enter`类将被移除，而附加在`fade-enter`上的`fade-enter-active`现在是唯一剩下的类。从该类的规则可以看出，透明度将在半秒钟内变为`1`。1是在哪里指定的？这是默认值。
- en: 'The complete set of classes Vue will look for in transitions are as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Vue在过渡中要寻找的完整类集如下：
- en: '`name-enter` : This is the starting class for `enter` ; it is applied before
    an element is inserted, and removed after one frame.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name-enter`：这是`enter`的起始类；它在元素插入之前应用，并在一帧之后被移除。'
- en: '`name-enter-active` : This is the persistent class for `enter` . It is applied
    before an element is inserted and is removed when the transition/animation finishes.
    Use this to define the features of the transition, such as duration and easing.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name-enter-active`：这是`enter`的持续类。它在元素插入之前应用，并在过渡/动画完成时被移除。使用它来定义过渡的特性，如持续时间和缓动。'
- en: '`name-enter-to` : This is the ending class for `enter` . It is applied when
    `name-enter` is removed.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name-enter-to`：这是`enter`的结束类。在移除了`name-enter`时应用。'
- en: '`name-leave` : This is the starting class for `leave` . It is applied when
    `leave` transition is triggered and is removed after one frame.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name-leave`：这是`leave`的起始类。在触发`leave`过渡时应用，并在一帧之后被移除。'
- en: '`name-leave-active` : This is the persistent class for `leave` . It is applied
    when `leave` transition is triggered and is removed when the transition/animation
    finishes.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name-leave-active`：这是`leave`的持续类。在触发`leave`过渡时应用，并在过渡/动画完成时被移除。'
- en: '`name-leave-to` : This replaces `name-leave` .'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name-leave-to`：这取代了`name-leave`。'
- en: Here, name is the name of your transition (`v` where no name is specified).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`name`是您过渡的名称（在未指定名称时为`v`）。
- en: There's more...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Transitions are cool, but there is a tree that is blocking our view in this
    recipe and it''s ruining the transition''s reputation; to follow along, consider
    the following HTML:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡很酷，但是在这个示例中有一个遮挡我们视图的树，这破坏了过渡的声誉。为了跟进，请考虑以下HTML：
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A little bit of CSS is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一小段CSS如下所示：
- en: '[PRE64]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, a simple Vue instance is required:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要一个简单的Vue实例：
- en: '[PRE65]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When we run the application, this is what we get:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们得到的结果如下所示：
- en: '![](img/Image00026.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00026.jpg)'
- en: Clicking on the tree reveals the real message.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 点击树会显示真正的消息。
- en: Outputting raw HTML
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出原始HTML
- en: Sometimes you need to insert HTML content, such as line breaks ( `<br>` ), in
    your application data. This can be easily achieved with the `v-html` directive.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要插入HTML内容，例如换行符（`<br>`），到您的应用程序数据中。这可以通过使用`v-html`指令轻松实现。
- en: In this recipe, we will build a thank-you note.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将构建一个感谢信。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you don't need any special knowledge, but we will build upon
    some basic Vue functionalities; if you completed a recipe in this or the last chapter,
    you are good to go.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您不需要任何特殊的知识，但我们将建立在一些基本的Vue功能之上；如果您在本章节或上一章节中完成了一个示例，您就可以开始了。
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s say you have a friend John. You want to prepare a formatted thank-you
    note before receiving a gift, but you don''t know what he''ll be giving you yet.
    You prewrite three texts:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个朋友约翰。在收到礼物之前，你想要准备一封格式化的感谢信，但是你不知道他会送给你什么。你预先写了三份文本：
- en: '[PRE66]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Consider that you were to output this variable directly in mustaches, as shown:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你会将这个变量直接输出在花括号内，如下所示：
- en: '[PRE67]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The problem is that, in this case, you would get plain text and all the HTML
    gibberish:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，这种情况下，你会得到纯文本和所有的HTML乱码：
- en: '![](img/Image00027.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00027.jpg)'
- en: This is not what you're looking for; you would like your thank-you letter well
    formatted following the HTML tags.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是你要寻找的；你希望你的感谢信按照HTML标签的格式进行良好的排版。
- en: 'What you need to do is use the `v-html` directive, as shown:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的是使用`v-html`指令，如下所示：
- en: '[PRE68]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This way, the HTML tags won''t be escaped by Vue and will be interpreted as
    is in our component:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，HTML标签就不会被Vue转义，并且会在我们的组件中按原样解释：
- en: '![](img/Image00028.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00028.jpg)'
- en: How it works...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理是这样的...
- en: Outputting raw HTML in general is very dangerous. Explaining web security is
    beyond the scope of this book, but just to get the idea, imagine that you have
    a comments section in your website, and that someone puts an `<img>` in a comment.
    If you were to interpret that as HTML and display it to other users, you could
    make your users download an image they don't necessarily want; if the image is
    not yours, you may be charged for bandwidth you didn't plan. Now you can expand
    this reason. If a user puts a `<script>` in the comment, this poses a greater
    risk as scripts can do almost anything.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，输出原始HTML是非常危险的。解释网站安全性超出了本书的范围，但只是为了让你有一个想法，想象一下你的网站上有一个评论部分，有人在评论中放置了一个`<img>`标签。如果你将其解释为HTML并展示给其他用户，你可能会让你的用户下载一个他们并不一定想要的图片；如果这个图片不属于你，你可能会因此被收取你没有计划的带宽费用。现在你可以扩展这个理由。如果一个用户在评论中放置了一个`<script>`标签，这将带来更大的风险，因为脚本可以做几乎任何事情。
- en: Vue, by default, avoids the problem altogether by not letting you output HTML
    by default; that's why we need the special `v-html` directive to see it. This
    said, always ensure that you are in full control of the content you are outputting.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Vue通过不让你默认输出HTML来避免这个问题；这就是为什么我们需要特殊的`v-html`指令来查看它。也就是说，始终确保你对输出内容有完全控制。
- en: There's more...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is another way to output raw HTML; it is advanced, but it's much cleaner
    and maintainable, especially if you have a component that depends heavily on HTML
    formatting.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种输出原始HTML的方法；这种方法更加先进，但更加清晰和可维护，尤其是对于那些严重依赖HTML格式化的组件来说。
- en: In these more contrived cases, you can opt for **functional components**  that
    are covered in detail in the *Create a functional component* recipe in [Chapter
    9](text00431.html) , *Advanced Vue.js - Directives, Plugins and Render Functions*
    , but here you will find an example that is an extension of what we have just
    done.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更加矫揉造作的情况下，你可以选择使用详细介绍在[第9章](text00431.html)的*创建一个函数式组件*配方中涵盖的**函数式组件**，但这里你将找到一个扩展了我们刚才所做的示例。
- en: 'The HTML you should write is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该写的HTML如下所示：
- en: '[PRE69]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You can already see that the intent is clear: to write a thank-you note for
    the batman gift using the HTML `<strong>` as decoration. The JavaScript to create
    the `<thanks>` component is as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以看到意图很明确：使用HTML `<strong>`作为装饰来写一封关于蝙蝠侠礼物的感谢信。创建`<thanks>`组件的JavaScript代码如下所示：
- en: '[PRE70]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Of course, you will need the Vue instance as well.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还需要Vue实例。
- en: Creating a form with checkboxes
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个带有复选框的表单
- en: Asking for user input is fundamental in today's web apps. Presenting the user
    with multiple choices makes the interface more fun to use and is necessary for
    structured input.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的Web应用中，询问用户的输入是基本的。向用户展示多个选择使界面更有趣，对于结构化输入是必要的。
- en: In this recipe, you will learn how to create checkboxes by building a confirmation
    page for your own print shop!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，你将学习如何通过构建确认页面来创建复选框，用于你自己的打印店！
- en: Getting ready
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We already know how data binding works in Vue, so you are good to go. Otherwise
    go back to the first recipe, collect 200, and then proceed to the *React to events
    like clicks and keystrokes* recipe in [Chapter 1](text00026.html) , *Getting started
    with Vue.js* , to learn more about the `v-model` directive.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了Vue中的数据绑定是如何工作的，所以你可以开始操作了。否则，请返回第一个教程，收集200积分，然后继续阅读[第1章](text00026.html)中的*响应点击和按键事件*教程，以了解更多关于`v-model`指令的内容。
- en: How to do it...
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Let''s suppose you have to set up a Martian printing shop with three different
    printers:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要为你的火星打印店设置三个不同的打印机：
- en: Monochrome printer
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 单色打印机'
- en: Plasma Color printer
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 等离子彩色打印机'
- en: 3D DNA Clone printer
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 3D DNA克隆打印机'
- en: 'The confirmation page will basically be just a form:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 确认页面基本上只是一个表单：
- en: '[PRE71]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Instead of name, we will use `v-model` to bind our model to the view:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`v-model`而不是名称来将我们的模型绑定到视图上：
- en: '[PRE72]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Every `<input>` checkbox with the same `v-model` will participate in a reactive
    array that will be updated in real time. Let''s declare this array in the Vue
    instance:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 每个具有相同`v-model`的`<input>`复选框都将参与一个反应性数组，在实时更新中插入和删除数组中的项。让我们在Vue实例中声明这个数组：
- en: '[PRE73]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is just a regular array. All the selected printers will be inserted and
    removed automatically from the array. Here''s the complete HTML:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个普通的数组。所有选中的打印机将自动插入和从数组中移除。以下是完整的HTML代码：
- en: '[PRE74]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This will result in a form like the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个类似下面的表单：
- en: '![](img/Image00029.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00029.jpg)'
- en: Put `{{ outputPrinter }}` somewhere inside your app in a  `<div>`  tag and see
    for yourself the array changing in real time while selecting printers.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序的任何地方的`<div>`标签内放置`{{ outputPrinter }}`，并通过选择打印机来实时查看数组的变化。
- en: How it works...
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'If you check the first and last printer, the array will look like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选中第一个和最后一个打印机，数组将如下所示：
- en: '[PRE75]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You can than use this array to send it via AJAX to a web service or to further
    build upon it.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用这个数组将其通过AJAX发送到一个Web服务或进一步进行其他操作。
- en: Checkboxes in Vue are just regular `<input>` elements, the only difference being
    that we don't really need the name attribute used in traditional forms. That's
    because we won't have a second page to submit our values (the page that normally
    reads the value using the name attributes).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue中，复选框只是普通的`<input>`元素，唯一的区别是我们实际上不需要在传统表单中使用的name属性。这是因为我们将不需要第二个页面来提交我们的值（通常使用name属性读取值的页面）。
- en: There's more...
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: To reach this "second page" I was talking about, just click on the submit button.
    This is the default behavior and, in our case it's not what we want; since we
    usually don't like having to change page when dealing with Vue, I will show you
    how to prevent it.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入我所说的“第二个页面”，只需点击提交按钮。这是默认行为，在我们的情况下并不是我们想要的；因为我们通常不喜欢在处理Vue时需要改变页面，我将向你展示如何阻止默认行为。
- en: Modern websites tend to give feedback for your action on the same page, sometimes
    without interrupting your workflow (what if you want to clone another five or
    six creatures in the same session?)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网站倾向于在同一页上为你的操作提供反馈，有时甚至不会中断你的工作流程（如果你想在同一会话中克隆另外五个或六个实体怎么办？）
- en: 'Let''s turn it into something more useful. First of all, we have to prevent
    the button default action, which is to change page; for this, we use the prevent
    modifier:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其变得更加有用。首先，我们必须阻止按钮的默认操作，即改变页面；为此，我们使用prevent修饰符：
- en: '[PRE76]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `printHandler` will be a method in our Vue instance that will get us some
    feedback. You are free to add whatever you want as a handler, perhaps a popup
    that tells you that printing is in progress; maybe you can just go back to the
    home page.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`printHandler`将是我们Vue实例中的一个方法，它将为我们提供一些反馈。您可以自由地添加处理程序，例如一个弹出窗口告诉您打印正在进行中；也许您可以返回主页。'
- en: 'In this example, we will just check whether the button works with an alert
    popup:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用警报弹出窗口来检查按钮是否正常工作：
- en: '[PRE77]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Creating a form with radio buttons
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个带单选按钮的表单
- en: Radio buttons let you choose only one option among many. When the user selects
    a radio button, any previously selected radio button is deselected. A common example
    of its use is when you are creating a registration form and you choose between
    male and female.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮让您在多个选项中选择一个选项。当用户选择一个单选按钮时，任何先前选择的单选按钮将被取消选择。其常见用途是在创建注册表单时选择男性或女性。
- en: Getting ready
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will resemble the *Creating a form with checkboxes* recipe because
    we are using a similar technique. I suggest you to complete both the recipes to
    become a black belt in Vue forms.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例类似于“创建一个带复选框的表单”案例，因为我们使用了类似的技术。我建议你完成这两个案例，以成为Vue表单黑带。
- en: How to do it...
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'First of all, we need something to choose from, so we write an array in our
    Vue instance:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些可选择的内容，所以我们在Vue实例中编写一个数组：
- en: '[PRE78]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We will use the variable gender (singular) to hold the value of the chosen
    option. From here, we can set up a form in just a few lines:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用变量gender（单数）来保存所选选项的值。从这里开始，我们可以通过几行代码来设置一个表单：
- en: '[PRE79]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You can run the app and it will work; however, you need to add a mustache after
    the form to see what is happening :'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行应用程序，它将工作；但是，您需要在form后面添加一个胡子括号，以查看发生了什么：
- en: '[PRE80]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This way, you can see how clicking on the radio buttons affects the internal
    data:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您可以看到单选按钮的点击如何影响内部数据：
- en: '![](img/Image00030.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00030.jpg)'
- en: How it works...
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Here we just inserts three radio buttons. Since they all have `v-model="gender"`
    , they logically belong to the same group. This means that only one of the values
    can be selected at any given time. We can have as many groups as we want in the
    same form.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们只插入了三个单选按钮。由于它们都有`v-model =“gender”`，它们在逻辑上属于同一组。这意味着在任何给定的时间只能选择一个值。我们可以在同一个表单中有任意多个组。
- en: There's more...
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步了解...
- en: 'In this recipe, the value of the radio buttons was completely fixed:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，单选按钮的值完全是固定的：
- en: '[PRE81]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can change the `value="male"` to make it reactive using `v-bind:value` .
    This binds the value to whatever variable we pass to it. For example, let''s say
    we have an array of genders in our model:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改`value =“male”`，使用`v-bind：value`使其动态响应。这会将值绑定到我们传递给它的任何变量。例如，假设我们的模型中有一个性别数组：
- en: '[PRE82]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can rewrite the preceding radio button like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样重写前面的单选按钮：
- en: '[PRE83]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here,  `:value` is a shorthand for `v-bind:value` .
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`:value`是`v-bind：value`的简写形式。
- en: To put what we have learned into practice, let's build a simple game.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们学到的知识付诸实践，让我们构建一个简单的游戏。
- en: Suppose you are a farmer, and you start with zero animals in your farm. Every
    day, there are new animals on sale at the animal market. You can only buy one
    on any given day. We can express this choice with radio buttons!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您是一位农民，您的农场一开始没有动物。每天，动物市场上都有新的动物出售。您一次只能买一只。我们可以使用单选按钮来表示这个选择！
- en: 'So we have an animals array in our model, an animal variable that will contain
    our choice for the day, and a farm array (initially empty) that will represent
    our hoarding. We add a little randomness with the `i` variable to hold a random
    number representing the available animals for the day:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在我们的模型中有一个动物数组，一个包含我们每天选择的动物的变量，以及一个表示我们养殖场的农场数组（最初为空）。我们使用`i`变量添加了一点随机性，以保存表示当天可用动物的随机数：
- en: '[PRE84]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: I used emojis to represent the animals because they are super fun to use. If
    you don't know where to find them, just copy and paste them from [http://emojipedia.org/](http://emojipedia.org/)
    and look for animals.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用表情符号来表示动物，因为它们非常有趣。如果你不知道在哪里找到它们，只需从[http://emojipedia.org/](http://emojipedia.org/)复制并粘贴它们，然后搜索动物。
- en: 'We can start from the same HTML we used at the beginning; we just need to change
    the legend:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从最初使用的相同HTML开始；我们只需要改变图例：
- en: '[PRE85]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'At this point we should add a list of animals from which to choose, but we
    want it to be dynamic, that is, a different pair of animals for every day:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该添加一个动物列表供选择，但我们希望它是动态的，也就是说，每天都有不同的动物对：
- en: '[PRE86]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This means that the value (and the label) of the radio button will change as
    the `i` variable is changed.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着随着`i`变量的改变，单选按钮的值（和标签）将会改变。
- en: 'The only thing remaining is a way to buy the animal, add it to the farm, and
    wait for the next day. We will summarize all this in a submit button:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的就是一种购买动物、将其添加到农场并等待下一天的方法。我们将在提交按钮中总结所有这些：
- en: '[PRE87]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Here, the `addToFarm` method is defined by the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`addToFarm`方法由以下内容定义：
- en: '[PRE88]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Don''t do anything if the animal was not chosen; otherwise, add the animal
    to the farm, draw a random number for the next day, and reset the selection. To
    see your farm, add this to your HTML:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有选择动物，则不执行任何操作；否则，将动物添加到农场，为下一天生成一个随机数，并重置选择。要查看你的农场，请将以下内容添加到你的HTML中：
- en: '[PRE89]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Your app will look like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序将如下所示：
- en: '![](img/Image00034.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00034.jpg)'
- en: Creating a form with a select element
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个带有选择元素的表单
- en: Select elements or "drop-down lists" are used in a form when radio buttons won't
    cut it, either because there are too many choices or because they always take
    the same space no matter how many options.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当单选按钮无法满足需求时，选择元素或“下拉列表”用于表单，无论是因为选择太多还是因为无论有多少选项，它们始终占据相同的空间。
- en: Getting ready
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I suggest you complete a recipe on data binding or forms before delving into
    the world of select elements. The *Creating a form with radio buttons* recipe
    will make you familiar with radio buttons, which have a function similar to select
    elements.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您在深入研究选择元素之前先完成有关数据绑定或表单的教程。有关单选按钮的教程将使您熟悉单选按钮，其功能类似于选择元素。
- en: How to do it...
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will create a simple country selector. I will start by writing
    the selector without the help of Vue, just to brush up on HTML. First, create
    a `form` in which to put the `select` element:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个简单的国家选择器。我将首先在没有Vue的帮助下编写选择器，只是为了复习HTML。首先，创建一个`form`，在其中放置`select`元素：
- en: '[PRE90]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Inside the `fieldset` , write the code for the `select` element:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fieldset`中，编写`select`元素的代码：
- en: '[PRE91]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Run the application. There you have a working select element right from the
    start. The anatomy is pretty simple. Every `<option>` will lengthen the list of
    things to choose from.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序。从一开始就有一个可工作的选择元素。结构非常简单。每个`<option>`将增加可选择的事物列表。
- en: 'For now, there is not much to be done with this element. Let''s bind the chosen
    country to a variable with Vue. You have to edit your HTML:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，对于这个元素来说，还没有太多可以做的。让我们将选择的国家与Vue绑定到一个变量上。您需要编辑您的HTML：
- en: '[PRE92]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, you have to add `choosenCountry` to your model:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要将`choosenCountry`添加到您的模型中：
- en: '[PRE93]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Don't forget to surround the form with `<div id="app">` or it won't be picked
    up by Vue.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记用`<div id="app">`将表单包围起来，否则Vue将无法识别它。
- en: Run the application now; you will notice that, whereas earlier the drop-down
    started with Japan  already selected, now it's obeying our initialization in the
    code.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，你会注意到，之前下拉菜单以日本为默认选择，现在它遵循了我们在代码中的初始化。
- en: 'This means that, initially, no country will be selected. We can add a mustache
    to see the current status of the variable:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着初始状态下没有选择任何国家。我们可以添加一个花括号来查看变量的当前状态：
- en: '[PRE94]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The country selector will look like this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 国家选择器将如下所示：
- en: '![](img/Image00035.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00035.jpg)'
- en: How it works...
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you bind a `<select>` element with `v-model` , the selected option will
    populate the bound variable.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`v-model`将`<select>`元素绑定时，所选选项将填充绑定的变量。
- en: 'Note that, if you set a value for your options, the variable will take it instead
    of what is written within the tags. For example, you can write as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果为选项设置了值，变量将使用该值，而不是标签中写的内容。例如，你可以这样写：
- en: '[PRE95]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This ensures that you have every country bound to a numeric value.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以确保每个国家都绑定到一个数值。
- en: There's more...
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Often, countries and cities are arranged in hierarchical ways. This means that
    we need two or more select elements to pin down a user birth place, for example.
    In this paragraph, we will explore a little bit of hierarchical selection with
    multiple drop-down menus. Since there are too many cities in the world, I will
    use a biological equivalent and we will select from animals:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，国家和城市以层次结构的方式排列。这意味着我们需要两个或更多的下拉菜单来确定用户的出生地，例如。在本段中，我们将使用生物学的等价物来选择动物：
- en: '[PRE96]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We will call the top level a `clan` , the second level a `type`  and the last
    will be an animal. I know it's an unorthodox way of classifying animals, but it
    will work for this example.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把顶层称为`clan`，第二层称为`type`，最后一层将是一个动物。我知道这是一种非正统的分类动物的方式，但对于这个例子来说，它是有效的。
- en: 'Let''s add the two variables that will hold the state to our Vue model:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为Vue模型添加两个保存状态的变量：
- en: '[PRE97]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We can now add the first `select` element:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加第一个`select`元素：
- en: '[PRE98]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This will create a drop-down menu with the following:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个下拉菜单，其中包含以下内容：
- en: Mammalia
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哺乳动物
- en: Birds
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸟类
- en: The variable types don't really do anything in this particular case.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，变量`types`实际上没有起作用。
- en: 'We would like to populate a second drop-down with the `type`  of a particular
    `clan` :'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用特定`clan`的`type`填充第二个下拉菜单：
- en: '[PRE99]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'When the variable clan has a value, this select element will let you choose
    the type of animal. Consider that we add a third select for the species though:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量`clan`有值时，这个选择元素将让你选择动物的类型。请注意，尽管我们为物种添加了第三个选择：
- en: '[PRE100]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: It will cause an error in our program because `clans[clan]` is undefined and
    Vue will try to evaluate it. To correct this, we may want the third select element
    to appear only when the first and the second have a value. For this, we can use
    the `v-show` directive, but the problem is that Vue renders the elements with
    `v-show` , and only after rendering, will it hide them. This means that the error
    will still be thrown.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 它会导致我们的程序出错，因为`clans[clan]`是未定义的，Vue将尝试对其进行求值。为了纠正这个问题，我们可能希望只有在第一个和第二个选择有值时才显示第三个选择元素。为此，我们可以使用`v-show`指令，但问题是Vue会渲染带有`v-show`的元素，只有在渲染之后才会隐藏它们。这意味着错误仍然会被抛出。
- en: 'The right way is to use `v-if` , which prevents the rendering of the element
    if the condition inside is not satisfied is, as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法是使用`v-if`，如果内部条件不满足，则阻止元素的渲染，如下所示：
- en: '[PRE101]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Go ahead and choose your favorite animal hierarchically!
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续选择你最喜欢的动物层次结构吧！
