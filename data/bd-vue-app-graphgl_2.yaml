- en: Components, Mixins, and Functional Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件、混合和功能性组件
- en: Building a Vue application is like putting a puzzle together. Each piece of
    the puzzle is a component, and each piece has a slot to fill.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Vue应用就像拼图一样。每个拼图的一部分都是一个组件，每个拼图都有一个槽要填充。
- en: Components play a big part in Vue development. In Vue, each part of your code
    will be a component – it could be a layout, a page, a container, or a button,
    but ultimately, it's a component. Learning how to interact with them and reuse
    them is the key to cleaning up code and performance in your Vue application. Components
    are the code that will, in the end, render something on the screen, whatever its
    size might be.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 组件在Vue开发中扮演着重要角色。在Vue中，你的代码的每一部分都将是一个组件 - 它可以是布局、页面、容器或按钮，但最终，它都是一个组件。学习如何与它们交互和重用它们是清理代码和提高Vue应用性能的关键。组件是最终会在屏幕上渲染出东西的代码，无论它的大小是多少。
- en: In this chapter, we will learn about how to make a visual component that can
    be reused in many places. We'll use slots to place data inside our components,
    create functional components for seriously fast rendering, implement direct communication
    between parent and child components, and look at loading our components asynchronously.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习如何制作一个可在多个地方重复使用的可视化组件。我们将使用插槽在组件内放置数据，为了快速渲染创建功能性组件，实现父子组件之间的直接通信，并异步加载我们的组件。
- en: Then, we'll put all those pieces together and create a beautiful puzzle that's
    also a Vue application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将把所有这些部分放在一起，创建一个既是美丽的拼图又是Vue应用的拼图。
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下示例：
- en: Creating a visual template component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可视化模板组件
- en: Using slots and named slots to place data inside your components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插槽和命名插槽在组件内放置数据
- en: Passing data to your component and validating the data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向您的组件传递数据并验证数据
- en: Creating functional components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建功能性组件
- en: Accessing your children component's data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问子组件的数据
- en: Creating a dynamic injected component
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个动态注入组件
- en: Creating a dependency injection component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个依赖注入组件
- en: Creating a `mixin` component
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`mixin`组件
- en: Lazy loading your components
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟加载您的组件
- en: Let's get started!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be using **Node.js** and **Vue-CLI****.**
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将使用**Node.js**和**Vue-CLI**。
- en: '**Attention Windows users**: You need to install an `npm` package called `windows-build-tools` to
    be able to install the required packages. To do so, open PowerShell as an administrator
    and execute the `> npm install -g windows-build-tools` command.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意Windows用户**：您需要安装一个名为`windows-build-tools`的`npm`包才能安装所需的包。为此，请以管理员身份打开PowerShell并执行`>
    npm install -g windows-build-tools`命令。'
- en: 'To install the **Vue CLI**, you need to open a Terminal (macOS or Linux) or
    Command Prompt*/*PowerShell (Windows) and execute the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装**Vue CLI**，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating a visual template component
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可视化模板组件
- en: 'Components can be data-driven, stateless, stateful, or simple visual components.
    But what is a visual component? A visual component is a component that has only
    one purpose: visual manipulation.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以是数据驱动的、无状态的、有状态的或简单的可视化组件。但是什么是可视化组件？可视化组件是一个只有一个目的的组件：视觉操作。
- en: A visual component could have a simple Scoped CSS with some `div` HTML elements,
    or it could be a more complex component that can calculate the position of the
    element on the screen in real time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可视化组件可以有一个简单的作用域CSS和一些`div` HTML元素，或者它可以是一个更复杂的组件，可以实时计算元素在屏幕上的位置。
- en: In this recipe, we will create a card wrapper component that follows the Material
    Design guide.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个遵循Material Design指南的卡片包装组件。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The prerequisite for this recipe is Node.js 12+.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的先决条件是Node.js 12+。
- en: 'The Node.js global objects that are required for this recipe are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To start our component, we need to create a new Vue project with the Vue CLI. 
    Open a Terminal (macOS or Linux) or Command Prompt/PowerShell (Windows) and execute
    the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的组件，我们需要使用Vue CLI创建一个新的Vue项目。打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The CLI will ask some questions that will help you create the project. You
    can use the arrow keys to navigate, the *Enter* key to continue, and the *s**pacebar* to
    select an option. Choose the `default` option:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CLI将询问一些问题，这些问题将帮助您创建项目。您可以使用箭头键导航，使用*Enter*键继续，并使用*空格键*选择选项。选择`default`选项：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, follow these steps to create a visual template component:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤创建一个视觉模板组件：
- en: Create a new file called `MaterialCardBox.vue` in the `src/components` folder.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中创建一个名为`MaterialCardBox.vue`的新文件。
- en: 'In this file, we will start working on the template of our component. We need
    to create the box for the card. By using the Material Design guide, this box will
    have a shadow and rounded corners:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，我们将开始处理组件的模板。我们需要为卡片创建一个框。通过使用Material Design指南，此框将具有阴影和圆角：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `<script>` part of our component, we will add just our basic name:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们组件的`<script>`部分中，我们将只添加我们的基本名称：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to create our elevation CSS rules. To do this, create a file named `elevation.css` in
    the `style` folder. There, we will create the elevations from `0` to `24` so that
    we can follow all the elevations provided by the Material Design guide:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建我们的高程CSS规则。为此，请在`style`文件夹中创建一个名为`elevation.css`的文件。在那里，我们将创建从`0`到`24`的高程，以便我们可以遵循Material
    Design指南提供的所有高程：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For styling our card in the `<style>` part of the component, we need to set
    the `scoped` attribute inside the `<style>` tag. This ensures that the visual
    style won''t interfere with any other components within our application. We will
    make this card follow the Material Design guide. We need to import the `Roboto` font
    family and apply it to all the elements that will be wrapped inside this component:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<style>`部分中为我们的卡片设置样式，我们需要在`<style>`标签内设置`scoped`属性。这确保了视觉样式不会干扰应用程序中的任何其他组件。我们将使此卡片遵循Material
    Design指南。我们需要导入`Roboto`字体系列并将其应用于此组件内部的所有元素：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `App.vue` file, we need to import our component to be able to see it:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.vue`文件中，我们需要导入我们的组件以便能够看到它：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To run the server and see your component, you need to open a Terminal (macOS
    or Linux) or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行服务器并查看您的组件，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Remember to always execute the command `npm run lint --fix`, to automatically
    fix any code lint error.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住始终执行命令`npm run lint --fix`，以自动修复任何代码lint错误。
- en: 'Here is the component rendered and running:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染和运行的组件：
- en: '![](assets/653a5ed9-5429-4c27-b2d7-6e26c147418c.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/653a5ed9-5429-4c27-b2d7-6e26c147418c.png)'
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A visual component is a component that will wrap any component and place the
    wrapped data alongside custom styles. Since this component mixes with others,
    it can form a new component without you needing to reapply or rewrite any style
    in your code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉组件是一个将包装任何组件并将包装数据与自定义样式放在一起的组件。由于此组件与其他组件混合，因此它可以形成一个新的组件，而无需您在代码中重新应用或重写任何样式。
- en: See also
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about Scoped CSS at [https://vue-loader.vuejs.org/guide/scoped-css.html#child-component-root-elements](https://vue-loader.vuejs.org/guide/scoped-css.html#child-component-root-elements).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Scoped CSS的更多信息，请访问[https://vue-loader.vuejs.org/guide/scoped-css.html#child-component-root-elements](https://vue-loader.vuejs.org/guide/scoped-css.html#child-component-root-elements)。
- en: You can find more information about Material Design cards at [https://material.io/components/cards/](https://material.io/components/cards/).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Material Design卡片的更多信息，请访问[https://material.io/components/cards/](https://material.io/components/cards/)。
- en: Check out the Roboto font family at [https://fonts.google.com/specimen/Roboto](https://fonts.google.com/specimen/Roboto).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[https://fonts.google.com/specimen/Roboto](https://fonts.google.com/specimen/Roboto)上的Roboto字体系列。
- en: Using slots and named slots to place data inside your components
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插槽和命名插槽将数据放入组件中
- en: Sometimes, the pieces of the puzzle go missing, and you find yourself with a
    blank spot. Imagine that you could fill that empty spot with a piece that you
    crafted yourself – not the original one that came with the puzzle box. That's
    a rough analogy for what a Vue slot is.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，拼图的一些部分会丢失，你会发现自己有一个空白的地方。想象一下，你可以用自己制作的一块填补那个空白的地方 - 而不是拼图盒子里原来的那块。这大致类似于Vue插槽的作用。
- en: Vue slots are like open spaces in your component that other components can fill
    with text, HTML elements, or other Vue components. You can declare where the slot
    will be and how it will behave in your component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Vue插槽就像是组件中的开放空间，其他组件可以用文本、HTML元素或其他Vue组件填充。你可以在组件中声明插槽的位置和行为方式。
- en: With this technique, you can create a component and, when needed, customize
    it without any effort at all.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种技术，你可以创建一个组件，并在需要时轻松自定义它。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The prerequisite for this recipe is Node.js 12+.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的先决条件是Node.js 12+。
- en: 'The Node.js global objects that are required for this recipe are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: To complete this recipe, we will use our Vue project and the Vue CLI, as we
    did in the *Creating a visual template component* recipe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，我们将使用我们的Vue项目和Vue CLI，就像在*创建可视化模板组件*食谱中所做的那样。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Follow these instructions to create slots and named slots in components:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明在组件中创建插槽和命名插槽：
- en: Open the `MaterialCardBox.vue` file in the `components` folder.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹中打开`MaterialCardBox.vue`文件。
- en: 'In the `<template>` part of the component, we will need to add four main sections
    to the card. These sections are based on the Material Design card''s anatomy and
    are the `header`, `media`, `main section`, and `action` areas. We will use the
    default slot for `main section`; the rest will all be named scopes. For some named
    slots, we will add a fallback configuration that will be displayed if the user doesn''t
    choose any setting for the slot:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<template>`部分，我们需要为卡片添加四个主要部分。这些部分基于Material Design卡片的结构，分别是`header`、`media`、`main
    section`和`action`区域。我们将使用默认插槽来放置`main section`；其余部分都将是命名插槽。对于一些命名插槽，我们将添加一个回退配置，如果用户没有为插槽选择任何设置，则将显示该配置：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we need to create our text CSS rules for the component. In the `style` folder,
    create a new file called `cardStyles.css`. Here, we will add the rules for the
    card''s text and headers:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为组件创建文本CSS规则。在`style`文件夹中，创建一个名为`cardStyles.css`的新文件。在这里，我们将添加卡片文本和标题的规则：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `<style>` part of the component, we need to create some CSS that will
    follow the rules of our design guide:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<style>`部分，我们需要创建一些遵循设计指南规则的CSS：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `App.vue` file, in the `src` folder, we need to add elements to these
    slots. These elements will be added to each one of the named slots, as well as the default
    slot. We will change the component inside the `<template>` part of the file. To
    add a named slot, we need to use a directive called `v-slot:` and then add the name of
    the slot we want to use:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中的`App.vue`文件中，我们需要向这些插槽添加元素。这些元素将被添加到每个命名插槽以及默认插槽。我们将更改文件的`<template>`部分内的组件。要添加命名插槽，我们需要使用一个名为`v-slot：`的指令，然后添加我们想要使用的插槽的名称：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For the default slot, we don't need to use a directive; it just needs to be
    wrapped inside the component so that it can placed inside the `<slot />` part
    of the component.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于默认插槽，我们不需要使用指令；它只需要包裹在组件内部，以便可以放置在组件的`<slot />`部分内。
- en: 'To run the server and see your component, you need to open a Terminal (macOS
    or Linux) or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行服务器并查看您的组件，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Remember to always execute the command `npm run lint --fix`, to automatically
    fix any code lint error.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住始终执行命令`npm run lint --fix`，以自动修复任何代码lint错误。
- en: 'Here is the component rendered and running:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染和运行的组件：
- en: '![](assets/8f8c0945-dabc-4cfe-bee4-1871cbfc651c.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8f8c0945-dabc-4cfe-bee4-1871cbfc651c.png)'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Slots are places where you can put anything that can be rendered into the DOM.
    We choose the position of our slot and tell the component where to render when
    it receives any information.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽是可以放置任何可以呈现到DOM中的东西的地方。我们选择插槽的位置，并告诉组件在接收到任何信息时在哪里呈现。
- en: In this recipe, we used named slots, which are designed to work with a component
    that requires more than one slot. To place any information inside that component
    within the Vue single file (`.vue`) `<template>` part, you need to add the `v-slot:` directive
    so that Vue knows where to place the information that was passed down.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了命名插槽，这些插槽旨在与需要多个插槽的组件一起使用。要在Vue单文件（`.vue`）的`<template>`部分中放置组件内的任何信息，您需要添加`v-slot：`指令，以便Vue知道在哪里放置传递下来的信息。
- en: See also
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about Vue slots at [https://v3.vuejs.org/guide/component-slots.html](https://v3.vuejs.org/guide/component-slots.html).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://v3.vuejs.org/guide/component-slots.html](https://v3.vuejs.org/guide/component-slots.html)找到有关Vue插槽的更多信息。
- en: You can find more information about the Material Design card's anatomy at [https://material.io/components/cards/#anatomy](https://material.io/components/cards/#anatomy).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://material.io/components/cards/#anatomy](https://material.io/components/cards/#anatomy)找到有关Material
    Design卡片解剖的更多信息。
- en: Passing data to your component and validating the data
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向组件传递数据并验证数据
- en: At this point, you know how to place data inside your component through slots,
    but those slots were made for HTML DOM elements or Vue components. Sometimes,
    you need to pass data such as strings, arrays, Booleans, or even objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您知道如何通过插槽将数据放入组件中，但这些插槽是为HTML DOM元素或Vue组件而设计的。有时，您需要传递诸如字符串、数组、布尔值甚至对象之类的数据。
- en: The whole application is like a puzzle, where each piece is a component. Communication
    between components is an important part of this. The possibility to pass data
    to a component is the first step when it comes to connecting the puzzle, while
    validating the data is the final step for connecting the pieces.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序就像一个拼图，其中每个部分都是一个组件。组件之间的通信是其中的重要部分。向组件传递数据是连接拼图的第一步，而验证数据是连接部件的最后一步。
- en: In this recipe, we will learn how to pass data to a component and validate the
    data that was passed to it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何向组件传递数据并验证传递给它的数据。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The prerequisite for this recipe is Node.js 12+.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的先决条件是 Node.js 12+。
- en: 'The Node.js global objects that are required for this recipe are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱所需的 Node.js 全局对象如下：
- en: '`@vue/cli`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: To complete this recipe, we will continue using the project from the *Using
    slots and named slots to place data inside your components* recipe.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，我们将继续使用来自 *使用插槽和命名插槽在组件内放置数据* 食谱的项目。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these instructions to pass data to the component and validate it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明传递数据给组件并验证它：
- en: Open the `MaterialCardBox.vue` file inside the `src/components` folder.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/components` 文件夹中的 `MaterialCardBox.vue` 文件。
- en: 'In the `<script>` part of the component, we will create a new property called `props`.
    This property receives the component''s data, which can be used for visual manipulation,
    variables inside your code, or for a function that needs to be executed. In this
    property, we need to declare the name of the attribute, its type, if it''s required,
    and the validation function. This function will be executed at runtime to validate
    whether the attribute that has been passed is a valid one:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的 `<script>` 部分，我们将创建一个名为 `props` 的新属性。这个属性接收组件的数据，可以用于视觉操作、代码内的变量，或者需要执行的函数。在这个属性中，我们需要声明属性的名称、类型、是否必需，以及验证函数。这个函数将在运行时执行，以验证传递的属性是否有效：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `computed` property, in the `<script>` part of the component, we need
    to create a set of visual manipulation rules that will be used to render the card.
    These rules are called `showMediaContent`, `showActionsButtons`, `showHeader`,
    and `cardElevation`. Each rule will check the received `props` and the `$slots` objects
    to check whether the relevant card part needs to be rendered:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的 `<script>` 部分的 `computed` 属性中，我们需要创建一组用于渲染卡片的视觉操作规则。这些规则被称为 `showMediaContent`、`showActionsButtons`、`showHeader`
    和 `cardElevation`。每个规则将检查接收到的 `props` 和 `$slots` 对象，以检查是否需要渲染相关的卡片部分：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After adding the visual manipulation rules, we need to add the created rules
    to the `<template>` part of our component. They will affect the appearance and
    behavior of our card. For example, if no header slot has been defined but a header
    property has been defined, we''ll show the fallback header. This header contains
    the data that was passed down via `props`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了视觉操作规则之后，我们需要将创建的规则添加到组件的 `<template>` 部分。它们将影响我们卡片的外观和行为。例如，如果没有定义头部插槽，但定义了头部属性，我们将显示备用头部。这个头部包含通过
    `props` 传递下来的数据：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To run the server and see your component, you need to open a Terminal (macOS
    or Linux) or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行服务器并查看你的组件，你需要打开终端（macOS 或 Linux）或命令提示符/PowerShell（Windows），并执行以下命令：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember to always execute the command `npm run lint --fix`, to automatically
    fix any code lint error.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 记得总是执行命令 `npm run lint --fix`，自动修复任何代码 lint 错误。
- en: 'Here is the component rendered and running:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染和运行的组件：
- en: '![](assets/c8fc07a8-43b1-4ce7-9448-e781a6647fb4.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c8fc07a8-43b1-4ce7-9448-e781a6647fb4.png)'
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each Vue component is a JavaScript object that has a render function. This render
    function is called when it is time to render it in the HTML DOM. A single-file
    component is an abstraction of this object.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Vue 组件都是一个 JavaScript 对象，有一个渲染函数。当需要在 HTML DOM 中渲染它时，会调用这个渲染函数。单文件组件是这个对象的一个抽象。
- en: When we are declaring that our component has unique props that can be passed,
    it opens a tiny door for other components or JavaScript to place information inside
    our component. We are then able to use those values inside our component to render
    data, do some calculations, or make visual rules.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明我们的组件具有可以传递的唯一props时，它为其他组件或JavaScript打开了一个小门，以在我们的组件内放置信息。然后，我们可以在组件内使用这些值来渲染数据，进行一些计算，或者制定视觉规则。
- en: In our case, using the single-file component, we are passing those rules as
    HTML attributes because `vue-template-compiler` will take those attributes and
    transform them into JavaScript objects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，使用单文件组件，我们将这些规则作为HTML属性传递，因为`vue-template-compiler`将获取这些属性并将其转换为JavaScript对象。
- en: When those values are passed to our component, Vue checks whether the passed
    attribute matches the correct type, and then we execute our validation function
    on top of each value to see whether it matches what we'd expect.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些值传递给我们的组件时，Vue会检查传递的属性是否与正确的类型匹配，然后我们对每个值执行验证函数，以查看它是否与我们期望的匹配。
- en: Once all of this is done, the component's life cycle continues, and we can render
    our component.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，组件的生命周期继续，我们可以渲染我们的组件。
- en: See also
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about `props` at [https://v3.vuejs.org/guide/component-props.html](https://v3.vuejs.org/guide/component-props.html).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://v3.vuejs.org/guide/component-props.html](https://v3.vuejs.org/guide/component-props.html)找到有关`props`的更多信息。
- en: You can find more information about `vue-template-compiler` at [https://vue-loader.vuejs.org/guide/](https://vue-loader.vuejs.org/guide/).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://vue-loader.vuejs.org/guide/](https://vue-loader.vuejs.org/guide)找到有关`vue-template-compiler`的更多信息。
- en: Creating functional components
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建功能组件
- en: The beauty of functional components is their simplicity. They are stateless
    components without any data, computed properties, or even life cycles. They are
    just render functions that are called when the data that has been passed changes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件的美丽之处在于它们的简单性。它们是无状态组件，没有任何数据、计算属性，甚至生命周期。它们只是在传递的数据发生变化时调用的渲染函数。
- en: You may be wondering how this can be useful. Well, a functional component is
    a perfect companion for UI components that don't need to keep any data inside
    them, or visual components that are just rendered components that don't require
    any data manipulation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道这有什么用。嗯，功能组件是UI组件的完美伴侣，它们不需要在内部保留任何数据，或者只是渲染组件而不需要任何数据操作的可视组件。
- en: As the name implies, they are similar to function components, and they have
    nothing more than the render function. They are a stripped-down version of a component
    that's used exclusively for performance rendering and visual elements.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，它们类似于函数组件，除了渲染函数外没有其他内容。它们是组件的精简版本，专门用于性能渲染和可视元素。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The prerequisite for this recipe is Node.js 12+.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的先决条件是Node.js 12+。
- en: 'The Node.js global objects that are required for this recipe are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: To complete this recipe, we will use our Vue project and the Vue CLI, as we
    did in the *Passing data to your component and validating the data*recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此配方，我们将使用我们的Vue项目和Vue CLI，就像在*将数据传递给您的组件并验证数据*配方中所做的那样。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these instructions to create a Vue functional component:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明创建一个Vue功能组件：
- en: Create a new file called `MaterialButton.vue` inside the `src/components` folder.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中创建一个名为`MaterialButton.vue`的新文件。
- en: 'In this component, we need to validate whether the prop we''ll receive is a
    valid color. To do this, install the `is-color` module inside the project. You''ll
    need to open a Terminal (macOS or Linux) or Command Prompt/PowerShell (Windows) and
    execute the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个组件中，我们需要验证我们将接收的prop是否是有效的颜色。为此，在项目中安装`is-color`模块。您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `<script>` part of our component, we need to create the `props` object
    that the functional component will receive. As a functional component is just
    a render function with no state, it''s stateless – the `<script>` part of the
    component is trimmed down to `props`, `injections`, and `slots`. There will be
    four `props` objects: `backgroundColor`, `textColor`, `isRound`, and `isFlat`.
    These won''t be required when we''re installing the component as we will have
    a default value defined in `props`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们组件的`<script>`部分，我们需要创建`props`对象，函数组件将接收该对象。由于函数组件只是一个没有状态的渲染函数，因此它是无状态的 -
    组件的`<script>`部分被简化为`props`，`injections`和`slots`。将有四个`props`对象：`backgroundColor`，`textColor`，`isRound`和`isFlat`。在安装组件时，这些将不是必需的，因为我们在`props`中定义了默认值：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We need to create a button HTML element with a basic `class` attribute button
    and a dynamic `class` attribute based on the `props` object that''s received.
    Compared to the normal component, we need to specify the `props` property in order
    to use the functional component. For the style of the button, we need to create
    a dynamic `style` attribute, also based on `$props`. To emit all the event listeners
    directly to the parent, we can call the `v-bind` directive and pass the `$attrs` property.
    This will bind all the event listeners without us needing to declare each one.
    Inside the button, we will add a `div` HTML element for visual enhancement and
    add `<slot>` where the text will be placed:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个带有基本`class`属性按钮的HTML元素，并且一个基于接收到的`props`对象的动态`class`属性。与普通组件相比，我们需要指定`props`属性以使用函数组件。对于按钮的样式，我们需要创建一个基于`$props`的动态`style`属性。为了直接将所有事件监听器传递给父级，我们可以调用`v-bind`指令并传递`$attrs`属性。这将绑定所有事件监听器，而无需我们声明每一个。在按钮内部，我们将添加一个用于视觉增强的`div`HTML元素，并添加`<slot>`，文本将放置在其中：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s make it pretty. In the `<style>` part of the component, we need
    to create all the CSS rules for this button. We need to add the `scoped` attribute
    to `<style>` so that the CSS rules won''t affect any other elements in our application:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们把它弄得漂亮一点。在组件的`<style>`部分，我们需要为这个按钮创建所有的CSS规则。我们需要在`<style>`中添加`scoped`属性，以便CSS规则不会影响我们应用程序中的任何其他元素：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `App.vue` file, we need to import our component to be able to see it:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.vue`文件中，我们需要导入我们的组件才能看到它：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To run the server and see your component, you need to open a Terminal (macOS
    or Linux) or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行服务器并查看您的组件，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember to always execute the command `npm run lint --fix`, to automatically
    fix any code lint error.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 记得总是执行命令`npm run lint --fix`，以自动修复任何代码lint错误。
- en: 'Here is the component rendered and running:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染和运行的组件：
- en: '![](assets/8c3b16c4-2334-48eb-855a-dbbf1b9a534a.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8c3b16c4-2334-48eb-855a-dbbf1b9a534a.png)'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Functional components are as simple as render functions. They don't have any
    sort of data, functions, or access to the outside world.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件就像渲染函数一样简单。它们没有任何类型的数据、函数或对外部世界的访问。
- en: They were first introduced in Vue as a JavaScript object `render()` function
    only; later, they were added to `vue-template-compiler` for the Vue single-file
    application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它们最初是作为JavaScript对象`render()`函数在Vue中引入的；后来，它们被添加到`vue-template-compiler`中，用于Vue单文件应用程序。
- en: A functional component works by receiving two arguments: `createElement` and `context`.
    As we saw in the single file, we only had access to the elements as they weren't
    in the `this` property of the JavaScript object. This occurs because as the context
    is passed to the render function, there is no `this` property.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性组件通过接收两个参数`createElement`和`context`来工作。正如我们在单文件中看到的，我们只能访问元素，因为它们不在JavaScript对象的`this`属性中。这是因为当上下文传递给渲染函数时，没有`this`属性。
- en: A functional component provides the fastest rendering possible on Vue as it
    doesn't depend on the life cycle of a component to check for the rendering; it
    just renders each time data is changed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性组件在Vue上提供了最快的渲染速度，因为它不依赖于组件的生命周期来检查渲染；它只在数据改变时渲染。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about the `is-color` module at [https://www.npmjs.com/package/is-color](https://www.npmjs.com/package/is-color).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://www.npmjs.com/package/is-color](https://www.npmjs.com/package/is-color)找到有关`is-color`模块的更多信息。
- en: Accessing your children component's data
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问您的子组件的数据
- en: Normally, parent-child communications are done via events or props. But sometimes,
    you need to access data, functions, or computed properties that exist in the child
    or the parent function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，父子通信是通过事件或props来完成的。但有时，您需要访问存在于子函数或父函数中的数据、函数或计算属性。
- en: Vue provides a way for us to interact in both ways, thereby opening doors to
    communications and events such as props and event listeners.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Vue为我们提供了双向交互的方式，从而打开了使用props和事件监听器等通信和事件的大门。
- en: There is another way to access the data between the components: by using direct
    access. This can be done with the help of a special attribute in the template
    when using the single-file component, or by making a direct call to the object
    inside the JavaScript. This method is seen by some as a little lazy, but there
    are times when there really is no other way to do it than this.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种访问组件之间数据的方法：直接访问。这可以通过在单文件组件中使用模板中的特殊属性来完成，或者通过直接调用JavaScript中的对象来完成。有些人认为这种方法有点懒惰，但有时确实没有其他方法可以做到这一点。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The prerequisite for this recipe is Node.js 12+.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的先决条件是Node.js 12+。
- en: 'The Node.js global objects that are required for this recipe are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: To complete this recipe, we will use our Vue project and the Vue CLI, as we
    did in the *Creating functional components* recipe.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，我们将使用我们的Vue项目和Vue CLI，就像在*创建功能性组件*的食谱中一样。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We're going to separate this recipe into four parts. The first three parts will
    cover the creation of new components –  `StarRatingInput`, `StarRatingDisplay`,
    and `StarRating` – whilethe last part will cover the direct parent-child manipulation
    of the data and function's access.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个食谱分成四个部分。前三部分将涵盖新组件的创建-`StarRatingInput`、`StarRatingDisplay`和`StarRating`，而最后一部分将涵盖数据和函数访问的直接父子操作。
- en: Creating the star rating input
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建星级评分输入
- en: In this recipe, we are going to create a star rating input, based on a five-star
    ranking system.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个基于五星评级系统的星级评分输入。
- en: 'Follow these steps to create a custom star rating input:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建自定义星级评分输入：
- en: Create a new file called `StarRatingInput.vue` in the `src/components` folder.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中创建一个名为`StarRatingInput.vue`的新文件。
- en: 'In the `<script>` part of the component, create a `maxRating` property in the `props` property that
    is a number, non-required, and has a default value of `5`. In the `data` property,
    we need to create our `rating` property, with a default value of `0`. In the `methods` property,
    we need to create three methods: `updateRating`, `emitFinalVoting`, and `getStarName`.
    The `updateRating` method will save the rating to the data, `emitFinalVoting` will
    call `updateRating` and emit the rating to the parent component through a `final-vote` event,
    and `getStarName` will receive a value and return the icon name of the star:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的 `<script>` 部分中，在 `props` 属性中创建一个 `maxRating` 属性，它是一个数字，非必需，并具有默认值 `5`。在
    `data` 属性中，我们需要创建我们的 `rating` 属性，其默认值为 `0`。在 `methods` 属性中，我们需要创建三种方法：`updateRating`、`emitFinalVoting`
    和 `getStarName`。`updateRating` 方法将评分保存到数据中，`emitFinalVoting` 将调用 `updateRating`
    并通过 `final-vote` 事件将评分传递给父组件，`getStarName` 将接收一个值并返回星星的图标名称：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `<template>` part of the component, we need to create a `<slot>` component
    so that we can place the text before the star rating. We''ll create a dynamic
    list of stars based on the `maxRating` value that we received via the `props` property.
    Each star that is created will have a listener attached to it in the `mouseenter`, `focus`,
    and `click` events. `mouseenter` and `focus`, when fired, will call the `updateRating` method,
    and `click` will call `emitFinalVote`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的 `<template>` 部分中，我们需要创建一个 `<slot>` 组件，以便我们可以在星级评分之前放置文本。我们将根据通过 `props`
    属性接收到的 `maxRating` 值创建一个动态星星列表。创建的每个星星都将在 `mouseenter`、`focus` 和 `click` 事件中附加一个监听器。当触发
    `mouseenter` 和 `focus` 时，将调用 `updateRating` 方法，而 `click` 将调用 `emitFinalVote`：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need to import the Material Design icons into our application. Create a
    new styling file in the `styles` folder called `materialIcons.css` and add the
    CSS rules for `font-family`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将 Material Design 图标导入到我们的应用程序中。在 `styles` 文件夹中创建一个名为 `materialIcons.css`
    的新样式文件，并添加 `font-family` 的 CSS 规则：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Open the `main.js` file and import the created stylesheet into it. The `css-loader` webpack will
    process the imported `.css` files in JavaScript files. This will help with development
    because you don''t need to reimport the file elsewhere:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `main.js` 文件并将创建的样式表导入其中。`css-loader` webpack 将处理 JavaScript 文件中导入的 `.css`
    文件。这将有助于开发，因为您无需在其他地方重新导入文件：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To style our component, we will create a common styling file in the `src/style` folder
    called `starRating.css`. There, we will add the common styles that will be shared
    between the `StarRatingDisplay` and `StarRatingInput` components:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给我们的组件设置样式，我们将在 `src/style` 文件夹中创建一个名为 `starRating.css` 的通用样式文件。在那里，我们将添加在
    `StarRatingDisplay` 和 `StarRatingInput` 组件之间共享的通用样式：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `<style>` part of the component, we need to create all the CSS rules.
    Then, inside the `StarRatingInput.vue` component file located in the `src/components` folder, we
    need to add the `scoped` attribute to `<style>` so that none of the CSS rules
    affect any of the other elements in our application. Here, we will import the
    common styles that we created and add new ones for the input:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的 `<style>` 部分中，我们需要创建所有的 CSS 规则。然后，在位于 `src/components` 文件夹中的 `StarRatingInput.vue`
    组件文件中，我们需要向 `<style>` 添加 `scoped` 属性，以便不影响应用程序中的任何其他元素的 CSS 规则。在这里，我们将导入我们创建的通用样式并添加新的输入样式：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To run the server and see your component, you will need to open a Terminal (macOS
    or Linux) or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行服务器并查看您的组件，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Remember to always execute the command `npm run lint --fix`, to automatically
    fix any code lint error.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 记住始终执行命令 `npm run lint --fix`，以自动修复任何代码 lint 错误。
- en: 'Here is the component rendered and running:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染和运行的组件：
- en: '![](assets/70f63b67-42a3-4f42-bb6c-5372703ab62d.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/70f63b67-42a3-4f42-bb6c-5372703ab62d.png)'
- en: Creating the StarRatingDisplay component
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建StarRatingDisplay组件
- en: 'Now that we have our input, we need a way to display the selected choice to
    the user. Follow these steps to create a `StarRatingDisplay` component:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了输入，我们需要一种方法来向用户显示所选的选择。按照以下步骤创建`StarRatingDisplay`组件：
- en: Create a new component called `StarRatingDisplay.vue` in the `src/components` folder.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中创建一个名为`StarRatingDisplay.vue`的新组件。
- en: 'In the `<script>` part of the component, in the `props` property, we need to
    create three new properties: `maxRating`, `rating`, and `votes`. All three of
    them will be numbers, non-required and have a default value. In the `methods` property,
    we need to create a new method called `getStarName`, which will receive a value
    and return the icon name of the star:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，在`props`属性中，我们需要创建三个新属性：`maxRating`，`rating`和`votes`。它们三个都将是数字，非必需的，并具有默认值。在`methods`属性中，我们需要创建一个名为`getStarName`的新方法，该方法将接收一个值并返回星星的图标名称：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In `<template>`, we need to create a dynamic list of stars based on the `maxRating` value
    that we received via the `props`property. After the list, we need to display that
    we received votes, and if we receive any more votes, we will display them too:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<template>`中，我们需要根据通过`props`属性接收到的`maxRating`值创建一个动态星星列表。在列表之后，我们需要显示我们收到的投票，如果我们收到更多的投票，我们也会显示它们：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `<style>` part of the component, we need to create all the CSS rules.
    We need to add the `scoped` attribute to `<style>`so that none of the CSS rules
    affect any of the other elements in our application. Here, we will import the
    common styles that we created and add new ones for the display:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<style>`部分，我们需要创建所有的CSS规则。我们需要向`<style>`添加`scoped`属性，以便没有任何CSS规则影响我们应用程序中的任何其他元素。在这里，我们将导入我们创建的通用样式，并添加新的样式以供显示：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To run the server and see your component, you need to open a Terminal (macOS
    or Linux) or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行服务器并查看您的组件，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Remember to always execute the command `npm run lint --fix`, to automatically
    fix any code lint error.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住始终执行命令`npm run lint --fix`，以自动修复任何代码lint错误。
- en: 'Here is the component rendered and running:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染和运行的组件：
- en: '![](assets/96ac3614-2ef5-41ae-8b26-2dc7f6d30f61.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/96ac3614-2ef5-41ae-8b26-2dc7f6d30f61.png)'
- en: Creating the StarRating component
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建StarRating组件
- en: Now that we've created the input and the display, we need to join them together
    inside a single component. This component will be the final component that we'll
    use in the application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了输入和显示，我们需要将它们合并到一个单独的组件中。这个组件将是我们在应用程序中使用的最终组件。
- en: 'Follow these steps to create the final `StarRating` component:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建最终的`StarRating`组件：
- en: Create a new file called `StarRating.vue` in the `src/components` folder.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`文件夹中创建一个名为`StarRating.vue`的新文件。
- en: 'In the `<script>` part of the component, we need to import the `StarRatingDisplay` and `StarRatingInput` components.
    In the `props` property, we need to create three new properties: `maxRating`, `rating`, and `votes`.
    All three of them will be numbers, non-required, and have a default value. In
    the `data` property, we need to create our `rating` property, with a default value
    of `0`, and a property called `voted`, with a default value of `false`. In the `methods` property,
    we need to add a new method called `vote`, which will receive `rank` as an argument.
    It will define `rating` as the received value and define the inside variable of
    the `voted` component as `true`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们需要导入`StarRatingDisplay`和`StarRatingInput`组件。在`props`属性中，我们需要创建三个新属性：`maxRating`，`rating`和`votes`。所有这三个属性都将是数字，非必需的，并具有默认值。在`data`属性中，我们需要创建我们的`rating`属性，其默认值为`0`，以及一个名为`voted`的属性，其默认值为`false`。在`methods`属性中，我们需要添加一个名为`vote`的新方法，它将接收`rank`作为参数。它将把`rating`定义为接收到的值，并将`voted`组件的内部变量定义为`true`：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For the `<template>` part, we will place both components here, thereby displaying
    the input of the rating:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`<template>`部分，我们将在这里放置两个组件，从而显示评分的输入：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Data manipulation on child components
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子组件中的数据操作
- en: Now that all of our components are ready, we need to add them to our application.
    The base application will access the child component, and it will set the rating
    to 5 stars.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的组件都准备好了，我们需要将它们添加到我们的应用程序中。基础应用程序将访问子组件，并将评分设置为5星。
- en: 'Follow these steps to understand and manipulate the data in the child components:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来理解和操作子组件中的数据：
- en: In the `App.vue` file, in the `<template>` part of the component, remove the `main-text` attribute
    of the `MaterialCardBox` component and set it as the default slot of the component.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.vue`文件中，在组件的`<template>`部分，删除`MaterialCardBox`组件的`main-text`属性，并将其设置为组件的默认插槽。
- en: 'Before the placed text, we will add the `StarRating` component. We will add
    a `ref` attribute to it. This attribute will tell Vue to link this component directly
    to a special property in the `this` object of the component. In the action buttons,
    we will add the listeners for the click event – one for `resetVote` and another
    for `forceVote`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在放置的文本之前，我们将添加`StarRating`组件。我们将为其添加一个`ref`属性。这个属性将告诉Vue将这个组件直接链接到组件的`this`对象中的一个特殊属性。在操作按钮中，我们将为点击事件添加监听器
    - 一个用于`resetVote`，另一个用于`forceVote`：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `<script>` part of the component, we will create a `methods` property
    and add two new methods: `resetVote` and `forceVote`. These methods will access
    the `StarRating` component and reset the data or set the data to a 5-star vote,
    respectively:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们将创建一个`methods`属性，并添加两个新方法：`resetVote`和`forceVote`。这些方法将访问`StarRating`组件并重置数据或将数据设置为5星评分：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the `ref` property is added to the component, Vue adds a link to the referenced
    element to the `$refs` property inside the `this` property object of JavaScript.
    From there, you have full access to the component.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ref`属性添加到组件时，Vue会将对被引用元素的链接添加到JavaScript的`this`属性对象内的`$refs`属性中。从那里，您可以完全访问组件。
- en: This method is commonly used to manipulate HTML DOM elements without the need
    to call for document query selector functions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常用于操作HTML DOM元素，而无需调用文档查询选择器函数。
- en: However, the main function of this property is to give access to the Vue component
    directly, enabling you to execute functions and see the computed properties, variables,
    and changed variables of the component – this is like having full access to the
    component from the outside.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该属性的主要功能是直接访问Vue组件，使您能够执行函数并查看组件的计算属性、变量和已更改的变量 - 这就像从外部完全访问组件一样。
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the same way that a parent can access a child component, a child can access
    a parent component by calling `$parent` on the `this` object. An event can access
    the root element of the Vue application by calling the `$root` property.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与父组件可以访问子组件的方式相同，子组件可以通过在`this`对象上调用`$parent`来访问父组件。事件可以通过调用`$root`属性来访问Vue应用程序的根元素。
- en: See also
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find out more information about parent-child communication at [https://v3.vuejs.org/guide/migration/custom-directives.html#edge-case-accessing-the-component-instance](https://v3.vuejs.org/guide/migration/custom-directives.html#edge-case-accessing-the-component-instance).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://v3.vuejs.org/guide/migration/custom-directives.html#edge-case-accessing-the-component-instance](https://v3.vuejs.org/guide/migration/custom-directives.html#edge-case-accessing-the-component-instance)找到有关父子通信的更多信息。
- en: Creating a dynamically injected component
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个动态注入的组件
- en: There are some cases where your component can be defined by the kind of variable
    you are receiving or the type of data that you have; then, you need to change
    the component on the fly, without the need to set a lot of Vue `v-if`, `v-else-if`,
    and `v-else` directives.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，您的组件可以根据您收到的变量的类型或您拥有的数据类型来定义；然后，您需要在不需要设置大量Vue `v-if`、`v-else-if`和`v-else`指令的情况下即时更改组件。
- en: In those cases, the best thing to do is use dynamic components, when a computed
    property or a function can define the component that will be used to be rendered,
    and the decision is made in real time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，最好的做法是使用动态组件，当计算属性或函数可以定义要呈现的组件时，并且决定是实时进行的。
- en: These decisions can sometimes be simple to make if there are two responses,
    but they can be more complex if there's a long switch case, where you may have
    a long list of possible components that need to be used.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两种响应，这些决定有时可能很容易做出，但如果有一个长的开关情况，那么它们可能会更复杂，其中您可能有一个需要使用的长列表可能组件。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The prerequisite for this recipe is Node.js 12+.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的先决条件是Node.js 12+。
- en: 'The Node.js global objects that are required for this recipe are as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: To complete this recipe, we will use our Vue project and the Vue CLI, as we
    did in the *Accessing* *your children components data* recipe.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，我们将使用我们的Vue项目和Vue CLI，就像我们在*访问你的子组件数据*配方中所做的那样。
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a dynamically injected component:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个动态注入的组件：
- en: Open the `StarRating.vue` component.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRating.vue`组件。
- en: 'In the `<script>` part of the component, we need to create a `computed` property
    with a new computed value called `starComponent`. This value will check whether
    the user has voted. If they haven''t, it will return the `StarRatingInput` component;
    otherwise, it will return the `StarRatingDisplay` component:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们需要创建一个带有名为`starComponent`的新计算值的`computed`属性。此值将检查用户是否已投票。如果他们没有，它将返回`StarRatingInput`组件；否则，它将返回`StarRatingDisplay`组件：
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `<template>` part of the component, we will remove both of the existing
    components and replace them with a special component called `<component>`. This
    special component has a named attribute that you can point to anywhere that returns
    a valid Vue component. In our case, we will point to the computed `starComponent` property.
    We will take all the bind props that were defined by both of the other components
    and put them inside this new component, including the text that has been placed
    inside `<slot>`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<template>`部分，我们将删除现有组件，并用一个名为`<component>`的特殊组件替换它们。这个特殊组件有一个命名属性，您可以指向任何返回有效的Vue组件的地方。在我们的例子中，我们将指向计算属性`starComponent`。我们将把由这两个其他组件定义的所有绑定属性放在这个新组件中，包括放在`<slot>`中的文本：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the Vue special `<component>` component, we declared what the component should
    render according to the rules that were set on the computed property.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue特殊的`<component>`组件，我们声明了根据计算属性设置的规则应该渲染什么组件。
- en: Being a generic component, you always need to guarantee that everything will
    be there for each of the components that can be rendered. The best way to do this
    is by using the `v-bind` directive with the props and rules that need to be defined,
    but it's possible to define it directly on the component as well since it will
    be passed down as a prop.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个通用组件，您总是需要保证每个可以渲染的组件都会有一切。这样做的最佳方式是使用`v-bind`指令与需要定义的props和规则，但也可以直接在组件上定义，因为它将作为一个prop传递下来。
- en: See also
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about dynamic components at [https://v3.vuejs.org/guide/component-dynamic-async.html#dynamic-async-components](https://v3.vuejs.org/guide/component-dynamic-async.html#dynamic-async-components).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://v3.vuejs.org/guide/component-dynamic-async.html#dynamic-async-components](https://v3.vuejs.org/guide/component-dynamic-async.html#dynamic-async-components)找到有关动态组件的更多信息。
- en: Creating a dependency injection component
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个依赖注入组件
- en: Accessing data directly from a child or a parent component without knowing whether
    they exist can be very dangerous.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从子组件或父组件访问数据而不知道它们是否存在可能非常危险。
- en: In Vue, it's possible to make your component behavior like an interface and
    have a common and abstract function that won't change in the development process.
    The process of dependency injection is a common paradigm in the developing world
    and has been implemented in Vue as well.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue中，可以使您的组件行为像一个接口，并且具有一个在开发过程中不会改变的常见和抽象函数。依赖注入的过程是开发世界中的一个常见范例，并且在Vue中也已经实现。
- en: There are some pros and cons to using Vue's internal dependency injection, but
    it is always a good way to make sure that your children components know what to
    expect from the parent component when you're developing it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue的内部依赖注入有一些优缺点，但这总是一种确保您的子组件在开发时知道从父组件可以期望什么的好方法。
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The prerequisite for this recipe is Node.js 12+.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的先决条件是Node.js 12+。
- en: 'The Node.js global objects that are required for this recipe are as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: To complete this recipe, we will use our Vue project and the Vue CLI, as we
    did in the *Creating a dynamically injected component* recipe.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，我们将使用我们的Vue项目和Vue CLI，就像在*创建一个动态注入组件*配方中所做的那样。
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow these steps to create a dependency injection component:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个依赖注入组件：
- en: Open the `StarRating.vue` component.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRating.vue`组件。
- en: 'In the `<script>` part of the component, add a new property called `provide`.
    In our case, we will just be adding a key-value to check whether the component
    is a child of the specific component. Create an object in the property with the `starRating` key and
    the `true` value:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，添加一个名为`provide`的新属性。在我们的情况下，我们将只是添加一个键值来检查组件是否是特定组件的子组件。在属性中创建一个包含`starRating`键和`true`值的对象：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Open the `StarRatingDisplay.vue` file.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRatingDisplay.vue`文件。
- en: In the `<script>` part of the component, we will add a new property called `inject`.
    This property will receive an object with a key named `starRating`, and the value
    will be an object that will have a `default()` function.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们将添加一个名为`inject`的新属性。这个属性将接收一个名为`starRating`的键的对象，值将是一个包含`default()`函数的对象。
- en: 'This function will log an error if this component is not a child of the `StarRating` component:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个组件不是`StarRating`组件的子组件，这个函数将记录一个错误：
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Open the `StarRatingInput.vue` file.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRatingInput.vue`文件。
- en: 'In the `<script>` part of the component, we will add a new property called `inject`.
    This property will receive an object with a key named `starRating`, and the value
    will be an object that will have a `default()` function. This function will log
    an error if this component is not a child of the `StarRating` component:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，我们将添加一个名为`inject`的新属性。这个属性将接收一个名为`starRating`的键的对象，值将是一个包含`default()`函数的对象。如果这个组件不是`StarRating`组件的子组件，这个函数将记录一个错误：
- en: '[PRE43]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At runtime, Vue will check for the injected property of `starRating` in the `StarRatingDisplay` and `StarRatingInput` components,
    and if the parent component does not provide this value, it will log an error
    to the console.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，Vue将检查`StarRatingDisplay`和`StarRatingInput`组件中的`starRating`的注入属性，如果父组件没有提供这个值，它将在控制台中记录一个错误。
- en: Using component injection is commonly used to provide and maintain a common
    interface between bounded components, such as a menu and an item. An item may
    need some function or data that is stored in the menu, or we may need to check
    whether it's a child of the menu.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件注入通常用于提供和维护绑定组件之间的公共接口，比如菜单和项目。项目可能需要一些存储在菜单中的函数或数据，或者我们可能需要检查它是否是菜单的子组件。
- en: The main downside of dependency injection is that there is no more reactivity
    on the shared element. Because of this, it's mostly used to share functions or
    check component links.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的主要缺点是共享元素上不再具有响应性。因此，它主要用于共享函数或检查组件链接。
- en: See also
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about component dependency injection at [https://v3.vuejs.org/guide/component-provide-inject.html#provide-inject](https://v3.vuejs.org/guide/component-provide-inject.html#provide-inject).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://v3.vuejs.org/guide/component-provide-inject.html#provide-inject](https://v3.vuejs.org/guide/component-provide-inject.html#provide-inject)找到有关组件依赖注入的更多信息。
- en: Creating a component mixin
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个组件mixin
- en: There are times when you will find yourself rewriting the same code over and
    over. However, there is a way to prevent this and make yourself far more productive.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会发现自己一遍又一遍地重写相同的代码。然而，有一种方法可以防止这种情况，并让自己更加高效。
- en: For this, you can use what is called a `mixin`, a special code import in Vue
    that joins code parts from outside your component to your current component.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您可以使用所谓的“mixin”，这是Vue中的一个特殊代码导入，它将外部代码部分连接到当前组件。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The prerequisite for this recipe is Node.js 12+.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的先决条件是Node.js 12+。
- en: 'The Node.js global objects that are required for his recipe are as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: To complete this recipe, we will use our Vue project and the Vue CLI, as we
    did in the *Creating a dependency injection component* recipe.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个示例，我们将使用我们的Vue项目和Vue CLI，就像我们在*创建一个依赖注入组件*示例中所做的那样。
- en: How to do it...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a component mixin:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个组件混合：
- en: Open the `StarRating.vue` component.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRating.vue`组件。
- en: 'In the `<script>` part, we need to extract the `props` property into a new
    file called `starRatingDisplay.js` that we need to create in the `mixins` folder.
    This new file will be our first `mixin`, and will look like this:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<script>`部分，我们需要将`props`属性提取到一个名为`starRatingDisplay.js`的新文件中，我们需要在`mixins`文件夹中创建这个新文件。这个新文件将是我们的第一个`mixin`，看起来会像这样：
- en: '[PRE44]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Back in the `StarRating.vue` component, we need to import this newly created
    file and add it to a new property called `mixin`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`StarRating.vue`组件，我们需要导入这个新创建的文件，并将其添加到一个名为`mixin`的新属性中。
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, we will open the `StarRatingDisplay.vue` file.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将打开`StarRatingDisplay.vue`文件。
- en: 'In the `<script>` part, we will extract the `inject` property into a new file
    called `starRatingChild.js`, which will be created in the `mixins` folder. This
    will be our `mixin` for the `inject` property:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<script>`部分，我们将`inject`属性提取到一个名为`starRatingChild.js`的新文件中，该文件将被创建在`mixins`文件夹中。这将是我们的`inject`属性的`mixin`：
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Back in the `StarRatingDisplay.vue` file, in the `<script>` part, we will extract
    the `methods` property into a new file called `starRatingName.js`, which will
    be created in the `mixins` folder. This will be our `mixin` for the `getStarName` method:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`StarRatingDisplay.vue`文件，在`<script>`部分，我们将`methods`属性提取到一个名为`starRatingName.js`的新文件中，该文件将被创建在`mixins`文件夹中。这将是我们的`getStarName`方法的`mixin`：
- en: '[PRE47]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Back in the `StarRatingDisplay.vue` file, we need to import those newly created
    files and add them to a new property called `mixin`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`StarRatingDisplay.vue`文件，我们需要导入这些新创建的文件，并将它们添加到一个名为`mixin`的新属性中：
- en: '[PRE48]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Open the `StarRatingInput.vue` file.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StarRatingInput.vue`文件。
- en: 'In the `<script>` part, remove the `inject` properties and extract the `props`property
    into a new file called `starRatingBase.js`, which will be created in the `mixins` folder.
    This will be our `mixin` for the `props` property:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<script>`部分，删除`inject`属性并将`props`属性提取到一个名为`starRatingBase.js`的新文件中，该文件将被创建在`mixins`文件夹中。这将是我们的`props`属性的`mixin`：
- en: '[PRE49]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Back in the `StarRatingInput.vue` file, we need to rename the `rating` data property to `rank`,
    and in the `getStarName` method, we need to add a new constant that will receive
    either the `rating` props or the `rank` data. Finally, we need to import `starRatingChildMixin` and `starRatingBaseMixin`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`StarRatingInput.vue`文件，我们需要将`rating`数据属性重命名为`rank`，并且在`getStarName`方法中，我们需要添加一个新的常量，它将接收`rating`属性或`rank`数据。最后，我们需要导入`starRatingChildMixin`和`starRatingBaseMixin`：
- en: '[PRE50]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Mixins merge objects together, but make sure you don't replace an already existing
    property in your component with an imported one.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 混合将对象合并在一起，但请确保不要用导入的对象替换组件中已经存在的属性。
- en: The order of the `mixins` properties is important as well, as they will be checked
    and imported as a `for` loop, so the last `mixin` won't change any properties
    from any of their ancestors.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`mixins`属性的顺序也很重要，因为它们将被作为`for`循环进行检查和导入，因此最后一个`mixin`不会改变任何祖先的属性。'
- en: Here, we took a lot of repeated parts of our code and split them into four different
    small JavaScript files that are easier to maintain and improve productivity without
    us needing to rewrite code.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将代码中的许多重复部分拆分成了四个不同的小的JavaScript文件，这样更容易维护并提高了生产力，而无需重写代码。
- en: See also
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about mixins at [https://v3.vuejs.org/guide/mixins.html#mixins](https://v3.vuejs.org/guide/mixins.html#mixins).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://v3.vuejs.org/guide/mixins.html#mixins](https://v3.vuejs.org/guide/mixins.html#mixins)找到有关混合的更多信息。
- en: Lazy loading your components
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟加载您的组件
- en: '`webpack` and Vue were born to be together. When using `webpack` as the bundler
    for your Vue project, it''s possible to make your components load asynchronously
    or when they are needed. This is commonly known as lazy loading.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack`和Vue天生就是一对。当将`webpack`作为Vue项目的打包工具时，可以使组件在需要时异步加载。这通常被称为延迟加载。'
- en: Getting ready
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The prerequisite for this recipe is Node.js 12+.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此教程的先决条件是Node.js 12+。
- en: 'The Node.js global objects that are required for this recipe are as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此教程所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: To complete this recipe, we will use our Vue project and the Vue CLI, as we
    did in the *Creating a component mixin* recipe.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此教程，我们将使用我们的Vue项目和Vue CLI，就像在*创建组件混合*教程中所做的那样。
- en: How to do it...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to import your component with a lazy loading technique:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用延迟加载技术导入您的组件：
- en: Open the `App.vue` file.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.vue`文件。
- en: 'In the `<script>` part of the component, import the `defineAsyncComponent`
    API from Vue and pass the `lazyLoad` component function as an argument of the
    `defineAsyncComponent` function:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的`<script>`部分，从Vue中导入`defineAsyncComponent` API，并将`lazyLoad`组件函数作为`defineAsyncComponent`函数的参数传递：
- en: '[PRE51]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Vue now uses a new API called `defineAsyncComponent` to identify a component
    as an asynchronous component and receives as an argument, another function that
    returns the `import()` method.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Vue现在使用一个名为`defineAsyncComponent`的新API来将组件标识为异步组件，并将另一个返回`import()`方法的函数作为参数传递。
- en: When we declare a function that returns an `import()` function for each component, `webpack` knows
    that this import function will be code-splitting, and it will make the component a
    new file on the bundle.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为每个组件声明一个返回`import()`函数的函数时，`webpack`知道这个导入函数将进行代码拆分，并将使组件成为捆绑包中的一个新文件。
- en: See also
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about async components at [https://v3.vuejs.org/guide/component-dynamic-async.html#dynamic-async-components](https://v3.vuejs.org/guide/component-dynamic-async.html#dynamic-async-components).
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://v3.vuejs.org/guide/component-dynamic-async.html#dynamic-async-components](https://v3.vuejs.org/guide/component-dynamic-async.html#dynamic-async-components)找到有关异步组件的更多信息。
- en: You can find more information about the TC39 dynamic import at [https://github.com/tc39/proposal-dynamic-import](https://github.com/tc39/proposal-dynamic-import).
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/tc39/proposal-dynamic-import](https://github.com/tc39/proposal-dynamic-import)找到有关TC39动态导入的更多信息。
