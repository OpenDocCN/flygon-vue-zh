- en: Creating a Framework-Agnostic PHP API for Nuxt
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 为Nuxt创建一个与框架无关的PHP API
- en: In previous chapters, such as [Chapter 8](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml),
    *Adding a Server-Side Framework*, and [Chapter 9](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml),
    *Adding a Server-Side Database*, you learned how to create APIs using Nuxt's default
    server with Node.js JavaScript frameworks such as Koa and Express. In [Chapter
    12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml), *Creating User Logins and API
    Authentication*, you learned how to create APIs using an external server with
    the same Node.js JavaScript framework – Koa.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，比如第8章《添加服务器端框架》和第9章《添加服务器端数据库》，你学习了如何使用Nuxt的默认服务器与Node.js JavaScript框架（如Koa和Express）创建API。在第12章《创建用户登录和API身份验证》中，你学习了如何使用相同的Node.js
    JavaScript框架Koa在外部服务器上创建API。
- en: 'In this chapter, we will guide you through how to create APIs using an external
    server with **PHP: Hypertext Preprocessor** (or simply PHP) instead. In [Chapter
    9](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml), *Adding a Server-Side Database*, you
    also learned how to use MongoDB to manage the database. However, in this chapter,
    we will use MySQL instead, which you used with Koa in [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml),
    *Creating User Logins and API Authentication*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将指导你如何使用PHP（超文本预处理器）在外部服务器上创建API。在第9章《添加服务器端数据库》中，你还学习了如何使用MongoDB来管理数据库。然而，在这一章中，我们将使用MySQL，而你在第12章《创建用户登录和API身份验证》中使用了Koa。
- en: Most importantly, in this chapter, you will learn all about PHP standards and
    the **PHP Standards Recommendations** (**PSRs**). In particular, you will learn
    about PSR-4 for autoloading, PSR-7 for HTTP messages, and PSR-15 for composing
    middleware components and handling HTTP server requests. We will put together
    the packages that are based on these PSR standards from different vendors such
    as Zend Framework and The PHP League to make a **framework-agnostic** PHP RESTful
    API for our Nuxt app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，最重要的是，你将学习关于PHP标准和PHP标准建议（PSRs）的所有知识。特别是，你将学习关于PSR-4用于自动加载，PSR-7用于HTTP消息，以及PSR-15用于组合中间件组件和处理HTTP服务器请求。我们将整合来自不同供应商（如Zend
    Framework和The PHP League）基于这些PSR标准的包，为我们的Nuxt应用创建一个与框架无关的PHP RESTful API。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Introducing PHP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍PHP
- en: Understanding HTTP messages and PHP standards
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解HTTP消息和PHP标准
- en: Writing CRUD operations with PHP database frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PHP数据库框架编写CRUD操作
- en: Integrating with Nuxt
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Nuxt集成
- en: Let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Introducing PHP
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍PHP
- en: PHP has come a long way. It existed long before Node.js and was created by Rasmus
    Lerdorf in 1994\. It stood for **Personal Home Page** originally. The PHP reference
    implementation is now produced by The PHP Group ([https://www.php.net/](https://www.php.net/)).
    PHP was originally developed as a templating language that allowed us to mix HTML
    with PHP code itself, just like Twig ([https://twig.symfony.com/](https://twig.symfony.com/))
    and Pug ([https://pugjs.org/](https://pugjs.org/)) do these days.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: PHP已经走过了很长的路。它早在Node.js之前就存在了，由Rasmus Lerdorf于1994年创建。最初它代表的是“个人主页”。PHP的参考实现现在由PHP组织（https://www.php.net/）生产。PHP最初是作为一个模板语言开发的，允许我们将HTML与PHP代码本身混合在一起，就像Twig（https://twig.symfony.com/）和Pug（https://pugjs.org/）现在所做的那样。
- en: Now, PHP is more than just a templating language. Over the years, it has evolved
    into a general-purpose scripting language and object-oriented language, especially
    suited for server-side web development. You can still use it for templating, but
    we should make use of its full power in modern PHP development. If you want to
    check out what else PHP can do, visit [https://www.php.net/manual/en/intro-whatcando.php](https://www.php.net/manual/en/intro-whatcando.php).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，PHP不仅仅是一个模板语言。多年来，它已经发展成为一种通用脚本语言和面向对象语言，特别适用于服务器端Web开发。您仍然可以用它来制作模板，但在现代PHP开发中，我们应该充分利用它的全部功能。如果您想了解PHP还能做什么，请访问[https://www.php.net/manual/en/intro-whatcando.php](https://www.php.net/manual/en/intro-whatcando.php)。
- en: At the time of writing this book, the current stable version of PHP is 7.4.x.
    If you are getting started with PHP, start with PHP 7.4\. If you are using PHP
    7.2 or 7.3, you should consider upgrading it to PHP 7.4 as it contains several
    bug fixes. For more about the changes in this release, visit [https://www.php.net/ChangeLog-7.php](https://www.php.net/ChangeLog-7.php).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，PHP的当前稳定版本是7.4.x。如果您刚开始使用PHP，请从PHP 7.4开始。如果您正在使用PHP 7.2或7.3，您应该考虑将其升级到PHP
    7.4，因为它包含了几个错误修复。有关此版本更改的更多信息，请访问[https://www.php.net/ChangeLog-7.php](https://www.php.net/ChangeLog-7.php)。
- en: In this book, we will guide you through how to install or upgrade to PHP 7.4
    on Ubuntu with Apache2 support. Let's get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将指导您如何在支持Apache2的Ubuntu上安装或升级到PHP 7.4。让我们开始吧！
- en: Installing or upgrading PHP
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装或升级PHP
- en: If you are on macOS, please use this guide: [https://phptherightway.com/mac_setup](https://phptherightway.com/#mac_setup).
    If you are on Windows, then please use this guide: [https://phptherightway.com/windows_setup](https://phptherightway.com/#windows_setup).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS，请使用此指南：[https://phptherightway.com/mac_setup](https://phptherightway.com/#mac_setup)。如果您使用的是Windows，请使用此指南：[https://phptherightway.com/windows_setup](https://phptherightway.com/#windows_setup)。
- en: 'We''re using an Apache2 HTTP server but you can use an Nginx HTTP server if
    you have it installed on your machine already. Now, follow these simple steps
    to install PHP:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Apache2 HTTP服务器，但如果您的计算机上已安装了Nginx HTTP服务器，也可以使用它。现在，按照以下简单步骤安装PHP：
- en: 'Run the following commands to update the local packages on your Ubuntu server
    and install Apache2:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令更新Ubuntu服务器上的本地软件包并安装Apache2：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After installing Apache2, verify it with the `-v` option:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Apache2后，使用`-v`选项进行验证：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can use the following commands to stop, start, and enable the Apache2 service
    so that it always starts up when the server boots up:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令停止、启动和启用Apache2服务，以便在服务器启动时始终启动：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can use the following command to check the status of Apache2:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令检查Apache2的状态：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should always get `active (running)` as the output in your terminal:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终在终端中获得`active (running)`的输出：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the following commands to install PHP 7.4:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令安装PHP 7.4：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should also install PHP 7.4-related modules and extensions that may be
    needed when developing PHP apps:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还应该安装与PHP 7.4相关的可能在开发PHP应用程序时需要的模块和扩展：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Disable PHP 7.3 (if you are on PHP 7.3) and then enable PHP 7.4:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用PHP 7.3（如果您使用的是PHP 7.3），然后启用PHP 7.4：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you are installing PHP for the first time, then you don''t have to disable
    the older version. If you want to uninstall PHP and all its related modules, you
    can use the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是第一次安装PHP，则无需禁用旧版本。如果您想卸载PHP及其所有相关模块，可以使用以下命令：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Restart the Apache2 and PHP services:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动Apache2和PHP服务：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, you can verify the PHP you just installed with the following command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令验证刚刚安装的PHP：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should get the following version information:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该获得以下版本信息：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that you have Apache2 and PHP 7.4 installed, the next thing you should do
    is configure PHP. We'll do this in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了Apache2和PHP 7.4，接下来应该做的是配置PHP。我们将在下一节中进行。
- en: Configuring PHP 7.4
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置PHP 7.4
- en: 'Now that Apache2 and PHP are installed, you may want to configure PHP so that
    you can use it according to what suits your PHP apps. The default PHP configuration
    file is located at `/etc/php/7.4/apache2/php.ini`, so follow these steps to configure
    your version of PHP 7.4:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Apache2和PHP已安装，您可能希望配置PHP，以便根据您的PHP应用程序的需要使用它。默认的PHP配置文件位于`/etc/php/7.4/apache2/php.ini`，因此请按照以下步骤配置您的PHP
    7.4版本：
- en: 'Run the following command to edit or configure PHP 7.4:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以编辑或配置PHP 7.4：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You may need to change the default allowance of `upload_max_filesize` for uploaded
    files:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要更改已上传文件的`upload_max_filesize`的默认允许量：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can find more information about this configuration at [http://php.net/upload-max-filesize](http://php.net/upload-max-filesize).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://php.net/upload-max-filesize](http://php.net/upload-max-filesize)找到有关此配置的更多信息。
- en: '2 MB maximum for uploaded files can be considered small for PHP apps. So, go
    ahead and change it to suit your needs, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PHP应用程序来说，上传文件的最大限制为2 MB可能被认为是很小的。因此，请根据您的需求进行更改，如下所示：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following are some other important lines/PHP directives to consider:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他重要的行/PHP指令需要考虑：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can find more information about the preceding PHP directives and other directives
    for configuring your PHP at [https://www.php.net/manual/en/ini.core.php](https://www.php.net/manual/en/ini.core.php).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.php.net/manual/en/ini.core.php](https://www.php.net/manual/en/ini.core.php)找到有关上述PHP指令和其他配置PHP的指令的更多信息。
- en: 'Restart Apache for the aforementioned modified PHP settings to take effect:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启Apache以使上述修改的PHP设置生效：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: PHP 7.4 is powerful. You can just have it installed and serving your site for
    development without relying on the Apache server if you don't want to install
    Apache on your local development machine. In the next section, you'll learn how
    to use PHP 7.4 without the Apache server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.4非常强大。如果您不想在本地开发机器上安装Apache，您可以只安装它并用于开发站点。在下一节中，您将学习如何在没有Apache服务器的情况下使用PHP
    7.4。
- en: Running PHP apps with a built-in PHP web server
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置的PHP Web服务器运行PHP应用程序
- en: 'Since PHP 5.4, you can run PHP scripts and apps with the built-in PHP web server,
    without needing a common web server such as Apache or Nginx. As long as you have
    PHP 7.4 installed, you can skip the preceding Apache installation. To start the
    PHP server, just open a terminal from your project''s root directory and run the
    following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 自PHP 5.4以来，您可以使用内置的PHP Web服务器运行PHP脚本和应用程序，而无需像Apache或Nginx这样的常见Web服务器。只要安装了PHP
    7.4，您就可以跳过上述Apache安装。要启动PHP服务器，只需从项目的根目录打开终端并运行以下命令：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to start the app from a specific document root directory, such
    as from the `public` directory, in the project directory called `www`, do the
    following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从特定的文档根目录开始应用程序，例如从名为`public`的项目目录中的`www`目录开始，请执行以下操作：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s create a classic "Hello World" example that will be served up by this
    built-in PHP web server to see whether everything is set up correctly:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个经典的“Hello World”示例，这个内置的PHP Web服务器将提供，以查看是否一切设置正确：
- en: 'Create a simple "Hello World" message page in a PHP file, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的PHP文件中的“Hello World”消息页面，如下所示：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Navigate to your project directory and start it with the built-in PHP web server
    by using the preceding command. The terminal should show the following information:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的项目目录，并使用上述命令启动内置的PHP Web服务器。终端应显示以下信息：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, load `localhost:8181` on your browser. You should see Hello world! on your
    screen, without any errors.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器上加载`localhost:8181`。您应该在屏幕上看到Hello world!，没有任何错误。
- en: If you want to learn about this built-in web server, visit [https://www.php.net/features.commandline.webserver](https://www.php.net/features.commandline.webserver).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解这个内置的Web服务器，请访问[https://www.php.net/features.commandline.webserver](https://www.php.net/features.commandline.webserver)。
- en: Next, you'll learn how to arm yourself with some PHP standards. You'll also
    understand what HTTP messages are and why we need PSR for modern PHP apps.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何使用一些PHP标准。您还将了解HTTP消息是什么，以及为什么我们需要为现代PHP应用程序使用PSR。
- en: Understanding HTTP messages and PSRs
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解HTTP消息和PSR
- en: '**Hypertext Transfer Protocol** (**HTTP**) is a communication protocol between
    client computers and web servers. A web browser such as Chrome, Safari, or Firefox
    can be the web client or the user-agent, while a web application on a computer
    that''s listening on some port can be the web server. Web clients are not only
    browsers but any application that can speak to the web server, such as cURL or
    Telnet.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（**HTTP**）是客户端计算机和Web服务器之间的通信协议。诸如Chrome、Safari或Firefox之类的网络浏览器可以是Web客户端或用户代理，而计算机上监听某个端口的Web应用程序可以是Web服务器。Web客户端不仅仅是浏览器，还包括任何可以与Web服务器通信的应用程序，比如cURL或Telnet。'
- en: 'A client opens a connection via the internet to make a request to the server
    and waits until they receive a response from the server. The request contains
    request information, while the response contains status information and the requested
    content. These two types of exchanged data are called HTTP messages. They are
    just bodies of text encoded in ASCII and they span multiple lines in the following
    structure:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过互联网打开连接，向服务器发出请求，并等待直到收到服务器的响应。请求包含请求信息，而响应包含状态信息和请求的内容。这两种交换的数据称为HTTP消息。它们只是用ASCII编码的文本体，并且跨越多行，具有以下结构：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This looks very simple and straightforward, doesn''t it? Although this may
    be the case, let''s elaborate on this structure:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常简单和直接，不是吗？尽管可能是这样，让我们详细说明一下这个结构：
- en: '`Start-line` describes the implemented request method (such as `GET`, `PUT`,
    or `POST`), the request target (usually a URI), and the HTTP version or the status
    (such as 200, 404, or 500) of the response and the HTTP version. `Start-line`
    is always a single line.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start-line`描述了实现的请求方法（例如`GET`、`PUT`或`POST`）、请求目标（通常是URI）和响应的HTTP版本或状态（例如200、404或500）以及HTTP版本。`Start-line`始终是单行。'
- en: The `HTTP Headers` line describes the specific details (meta-information) of
    the request or the response, such as `Host`, `User-Agent`, `Server`, `Content-type`,
    and so on.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP Headers`行描述了请求或响应的特定细节（元信息），例如`Host`、`User-Agent`、`Server`、`Content-type`等。'
- en: The blank line indicates that all the meta-information for the request has been
    sent.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白行表示请求的所有元信息已经发送。
- en: '`Body` (or, message body) contains the exchanged data of the request (such
    as the content of an HTML form) or the response (such as the content of an HTML
    document). The message body is optional (sometimes, it is not needed in the request
    for requesting data from the server).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Body`（或消息体）包含请求的交换数据（例如HTML表单的内容）或响应的内容（例如HTML文档的内容）。消息体是可选的（有时，在请求中不需要它来请求服务器的数据）。'
- en: 'Now, let''s use cURLto see how the data of the HTTP request and response is
    exchanged:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用cURL来看看HTTP请求和响应的数据是如何交换的：
- en: 'Serve the PHP "Hello World" app that you learned about in the previous section
    on `localhost:8181` using the built-in PHP web server:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的PHP Web服务器在`localhost:8181`上提供您在上一节中学到的PHP“Hello World”应用程序：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Open a new tab on your terminal and run the following cURL script:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端上打开一个新标签，并运行以下cURL脚本：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see that the request message is displayed in the first part, as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到请求消息显示在第一部分中，如下所示：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, you can see that the blank line is represented at `004a:` and that there
    is no message body in the request at all. The response message is displayed in
    the second part, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到空行表示为`004a:`，请求中根本没有消息正文。响应消息显示在第二部分中，如下所示：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, you can see the status is `200 OK` in the start line in the response.
    But in the preceding example, we did not send any data, so there is no message
    body in the request message. Let''s create another very basic PHP script, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应的起始行中，您可以看到状态是`200 OK`。但在前面的示例中，我们没有发送任何数据，因此请求消息中没有消息正文。让我们创建另一个非常基本的PHP脚本，如下所示：
- en: 'Create a PHP page with the PHP `print` function so that it displays `POST`
    data, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有PHP `print`函数的PHP页面，以便显示`POST`数据，如下所示：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Serve the page on `localhost:8181` using the built-in PHP web server:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的PHP Web服务器在`localhost:8181`上提供页面：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Send some data over cURL on your terminal:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上使用cURL发送一些数据：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This time, the request message will be displayed in the first part, along with
    the message body:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，请求消息将显示在第一部分中，以及消息正文：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The response message is displayed in the second part, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 响应消息显示在第二部分中，如下所示：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, you can also see the request message and the request message for the
    `PUT` method over cURL on your terminal:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，您还可以在终端上使用cURL查看`PUT`方法的请求消息和请求消息：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The same applies for the `DELETE` method over cURL, as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于cURL上的`DELETE`方法也是如此，如下所示：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Last but not least, we also can use the Developer Tools in Google Chrome to
    help us inspect the exchanged data. Let''s create another simple PHP script that
    will receive data from the URI:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们还可以使用Google Chrome中的开发者工具来帮助我们检查交换的数据。让我们创建另一个简单的PHP脚本，它将从URI接收数据：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Send some data on your browser by using `0.0.0.0:8181/?param1=value1&param2=value2`.
    By doing this, the data is sent as `param1=value1&param2=value2`, as shown in
    the following screenshot:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`0.0.0.0:8181/?param1=value1&param2=value2`在浏览器上发送一些数据。通过这样做，数据将作为`param1=value1&param2=value2`发送，如下截图所示：
- en: '![](assets/e4fb51b8-fde2-4b80-b57d-c433f69124cf.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e4fb51b8-fde2-4b80-b57d-c433f69124cf.png)'
- en: If you want to know more about HTTP and HTTP messages, please visit [https://developer.mozilla.org/en-US/docs/Web/HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)
    for HTTP in general and [https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages)
    for HTTP messages specifically.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于HTTP和HTTP消息的信息，请访问[https://developer.mozilla.org/en-US/docs/Web/HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)了解HTTP的一般信息，以及[https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages)了解特定的HTTP消息。
- en: 'When it comes to server-side development, HTTP messages are better encapsulated
    in objects so that they are easier to work with. For example, Node.js has a built-in
    HTTP module ([https://nodejs.dev/the-nodejs-http-module](https://nodejs.dev/the-nodejs-http-module))
    for HTTP communication, in which you can get the HTTP messages objects from the
    callback in the `http.createServer()` method when using it to create an HTTP server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及服务器端开发时，HTTP消息最好封装在对象中，以便更容易处理。例如，Node.js具有内置的HTTP模块（[https://nodejs.dev/the-nodejs-http-module](https://nodejs.dev/the-nodejs-http-module)）用于HTTP通信，在其中，您可以从`http.createServer()`方法的回调中获取HTTP消息对象，用于创建HTTP服务器：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you are using a Node.js framework such as Koa, you can find the HTTP messages
    objects in `ctx`, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Node.js框架，例如Koa，您可以在`ctx`中找到HTTP消息对象，如下所示：
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, `ctx` is the Koa context, while `ctx.request` is the
    HTTP request message and `ctx.response` is the HTTP response message. We can do
    the same in Express; you can find the HTTP messages as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`ctx`是Koa上下文，而`ctx.request`是HTTP请求消息，`ctx.response`是HTTP响应消息。在Express中也是一样的；您可以按如下方式找到HTTP消息：
- en: '[PRE36]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Unlike Node.js, PHP has never had built-in HTTP message objects like these.
    There are a bunch of ways to get and set the web data, both manually and directly,
    just like we saw in the previous PHP examples, by using superglobals (`$_GET`,
    `$_POST`) and the built-in functions (`echo`, `print_r`). If you want to catch
    the incoming request, you can use `$_GET`, `$_POST`, `$_FILE`, `$_COOKIE`, `$_SESSION`,
    or any other superglobals ([https://www.php.net/manual/en/language.variables.superglobals.php](https://www.php.net/manual/en/language.variables.superglobals.php)),
    depending on the situation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与Node.js不同，PHP从来没有内置的HTTP消息对象。有很多方法可以手动和直接获取和设置Web数据，就像我们在之前的PHP示例中看到的那样，通过使用超全局变量（`$_GET`、`$_POST`）和内置函数（`echo`、`print_r`）。如果您想捕获传入的请求，您可以根据情况使用`$_GET`、`$_POST`、`$_FILE`、`$_COOKIE`、`$_SESSION`或其他超全局变量（[https://www.php.net/manual/en/language.variables.superglobals.php](https://www.php.net/manual/en/language.variables.superglobals.php)）。
- en: 'The same goes for returning a response: you use global functions such as `echo`,
    `print`, and `header` to set response headers manually. In the past, PHP developers
    and frameworks had their own ways of implementing HTTP messages. This led to a
    time where different frameworks had different abstractions to **represent** HTTP
    messages, and any app based on a specific implementation of HTTP messages could
    hardly be interoperable in the project for using other frameworks. This lack of
    industry standards made the components of a framework tightly coupled. If you
    didn''t start with a framework, you would end up building one yourself.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 返回响应也是一样的：您可以使用全局函数，如`echo`、`print`和`header`手动设置响应头。过去，PHP开发人员和框架有他们自己实现HTTP消息的方式。这导致了不同框架有不同的抽象来**表示**HTTP消息的时代，任何基于特定实现的HTTP消息的应用程序几乎无法在项目中与其他框架一起使用。这种行业标准的缺乏使得框架的组件紧密耦合。如果您没有从框架开始，最终您会自己构建一个框架。
- en: 'But today, the PHP community has learned and enforced PHP standards and recommendations.
    You don''t have to fully comply with these standards and recommendations; you
    can ignore them if you have philosophical reasons that urge you to. But they are
    a measure with a good intention to end the PHP war – at least commercially and
    collaboratively. And once for all, PHP developers can focus on PHP standards rather
    than frameworks in a framework-agnostic way. When we talk about PHP standards,
    we tend to refer to the PSR, a PHP specification defined and published by the PHP
    Framework Interop Group (PHP-FIG). PSR-7: HTTP message interfaces is one of the
    specifications suggested by the PHP-FIG members and was voted for according to
    the established protocol that they agreed upon.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是今天，PHP社区已经学习并执行了PHP标准和建议。您不必完全遵守这些标准和建议；如果您有哲学原因要求您这样做，您可以忽略它们。但它们是一个良好意图的衡量标准，至少在商业和合作方面结束PHP战争。最重要的是，PHP开发人员可以专注于PHP标准，而不是以框架无关的方式。当我们谈论PHP标准时，我们倾向于指的是PSR，这是由PHP框架互操作性组（PHP-FIG）定义和发布的PHP规范。PSR-7：HTTP消息接口是PHP-FIG成员提出的规范之一，并根据他们同意的既定协议进行了投票。
- en: PSR-7 was officially accepted in May 2015\. It is basically used to standardize
    HTTP message interfaces. Before jumping into PSR-7, we should know about some
    other PSR numbers as well, notably PSR-12 (replacement of PSR-2), PSR-4, and PSR-15\.
    We will guide you through them in this book so that you can write reusable, framework-agnostic
    apps and components that can be used on their own or can be interoperable with
    other frameworks, whether they are a full-stack or micro frameworks. Let's get
    started!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-7于2015年5月正式被接受。它基本上用于标准化HTTP消息接口。在深入研究PSR-7之前，我们还应该了解一些其他PSR编号，特别是PSR-12（取代PSR-2），PSR-4和PSR-15。我们将在本书中为您介绍它们，以便您可以编写可重用的，与框架无关的应用程序和组件，这些应用程序和组件可以独立使用，也可以与其他框架进行互操作，无论它们是全栈还是微框架。让我们开始吧！
- en: Why PSRs?
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用PSR？
- en: 'Internally, PHP never tells developers how they should write their PHP code.
    For example, Python uses indentation to indicate a block of code, while for other
    programming languages such as PHP and JavaScript, indentation in code is done
    for readability. The following is an example of what Python will accept:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，PHP从不告诉开发人员他们应该如何编写他们的PHP代码。例如，Python使用缩进来指示一块代码，而对于其他编程语言，如PHP和JavaScript，代码中的缩进是为了可读性。以下是Python将接受的示例：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Python will return an error if there''s no indentation:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有缩进，Python将返回错误：
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The number of spaces is up to the coder''s preference, but you must use at
    least one and have the same number of spaces for other lines in the same block;
    otherwise, Python will return an error:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 空格的数量取决于编码者的偏好，但您必须至少使用一个空格，并且在同一块中的其他行中使用相同数量的空格；否则，Python将返回错误：
- en: '[PRE39]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On the other hand, in PHP, you can write the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在PHP中，您可以编写以下内容：
- en: '[PRE40]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following is valid in PHP too:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中也可以使用以下内容：
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Python internally enforces readability and tidiness for code. PHP does not.
    You can imagine that without some basic enforcement, and depending on the experience
    of the coder, PHP code can end up very messy, ugly, and unreadable. Perhaps the
    low barrier to entry in PHP web development plays a part in that. So, your PHP
    code must adhere to a common code style to make it easy for collaboration and
    maintenance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python在内部强制执行代码的可读性和整洁性。PHP没有。您可以想象，如果没有一些基本的强制措施，并且根据编码者的经验，PHP代码可能会变得非常混乱，丑陋和难以阅读。也许PHP
    Web开发的低门槛在其中起了作用。因此，您的PHP代码必须遵循通用的代码风格，以便于协作和维护。
- en: 'There are a few PHP coding standards around for specific frameworks, but they
    are more or less based on (or similar to) PSR standards:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特定框架的PHP编码标准，但它们基本上是基于（或类似于）PSR标准的：
- en: Zend Coding Standard at [https://framework.zend.com/manual/2.4/en/ref/coding.standard.html](https://framework.zend.com/manual/2.4/en/ref/coding.standard.html)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zend编码标准在[https://framework.zend.com/manual/2.4/en/ref/coding.standard.html](https://framework.zend.com/manual/2.4/en/ref/coding.standard.html)
- en: Symfony Coding Standards at [https://symfony.com/doc/master/contributing/code/standards.html](https://symfony.com/doc/master/contributing/code/standards.html)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Symfony编码标准在[https://symfony.com/doc/master/contributing/code/standards.html](https://symfony.com/doc/master/contributing/code/standards.html)
- en: CakePHP Coding Standards at [https://book.cakephp.org/3.0/en/contributing/cakephp-coding-conventions.html](https://book.cakephp.org/3.0/en/contributing/cakephp-coding-conventions.html)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CakePHP编码标准在[https://book.cakephp.org/3.0/en/contributing/cakephp-coding-conventions.html](https://book.cakephp.org/3.0/en/contributing/cakephp-coding-conventions.html)
- en: FuelPHP Coding Standards at [https://fuelphp.com/docs/general/coding_standards.html](https://fuelphp.com/docs/general/coding_standards.html)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FuelPHP编码标准在[https://fuelphp.com/docs/general/coding_standards.html](https://fuelphp.com/docs/general/coding_standards.html)
- en: WordPress Coding Standards at [https://codex.wordpress.org/WordPress_Coding_Standards](https://codex.wordpress.org/WordPress_Coding_Standards)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WordPress编码标准在[https://codex.wordpress.org/WordPress_Coding_Standards](https://codex.wordpress.org/WordPress_Coding_Standards)
- en: Pragmatically, your code should adhere to the framework that you are tied to,
    and that specific framework only. But if you are only using some components or
    libraries from the framework, then you can comply with any combination of PSRs,
    or the coding standards made by PEAR. The PEAR Coding Standards can be found at
    [https://pear.php.net/manual/en/standards.php](https://pear.php.net/manual/en/standards.php).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从实用的角度来看，您的代码应该遵循您所依赖的框架，以及特定的框架。但是，如果您只是从框架中使用一些组件或库，那么您可以遵守任何组合的PSR，或者由PEAR制定的编码标准。PEAR编码标准可以在[https://pear.php.net/manual/en/standards.php](https://pear.php.net/manual/en/standards.php)找到。
- en: This book focuses on a variety of PSRs because this chapter aims to create framework-agnostic
    PHP apps. You don't have to agree with PSR, but if you are looking for a standard
    to start a project with and do not have any standard of your own within your organization,
    it might be a good place to start. You can find out more about the PSR at [https://www.php-fig.org/psr/](https://www.php-fig.org/psr/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本书侧重于各种PSR，因为本章旨在创建与框架无关的PHP应用程序。您不必同意PSR，但如果您正在寻找一个标准来开始项目，并且在您的组织内没有自己的标准，那么这可能是一个很好的开始。您可以在[https://www.php-fig.org/psr/](https://www.php-fig.org/psr/)找到更多关于PSR的信息。
- en: 'On top of what we have mentioned here, you should also check out **PHP: The
    Right Way** at [https://phptherightway.com/](https://phptherightway.com/). It
    outlines things that a modern PHP coder can use as references, from setting up
    PHP, dependency management with **Composer** (which we will cover later in this
    chapter), coding style guides (in which PSRs are recommended), dependency injection,
    databases, templating, to testing frameworks and more. It is a good start for
    new PHP coders who want to avoid the mistakes of the past and find links to authoritative
    PHP tutorials on the web. It is also a good place for experienced PHP coders who
    need a quick reference and updates from the PHP community at large, or anything
    they might have missed in the past few years.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '除了我们在这里提到的内容之外，您还应该查看[https://phptherightway.com/](https://phptherightway.com/)的**PHP:
    The Right Way**。它概述了现代PHP编码人员可以用作参考的事项，从设置PHP，使用**Composer**进行依赖管理（我们将在本章后面介绍），编码风格指南（其中推荐使用PSR），依赖注入，数据库，模板化，测试框架等等。对于想要避免过去错误并在网络上找到权威PHP教程链接的新PHP编码人员来说，这是一个很好的开始。对于需要快速参考和来自PHP社区的更新的经验丰富的PHP编码人员来说，这也是一个很好的地方，或者是他们在过去几年中可能错过的任何内容。'
- en: Now, let's dive into PSRs, starting with **PSR-12**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始研究PSR，从**PSR-12**开始。
- en: PSR-12 – Extended Coding Style guide
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PSR-12 - 扩展编码风格指南
- en: PSR-12 is a revised coding style guide of PSR-2 that takes PHP 7 into account.
    The PSR-12 specification was approved on 9 August 2019\. Since PSR-2 was accepted
    in 2012, many changes have been made to PHP that have had some impact on coding
    style guidelines, the most notable of which is **return type declarations**, which
    are introduced in PHP 7 and not described in PSR-2\. Hence, a standard should
    be defined for using them so that they can be adopted by the wider PHP community
    before individual PHP coders implement their standards, which might conflict with
    each other eventually.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-12是PSR-2的修订编码风格指南，考虑了PHP 7。PSR-12规范于2019年8月9日获得批准。自2012年接受PSR-2以来，PHP已经进行了许多更改，对编码风格指南产生了一些影响，其中最显着的是**返回类型声明**，这是在PHP
    7中引入的，而在PSR-2中没有描述。因此，应该定义一个标准来使用它们，以便它们可以被更广泛的PHP社区采用，然后再由个别的PHP编码人员实施他们的标准，这可能最终会发生冲突。
- en: 'For example, the **return type declarations** that have been added in PHP 7
    simply specifies the type of value that a function should return. Let''s take
    a look at the following function, which adopts the **return type declarations**:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，PHP 7中添加的**返回类型声明**简单地指定了函数应该返回的值的类型。让我们看一下以下采用**返回类型声明**的函数：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You will get the correct result of `2` as an integer. However, let''s see what
    happens if you change the code inside the `returnInt` function, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到`2`作为整数的正确结果。但是，让我们看看如果您改变`returnInt`函数内的代码会发生什么，如下所示：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'PHP will give up with the following error:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: PHP将放弃以下错误：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So, to cater for the need of this new feature of PHP 7, PSR-12 requires you
    to use a single space after the colon, followed by the type declaration for the
    methods with the return type declaration. Also, the colon and declaration must
    be on the same line as the argument list''s closing parenthesis with no spaces
    between the two characters. Let''s take a look at a simple example that has a
    `return` type declaration:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了满足PHP 7的这一新功能的需求，PSR-12要求您在冒号后使用一个空格，后面是带有返回类型声明的方法的类型声明。此外，冒号和声明必须与参数列表的右括号在同一行，两个字符之间没有空格。让我们看一个简单的例子，其中有一个`return`类型声明：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Some rules are kept the same in PSR-2 and PSR-12\. For example, in both PSRs,
    you must not use tabs for indentation but four single spaces instead. But the
    rule in PSR-2 regarding the list of blocks has been revised. Now, in PSR-12, the
    blocks that use statements for importing classes, functions, and constants must
    be separated by a single blank line, even though there is just one import of them.
    Let''s take a quick look at some code that complies with this rule:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在PSR-2和PSR-12中有一些规则保持不变。例如，在这两个PSR中，您不能使用制表符进行缩进，而是使用四个单个空格。但是在PSR-2中关于块列表的规则已经修订。现在，在PSR-12中，使用语句导入类、函数和常量的块必须用单个空行分隔，即使只有一个导入它们的地方。让我们快速看一下符合此规则的一些代码：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, you should notice that, in PSR-12, you must use a single blank line right
    after the opening `<?php` tag. However, in PSR-2, this isn''t necessary. For example,
    you can write the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该注意，在PSR-12中，您必须在开头的`<?php`标记后使用一个空行。但是，在PSR-2中，这是不必要的。例如，您可以编写以下内容：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is worth knowing that PSR-2 was extended from PSR-1, which was a basic coding
    standard, but since PSR-12 was accepted, PSR-2 is now officially deprecated.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 值得知道，PSR-2是从PSR-1扩展而来的，它是一个基本的编码标准，但自从PSR-12被接受以来，PSR-2现在已正式弃用。
- en: 'To implement these PSRs for your code, please visit the following sites:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要为您的代码实施这些PSR，请访问以下网站：
- en: '[https://www.php-fig.org/psr/psr-1/](https://www.php-fig.org/psr/psr-1/) for
    the PSR-1: Basic Coding Standard'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.php-fig.org/psr/psr-1/](https://www.php-fig.org/psr/psr-1/) 用于PSR-1：基本编码标准'
- en: '[https://www.php-fig.org/psr/psr-2/](https://www.php-fig.org/psr/psr-2/) for
    the PSR-2: Coding Style Guide (deprecated)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.php-fig.org/psr/psr-2/](https://www.php-fig.org/psr/psr-2/) 用于PSR-2：编码风格指南（已弃用）'
- en: '[https://www.php-fig.org/psr/psr-12/](https://www.php-fig.org/psr/psr-12/) for
    the PSR-12: Extended Coding Style'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.php-fig.org/psr/psr-12/](https://www.php-fig.org/psr/psr-12/) 用于PSR-12：扩展编码风格'
- en: If you want to find out the new features in PHP 7, such as scalar type declarations
    and return type declarations, please visit [https://www.php.net/manual/en/migration70.new-features.php](https://www.php.net/manual/en/migration70.new-features.php).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解PHP 7的新功能，例如标量类型声明和返回类型声明，请访问[https://www.php.net/manual/en/migration70.new-features.php](https://www.php.net/manual/en/migration70.new-features.php)。
- en: PSR-12 helps PHP coders write more readable and structured code, so it is worth
    adopting it in your code when writing in PHP. Now, let's move on to **PSR-4**,
    which allows us to use autoloading in PHP.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-12帮助PHP编码人员编写更易读和结构化的代码，因此在使用PHP编写代码时值得采用它。现在，让我们继续讨论**PSR-4**，它允许我们在PHP中使用自动加载。
- en: PSR-4 – Autoloader
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PSR-4 – 自动加载器
- en: In the old days of PHP, if you wanted to bring a third-party library into your
    PHP project, or bring in your functions and classes from separate PHP files, you
    would use `include` or `require` statements. With the arrival of PHP autoloading,
    you would use the `__autoload` magic method (which is now deprecated since PHP
    7.2) or `spl_autoload` to automatically call your code. Then came **true namespace**
    support in PHP 5.3, where developers and frameworks can devise their approaches
    to prevent naming collisions. But still, it was quite far from ideal because of
    the battle between different approaches. You can imagine a situation where you
    have two frameworks – framework A and framework B – and individual developers
    disagreeing with each other and implementing their own ways to achieve the same
    result. This was madness.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP的旧日子里，如果您想将第三方库引入您的PHP项目，或者从单独的PHP文件中引入您的函数和类，您将使用`include`或`require`语句。随着PHP自动加载的到来，您将使用`__autoload`魔术方法（自PHP
    7.2起已弃用）或`spl_autoload`来自动调用您的代码。然后在PHP 5.3中出现了**真正的命名空间**支持，开发人员和框架可以设计他们的方法来防止命名冲突。但仍然远非理想，因为不同方法之间存在冲突。您可以想象一种情况，您有两个框架
    - 框架A和框架B - 以及个别开发人员彼此不同意并实施自己的方法来实现相同的结果。这是疯狂的。
- en: 'Today, we comply with PSR-4 (which is the successor of PSR-0) to standardize
    the autoloading approach and bind developers and frameworks together. It specifies
    the standard for autoloading classes from **file paths**. It also describes the
    location of the file. So, a **fully qualified class name** should adhere to the
    following form:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们遵守PSR-4（它是PSR-0的后继者）来标准化自动加载的方法，并将开发人员和框架绑定在一起。它指定了从**文件路径**自动加载类的标准。它还描述了文件的位置。因此，一个**完全限定的类名**应该遵循以下形式：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In this rule, we have the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个规则中，我们有以下内容：
- en: The namespace for a fully qualified class must have a top-level vendor namespace,
    which is the `<NamespaceName>` part in the preceding code.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全限定类的命名空间必须具有顶级供应商命名空间，这是上述代码中的`<NamespaceName>`部分。
- en: You can use one or more sub-namespaces, as shown by the `<SubNamespaceNames>` part
    of the preceding code.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上面的代码中，您可以使用一个或多个子命名空间，如`<SubNamespaceNames>`部分所示。
- en: Then, you must end the namespace with your class name, as shown by the `<ClassName>`
    part of the preceding code.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，您必须使用您的类名结束命名空间，如上述代码中的`<ClassName>`部分所示。
- en: So, if you are writing an autoloader, it is recommended to use this standard.
    However, you don't have to (and probably shouldn't) go through the hassle of writing
    your own autoloader while complying with PSR-4\. This is because you can use **Composer**
    to help you do this. Composer is a package manager for PHP. It is akin to npm
    in Node.js. It was initially released in 2012\. Since then, it has been used by
    all modern PHP frameworks and PHP coders alike. This means you can focus more
    on your code development and worry less about the interoperability of different
    packages and libraries that you are going to bring into your project environment.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您正在编写自动加载程序，建议使用此标准。但是，您不必（也可能不应该）费力地编写自己的自动加载程序来符合PSR-4。这是因为您可以使用**Composer**来帮助您做到这一点。Composer是PHP的包管理器。它类似于Node.js中的npm。它最初是在2012年发布的。从那时起，它已被所有现代PHP框架和PHP编码人员使用。这意味着您可以更多地专注于您的代码开发，而不必过多担心要引入项目环境中的不同包和库的互操作性。
- en: 'Before we start, make sure you have Composer installed on your system. Depending
    on your system, you can follow the following guides to install Composer:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保您的系统上已安装Composer。根据您的系统，您可以按照以下指南安装Composer：
- en: '[https://getcomposer.org/doc/00-intro.md](https://getcomposer.org/doc/00-intro.md) and [https://getcomposer.org/download/](https://getcomposer.org/download/) from the
    official Composer site'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://getcomposer.org/doc/00-intro.md](https://getcomposer.org/doc/00-intro.md)和[https://getcomposer.org/download/](https://getcomposer.org/download/)来自官方Composer网站'
- en: '[https://php](https://phptherightway.com/#dependency_management)[therightway.com/dependency_management](https://phptherightway.com/#dependency_management) from **PHP:
    The Right Way**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://php](https://phptherightway.com/#dependency_management)[therightway.com/dependency_management](https://phptherightway.com/#dependency_management)来自**PHP:正确的方式**'
- en: 'The current version is 1.10.9\. Follow these steps to install Composer and
    make use of the autoloader that it offers:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本为1.10.9。按照以下步骤安装Composer并利用其提供的自动加载程序：
- en: 'Install Composer in your current directory by running the following script
    in your terminal:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中运行以下脚本在当前目录中安装Composer：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the Composer setup file, as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤运行Composer设置文件：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You should get the following output in your terminal:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端中获得以下输出：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Remove the Composer setup file, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤删除Composer设置文件：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Verify the installation by running `php composer.phar` on your terminal. If
    you want to use Composer **globally**, then move Composer to `/usr/local/bin`
    (if you are using Linux/Unix):'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端上运行`php composer.phar`来验证安装。如果您想**全局**使用Composer，则将Composer移动到`/usr/local/bin`（如果您使用Linux/Unix）：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, you can run Composer globally. To verify it, just run the following command:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以全局运行Composer。要验证它，只需运行以下命令：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should see the logo for Composer, as well as its available commands and
    options:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到Composer的标志，以及其可用的命令和选项：
- en: '[PRE55]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Alternatively, you can use the `-V` option to check the version you''ve installed
    directly:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`-V`选项直接检查您安装的版本：
- en: '[PRE56]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that you have Composer installed on your system, simply navigate to your
    project''s root through your terminal and use `composer require`, followed by
    `<package-name>`, to install any third-party packages (also known as dependencies)
    that you need in your project, as follows:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经在系统上安装了Composer，只需通过终端导航到项目的根目录，并使用`composer require`，然后是`<package-name>`，来安装您项目中需要的任何第三方软件包（也称为依赖项），如下所示：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'After installing the required packages, you can go to your project root. You
    should see that a `composer.json` file has been created that contains the dependency
    of your project in a `require` key:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装所需的软件包后，您可以转到项目根目录。您应该看到已创建一个包含项目依赖项的`composer.json`文件，其中包含`require`键：
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you want to install all the dependencies again next time, you can just run
    the `install` command, as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想下次再次安装所有依赖项，只需运行`install`命令，如下所示：
- en: '[PRE59]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When you have installed your project dependencies, whether that be with the
    `require` or `install` command, you will always get a `/vendor/` folder generated
    by Composer that contains all your dependencies. An `autoload.php` file will always
    be generated and located inside the `/vendor/` folder. You then can include this
    file and start using the classes that those packages provide straight away, as
    follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您安装了项目的依赖项，无论是使用`require`还是`install`命令，Composer都会生成一个包含所有依赖项的`/vendor/`文件夹。`autoload.php`文件将始终生成并位于`/vendor/`文件夹内。然后，您可以包含此文件并立即开始使用这些软件包提供的类，如下所示：
- en: '[PRE60]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Most importantly, you can even add your classes to the autoloader by adding
    the `autoload` key, along with your custom namespace, to the `composer.json` file.
    For example, you can have your classes stored in an `/src/` folder in the project
    root, on the same level where the `/vendor/` directory is:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最重要的是，您甚至可以通过向`composer.json`文件添加`autoload`键以及自定义命名空间来将您的类添加到自动加载程序。例如，您可以将类存储在项目根目录中的`/src/`文件夹中，与`/vendor/`目录位于同一级别：
- en: '[PRE61]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you have the source files in multiple locations, you can use an array, `[]`,
    to associate it with your custom namespace, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的源文件位于多个位置，您可以使用数组`[]`将其与您的自定义命名空间关联起来，如下所示：
- en: '[PRE62]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Composer will register a PSR-4 autoloader for the `Spectre` namespace. After
    that, you can start writing your classes. For example, you can create a `/src/Foo.php`
    file that contains a `Spectre\Foo` class. After that, just run `dump-autoload`
    on your terminal to regenerate the `autoload.php` file inside the `/vendor/` directory.
    You also can add multiple custom namespaces to the `autoload` field, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Composer将为`Spectre`命名空间注册一个PSR-4自动加载程序。之后，您可以开始编写您的类。例如，您可以创建一个包含`Spectre\Foo`类的`/src/Foo.php`文件。之后，只需在终端上运行`dump-autoload`来重新生成`/vendor/`目录中的`autoload.php`文件。您还可以添加多个自定义命名空间到`autoload`字段，如下所示：
- en: '[PRE63]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Besides PSR-4, Composer also supports PSR-0\. You can add a PSR-0 key to the
    `composer.json` file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了PSR-4，Composer还支持PSR-0。您可以在`composer.json`文件中添加PSR-0键。
- en: For more information and examples of how to use PSR-0 with Composer, please
    visit [https://getcomposer.org/doc/04-schema.mdautoload](https://getcomposer.org/doc/04-schema.md#autoload).
    However, please note that PSR-0 is now deprecated. If you want to read more about
    these two PSRs, please visit [https://www.php-fig.org/psr/psr-0/](https://www.php-fig.org/psr/psr-0/)
    for PSR 0 (deprecated) and [https://www.php-fig.org/psr/psr-4/](https://www.php-fig.org/psr/psr-4/)
    for PSR-4. If you want to know about Monolog, which we used in the preceding example
    for logging in PHP, please visit [https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog).
    If you want to read more about Autoloading Classes in PHP, please visit [https://www.php.net/manual/en/language.oop5.autoload.php](https://www.php.net/manual/en/language.oop5.autoload.php)[.](https://www.php.net/manual/en/language.oop5.autoload.php)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何在Composer中使用PSR-0的更多信息和示例，请访问[https://getcomposer.org/doc/04-schema.mdautoload](https://getcomposer.org/doc/04-schema.md#autoload)。但是，请注意，PSR-0现在已经不推荐使用。如果您想阅读有关这两个PSR的更多信息，请访问[https://www.php-fig.org/psr/psr-0/](https://www.php-fig.org/psr/psr-0/)了解PSR
    0（不推荐使用），以及[https://www.php-fig.org/psr/psr-4/](https://www.php-fig.org/psr/psr-4/)了解PSR-4。如果您想了解我们在PHP中用于记录的Monolog，请访问[https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog)。如果您想了解PHP中自动加载类的更多信息，请访问[https://www.php.net/manual/en/language.oop5.autoload.php](https://www.php.net/manual/en/language.oop5.autoload.php)。
- en: As soon as you have armed yourself with knowledge about PSR-12 and PSR-4, it
    will be easier for you to build PHP apps that comply with other PSRs. The other
    two PSRs that this book focuses on are PSR-7 and PSR-15\. Let's move on and look
    at **PSR-7** first.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您掌握了关于PSR-12和PSR-4的知识，您将更容易构建符合其他PSR的PHP应用程序。本书关注的另外两个PSR是PSR-7和PSR-15。让我们先来看一下**PSR-7**。
- en: PSR-7 – HTTP Message Interfaces
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PSR-7 - HTTP消息接口
- en: Earlier, we mentioned that PHP does not have HTTP request and response message
    objects, which is why PHP frameworks and coders came out with different abstractions
    to represent (or "imitate") HTTP messages in the past. Luckily, in 2015, PSR-7
    came to the rescue to end these "disagreements" and differences.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们提到PHP没有HTTP请求和响应消息对象，这就是为什么PHP框架和编码人员在过去提出了不同的抽象来表示（或“模拟”）HTTP消息。幸运的是，在2015年，PSR-7出现了，结束了这些“分歧”和差异。
- en: PSR-7 is a set of common interfaces (abstractions) that specify public methods
    for HTTP messages and URIs when communicating over HTTP. In object-oriented programming
    (OOP), an interface is, in fact, an abstraction of the actions (public methods)
    that an object (a class) must implement, without defining the complexities and
    details of how these actions are implemented. For example, the following table
    shows the methods that your HTTP message classes must implement when composing
    them so that they comply with the PSR-7 specification.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-7是一组通用接口（抽象），用于在HTTP通信中指定HTTP消息和URI的公共方法。在面向对象编程（OOP）中，接口实际上是对象（类）必须实现的操作（公共方法）的抽象，而不定义这些操作的复杂性和细节。例如，以下表格显示了当组合HTTP消息类时，必须实现的方法，以便符合PSR-7规范。
- en: 'The specified methods for accessing and modifying the request and response
    objects are as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问和修改请求和响应对象的指定方法如下：
- en: '|  **To access** |  **To modify** |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|  **访问** |  **修改** |'
- en: '| `getProtocolVersion()` | `withProtocolVersion($version)` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `getProtocolVersion()` | `withProtocolVersion($version)` |'
- en: '| `getHeaders()` | `withHeader($name, $value)` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `getHeaders()` | `withHeader($name, $value)` |'
- en: '| `hasHeader($name)` | `withAddedHeader($name, $value)` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `hasHeader($name)` | `withAddedHeader($name, $value)` |'
- en: '| `getHeader($name)``getHeaderLine($name)` | `withoutHeader($name)` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `getHeader($name)``getHeaderLine($name)` | `withoutHeader($name)` |'
- en: '| `getBody()` | `withBody(StreamInterface $body)` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `getBody()` | `withBody(StreamInterface $body)` |'
- en: 'The specified methods for accessing and modifying just **request** objects
    are as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问和修改**请求**对象的指定方法如下：
- en: '| **To access** | **To modify** |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **访问** | **修改** |'
- en: '|'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`getRequestTarget()`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRequestTarget()`'
- en: '`getMethod()`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMethod()`'
- en: '`getUri()`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUri()`'
- en: '`getServerParams()`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getServerParams()`'
- en: '`getCookieParams()`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCookieParams()`'
- en: '`getQueryParams()`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueryParams()`'
- en: '`getUploadedFiles()`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUploadedFiles()`'
- en: '`getParsedBody()`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取解析后的主体`getParsedBody()`
- en: '`getAttributes()`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取属性`getAttributes()`
- en: '`getAttribute($name, $default = null)`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAttribute($name, $default = null)`'
- en: '|'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`withMethod($method)`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`withMethod($method)`方法
- en: '`withRequestTarget($requestTarget)`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withRequestTarget($requestTarget)`'
- en: '`withUri(UriInterface $uri, $preserveHost = false)`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`withUri(UriInterface $uri, $preserveHost = false)`方法
- en: '`withCookieParams(array $cookies)`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withCookieParams(array $cookies)`'
- en: '`withQueryParams(array $query)`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withQueryParams(array $query)`'
- en: '`withUploadedFiles(array $uploadedFiles)`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withUploadedFiles(array $uploadedFiles)`'
- en: '`withParsedBody($data)`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withParsedBody($data)`'
- en: '`withAttribute($name, $value)`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withAttribute($name, $value)`'
- en: '`withoutAttribute($name)`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withoutAttribute($name)`'
- en: '|'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The specified methods for accessing and modifying just **response** objects
    are as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问和修改**响应**对象的指定方法如下：
- en: '| **To access** | **To modify** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **访问** | **修改** |'
- en: '|'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`getStatusCode()`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取状态码`getStatusCode()`
- en: '`getReasonPhrase()`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getReasonPhrase()`'
- en: '|'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`withStatus($code, $reasonPhrase = '''')`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withStatus($code, $reasonPhrase = '''')`'
- en: '|'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Since PSR-7 was accepted on 18 May 2015, many packages have been made based
    on it. You can develop your own version as long as you implement the interfaces
    and methods specified in PSR-7\. However, you might be "reinventing the wheel"
    since there are PSR-7 HTTP messages packages out there already – unless you have
    some strong reasons to do so. So, for the sake of getting it started quickly,
    let''s use `zend-diactoros` from Zend Framework. We will "reuse" the PSR knowledge
    (PSR-12 and PSR-4) you gained in the previous sections to create a simple "Hello
    World" server-side app with HTTP messages. Let''s get started:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2015年5月18日接受了PSR-7以来，许多基于它制作的软件包已经问世。只要实现了PSR-7中指定的接口和方法，就可以开发自己的版本。然而，除非你有充分的理由这样做，否则你可能会“重复造轮子”，因为已经有了PSR-7
    HTTP消息软件包。因此，为了快速开始，让我们使用Zend Framework中的`zend-diactoros`。我们将“重用”你在前几节中学到的PSR知识（PSR-12和PSR-4）来创建一个简单的基于HTTP消息的“Hello
    World”服务器端应用程序。让我们开始吧：
- en: 'Create a `/public/` directory in the app root with an `index.php` file in it.
    Add the following lines to it to bootstrap the app environment:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序根目录中创建一个`/public/`目录，并在其中添加一个`index.php`文件。将以下行添加到其中以引导应用程序环境：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In these two lines of code, we have changed the current directory from `/path/to/public` to `/path/to` so
    that we can import the `autoload.php` file by writing `vendor/autoload.php` instead
    of `../vendor/autoload.php`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两行代码中，我们已将当前目录从`/path/to/public`更改为`/path/to`，以便我们可以通过写`vendor/autoload.php`而不是`../vendor/autoload.php`来导入`autoload.php`文件。
- en: The `__DIR__` (magic) constant is used to get the directory path of the current
    file, which is `index.php`, in the `/path/to/public/` directory. The `dirname` function
    is then used to get the parent directory's path, which is `/path/to`.  The `chdir` function
    is then used to change the current directory.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`__DIR__`（魔术）常量用于获取当前文件的目录路径，即`index.php`，位于`/path/to/public/`目录中。然后使用`dirname`函数获取父目录的路径，即`/path/to`。然后使用`chdir`函数来改变当前目录。'
- en: 'Note that in the upcoming sections on PSRs, we will use this pattern to bootstrap
    the app environment and import the autoload file. Please visit the following links
    to find out more about the constants and functions mentioned previously:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在接下来关于PSR的章节中，我们将使用这种模式来引导应用程序环境并导入自动加载文件。请访问以下链接以了解更多关于之前提到的常量和函数：
- en: The `__DIR__` (magic) constant: [https://www.php.net/manual/en/language.constants.predefined.php](https://www.php.net/manual/en/language.constants.predefined.php)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__DIR__`（魔术）常量：[https://www.php.net/manual/en/language.constants.predefined.php](https://www.php.net/manual/en/language.constants.predefined.php)'
- en: The `dirname` function: [https://www.php.net/manual/en/function.dirname.php](https://www.php.net/manual/en/function.dirname.php)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dirname`函数：[https://www.php.net/manual/en/function.dirname.php](https://www.php.net/manual/en/function.dirname.php)'
- en: The `chdir` function: [https://www.php.net/manual/en/function.chdir.php](https://www.php.net/manual/en/function.chdir.php)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chdir`函数：[https://www.php.net/manual/en/function.chdir.php](https://www.php.net/manual/en/function.chdir.php)'
- en: 'Also, note that you must run all the incoming PHP apps on a terminal by using
    the built-in PHP web server, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，您必须通过使用内置的PHP Web服务器在终端上运行所有传入的PHP应用程序，如下所示：
- en: '[PRE65]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Install `zend-diactoros` into the app''s root directory via Composer:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Composer将`zend-diactoros`安装到应用程序的根目录：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To marshal an incoming request, you should create a request object in the `index.php` file
    in the `/public/` directory, as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要整理传入的请求，您应该在`/public/`目录中的`index.php`文件中创建一个请求对象，如下所示：
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, we can create a response object and manipulate the response, as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个响应对象并对响应进行操作，如下所示：
- en: '[PRE68]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Note that the `write` method is specified in the stream interface (`StreamInterface`)
    and that we can also append more data by making multiple calls with this method:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意`write`方法在流接口（`StreamInterface`）中指定，我们也可以通过多次调用此方法来追加更多数据：
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can then manipulate the headers if needed:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，我们可以操作标头。
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Note that the headers should be added after data is written to the body. Then,
    that''s it – you have managed to transform the simple PHP "Hello World" app that
    you learned about at the beginning of this chapter into a modern PHP app with
    PSR-7! However, if you run this PSR-7 "Hello World" app on your browser with `php
    -S localhost:8181 -t public` from your terminal, you will see nothing on the screen.
    This is because we did not **emit** the response to the browser with **PSR-15
    HTTP Server Request Handlers** and **PSR-7 HTTP Response Emitter**, which we will
    cover in the next section. If you want to see the output, for now, you can access
    the data by using the `getBody` method and then using `echo`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，头部应在数据写入主体后添加。然后，您已经成功将您在本章开头学到的简单PHP“Hello World”应用程序转换为具有PSR-7的现代PHP应用程序！但是，如果您在终端中使用`php
    -S localhost:8181 -t public`运行此PSR-7“Hello World”应用程序在浏览器上，您将看不到任何内容。这是因为我们没有使用**PSR-15
    HTTP服务器请求处理程序**和**PSR-7 HTTP响应发射器**将响应发送到浏览器，我们将在下一节中介绍。如果您现在想看到输出，可以使用`getBody`方法访问数据，然后使用`echo`：
- en: '[PRE71]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If you inspect the `Content-type` of your page through the Developer Tools on
    Chrome, you'll get `text/html` instead of `text/plain`, which is what we modified
    with the `withHeader` method. We will get the correct content type with the emitter
    in the next chapter.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您通过Chrome的开发者工具检查页面的`Content-type`，您将得到`text/html`而不是我们用`withHeader`方法修改的`text/plain`。我们将在下一章中使用发射器获得正确的内容类型。
- en: 'For more information about `zend-diactoros` and their advanced usage, please
    visit [https://docs.zendframework.com/zend-diactoros/](https://docs.zendframework.com/zend-diactoros/).
    Besides `zend-diactoros` from Zend Framework, you also can use the HTTP messages
    package from other frameworks and libraries:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`zend-diactoros`及其高级用法的更多信息，请访问[https://docs.zendframework.com/zend-diactoros/](https://docs.zendframework.com/zend-diactoros/)。除了Zend
    Framework的`zend-diactoros`之外，您还可以使用其他框架和库的HTTP消息包：
- en: Guzzle and PSR-7 from Guzzle at [http://docs.guzzlephp.org/en/latest/psr7.html](http://docs.guzzlephp.org/en/latest/psr7.html)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Guzzle的Guzzle和PSR-7在[http://docs.guzzlephp.org/en/latest/psr7.html](http://docs.guzzlephp.org/en/latest/psr7.html)
- en: HTTPlug from PHP-HTTP at [http://docs.php-http.org/en/latest/](http://docs.php-http.org/en/latest/)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP-HTTP的HTTPlug在[http://docs.php-http.org/en/latest/](http://docs.php-http.org/en/latest/)
- en: The PSR-7 Bridge from Symfony at [https://symfony.com/doc/master/components/http_foundation.html](https://symfony.com/doc/master/components/http_foundation.html)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Symfony的PSR-7桥梁在[https://symfony.com/doc/master/components/http_foundation.html](https://symfony.com/doc/master/components/http_foundation.html)
- en: Slim at [http://www.slimframework.com](http://www.slimframework.com)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Slim在[http://www.slimframework.com](http://www.slimframework.com)
- en: You should check out the PSR-7 documentation at [https://www.php-fig.org/psr/psr-7/](https://www.php-fig.org/psr/psr-7/) for
    more information about this PSR. If you are new to PHP interfaces, please visit [https://www.php.net/manual/en/language.oop5.interfaces.php](https://www.php.net/manual/en/language.oop5.interfaces.php) for
    further reading.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该查看[https://www.php-fig.org/psr/psr-7/](https://www.php-fig.org/psr/psr-7/)上的PSR-7文档，以获取有关此PSR的更多信息。如果您是PHP接口的新手，请访问[https://www.php.net/manual/en/language.oop5.interfaces.php](https://www.php.net/manual/en/language.oop5.interfaces.php)进行进一步阅读。
- en: 'From the PSR-7 documentation, you can find out the rest of the public methods
    that are not mentioned in this book. They should be expected in any PSR-7 HTTP
    messages package, such as `zend-diactoros`. It is useful to know about these methods
    so you know what you can do with them. You also can use the built-in PHP `get_class_methods`
    method at runtime to list all the methods that you can use in the request and
    response objects. For example, for the `request` object, you can do the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 从PSR-7文档中，您可以找到本书中未提及的其他公共方法。它们应该在任何PSR-7 HTTP消息包中都可以找到，比如`zend-diactoros`。了解这些方法很有用，这样您就知道可以用它们做什么。您还可以在运行时使用内置的PHP
    `get_class_methods` 方法列出您可以在请求和响应对象中使用的所有方法。例如，对于`request`对象，您可以执行以下操作：
- en: '[PRE72]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You will get a list of request methods in an array that you can call. The same
    goes for the `response` object; you will get a list of response methods in an
    array by doing this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得一个可以调用的请求方法列表的数组。对于`response`对象也是一样；通过这样做，您将获得一个响应方法列表的数组：
- en: '[PRE73]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, let's move on and look at **PSR-15**, where we'll find out how to emit
    the response to the client (browser).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续并查看**PSR-15**，在那里我们将了解如何向客户端（浏览器）发出响应。
- en: PSR-15 – HTTP Server Request Handlers (request handlers)
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PSR-15 - HTTP服务器请求处理程序（请求处理程序）
- en: PSR-7 was a great step in the PHP community, but it is only halfway to the goal
    that **could** free PHP coders from monolithic MVC frameworks and allow them to
    compose agnostic PHP apps out of a range of reusable middlewares. It only defines
    HTTP messages (the request and the response); it never defines how to deal with
    them afterward. So, we need a request handler to process the request in order
    to produce a response.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-7是PHP社区的一个重要进步，但它只是实现目标的一半，**可能**使PHP编码人员摆脱庞大的MVC框架，并允许他们从一系列可重用的中间件中组合出不可知的PHP应用。它只定义了HTTP消息（请求和响应）；它从未定义如何处理它们。因此，我们需要一个请求处理程序来处理请求以产生响应。
- en: 'Like PSR-7, PSR-15 is a set of common interfaces, but they take things a step
    further and specify the standard for request handlers (HTTP server request handlers)
    and middleware (HTTP server request middleware). It was accepted on 22 January
    2018\. We will cover the HTTP server request middleware in the next section. Now,
    let''s understand the HTTP server request handlers in the PSR-15 interface, `RequestHandlerInterface`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与PSR-7一样，PSR-15是一组常见接口，但它们更进一步，并指定了请求处理程序（HTTP服务器请求处理程序）和中间件（HTTP服务器请求中间件）的标准。它于2018年1月22日被接受。我们将在下一节中介绍HTTP服务器请求中间件。现在，让我们了解PSR-15接口中的HTTP服务器请求处理程序`RequestHandlerInterface`：
- en: '[PRE74]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As you can see, this is a very simple interface. It only has one specified
    public method, `handle`, which only accepts a PSR-7 HTTP request message and **must**
    return a PSR-7 HTTP response message. We will use the `zend-httphandlerrunner`
    component from Zend Framework, which implements this interface, to provide utilities
    that we can use to emit PSR-7 responses. Let''s get it hooked up to the app:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这是一个非常简单的接口。它只有一个指定的公共方法`handle`，它只接受一个PSR-7 HTTP请求消息，并且**必须**返回一个PSR-7
    HTTP响应消息。我们将使用Zend Framework的`zend-httphandlerrunner`组件来实现这个接口，以提供我们可以用来发出PSR-7响应的实用工具。让我们将其连接到应用程序：
- en: 'Install `zend-httphandlerrunner` via Composer:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Composer安装`zend-httphandlerrunner`：
- en: '[PRE75]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As soon as we have it installed in our project environment, we can send the
    response that we created previously to the browser, as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们在项目环境中安装好了，我们可以将之前创建的响应发送到浏览器，如下所示：
- en: '[PRE76]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If you inspect `Content-Type` of your page again through the Developer Tools
    on Chrome, you'll get the correct content type, which is `text/plain`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过Chrome的开发者工具再次检查页面的`Content-Type`，您将获得正确的内容类型，即`text/plain`。
- en: For more information about `zend-httphandlerrunner`, visit [https://docs.zendframework.com/zend-httphandlerrunner/](https://docs.zendframework.com/zend-httphandlerrunner/).
    For more information about PSR-15, visit [https://www.php-fig.org/psr/psr-15/](https://www.php-fig.org/psr/psr-15/).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`zend-httphandlerrunner`的更多信息，请访问[https://docs.zendframework.com/zend-httphandlerrunner/](https://docs.zendframework.com/zend-httphandlerrunner/)。有关PSR-15的更多信息，请访问[https://www.php-fig.org/psr/psr-15/](https://www.php-fig.org/psr/psr-15/)。
- en: 'Besides `zend-httphandlerrunner`, you can also use Http Response Emitter from
    Narrowspark at [https://github.com/narrowspark/http-emitter](https://github.com/narrowspark/http-emitter)
    to handle the request and emit the response. Now, let''s move on and look at the
    **second interface** of PSR-15: `MiddlewareInterface`.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`zend-httphandlerrunner`，您还可以使用Narrowspark的Http Response Emitter [https://github.com/narrowspark/http-emitter](https://github.com/narrowspark/http-emitter)
    来处理请求并发出响应。现在，让我们继续看一下PSR-15的**第二个接口**：`MiddlewareInterface`。
- en: PSR-15 – HTTP Server Request Handlers (middleware)
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PSR-15 - HTTP服务器请求处理程序（中间件）
- en: 'The middleware interface in PSR-15 has the following abstraction:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-15中的中间件接口具有以下抽象：
- en: '[PRE77]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Again, you can see it is a very simple interface. It only has one specified
    public method process for middleware implementation. The component (middleware)
    that implements this interface will only accept a PSR-7 HTTP request message and
    a PSR-15 HTTP server request handler and then **must** return a PSR-7 HTTP response
    message.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您可以看到这是一个非常简单的接口。它只有一个指定的公共方法`process`用于中间件实现。实现这个接口的组件（中间件）将只接受一个PSR-7 HTTP请求消息和一个PSR-15
    HTTP服务器请求处理程序，然后**必须**返回一个PSR-7 HTTP响应消息。
- en: 'We will use the `zend-stratigility` components from Zend Framework, which implement
    this interface, to allow us to create PSR-15 middleware in our app. Let''s learn
    how to get it hooked up to the app:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Zend Framework的`zend-stratigility`组件来实现这个接口，以便我们可以在我们的应用程序中创建PSR-15中间件。让我们学习如何将其连接到应用程序：
- en: 'Install `zend-stratigility` via Composer:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Composer安装`zend-stratigility`：
- en: '[PRE78]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As soon as we have it installed in our project environment, we will import
    the `middleware` function and `MiddlewarePipe` class, as follows:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们在项目环境中安装了它，我们将导入`middleware`函数和`MiddlewarePipe`类，如下所示：
- en: '[PRE79]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then, we can use this `middleware` function to create **three** middlewares
    and attach them to the pipeline, as follows:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这个`middleware`函数创建**三个**中间件并将它们附加到管道中，如下所示：
- en: '[PRE80]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'As you can see, the "Hello World" code block we created previously now is a
    piece of middleware that''s stacked with other middleware. Finally, we can generate
    a **final** response from these pieces of middleware and emit it to the browser,
    as follows:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，“Hello World”代码块我们之前创建的现在是一个与其他中间件堆叠在一起的中间件。最后，我们可以从这些中间件生成一个**最终**响应并将其发出到浏览器，如下所示：
- en: '[PRE81]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You should get a result similar to the following on your browser at `0.0.0.0:8181`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在`0.0.0.0:8181`的浏览器上获得类似以下的结果：
- en: '[PRE82]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: For more information about `zend-stratigility`, visit [https://docs.zendframework.com/zend-stratigility/](https://docs.zendframework.com/zend-stratigility/).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`zend-stratigility`的更多信息，请访问[https://docs.zendframework.com/zend-stratigility/](https://docs.zendframework.com/zend-stratigility/)。
- en: 'Besides `zend-stratigility`, you can also use the following packages to create
    your middleware:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`zend-stratigility`，您还可以使用以下软件包来创建您的中间件：
- en: Northwoods Broker at [https://github.com/northwoods/broker](https://github.com/northwoods/broker)
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Northwoods Broker at [https://github.com/northwoods/broker](https://github.com/northwoods/broker)
- en: Relay at [https://relayphp.com/](https://relayphp.com/)
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Relay at [https://relayphp.com/](https://relayphp.com/)
- en: So, there you go. With the help of several interoperable components, we have
    bootstrapped a modern PHP app that complies with PSR-12, PSR-7, and PSR-15, which
    means you can freely pick (agnostically) from a broad range of vendor implementations
    of those standards for your HTTP messages, request handler, and middleware. But
    we haven't finished yet. As you may have noticed, the app we have created is just
    a one-page app that runs on a single "route" at `0.0.0.0:8181`. It doesn't have
    any other routes, such as `/about`, `/contact`, and so on. Therefore, we need
    a router that implements PSR-15\. We'll cover this in the next section.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，就是这样。借助几个可互操作的组件，我们已经启动了一个符合PSR-12、PSR-7和PSR-15的现代PHP应用程序，这意味着您可以自由地从广泛的供应商实现中（不可知论）选择用于HTTP消息、请求处理程序和中间件的标准。但我们还没有完成。您可能已经注意到，我们创建的应用程序只是一个在`0.0.0.0:8181`上运行的单页面应用程序。它没有其他路由，如`/about`、`/contact`等。因此，我们需要一个实现PSR-15的路由器。我们将在下一节中介绍这个。
- en: PSR-7/PSR-15 router
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PSR-7/PSR-15路由器
- en: We will use Route from The League of Extraordinary Packages (a PHP developer
    group) so that we have a PSR-7 routing system and dispatch our PSR-15 middleware
    on it. In short, Route is a fast PSR-7 routing/dispatcher package.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自The League of Extraordinary Packages（一个PHP开发者组）的Route，以便我们拥有一个PSR-7路由系统，并在其上调度我们的PSR-15中间件。简而言之，Route是一个快速的PSR-7路由/调度程序包。
- en: It is a PSR-15 server request handler and can handle the invocation of a stack
    of middleware. It is built on top of FastRoute ([https://github.com/nikic/FastRoute](https://github.com/nikic/FastRoute))
    by Nikita Popov.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个PSR-15服务器请求处理程序，可以处理一系列中间件的调用。它是建立在Nikita Popov的FastRoute ([https://github.com/nikic/FastRoute](https://github.com/nikic/FastRoute))之上。
- en: 'Let''s learn how to get it hooked up to the app:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何将其连接到应用程序：
- en: 'Install `league/route` via Composer:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Composer安装`league/route`：
- en: '[PRE83]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Once you have it installed, we can refactor our "Hello World" component with
    a route, as follows:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后，我们可以按如下方式重构我们的“Hello World”组件以使用路由：
- en: '[PRE84]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Then, we just have to create a PSR-7 HTTP response by using a `dispatch` method
    from Route and emitting it to the browser:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们只需使用Route的`dispatch`方法创建一个PSR-7 HTTP响应，并将其发送到浏览器：
- en: '[PRE85]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Check out the list of HTTP request methods (`get`, `post`, `put`, `delete`,
    and so on) that you can use at [https://route.thephpleague.com/4.x/route](https://route.thephpleague.com/4.x/route).
    What's more, we can attach middleware to our app.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 查看您可以在[https://route.thephpleague.com/4.x/route](https://route.thephpleague.com/4.x/route)使用的HTTP请求方法列表（`get`、`post`、`put`、`delete`等）。此外，我们可以将中间件附加到我们的应用程序。
- en: 'If you want to lock down the entire app, you can add the middleware to the
    router, as follows:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想锁定整个应用程序，可以将中间件添加到路由器，如下所示：
- en: '[PRE86]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If you want to lock down a group of routes, you can add the middleware to the
    group, as follows:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想锁定一组路由，可以将中间件添加到该组，如下所示：
- en: '[PRE87]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If you want to lock down a specific route, you can add the middleware to that
    route, as follows:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想锁定特定路由，可以将中间件添加到该路由，如下所示：
- en: '[PRE88]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'For example, you can use Route with `zend-stratigility`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，您可以使用`zend-stratigility`与Route：
- en: '[PRE89]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If you don''t want to use the `middleware` function or prefer not to use `zend-stratigility`
    at all, you can create anonymous middleware, as follows:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不想使用`middleware`函数，或者根本不想使用`zend-stratigility`，您可以创建匿名中间件，如下所示：
- en: '[PRE90]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As long as you comply with PSR7 and PSR-15 by implementing the `process` method
    in your middleware, there's no need for `zend-stratigility` at all. If you want
    to create class-based middleware in a separate PHP file, please check out the
    example provided at [https://route.thephpleague.com/4.x/middleware/](https://route.thephpleague.com/4.x/middleware/).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您遵守PSR7和PSR-15，通过在中间件中实现`process`方法，就无需`zend-stratigility`。如果您想在单独的PHP文件中创建基于类的中间件，请查看提供的示例[https://route.thephpleague.com/4.x/middleware/](https://route.thephpleague.com/4.x/middleware)。
- en: 'For more information about Route from The League of Extraordinary Packages,
    visit [https://route.thephpleague.com/](https://route.thephpleague.com/). You
    can also check out other packages that have been created by this group of developers
    at [https://thephpleague.com](https://thephpleague.com)/. Besides Route from The
    League of Extraordinary, you can also use the following packages for HTTP routers
    based on PSR-7 and PSR-15:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有关The League of Extraordinary Packages的Route的更多信息，请访问[https://route.thephpleague.com/](https://route.thephpleague.com/)。您还可以查看由这个开发人员组创建的其他软件包，网址为[https://thephpleague.com](https://thephpleague.com)/。除了The
    League of Extraordinary的Route之外，您还可以使用以下基于PSR-7和PSR-15的HTTP路由器软件包：
- en: '`delolmo/symfony-router` at [https://github.com/delolmo/symfony-router](https://github.com/delolmo/symfony-router)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delolmo/symfony-router`在[https://github.com/delolmo/symfony-router](https://github.com/delolmo/symfony-router)'
- en: '`middlewares/aura-router` at [https://github.com/middlewares/aura-router](https://github.com/middlewares/aura-router)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`middlewares/aura-router`在[https://github.com/middlewares/aura-router](https://github.com/middlewares/aura-router)'
- en: '`middlewares/fast-route` at [https://github.com/middlewares/fast-route](https://github.com/middlewares/fast-route)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`middlewares/fast-route`在[https://github.com/middlewares/fast-route](https://github.com/middlewares/fast-route)'
- en: '`timtegeler/routerunner` at [https://github.com/timtegeler/routerunner](https://github.com/timtegeler/routerunner)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timtegeler/routerunner`在[https://github.com/timtegeler/routerunner](https://github.com/timtegeler/routerunner)'
- en: '`sunrise-php/http-router` at [https://github.com/sunrise-php/http-router](https://github.com/sunrise-php/http-router)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sunrise-php/http-router`在[https://github.com/sunrise-php/http-router](https://github.com/sunrise-php/http-router)'
- en: You may need a dispatcher to use with some of these packages. The advantage
    of using Route from The League of Extraordinary Packages is that it provides a
    router and a dispatcher in one package.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要一个分发器来与其中一些软件包一起使用。使用The League of Extraordinary Packages的Route的优势在于它提供了一个路由器和一个分发器在一个软件包中。
- en: With that, we have composed an agnostic PHP app by using PSR-12, PSR-4, PSR-7,
    and PSR-15\. But our PHP API isn't done yet. There's one more task to do – we
    need to add a database framework for CRUD operations. We will guide you through
    this task in the next section.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们通过使用PSR-12、PSR-4、PSR-7和PSR-15，编写了一个不可知的PHP应用程序。但是我们的PHP API还没有完成。还有一项任务要做——我们需要为CRUD操作添加一个数据库框架。我们将在下一节中指导您完成这项任务。
- en: Writing CRUD operations with PHP database frameworks
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP数据库框架编写CRUD操作
- en: As you may recall from [Chapter 9](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml),
    *Adding a Server-Side Database*, **CRUD** stands for **c**reate, **r**ead, **u**pdate,
    and **d**elete. In that chapter, we used MongoDB to create CRUD operations. In
    this section, we will use MySQL to create backend authentication. We will use
    MySQL with PHP in the PHP app we have just created with PSRs. So, let's start
    by creating the table that we will need in the MySQL database.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得的那样[第9章](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml)，*添加服务器端数据库*，**CRUD**代表**c**reate，**r**ead，**u**pdate和**d**elete。在那一章中，我们使用MongoDB来创建CRUD操作。在本节中，我们将使用MySQL来创建后端身份验证。我们将在刚刚使用PSRs创建的PHP应用程序中使用MySQL和PHP。因此，让我们首先创建我们在MySQL数据库中需要的表。
- en: Creating MySQL tables
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建MySQL表
- en: 'Make sure you have installed MySQL Server on your local machine and created
    a database called `nuxt-php`. Once you''ve done that, follow these steps to finish
    up the first part of our API:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已在本地计算机上安装了MySQL服务器并创建了一个名为`nuxt-php`的数据库。完成这些操作后，请按照以下步骤完成我们API的第一部分：
- en: 'Insert the following SQL query to create the table in the database:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库中插入以下SQL查询以创建表：
- en: '[PRE91]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The first thing you will have noticed is that we are using `uuid` instead of
    `id` like we did in [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml), *Creating
    User Logins and API Authentication*. UUID stands for **Universally Unique Identifier**.
    There may be reasons why and benefits that will make you want to choose UUIDs
    over auto increment keys for indexing records in database tables. For example,
    you can create a UUID without connecting to the database. It is practically unique
    across apps, so you can easily combine data from different databases and never
    get a clash. To generate UUIDs in a PHP app, we can use `ramsey/uuid` by Ben Ramsey
    to help us generate RFC 4122 ([https://tools.ietf.org/html/rfc4122](https://tools.ietf.org/html/rfc4122))
    version 1, 3, 4, and 5 UUIDs.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到的第一件事是，我们使用的是`uuid`而不是像我们在[第12章](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml)中所做的`id`。UUID代表**通用唯一标识符**。可能有一些原因和好处会让您选择UUID而不是自动递增键来索引数据库表中的记录。例如，您可以在不连接到数据库的情况下创建UUID。它在应用程序中几乎是唯一的，因此您可以轻松地从不同的数据库中组合数据而永远不会发生冲突。为了在PHP应用程序中生成UUID，我们可以使用Ben
    Ramsey的`ramsey/uuid`来帮助我们生成RFC 4122（[https://tools.ietf.org/html/rfc4122](https://tools.ietf.org/html/rfc4122)）版本1、3、4和5的UUID。
- en: 'So, let''s install `ramsey/uuid` via Composer:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，让我们通过Composer安装`ramsey/uuid`：
- en: '[PRE92]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, you can use this package to generate version 1 of UUID, as follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用这个包来生成UUID的第一个版本，如下所示：
- en: '[PRE93]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: If you want to find out more information about this package, visit [https://github.com/ramsey/uuid](https://github.com/ramsey/uuid).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于这个包的信息，请访问[https://github.com/ramsey/uuid](https://github.com/ramsey/uuid)。
- en: Now, let's learn how to use PHP to work with MySQL databases and find out why
    we need a database framework to speed up our development in PHP.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用PHP来处理MySQL数据库，并了解为什么我们需要一个数据库框架来加快PHP开发速度。
- en: Using Medoo as a database framework
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Medoo作为数据库框架
- en: 'In the old days of PHP, developers used MySQL functions ([https://www.php.net/manual/en/ref.mysql.php](https://www.php.net/manual/en/ref.mysql.php))
    to manage MySQL databases. Then, the MySQLi extension ([https://www.php.net/manual/en/book.mysqli.php](https://www.php.net/manual/en/book.mysqli.php))
    came to replace MySQL functions, which are now deprecated. However, now, developers
    are encouraged to use **PHP Data Objects** (**PDO**) ([https://www.php.net/manual/en/book.pdo.php](https://www.php.net/manual/en/book.pdo.php)).
    PDO is a built-in PHP interface abstraction, just like PSR-7 and PSR-15 are. It
    is a data-access abstraction layer that provides a consistent interface (a unified
    API) for accessing and managing databases (for example, MySQL and PostgreSQL),
    which means regardless of which database you are using, you use the same functions
    to query and fetch data. It supports the following databases:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP的旧时代，开发人员使用MySQL函数（[https://www.php.net/manual/en/ref.mysql.php](https://www.php.net/manual/en/ref.mysql.php)）来管理MySQL数据库。然后，MySQLi扩展（[https://www.php.net/manual/en/book.mysqli.php](https://www.php.net/manual/en/book.mysqli.php)）取代了现在已经弃用的MySQL函数。然而，现在，开发人员被鼓励使用**PHP数据对象**（**PDO**）（[https://www.php.net/manual/en/book.pdo.php](https://www.php.net/manual/en/book.pdo.php)）。PDO是一个内置的PHP接口抽象，就像PSR-7和PSR-15一样。它是一个数据访问抽象层，为访问和管理数据库（例如MySQL和PostgreSQL）提供了一个一致的接口（统一的API），这意味着无论你使用哪种数据库，你都可以使用相同的函数来查询和获取数据。它支持以下数据库：
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: CUBRID
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUBRID
- en: MS SQL Server
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MS SQL Server
- en: Firebird
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebird
- en: IBM
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM
- en: '|'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Informix
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Informix
- en: MySQL
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL
- en: Oracle
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle
- en: ODBC and DB2
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ODBC和DB2
- en: '|'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: PostgreSQL
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: SQLite
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite
- en: 4D
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4D
- en: '|'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Note that PDO is a data-access abstraction layer, not a database abstraction
    layer. Hence, depending on which database you use, a PDO driver for that database
    must be installed for using PDO. We are using a MySQL database, so we must make
    sure that the `PDO_MYSQL` driver is installed. In Ubuntu, you can use the following
    command to check whether you have the PDO extension is enabled and that `PDO_MYSQL`
    driver is installed in your environment:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PDO是一个数据访问抽象层，而不是数据库抽象层。因此，取决于您使用的数据库，必须安装该数据库的PDO驱动程序才能使用PDO。我们正在使用MySQL数据库，因此必须确保安装了`PDO_MYSQL`驱动程序。在Ubuntu中，您可以使用以下命令来检查您是否已启用PDO扩展，并且`PDO_MYSQL`驱动程序已安装在您的环境中：
- en: '[PRE94]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You should get a list of PHP modules. Look for `PDO` and `pdo_mysql`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到一系列PHP模块。查找`PDO`和`pdo_mysql`：
- en: '[PRE95]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Another more specific option you can use to check for PDO and its drivers is
    as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更具体的选项是检查PDO及其驱动程序，如下所示：
- en: '[PRE96]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If you just want to search for PDO drivers, do the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想搜索PDO驱动程序，请执行以下操作：
- en: '[PRE97]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You can also create a PHP page with `phpinfo()` to look for them. Alternatively,
    you can use the `getAvailableDrivers` method, as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个带有`phpinfo()`的PHP页面来查找它们。或者，您可以使用`getAvailableDrivers`方法，如下所示：
- en: '[PRE98]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You should get a list of PDO drivers, as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到一系列PDO驱动程序，如下所示：
- en: '[PRE99]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Alternatively, there are some built-in PHP functions that can help you:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，还有一些内置的PHP函数可以帮助您：
- en: '[PRE100]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If you don''t see any PDO drivers, then you must install the driver for MySQL
    support. Follow these steps to do so:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到任何PDO驱动程序，则必须安装MySQL支持的驱动程序。请按照以下步骤执行：
- en: 'Search for the package name (Ubuntu):'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索软件包名称（Ubuntu）：
- en: '[PRE101]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Install `php7.4-mysql` and restart your Apache server:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`php7.4-mysql`并重新启动Apache服务器：
- en: '[PRE102]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Once you have the `PDO_MYSQL` driver in place, you can start writing CRUD operations
    immediately. For example, let''s write an `insert` operation, as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了`PDO_MYSQL`驱动程序，就可以立即开始编写CRUD操作。例如，让我们编写一个`insert`操作，如下所示：
- en: 'Create the MySQL database connection:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建MySQL数据库连接：
- en: '[PRE103]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note that `<username>`, `<password>`, and `<dbname>` are placeholders for the
    actual connection details. You must change them according to your own database
    settings.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`<username>`，`<password>`和`<dbname>`是实际连接详细信息的占位符。您必须根据自己的数据库设置进行更改。
- en: 'Prepare the SQL query and `bind` parameters:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备SQL查询并“绑定”参数：
- en: '[PRE104]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Insert a fresh row:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入一行新数据：
- en: '[PRE105]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This is not ideal because you have to `prepare` the statement every time and
    bind parameters where they needed, and this takes quite a lot of lines to operate.
    For this reason, we should pick a PHP database framework to accelerate development.
    **Medoo** ([https://medoo.in/](https://medoo.in/)) is one of the choices out there.
    It is lightweight and very easy to integrate and use.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不理想，因为您必须每次“准备”语句并绑定参数，这需要相当多的行来操作。因此，我们应该选择一个PHP数据库框架来加速开发。**Medoo** ([https://medoo.in/](https://medoo.in/))是其中的一个选择。它非常轻量级，非常容易集成和使用。
- en: 'Let''s get it installed and hooked up to our app:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装并连接到我们的应用程序：
- en: 'Install Medoo via Composer:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Composer安装Medoo：
- en: '[PRE106]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'If everything is set and in place, you can import Medoo and pass in an array
    of configuration to start the database connection, just as we did previously in
    the vanilla approach:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切都设置好了，您可以导入Medoo并传递一个配置数组来启动数据库连接，就像我们之前在原始方法中所做的那样：
- en: '[PRE107]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: That's it for establishing a connection to the MySQL database through this database
    framework. You can find the actual usage of this snippet in `/chapter-16/nuxt-php/proxy/backend/core/mysql.php`
    in this book's GitHub repository. We will show you how to implement it in the
    upcoming section, but for now, let's explore how to write some basic CRUD operations
    with Medoo.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个数据库框架建立与MySQL数据库的连接就到此为止。您可以在本书的GitHub存储库中的`/chapter-16/nuxt-php/proxy/backend/core/mysql.php`中找到此片段的实际用法。我们将在接下来的部分中向您展示如何实现它，但现在让我们探索如何使用Medoo编写一些基本的CRUD操作。
- en: Inserting records
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入记录
- en: 'You can use the `insert` method when you want to insert new records into a
    table, as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要向表中插入新记录时，可以使用`insert`方法，如下所示：
- en: '[PRE108]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: If you want to find out more details about this method, visit [https://medoo.in/api/insert](https://medoo.in/api/insert).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关此方法的更多细节，请访问[https://medoo.in/api/insert](https://medoo.in/api/insert)。
- en: Querying records
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询记录
- en: 'You can use the `select` method when you want to list records from a table,
    as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要列出表中的记录时，可以使用`select`方法，如下所示：
- en: '[PRE109]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The `select` method gives you a list of records. If you just want to select
    a specific row, you can use the `get` method, as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`方法会给您一个记录列表。如果您只想选择特定行，可以使用`get`方法，如下所示：'
- en: '[PRE110]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: If you want to find out more details, visit [https://medoo.in/api/select](https://medoo.in/api/select)
    for the `select` method and [https://medoo.in/api/get](https://medoo.in/api/get)
    for the `get` method.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多细节，请访问[https://medoo.in/api/select](https://medoo.in/api/select)查看`select`方法和[https://medoo.in/api/get](https://medoo.in/api/get)查看`get`方法。
- en: Updating records
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新记录
- en: 'You can use the `update` method when you want to modify the data of a record
    in a table, as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要修改表中记录的数据时，可以使用`update`方法，如下所示：
- en: '[PRE111]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: If you want to find out more details about this method, visit [https://medoo.in/api/update](https://medoo.in/api/update).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关此方法的更多细节，请访问[https://medoo.in/api/update](https://medoo.in/api/update)。
- en: Deleting records
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除记录
- en: 'You can use the `delete` method when you want to remove a record from a table,
    as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要从表中删除记录时，可以使用`delete`方法，如下所示：
- en: '[PRE112]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: If you want to find out more details about this method, visit [https://medoo.in/api/delete](https://medoo.in/api/delete).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关此方法的更多细节，请访问[https://medoo.in/api/delete](https://medoo.in/api/delete)。
- en: That's it regarding how to write basic CRUD operations with Medoo and PDO.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用Medoo和PDO编写基本CRUD操作的全部内容。
- en: Please check out Medoo's documentation at [https://medoo.in/doc](https://medoo.in/doc)
    for the rest of the methods that you can use. There are other alternatives to
    Medoo, such as Doctrine DBAL at [https://github.com/doctrine/dbal](https://github.com/doctrine/dbal) and Eloquent
    at [https://github.com/illuminate/database](https://github.com/illuminate/database).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看Medoo的文档[https://medoo.in/doc](https://medoo.in/doc)以了解您可以使用的其他方法。还有其他替代方案，如[https://github.com/doctrine/dbal](https://github.com/doctrine/dbal)上的Doctrine
    DBAL和[https://github.com/illuminate/database](https://github.com/illuminate/database)上的Eloquent。
- en: In this section, you studied a handful of PSRs and CRUD operations. Next, we
    will cover how to put all these together and integrate them with Nuxt. Since PHP
    and JavaScript are two different languages, the only way for them to talk to each
    other is through JSON in the API.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了一些PSR和CRUD操作。接下来，我们将介绍如何将它们全部整合到Nuxt中。由于PHP和JavaScript是两种不同的语言，它们之间唯一的交流方式是通过API中的JSON。
- en: But before we write a script that will enable that, we should look into the
    cross-domain application structure for these two programs.We have been using cross-domain
    application structures for our Nuxt apps since [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml),
    *Creating User Logins and API Authentication*, so this should be familiar to you.
    Let's get started!
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 但在编写启用该功能的脚本之前，我们应该研究这两个程序的跨域应用程序结构。自从[第12章](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml)以来，我们一直在为我们的Nuxt应用程序使用跨域应用程序结构，*创建用户登录和API身份验证*，所以这对您来说应该很熟悉。让我们开始吧！
- en: Structuring cross-domain app directories
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建跨域应用程序目录
- en: 'Again, just like when structuring cross-domain app directories, the following
    is our holistic view for Nuxt and our PHP API:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，就像构建跨域应用程序目录时一样，以下是我们对Nuxt和我们的PHP API的整体视图：
- en: '[PRE113]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Individually, the directory structure for Nuxt remains the same. We only have
    to make a slight change to the API directory''s structure, as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 就Nuxt的目录结构而言，它保持不变。我们只需对API目录的结构进行轻微更改，如下所示：
- en: '[PRE114]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The directory structure for the PHP API is a suggestion. You can always design
    a structure that you prefer and that suits you the most. So, at a glance, we have
    the following:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: PHP API的目录结构是一个建议。您可以始终设计自己喜欢并最适合您的结构。因此，一目了然，我们有以下内容：
- en: The `/vendor/` directory is where all the third-party packages or dependencies
    are kept.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/vendor/`目录是存放所有第三方包或依赖项的地方。'
- en: The `/public/` directory only contains an `index.php` file that initiates our
    API.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/public/`目录只包含一个`index.php`文件，该文件启动我们的API。'
- en: The `/static/` directory for static files, such as a favicon.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/static/`目录用于静态文件，例如网站图标。'
- en: The `/config/` directory stores the configuration files, such as MySQL files.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/config/`目录存储配置文件，例如MySQL文件。'
- en: The `/core/` directory stores the common objects and functions that we can use
    across the app.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/core/`目录存储我们可以在整个应用程序中使用的常见对象和函数。'
- en: The `/middleware/` directory stores our PSR-15 middleware.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/middleware/`目录存储我们的PSR-15中间件。'
- en: The `/module/` directory stores the custom modules we will create later, just
    as we did in [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml), *Creating
    User Logins and API Authentication*, with Koa.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/module/`目录存储我们稍后将创建的自定义模块，就像我们在[第12章](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml)中所做的那样，*创建用户登录和API身份验证*，使用Koa。'
- en: The `composer.json` file is always located at the root level.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`composer.json`文件始终位于根级别。'
- en: The `middlewares.php` file is the core location for importing middleware from
    the `/middleware/` directory.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`middlewares.php`文件是从`/middleware/`目录导入中间件的核心位置。'
- en: The `routes.php` file is the core location for importing routes from the `/module/`
    directory.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes.php`文件是从`/module/`目录导入路由的核心位置。'
- en: 'Once you have the structure ready, you can start writing the top-level code
    that will glue the other code from the different locations and directory into
    a single app in the `index.php` file in the `/public/` directory. So, let''s get
    started:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您准备好结构，就可以开始编写顶级代码，将来自不同位置和目录的其他代码粘合到`/public/`目录中的`index.php`文件中，从而形成一个单一的应用程序。所以，让我们开始吧：
- en: 'Put the `foreach` loop in the `routes.php` file to iterate each module that
    you will create later:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`foreach`循环放在`routes.php`文件中，以迭代稍后将创建的每个模块：
- en: '[PRE115]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Create a `routes.php` file in the `/config/` directory that will list the filename
    of your module, as follows:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/config/`目录中创建一个`routes.php`文件，该文件将列出您的模块的文件名，如下所示：
- en: '[PRE116]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'In this PHP API, the `middlewares.php` file will import a piece of middleware
    that is used to decorate the CRUD operation''s output:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个PHP API中，`middlewares.php`文件将导入一个用于装饰CRUD操作输出的中间件片段：
- en: '[PRE117]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'This decorator will print the CRUD operation''s output in JSON in the following
    format:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 此装饰器将以以下格式以JSON格式打印CRUD操作的输出：
- en: '[PRE118]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Create a file called `outputDecorator.php` in the `/middleware/` directory
    that contains the following code. This will wrap the operation''s output in the
    preceding format:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/middleware/`目录中创建一个名为`outputDecorator.php`的文件，其中包含以下代码。这将以前述格式包装操作的输出：
- en: '[PRE119]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Here, we use the `middleware` method from the `zend-stratigility` component to
    create the decorator middleware. Then, we lock down the entire application with
    this middleware by using the router from `league/route` by The League of Extraordinary.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`zend-stratigility`组件的`middleware`方法来创建装饰器中间件。然后，我们使用The League of Extraordinary的`league/route`路由器来使用此中间件锁定整个应用程序。
- en: 'Create a `mysql.php` file in the `/core/` directory that returns the Medoo
    instance for the MySQL connection:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/core/`目录中创建一个名为`mysql.php`的文件，该文件返回MySQL连接的Medoo实例：
- en: '[PRE120]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'As we mentioned earlier, the `/public/` directory only contains an `index.php`
    file. This is used to initiate our program, so it contains the script that you
    learned about previously regarding PSRs:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`/public/`目录只包含一个`index.php`文件。这用于启动我们的程序，因此它包含了您之前学习的关于PSRs的脚本：
- en: '[PRE121]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Here, you can see that the `middlewares.php` and `routes.php` files are imported
    into this file to produce a PSR-7 response. They are wrapped in the `try` and
    `catch` blocks to catch any HTTP errors, such as 404 and 506 errors. Due to this,
    any output from the module and any errors will be emitted to the browser through
    the last line. Hopefully, this has given you a bird's-eye view on this simple
    API. Now, let's move on and dive into the `/module/` directory in more detail
    to learn how to create modules and routes.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到`middlewares.php`和`routes.php`文件被导入到这个文件中以生成一个PSR-7响应。它们被包裹在`try`和`catch`块中，以捕获任何HTTP错误，比如404和506错误。因此，模块的任何输出和错误都将通过最后一行传递到浏览器。希望这给您提供了一个对这个简单API的整体了解。现在，让我们继续深入学习`/module/`目录，以更详细地了解如何创建模块和路由。
- en: Creating the API's public routes and their modules
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建API的公共路由及其模块
- en: 'Creating the API''s public routes and their modules is very similar to the
    API you learned to build in the previous chapters of this book; the main difference
    is the language. We used JavaScript and the Node.js framework – Koa, previously,
    while for the API in this chapter, we are using PHP and PSRs to create a framework-agnostic
    API. So, let''s get started:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 创建API的公共路由及其模块与您在本书前几章中学习构建的API非常相似；主要区别在于语言。以前我们使用JavaScript和Node.js框架Koa，而在本章中的API中，我们使用PHP和PSRs来创建一个与框架无关的API。所以，让我们开始吧：
- en: 'Create two directories in the `/module/` directory: one called `Home` and another
    called `User`. These two sub-directories are the modules in this API. In each
    module, create a `/_routes/` directory and an `index.php` file that will import
    the routes from the `/_routes/` directory, as follows:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/module/`目录中创建两个目录：一个名为`Home`，另一个名为`User`。这两个子目录是API中的模块。在每个模块中，创建一个`/_routes/`目录和一个`index.php`文件，该文件将从`/_routes/`目录导入路由，如下所示：
- en: '[PRE122]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'In the `Home` module, output a "Hello world!" message and map it to the `/`
    route, as follows:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Home`模块中，输出一个“Hello world！”消息，并将其映射到`/`路由，如下所示：
- en: '[PRE123]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'In the `User` module, write the CRUD operations so that we can create, read,
    update, and delete our users. So, in the `/_routes/` directory, create five files
    called `fetch_user.php`, `fetch_users.php`, `insert_user.php`,  and `update_user.php`,
    and `delete_user.php`. In each of these files, we will map the route for each
    of the CRUD operations in the `/Controller/` directory:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`User`模块中，编写CRUD操作，以便我们可以创建、读取、更新和删除用户。因此，在`/_routes/`目录中，创建五个文件，分别为`fetch_user.php`、`fetch_users.php`、`insert_user.php`、`update_user.php`和`delete_user.php`。在这些文件中，我们将在`/Controller/`目录中为每个CRUD操作映射路由：
- en: '[PRE124]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'For example, in the `fetch_users.php` file, we will define a `/users` route
    for listing all the users, as follows:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，在`fetch_users.php`文件中，我们将定义一个`/users`路由来列出所有用户，如下所示：
- en: '[PRE125]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Here, you can see that we import the Medoo instance as `$database` and pass
    it the controller that will perform the **Read** operation and then call the `fetch`
    method to get all the available users.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们将Medoo实例作为`$database`导入，并将其传递给执行**Read**操作的控制器，然后调用`fetch`方法以获取所有可用用户。
- en: 'So, the next thing we will do is create some CRUD directories: `Insert`, `Fetch`,
    `Update`, and `Delete`. In each of these CRUD directories, we will store the PSR-4
    classes inside the `/Controller/` directory, as follows:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是创建一些CRUD目录：`Insert`，`Fetch`，`Update`和`Delete`。在每个CRUD目录中，我们将把PSR-4类存储在`/Controller/`目录中，如下所示：
- en: '[PRE126]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'First of all, create an `abstract` class that can be extended by the classes
    in the CRUD directories. This class will only accept the `Medoo\Medoo` database
    in its constructor, as follows:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`abstract`类，可以被CRUD目录中的类扩展。这个类将只在其构造函数中接受`Medoo\Medoo`数据库，如下所示：
- en: '[PRE127]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Import the preceding `abstract` class and extend it to any other classes that
    need to connect to the MySQL database, as follows:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入上述`abstract`类并将其扩展到需要连接到MySQL数据库的任何其他类中，如下所示：
- en: '[PRE128]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In this class, we use the `select` method to fetch all the users from the `user`
    table in the MySQL database. Medoo will return an `Array` containing the list
    of users or an empty `Array` if there are no users. This result will then be converted
    into JSON using the `JsonResponse` method from `zend-diactoros` in the `fetch_users.php`
    file.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们使用`select`方法从MySQL数据库的`user`表中获取所有用户。Medoo将返回一个包含用户列表的`Array`，如果没有用户，则返回一个空的`Array`。然后，使用`zend-diactoros`中的`JsonResponse`方法将结果转换为JSON，在`fetch_users.php`文件中。
- en: 'Finally, it will be decorated by the middleware in the `/middleware/` directory.
    This will result in the following output:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将被装饰在`/middleware/`目录中的中间件。这将产生以下输出：
- en: '[PRE129]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: That's it regarding the PHP API. It's pretty easy, isn't it? In this exercise,
    we will skip the task of dealing with CORS on the API side as we will be using
    the Nuxt Axios and Proxy modules to handle CORS seamlessly and effortlessly for
    us in the Nuxt app that we are going to create. So, let's get started!
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 关于PHP API就是这样了。很简单，不是吗？在这个练习中，我们将跳过在API端处理CORS的任务，因为我们将使用Nuxt Axios和Proxy模块在我们即将创建的Nuxt应用程序中无缝轻松地处理CORS。所以，让我们开始吧！
- en: You can find this PHP API in `/chapter-16/nuxt-php/proxy/backend/` and the rest
    of the CRUD classes of this API in `/chapter-16/nuxt-php/proxy/backend/module/User/Controller/`
    in this book's GitHub repository.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-16/nuxt-php/proxy/backend/`中找到这个PHP API，以及这个API的其余CRUD类在`/chapter-16/nuxt-php/proxy/backend/module/User/Controller/`中。
- en: Integrating with Nuxt
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Nuxt集成
- en: 'The `@nuxtjs/axios` module is well integrated with the `@nuxtjs/proxy` module
    and is very useful in many cases. Preventing the CORS problem is one of the benefits
    of using these two modules together. You learned how to install and use them in
    [Chapter 6](2102475f-1a6b-42c0-abaa-ec018f8fa25a.xhtml), *Writing Plugins and
    Modules*. Let''s recap:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`@nuxtjs/axios`模块与`@nuxtjs/proxy`模块很好地集成在一起，在许多情况下非常有用。防止CORS问题是使用这两个模块的好处之一。您在[第6章](2102475f-1a6b-42c0-abaa-ec018f8fa25a.xhtml)中学习了如何安装和使用它们，*编写插件和模块*。让我们回顾一下：'
- en: 'Install the `@nuxtjs/axios` and `@nuxtjs/proxy` modules via npm:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm安装`@nuxtjs/axios`和`@nuxtjs/proxy`模块：
- en: '[PRE130]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Register `@nuxtjs/axios` in the `modules` option in the Nuxt config file, as
    follows:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nuxt配置文件的`modules`选项中注册`@nuxtjs/axios`，如下所示：
- en: '[PRE131]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Note that it is not required to register the `@nuxtjs/proxy` module when you
    are using it with `@nuxtjs/axios`, as long as it is installed and in the `dependencies`
    field in `package.json`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您与`@nuxtjs/axios`一起使用`@nuxtjs/proxy`时，不需要注册`@nuxtjs/proxy`模块，只要它已安装并在`package.json`的`dependencies`字段中。
- en: 'In the preceding configuration, we use `/api/` as the proxy for `http://0.0.0.0:8181`,
    which is where our PHP API is running. So, whenever we use `/api/` in any of our
    API endpoint requests, it is calling `0.0.0.0:8181`. For example, let''s say you
    are making an API call, as follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，我们使用`/api/`作为`http://0.0.0.0:8181`的代理，这是我们的PHP API运行的地方。因此，每当我们在任何API端点请求中使用`/api/`时，它都会调用`0.0.0.0:8181`。例如，假设您正在进行API调用，如下所示：
- en: '[PRE132]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `@nuxtjs/axios` and `@nuxtjs/proxy` modules will convert that `/api/users`
    endpoint into the following:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`@nuxtjs/axios`和`@nuxtjs/proxy`模块将把`/api/users`端点转换为以下内容：'
- en: '[PRE133]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'But since we don''t use `/api/` in our PHP API''s routes, we use `pathRewrite`
    in the configuration to `remove` it during the call. Then, the actual URL that''s
    sent by the `@nuxtjs/axios` and `@nuxtjs/proxy` modules to the API is as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于我们在PHP API的路由中不使用`/api/`，所以我们在配置中使用`pathRewrite`在调用过程中将其`移除`。然后，由`@nuxtjs/axios`和`@nuxtjs/proxy`模块发送到API的实际URL如下：
- en: '[PRE134]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Once more, visit the following links for more information about these two modules:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 再次访问以下链接，了解有关这两个模块的更多信息：
- en: '[https://axios.nuxtjs.org/](https://axios.nuxtjs.org/) for `@nuxtjs/axios`'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://axios.nuxtjs.org/](https://axios.nuxtjs.org/) 用于`@nuxtjs/axios`'
- en: '[https://github.com/nuxt-community/proxy-module](https://github.com/nuxt-community/proxy-module) for `@nuxtjs/proxy`'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/nuxt-community/proxy-module](https://github.com/nuxt-community/proxy-module) 用于`@nuxtjs/proxy`'
- en: After the installation and configuration are in place, we can start creating
    the **frontend UI** for communicating with the PHP API. We'll look at this in
    the next section.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和配置完成后，我们可以开始创建用于与PHP API通信的**前端UI**。我们将在下一节中讨论这个问题。
- en: Creating CRUD pages
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建CRUD页面
- en: 'Again, this is not a completely new task to you as this is almost the same
    as creating the CRUD pages you learned to create in [Chapter 9](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml),
    *Adding a Server-Side Database*. Let''s recap:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这对您来说并不是完全新的任务，因为这几乎与您在[第9章](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml)中学习创建的CRUD页面相同，即*添加服务器端数据库*。让我们回顾一下：
- en: 'Create the following pages in the `/pages/users/` directory for sending and
    fetching data:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/pages/users/`目录中创建以下页面以发送和获取数据：
- en: '[PRE135]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'For example, use the following script to fetch all the available users:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，使用以下脚本来获取所有可用用户：
- en: '[PRE136]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The scripts, templates, and directory structure in this Nuxt app are the same
    as the app you learned to create in [Chapter 9](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml),
    *Adding a Server-Side Database*. The difference is that an `_id` was used in that
    chapter but in this chapter, we''re using `_slug`. By now, you should be able
    to complete the rest of the CRUD pages on your own. However, you can always revisit
    the following sections in [Chapter 9](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml),
    *Adding a Server-Side Database*, for more information:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Nuxt应用程序中的脚本、模板和目录结构与您在[第9章](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml)中学习创建的应用程序相同，即*添加服务器端数据库*。不同之处在于在那一章中使用了`_id`，但在这一章中，我们使用`_slug`。到目前为止，您应该能够独立完成其余的CRUD页面。但是，您可以随时回顾[第9章](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml)中的以下部分，*添加服务器端数据库*，以获取更多信息：
- en: '*Creating an Add page*'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建添加页面*'
- en: '*Creating an Update page*'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建更新页面*'
- en: '*Creating a Delete page*'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建删除页面*'
- en: Once you have created these pages, you can run the Nuxt app with `npm run dev`.
    You should see the app running on your browser at `localhost:3000`.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了这些页面后，可以使用`npm run dev`运行Nuxt应用程序。您应该在浏览器上看到应用程序在`localhost:3000`上运行。
- en: You can find the complete source code for this app in `/chapter-16/nuxt-php/proxy/frontend/nuxt-universal/`
    in this book's GitHub repository.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub存储库中的`/chapter-16/nuxt-php/proxy/frontend/nuxt-universal/`中找到此应用程序的完整源代码。
- en: If you don't want to use the `@nuxtjs/axios` and `@nuxtjs/proxy` modules in
    this Nuxt app, you can find the complete source regarding how to enable CORS in
    the PHP API for the Nuxt app in `/chapter-16/nuxt-php/cors/` in this book's GitHub
    repository.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在这个Nuxt应用中使用`@nuxtjs/axios`和`@nuxtjs/proxy`模块，你可以在本书的GitHub存储库中的`/chapter-16/nuxt-php/cors/`中找到有关如何在Nuxt应用中为PHP
    API启用CORS的完整源代码。
- en: You can also find a copy of the database saved as `user.sql` in `/chapter-16/nuxt-php/`
    in this book's GitHub repository.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在本书的GitHub存储库中的`/chapter-16/nuxt-php/`中找到名为`user.sql`的数据库副本。
- en: Now, let's summarize what you've learned in this long chapter. We hope you have
    enjoyed this chapter and found it inspiring.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结一下你在这一长章节中学到的东西。我们希望你喜欢这一章，并且觉得它很有启发性。
- en: Summary
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have not only managed to decouple a Nuxt app from an API,
    similar to what you did in [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml), *Creating
    User Logins and API Authentication*, but you also managed to write an API in a
    different language, PHP, one of the most popular server-side scripting languages
    in web development. You learned how to install PHP and Apache in order to run
    PHP apps or use the built-in PHP web server for development, all while complying
    with PSR-12, PSR4, PSR7, and PSR-15 in order to build a modern framework-agnostic
    app. You also learned to use the PHP database framework known as Medoo for writing
    CRUD operations, reusing the Nuxt app from [Chapter 9](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml), *Adding
    a Server-Side Database*, but with a few modifications, and gluing the frontend
    UI and the backend API together perfectly. Now, you also understand HTTP messages
    in more detail and know how to use PDO for modern PHP database management. Well
    done.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你不仅成功地将Nuxt应用程序与API解耦，类似于你在[第12章](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml)中所做的，*创建用户登录和API身份验证*，而且还成功地用不同的语言PHP编写了一个API，PHP是Web开发中最流行的服务器端脚本语言之一。你学会了如何安装PHP和Apache以运行PHP应用程序，或者使用内置的PHP
    Web服务器进行开发，同时遵守PSR-12、PSR4、PSR7和PSR-15，以构建一个现代的框架无关的应用程序。你还学会了使用PHP数据库框架Medoo来编写CRUD操作，重用了来自[第9章](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml)的Nuxt应用程序，*添加服务器端数据库*，但进行了一些修改，并完美地将前端UI和后端API粘合在一起。现在，你还更详细地了解了HTTP消息，并知道如何使用PDO进行现代PHP数据库管理。干得好。
- en: In the next chapter, you will discover what else you can do with Nuxt in terms
    of real-time apps. Here, you will learn about **Socket.io** and **RethinkDB**. We
    will walk you through the installation process for these two technologies. Then,
    you will learn how to perform real-time CRUD operations in a RethinkDB database,
    write real-time code in JavaScript with Socket.io, and integrate them with the
    Nuxt app. This will be another interesting and exciting chapter that we will guide
    you through. So, stay tuned!
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解Nuxt在实时应用方面还能做些什么。在那里，你将学习**Socket.io**和**RethinkDB**。我们将带你了解这两种技术的安装过程。然后，你将学习如何在RethinkDB数据库中执行实时CRUD操作，在JavaScript中使用Socket.io编写实时代码，并将它们与Nuxt应用集成。这将是另一个有趣和激动人心的章节，我们将会引导你完成。所以，敬请关注！
