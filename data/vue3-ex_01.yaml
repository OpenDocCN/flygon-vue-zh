- en: '*Chapter 1*: Creating Your First Application in Vue 3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：在Vue 3中创建您的第一个应用程序'
- en: '**Vue 3** is the latest version of the popular Vue.js framework. It is focused
    on improving developer experience and speed. It is a component-based framework
    that lets us create modular, testable apps with ease. It includes concepts that
    are common to other frameworks such as props, transitions, event handling, templates,
    directives, data binding, and more. The main goal of this chapter is to get you
    started with developing your first Vue app. This chapter is focused on how to
    create components.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vue 3**是流行的Vue.js框架的最新版本。它专注于改善开发人员的体验和速度。它是一个基于组件的框架，让我们可以轻松创建模块化、可测试的应用程序。它包括其他框架常见的概念，如props、过渡、事件处理、模板、指令、数据绑定等。本章的主要目标是让您开始开发您的第一个Vue应用程序。本章侧重于如何创建组件。'
- en: In this chapter, we will look at how to use Vue 3 to create simple apps from
    scratch. We will start by building the most basic apps and then move on to building
    more complex solutions in the next few chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Vue 3从头开始创建简单的应用程序。我们将从构建最基本的应用程序开始，然后在接下来的几章中构建更复杂的解决方案。
- en: 'The major topics we will cover are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的主要主题如下：
- en: Understanding Vue as a framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Vue作为一个框架
- en: Setting up the Vue project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Vue项目
- en: Vue 3 core features – components and built-in directives
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue 3核心功能-组件和内置指令
- en: Debugging with Vue.js Devtools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue.js Devtools进行调试
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter is located at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter01](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter01).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于[https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter01](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter01)。
- en: Understanding Vue as a framework
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Vue作为一个框架
- en: As we mentioned in the introduction, there are concepts in Vue that are available
    from other frameworks. Directives manipulate the **Document Object Model** (**DOM**)
    just like in Angular.js and Angular. Templates render data like we do with Angular.
    It also has its own special syntax for data binding and adding directives.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中提到的，Vue中有一些概念可以从其他框架中获得。指令可以像在Angular.js和Angular中一样操作**文档对象模型**（**DOM**）。模板可以像我们在Angular中一样渲染数据。它还有自己特殊的语法用于数据绑定和添加指令。
- en: Angular and React both have props that pass data between components. We can
    also loop through array and object entries to display items from lists. Also,
    like Angular, we can add plugins to a Vue project to extend its functionality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Angular和React都有props，用于在组件之间传递数据。我们还可以循环遍历数组和对象条目，以显示列表中的项目。与Angular一样，我们可以向Vue项目添加插件以扩展其功能。
- en: Concepts that are exclusive to Vue.js include computed properties, which are
    component properties that are derived from other properties. Also, Vue components
    have watchers that let us watch for reactive data changes. Reactive data is data
    that is watched by Vue.js and actions are done automatically when reactive data
    changes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js独有的概念包括计算属性，这些属性是从其他属性派生出来的组件属性。此外，Vue组件具有watchers，让我们可以监视响应式数据的变化。响应式数据是由Vue.js监视的数据，当响应式数据发生变化时，操作会自动执行。
- en: As reactive data changes, other parts of a component and other components that
    reference those values are all updated automatically. This is the magic of Vue.
    It is one of the reasons that we can do so much with so little code. It takes
    care of the task of watching for data changes for us, so that we don't have to
    do that.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着响应式数据的变化，组件的其他部分和引用这些值的其他组件都会自动更新。这就是Vue的魔力。这也是我们可以用如此少的代码做如此多事情的原因之一。它替我们负责监视数据变化的任务，这样我们就不必自己做了。
- en: Another unique feature of Vue 3 is that we can add the framework and its libraries
    with script tags. This means that if we have a legacy frontend, we can still use
    Vue 3 and its libraries to enhance legacy frontends. Also, we don't need to add
    build tools to build our app. This is a great feature that isn't available with
    most other popular frameworks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3的另一个独特功能是，我们可以使用脚本标签添加框架及其库。这意味着，如果我们有一个旧的前端，我们仍然可以使用Vue 3及其库来增强旧的前端。此外，我们不需要添加构建工具来构建我们的应用程序。这是大多数其他流行框架所没有的一个很棒的功能。
- en: There's also the popular Vue Router library for routing, and the Vuex library
    for state management. They have all been updated to be compatible with Vue 3,
    so we can use them safely. This way, we don't have to worry about which router
    and state management library to use as we do with other frameworks such as React.
    Angular comes with its own routes, but no standard state management library has
    been designated.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 还有流行的Vue Router库用于路由，以及Vuex库用于状态管理。它们都已更新为与Vue 3兼容，因此我们可以安全地使用它们。这样，我们就不必像在使用其他框架（如React）时担心要使用哪个路由器和状态管理库。Angular自带其自己的路由，但没有指定标准状态管理库。
- en: Setting up the Vue project with the Vue CLI and script tag
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue CLI和脚本标签设置Vue项目
- en: 'There are several ways to create Vue projects or to add script tags to our
    existing frontends. For prototyping or learning purposes, we can add the latest
    version of Vue 3 by adding the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以创建Vue项目或向现有前端添加脚本标签。对于原型设计或学习目的，我们可以通过添加以下代码来添加Vue 3的最新版本：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will always include the latest version of Vue in our app. If we use it
    in production, we should include the version number to avoid unexpected changes
    from newer versions breaking our app. The version number can replace the `next`
    word if we want to specify the version.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将始终在我们的应用程序中包含最新版本的Vue。如果我们在生产中使用它，我们应该包含版本号，以避免新版本的意外更改破坏我们的应用程序。如果我们想指定版本，版本号可以替换`next`这个词。
- en: 'We can also install Vue by installing it as a package. To do that, we can run
    the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过安装包来安装Vue。为此，我们可以运行以下命令：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will install the latest version of Vue in our JavaScript project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的JavaScript项目中安装最新版本的Vue。
- en: 'If we created a Vue project from scratch with an older version of the Vue CLI,
    then we can use the CLI to generate all the files and install all the packages
    for us. This is the easiest way to get started with a Vue project. With Vue 3,
    we should use Vue CLI v4.5 by running the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用旧版本的Vue CLI从头创建了一个Vue项目，那么我们可以使用CLI为我们生成所有文件并安装所有包。这是开始使用Vue项目的最简单的方法。对于Vue
    3，我们应该使用Vue CLI v4.5，通过运行以下命令：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also install the Vue palate by running the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过运行以下命令安装Vue调色板：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, to upgrade our Vue project to Vue 3, we can run the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要将我们的Vue项目升级到Vue 3，我们可以运行以下命令：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The Vite build tool will let us create a Vue 3 project from scratch. It lets
    us serve our project much faster than with the Vue CLI because it can work with
    modules natively. We can set up a Vue project from scratch by running these commands
    with NPM:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Vite构建工具将让我们从头开始创建一个Vue 3项目。它可以比Vue CLI更快地为我们提供项目服务，因为它可以原生地处理模块。我们可以通过使用NPM运行以下命令来从头开始设置Vue项目：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With Yarn, we must run the following commands:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Yarn，我们必须运行以下命令：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In either case, we replace `<project-name>` with the project name of our choice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们都可以用我们选择的项目名称替换`<project-name>`。
- en: There are various builds of Vue that we can use. One set are CDN versions, which
    don't come with bundlers. We can recognize them by the `vue(.runtime).global(.prod).js`
    pattern in the filename. These can be included directly with script tags.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用各种版本的Vue。其中一组是CDN版本，不带捆绑器。我们可以通过文件名中的`vue(.runtime).global(.prod).js`模式来识别它们。这些可以直接通过脚本标签包含。
- en: We use them with templates that are directly added to the HTML. The `vue.global.js`
    file is the full build and includes both the compiler and the runtime, so it can
    compile templates on the fly from HTML. The `vue.runtime.global.js` file only
    contains the runtime and requires the template to be precompiled during a build
    step.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用它们与直接添加到HTML中的模板一起。`vue.global.js`文件是完整的构建，包括编译器和运行时，因此它可以从HTML动态编译模板。`vue.runtime.global.js`文件只包含运行时，并且需要在构建步骤中预编译模板。
- en: The development and production branches are hardcoded, and we can tell them
    apart by checking if the file ends with `.prod.js`. These files are production
    ready as they're minified. These aren't **Universal Module Definition** (**UMD**)
    builds. They contain IIFEs that are meant to be used with regular script tags.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和生产分支是硬编码的，我们可以通过检查文件是否以`.prod.js`结尾来区分它们。这些文件已经准备好用于生产，因为它们已经被压缩。这些不是**通用模块定义**（**UMD**）构建。它们包含用于常规脚本标签的IIFE。
- en: If we use a bundler such as Webpack, Rollup, or Parcel, then we can use the
    `vue(.runtime).esm-bundler.js` file. The development and production branches are
    determined by the `process.env.NODE_ENV` property. It also has the full version,
    which compiles the template on the fly at runtime and a runtime version.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用诸如Webpack、Rollup或Parcel之类的捆绑器，那么我们可以使用`vue(.runtime).esm-bundler.js`文件。开发和生产分支由`process.env.NODE_ENV`属性确定。它还有完整版本，它可以在运行时动态编译模板和运行时版本。
- en: In this chapter, we will be going through the basic features of Vue with the
    script tag version of Vue. In the subsequent chapters, we'll move on to using
    the Vue CLI to create our Vue 3 projects. This way, we can focus on exploring
    the basic features of Vue 3, which will be handy when we move on to creating more
    complex projects. Let's begin by creating a Vue instance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过Vue的脚本标签版本介绍Vue的基本功能。在随后的章节中，我们将继续使用Vue CLI来创建我们的Vue 3项目。这样，我们可以专注于探索Vue
    3的基本功能，这在我们转向创建更复杂的项目时会很有用。让我们开始创建一个Vue实例。
- en: Creating your Vue instance
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您的Vue实例
- en: Now that we have set up our Vue project, we can look at the Vue instance more
    closely. All Vue 3 apps have a Vue instance. The Vue instance serves as the entry
    point of the app. This means this is what is loaded first. It is the root component
    of the app, and it has a template and a component option object to control how
    the template is rendered in the browser.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了我们的Vue项目，我们可以更仔细地看一下Vue实例。所有Vue 3应用程序都有一个Vue实例。Vue实例充当应用程序的入口点。这意味着这是首先加载的内容。它是应用程序的根组件，它有一个模板和一个组件选项对象，用于控制模板在浏览器中的呈现方式。
- en: 'To create our first Vue 3 app, we must add the following code to the `index.html`
    file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的第一个Vue 3应用程序，我们必须将以下代码添加到`index.html`文件中：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our first Vue 3 app, we started by adding the `script` tag to add the Vue
    framework script. It's not final yet, so we added the next version of the Vue
    script.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个Vue 3应用程序中，我们首先添加了`script`标签以添加Vue框架脚本。它还不是最终版本，所以我们添加了Vue脚本的下一个版本。
- en: In the body, we have a `div` with the ID app, which we use to hold the template.
    The only content that is inside the template will be compiled by the template
    compiler that comes with Vue 3\. Below that, we have a `script` tag to create
    our app. It provides the `Counter` object, which contains the properties we can
    use to create our app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在body中，我们有一个ID为app的`div`，我们用它来容纳模板。模板中唯一的内容将由Vue 3附带的模板编译器编译。在下面，我们有一个`script`标签来创建我们的应用程序。它提供了`Counter`对象，其中包含我们可以用来创建应用程序的属性。
- en: Vue components come as objects that will be used by Vue to create any necessary
    components. The `data` property is a special property that returns the initial
    values of our states. The states are automatically reactive. The `count` state
    is a reactive state that we can update. It is the same one that's in the template.
    Anything in the curly braces must be some expression that contains reactive properties
    or other JavaScript expressions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Vue组件作为对象提供，Vue将使用它们来创建任何必要的组件。`data`属性是一个特殊属性，返回我们状态的初始值。这些状态是自动响应的。`count`状态是一个我们可以更新的响应式状态。它与模板中的相同。花括号中的任何内容必须是包含响应式属性或其他JavaScript表达式的表达式。
- en: 'If we add reactive states between the curly braces, then they will be updated.
    Since the `count` reactive property is initialized to `0`, the `count` property
    is also `0` in the template. The `Counter` object is passed into the `Vue.createApp`
    method to compile the template and connect the reactive properties, to render
    the expression inside the curly braces as the final result. So, we should see
    `count: 0` in our rendered output.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们在花括号之间添加响应式状态，它们将被更新。由于`count`响应式属性被初始化为`0`，模板中的`count`属性也是`0`。`Counter`对象被传递到`Vue.createApp`方法中，以编译模板并连接响应式属性，将花括号内的表达式渲染为最终结果。因此，我们应该在渲染的输出中看到`count:
    0`。'
- en: The `mount()` method accepts a CSS selector string as its argument. The selector
    is the template to render the app in. Whatever is inside it will be considered
    Vue expressions, and they will be rendered accordingly. Expressions in curly braces
    will be rendered and attributes will be interpreted by Vue as props or directives,
    depending on how they are written.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount()`方法接受一个CSS选择器字符串作为参数。选择器是要在其中渲染应用程序的模板。其中的任何内容都将被视为Vue表达式，并相应地进行渲染。花括号中的表达式将被渲染，属性将被Vue解释为props或指令，具体取决于它们的编写方式。'
- en: In the next section, we will look at the core features of Vue.js 3.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下Vue.js 3的核心特性。
- en: Vue 3 core features – components and built-in directives
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 3核心特性 - 组件和内置指令
- en: Now that we have created a basic Vue app with a Vue instance, we can look more
    closely at how to make it do more. Vue 3 is a component-based framework. Therefore,
    components are the core building blocks that are used to build full production
    - quality Vue 3 apps. Components are parts that can be combined to form a full
    app and are reusable. Vue 3 components have several parts, which include the template,
    the component option object, and the styles. The styles are the CSS styles that
    we apply to the rendered elements. The template is what is rendered on the browser's
    screen. It contains HTML code combined with JavaScript expressions to form the
    content that's rendered in the browser.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个带有Vue实例的基本Vue应用程序，我们可以更仔细地看一下如何使它做更多的事情。Vue 3是一个基于组件的框架。因此，组件是用于构建完整的生产质量Vue
    3应用程序的核心构建块。组件是可以组合成完整应用程序并且可重用的部分。Vue 3组件有几个部分，包括模板、组件选项对象和样式。样式是我们应用于渲染元素的CSS样式。模板是在浏览器屏幕上呈现的内容。它包含HTML代码和JavaScript表达式，形成在浏览器中呈现的内容。
- en: Templates get their data from the corresponding component option object. Also,
    the component templates can have directives that control how content is rendered
    and how to bind data from the template to a reactive property.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 模板从相应的组件选项对象获取数据。此外，组件模板可以具有指令，控制内容的呈现方式以及将数据从模板绑定到响应式属性。
- en: Components
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: We created a basic Vue app with a Vue instance. Now, we must find a way to organize
    our app in a manageable way. Vue 3 is a component-based frontend framework. This
    means that apps created with Vue 3 are created by composing multiple components
    into one. This way, we can keep each part of our app small, and this helps with
    making testing easy, as well as easy to debug. This is something that is important
    as we are creating a non-trivial app that provides functionality for users.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一个Vue实例创建了一个基本的Vue应用。现在，我们必须找到一种管理我们应用的方法。Vue 3是一个基于组件的前端框架。这意味着使用Vue 3创建的应用是由多个组件组合而成的。这样，我们可以保持应用的每个部分都很小，这有助于使测试变得容易，也容易调试。这对我们来说很重要，因为我们正在创建一个为用户提供功能的非平凡应用。
- en: In Vue 3, a component is a Vue instance with some predefined options. To use
    components in another component, we must register them. To create a Vue component,
    we can call the `app.component()` method. The first argument is the component,
    called `string`, while the second argument is an object that contains the component
    options.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 3中，组件是具有一些预定义选项的Vue实例。要在另一个组件中使用组件，我们必须注册它们。要创建一个Vue组件，我们可以调用`app.component()`方法。第一个参数是组件，称为`string`，而第二个参数是一个包含组件选项的对象。
- en: 'A minimal component should at least contain the template property that was
    added to the object. This way, it will display something in our component to make
    it useful. We will start by creating a component for displaying todo items. To
    display our todo item, we can create a `todo-item` component. Also, a component
    most likely needs to accept props to display data from its parent component. A
    **prop** is a special attribute that lets a Vue component pass some data to a
    child component. A child component has the `props` property to define what kind
    of value it will accept. To do this, we can write the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最小的组件应该至少包含添加到对象中的模板属性。这样，它将在我们的组件中显示一些内容，使其有用。我们将首先创建一个用于显示待办事项的组件。为了显示我们的待办事项，我们可以创建一个`todo-item`组件。此外，组件很可能需要接受props来显示来自其父组件的数据。**prop**是一个特殊的属性，让Vue组件将一些数据传递给子组件。子组件具有`props`属性来定义它将接受的值的类型。为此，我们可以编写以下代码：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We called the `app.component()` method to create the `todo-item` component.
    It contains the `props` property with an array of prop names to accept the `todo`
    prop. The way we defined the prop means that we can accept any value as the value
    of the `todo` prop. We can also specify them with a value type, set whether it
    is required or not, or provide a default value for it. The `template` property
    lets us render it when we want to. We just set it to a string, and it will render
    the items like any other template.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了`app.component()`方法来创建`todo-item`组件。它包含了`props`属性，其中包含一个接受`todo`prop的prop名称数组。我们定义prop的方式意味着我们可以接受任何值作为`todo`prop的值。我们还可以指定它们的值类型，设置它是否是必需的，或为其提供默认值。`template`属性让我们在需要时呈现它。我们只需将其设置为一个字符串，它将像任何其他模板一样呈现项目。
- en: The `li` element is rendered in the template. The curly braces work the same
    way as any other template. It is used to interpolate the value. To access the
    prop's value, we just access it as a property of this in the component or just
    with the prop name itself in the template.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`li`元素在模板中呈现。花括号的工作方式与任何其他模板相同。它用于插值值。要访问prop的值，我们只需在组件中将其作为this的属性访问，或者在模板中直接使用prop名称本身。'
- en: To pass the `todo` prop from the root Vue instance to the `todo-item` component,
    we prefix the prop name with a colon to indicate that it is a prop. The colon
    is short for `v-bind`. The `v-bind` directive is a built-in Vue directive that
    lets us pass data to a child component as a prop. If we have a prop name that
    is in camel case, then it will be mapped to a kebab-case name in the HTML to keep
    it valid. This is because valid attributes should have kebab-case names. The template
    compiler that comes with Vue 3 will do the mapping automatically. So, we just
    have to follow the conventions and then we can pass our props correctly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`todo`属性从根Vue实例传递给`todo-item`组件，我们需要使用冒号前缀属性名称，以指示它是一个prop。冒号是`v-bind`的简写。`v-bind`指令是Vue的内置指令，它让我们将数据作为prop传递给子组件。如果prop名称是驼峰式命名，则它将被映射到HTML中的kebab-case名称，以保持其有效。这是因为有效的属性应该具有kebab-case名称。Vue
    3附带的模板编译器将自动执行映射。因此，我们只需遵循惯例，然后我们就可以正确传递我们的props。
- en: 'If we are using the `v-for` directive, we should add the key prop so that Vue
    3 can keep track of the items properly. With the `v-for` directive, we can loop
    through an array or object and display the entries from them. The value should
    be a unique ID so that Vue can render the items properly, even if we swap the
    positions of the items and add or delete items and perform other actions in a
    list. To do this, we can write the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`v-for`指令，我们应该添加key属性，以便Vue 3可以正确跟踪项目。使用`v-for`指令，我们可以循环遍历数组或对象，并显示它们的条目。值应该是一个唯一的ID，以便Vue可以正确渲染项目，即使我们交换项目的位置并添加或删除项目并在列表中执行其他操作。为此，我们可以编写以下代码：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each `id` property value is unique for Vue's list tracking to work.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`id`属性值对于Vue的列表跟踪是唯一的。
- en: Vue components look like custom elements in the web component's specification,
    but Vue components are not custom elements. They can't be used interchangeably.
    It is just a way to use a familiar syntax for creating components, and this is
    standard. There are some features in Vue components that are not available in
    custom elements. There is no cross-component data flow, custom event communication,
    and build tool integration with custom components. However, all these features
    are available in Vue components. We will cover these features of Vue components
    in the following sections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Vue组件看起来像Web组件规范中的自定义元素，但Vue组件不是自定义元素。它们不能互换使用。这只是一种使用熟悉的语法来创建组件的方式，这是标准的。Vue组件中有一些特性在自定义元素中是不可用的。在自定义元素中没有跨组件数据流、自定义事件通信和构建工具集成。然而，所有这些特性都在Vue组件中可用。我们将在接下来的部分中介绍Vue组件的这些特性。
- en: Component life cycle
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: Each Vue 3 component has its own life cycle, and each life cycle stage has its
    own method. If the given stage of the life cycle is reached and if the method
    is defined in the component, the method will be run.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Vue 3组件都有自己的生命周期，每个生命周期阶段都有自己的方法。如果达到了生命周期的给定阶段，并且在组件中定义了该方法，那么该方法将被运行。
- en: Right after the app is mounted with `app.mount(),` the events and life cycle
    are initialized. The first method that will be run when the component is being
    loaded is the `beforeCreate()` method. Then, the components are initialized with
    the reactive properties. Then, the `created()` method is run. Since the reactive
    properties are initialized at this stage, we can access the reactive properties
    in this method and the methods that are loaded after this one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`app.mount()`挂载应用程序后，事件和生命周期被初始化。当组件加载时将运行的第一个方法是`beforeCreate()`方法。然后，组件被初始化为响应式属性。然后运行`created()`方法。由于在这个阶段初始化了响应式属性，我们可以在这个方法和之后加载的方法中访问这些响应式属性。
- en: Then, the component's template or render functions are run to render the items.
    Once the content is loaded, `beforeMount` is run. Once `beforeMount` is run, the
    app will be mounted into the element that we specified with the selector we passed
    into the `app.mount()` method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行组件的模板或渲染函数来呈现项目。内容加载完成后，将运行`beforeMount`。一旦运行了`beforeMount`，应用程序将被挂载到我们在`app.mount()`方法中传递给选择器指定的元素中。
- en: Once the app is mounted into the element, the mounted hook is run. Now, when
    any reactive property changes, the `beforeUpdate` hook is run. Then, the virtual
    DOM is rerendered, and the latest items are rendered from the latest values of
    the reactive properties. It is a good place to run any initialization code for
    outside libraries. Once that is done, the `updated` hook is run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序被挂载到元素中，就会运行挂载钩子。现在，当任何响应属性发生变化时，将运行`beforeUpdate`钩子。然后，重新渲染虚拟DOM，并从响应属性的最新值呈现最新的项目。这是运行任何外部库的初始化代码的好地方。完成后，将运行`updated`钩子。
- en: '`beforeDestroy` is run right before the component is unmounted. It is a good
    place to run any cleanup code before destroying the component. The `destroyed`
    hook is run when the component is destroyed. The reactive properties won''t be
    available here.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeDestroy`在组件卸载之前运行。这是在销毁组件之前运行任何清理代码的好地方。当组件被销毁时，将运行`destroyed`钩子。在这里，响应属性将不可用。'
- en: Reactive properties
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应属性
- en: Reactive properties are properties of the component option object that let us
    synchronize what is displayed in the template, and they change according to the
    operations we do with them. Any changes that are applied to reactive properties
    are propagated throughout the app wherever they are referenced.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 响应属性是组件选项对象的属性，它们让我们同步模板中显示的内容，并根据我们对它们进行的操作而改变。对响应属性所做的任何更改都会在引用它们的任何地方传播到整个应用程序中。
- en: 'In the previous example, we added the `count` reactive property to our app.
    To update it, we just have to update the reactive property''s value itself:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们向我们的应用程序添加了`count`响应属性。要更新它，我们只需更新响应属性的值本身：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we have the `@click="count++"` expression, which listens for clicks of
    the button, and we increase the count by `1` when we click the increment button.
    The latest value will be reflected everywhere since it is a reactive property.
    Vue can pick up the changes for reactive properties automatically. `@click` is
    shorthand for `v-on:click`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`@click="count++"`表达式，它监听按钮的点击，并在点击增加按钮时将计数增加`1`。最新的值将在任何地方都得到反映，因为它是一个响应属性。Vue可以自动捕捉到响应属性的变化。`@click`是`v-on:click`的简写。
- en: 'Also, we can rewrite the expression as a method. To do that, we can write the
    following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以将表达式重写为方法。为此，我们可以编写以下代码：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To reference the `count` reactive property in the Vue instance object, we must
    reference it as a property of this. So, `this.count` in the Vue instance object
    is the same as `count` in the template. The `this` keyword refers to the component
    instance. We should remember this so that we don't run into problems later.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 引用Vue实例对象中的`count`响应属性，我们必须将其作为`this`的属性引用。因此，在Vue实例对象中的`this.count`与模板中的`count`是相同的。`this`关键字指的是组件实例。我们应该记住这一点，这样我们就不会在以后遇到问题。
- en: Also, we add the method's properties to the component object. This is a special
    property that is used to hold methods in our code that we can reference in other
    parts of the Vue instance or in our template. Like with reactive properties, methods
    are referenced as properties of this in the Vue instance object, and we omit this
    in the template.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将方法的属性添加到组件对象中。这是一个特殊的属性，用于在我们的代码中保存我们可以在Vue实例的其他部分或模板中引用的方法。与响应属性一样，方法在Vue实例对象中被引用为`this`的属性，并且在模板中省略了`this`。
- en: So, when we click the button, we run the increment method in the `methods` property.
    When we click the button, the count value will increase by `1`, and we should
    see that displayed in our browser's output.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们点击按钮时，我们运行`methods`属性中的增量方法。当我们点击按钮时，计数值将增加`1`，我们应该在浏览器的输出中看到它显示。
- en: Handling user input
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: Most apps require users to input something to forms. We can do this easily with
    Vue 3 with the `v-model` directive. It synchronizes the inputted value with the
    reactive properties that we have defined in our Vue instance.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序需要用户向表单输入内容。我们可以使用Vue 3的`v-model`指令轻松实现这一点。它将输入的值与我们在Vue实例中定义的响应属性进行同步。
- en: 'To use it, we just add the `v-model` attribute to the input box. To do that,
    we can write the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们只需将`v-model`属性添加到输入框中。为此，我们可以编写以下代码：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we have the `message` reactive property, which has been initialized to
    the `hello world.` string. We can use the same value in the template by setting
    that as the value of the `v-model` directive. It will do the synchronization between
    the inputted value and the `message` reactive property so that whatever we type
    in will be propagated to the rest of the Vue instance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`message`响应属性，它已初始化为'hello world.'字符串。我们可以通过将其设置为`v-model`指令的值，在模板中使用相同的值。它将在输入的值和`message`响应属性之间进行同步，以便我们输入的任何内容都会传播到Vue实例的其余部分。
- en: Therefore, the `hello world.` string is both shown in the input box and the
    paragraph element. And when we enter something into the input box, it will also
    be shown in the paragraph element. It will update the value of the `message` reactive
    property. This is one great feature that comes with Vue 3 that we will use in
    many places.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，'hello world.'字符串既显示在输入框中，也显示在段落元素中。当我们在输入框中输入内容时，它也会显示在段落元素中。它将更新`message`响应属性的值。这是Vue
    3带来的一个很棒的功能，我们将在许多地方使用它。
- en: Conditionals and loops
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件和循环
- en: Another very useful feature of Vue 3 is that we can conditionally render content
    in the template. To do this, we can use the `v-if` directive, which lets us show
    something conditionally. The `v-if` directive puts the element in the DOM only
    if the condition we assign to it is true. The `v-show` directive shows and hides
    the element it is bound to with CSS, and the element is always in the DOM. If
    the value for it is true, then we will see it shown in the template. Otherwise,
    we don't see the item displayed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3的另一个非常有用的功能是我们可以在模板中有条件地渲染内容。为此，我们可以使用`v-if`指令，它让我们有条件地显示某些内容。`v-if`指令只有在我们分配给它的条件为真时，才将元素放入DOM中。`v-show`指令使用CSS显示和隐藏它绑定的元素，并且该元素始终在DOM中。如果它的值为真，我们将在模板中看到它显示。否则，我们不会看到该项显示。
- en: It works by conditionally attaching the item to the DOM. The elements and components
    that are inside the element or component that has the `v-if` directive are only
    appended to the DOM when the `v-if` value is true. Otherwise, they won't be attached
    to the DOM.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过有条件地将项目附加到DOM来工作。只有当`v-if`值为真时，具有`v-if`指令的元素或组件内的元素和组件才会被附加到DOM中。否则，它们不会附加到DOM中。
- en: 'For instance, let''s say we have the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有以下代码：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, `''hello world''` will be shown since `show` is `true`. If we have the
    following code, we won''t see anything displayed since the span isn''t attached
    to the DOM:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，'hello world'将被显示，因为`show`是`true`。如果我们有以下代码，我们将看不到任何显示，因为span没有附加到DOM上：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To render an array of items in our template and the final output, we can use
    the `v-for` directive. We place a value that is a special JavaScript expression
    that lets us loop through the array. We can use the `v-for` directive by writing
    the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模板中呈现项目数组和最终输出，我们可以使用`v-for`指令。我们放置一个特殊的JavaScript表达式，让我们循环遍历数组。我们可以通过编写以下代码来使用`v-for`指令：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have the `v-for` directive with our `li` element. `'todo in todos'` loops
    through the `todo` array and renders the item in-between the tags. The `todo`
    variable is the individual *todos* entry that is being iterated. We access the
    description property so that we can show the value of the description in the list.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`li`元素中使用了`v-for`指令。`'todo in todos'`循环遍历`todo`数组并呈现标签之间的项目。`todo`变量是正在迭代的单个*todos*条目。我们访问描述属性，以便我们可以在列表中显示描述的值。
- en: Once we have done that, we will see a numbered list with the `todo` text listed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们将看到一个带有`todo`文本的编号列表。
- en: Template syntax
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板语法
- en: We have already used templates extensively. We mainly use interpolation to display
    data and some directives to render data. Also, we can use the `@` or `v-on` directive
    to listen to events that are emitted, such as clicks and input value changes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经广泛使用了模板。我们主要使用插值来显示数据和一些指令来呈现数据。此外，我们可以使用`@`或`v-on`指令来监听发出的事件，例如点击和输入值更改。
- en: There is other useful syntax that we can use to create templates with. One of
    them is displaying raw HTML with our interpolated expressions. By default, Vue
    3 escapes all HTML entities so that they will be displayed as-is. The `v-html`
    directive lets us display HTML code as real HTML rather than as plain text.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他有用的语法，我们可以用来创建模板。其中之一是使用插值表达式显示原始HTML。默认情况下，Vue 3会转义所有HTML实体，以便它们按原样显示。`v-html`指令让我们将HTML代码显示为真正的HTML，而不是纯文本。
- en: 'For example, let''s write the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们编写以下代码：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we set the `rawHtml` reactive property as the value of `v-html`, so that
    we can see the `b` tag being rendered as bold text instead of the characters in
    raw form being rendered.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`rawHtml`响应式属性设置为`v-html`的值，这样我们就可以看到`b`标签被呈现为粗体文本，而不是以原始形式呈现的字符。
- en: JavaScript expressions and templates
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript表达式和模板
- en: We can put any JavaScript expressions in-between the curly braces. It can only
    be a single expression.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在大括号之间放置任何JavaScript表达式。它只能是单个表达式。
- en: 'For example, the following pieces of code show what''s valid in-between the
    curly braces:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段显示了大括号之间的有效内容：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, we can't put any JavaScript statements in-between the curly braces.
    For example, we can't write `{{ var foo = 1 }}` or `{{ if (yes) { return message
    } }}`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们不能在大括号之间放置任何JavaScript语句。例如，我们不能写`{{ var foo = 1 }}`或`{{ if (yes) { return
    message } }}`。
- en: Computed properties
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算属性
- en: '**Computed properties** are special reactive properties that are derived from
    other reactive properties. Computed properties are added to the computed property''s
    objects as functions. They always return something that is derived from other
    reactive properties. Therefore, they must be synchronous functions.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算属性**是从其他响应式属性派生出来的特殊响应式属性。计算属性被添加到计算属性对象中作为函数。它们总是返回从其他响应式属性派生出来的东西。因此，它们必须是同步函数。'
- en: 'To create a computed property, we can write the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建计算属性，我们可以编写以下代码：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we created the `reversedMessage` computed property, which is the reverse
    of the `message` reactive property. We return the message with the order of the
    characters reversed. Whenever the `message` reactive property is updated, the
    `reversedMessage()` method will be run again and return the newest value. Therefore,
    we can see both `'hello world'` and `'dlrow olleh'` in the same template. The
    return values of these computed properties must have other reactive properties
    in them so that they will be updated when other reactive properties update.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了`reversedMessage`计算属性，它是`message`响应式属性的反转。我们返回了字符顺序反转后的消息。每当`message`响应式属性更新时，`reversedMessage()`方法将再次运行并返回最新的值。因此，我们可以在同一个模板中看到`'hello
    world'`和`'dlrow olleh'`。这些计算属性的返回值必须包含其他响应式属性，以便在其他响应式属性更新时它们也会更新。
- en: Directives
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令
- en: Components may not have enough to do what we want. The main thing that is missing
    is the ability to manipulate the DOM and synchronize input data with reactive
    properties. Directives are special attributes that start with the `v-` prefix.
    They expect single JavaScript expressions as values. We have already seen some
    built-in directives such as `v-if`, `v-for`, `v-bind`, and `v-on` being used for
    various purposes. Directives can take arguments in addition to values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可能没有足够的能力做我们想要的事情。最重要的缺失是操作DOM并将输入数据与响应式属性同步的能力。指令是以`v-`前缀开头的特殊属性。它们期望单个JavaScript表达式作为值。我们已经看到一些内置指令，比如`v-if`、`v-for`、`v-bind`和`v-on`被用于各种目的。指令除了值之外还可以带参数。
- en: For example, we can write `<a v-on:click="doSomething"> ... </a>` to listen
    to the click event on the anchor element. The `v-on` part is the directive's name.
    The part between the colon and the equal sign is the argument for the directive,
    so `click` is the directive's argument. `doSomething` is the value of the directive.
    It is the name of the method we want to call.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以写`<a v-on:click="doSomething"> ... </a>`来监听锚元素上的点击事件。`v-on`部分是指令的名称。冒号和等号之间的部分是指令的参数，所以`click`是指令的参数。`doSomething`是指令的值。它是我们想要调用的方法的名称。
- en: 'Directive arguments can be dynamic. To add dynamic arguments, we can put them
    between square brackets:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 指令参数可以是动态的。要添加动态参数，我们可以将它们放在方括号之间：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`attributeName` is the reactive property that we want to use to set the value
    of the argument. It should be a string. We can also do the same thing with the
    `v-on` directive:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`attributeName`是我们想要用来设置参数值的响应式属性。它应该是一个字符串。我们也可以用`v-on`指令做同样的事情：'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We listen to the event with the given `eventName`. `eventName` should also be
    a string.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用给定的`eventName`来监听事件。`eventName`也应该是一个字符串。
- en: Directive modifiers
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指令修饰符
- en: 'Directives can take modifiers that let us change the behavior of a directive.
    Modifiers are special postfixes that are denoted by a dot. They can be chained
    to provide more changes. They indicate that a directive should be bound in some
    special way. For instance, if we need to listen to the `submit` event, we can
    add the `prevent` modifier to make it call `event.preventDefault()`, which will
    prevent the default submission behavior. We can do that by writing the following
    code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 指令可以带有修饰符，让我们改变指令的行为。修饰符是以点表示的特殊后缀。它们可以链接在一起以提供更多的改变。它们表示指令应该以某种特殊的方式绑定。例如，如果我们需要监听`submit`事件，我们可以添加`prevent`修饰符来调用`event.preventDefault()`，这将阻止默认的提交行为。我们可以通过编写以下代码来实现：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we will look at how to debug Vue 3 projects easily with the Vue.js Devtools
    browser extension.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何使用Vue.js Devtools浏览器扩展轻松调试Vue 3项目。
- en: Debugging with Vue.js Devtools
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue.js Devtools进行调试
- en: Right now, there is no easy way to debug our app. All we can do is add `console.log`
    statements to our code to look at the values. With Vue.js Devtools, we can have
    more visibility in our app. Vue.js Devtools is a Chrome or Firefox extension that
    we can use to debug our Vue.js applications. It can be used on projects that are
    created with Vite or created from scratch by including the `script` tag for Vue
    3\. We can install the extension by searching for the Vue.js Devtools extension
    in the respective browser's app store.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们没有简单的方法来调试我们的应用程序。我们只能在代码中添加`console.log`语句来查看值。使用Vue.js Devtools，我们可以更清晰地看到我们的应用程序。Vue.js
    Devtools是一个Chrome或Firefox扩展，我们可以用它来调试我们的Vue.js应用程序。它可以用于使用Vite创建的项目，也可以通过包含Vue
    3的`script`标签从头开始创建的项目。我们可以通过在各自浏览器的应用商店中搜索Vue.js Devtools扩展来安装该扩展。
- en: 'Important:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The URL to install the Chrome version of Vue.js Devtools is at [https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Chrome版本的Vue.js Devtools的URL在[https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)。
- en: The Firefox version of the add-on is at [https://addons.mozilla.org/en-CA/firefox/addon/vue-js-devtools/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search](https://addons.mozilla.org/en-CA/firefox/addon/vue-js-devtools/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox版本的插件在[https://addons.mozilla.org/en-CA/firefox/addon/vue-js-devtools/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search](https://addons.mozilla.org/en-CA/firefox/addon/vue-js-devtools/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search)。
- en: 'Once we''ve installed it, we should see the Vue tab in the browser''s development
    console. With it, we can inspect the reactive properties that are loaded by Vue.
    If our component has a `name` property, then it will be displayed in the component
    tree of the application. For example, let''s say we have the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们应该在浏览器的开发控制台中看到Vue选项卡。通过它，我们可以检查Vue加载的响应式属性。如果我们的组件有一个`name`属性，那么它将显示在应用程序的组件树中。例如，假设我们有以下代码：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, since we have the `name` property of the `foo` component set to `'foo'`,
    we will see that listed in the component tree. Also, the `foo` component has the
    `message` reactive property, so we will also see the `message` property displayed
    with its value. Above the component tree, there is a search box that lets us find
    the reactive property with the given name. We can also search for components with
    the **Find components**`…` input box.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于我们将`foo`组件的`name`属性设置为`'foo'`，我们将在组件树中看到它的列表。此外，`foo`组件具有`message`响应式属性，因此我们还将看到`message`属性及其值的显示。在组件树上方，有一个搜索框，让我们可以找到具有给定名称的响应式属性。我们还可以在**查找组件**`…`输入框中搜索组件。
- en: 'The following screenshot shows us the values of Reactive properties in our
    Vue 3 app, within the Vue Devtools extension:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的Vue 3应用程序中Vue Devtools扩展中的响应式属性的值：
- en: '![Figure 1.1 – Inspecting reactive properties with Vue Devtools'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1-使用Vue Devtools检查响应式属性'
- en: '](image/Figure_1.1_B14405.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.1_B14405.jpg)'
- en: Figure 1.1 – Inspecting reactive properties with Vue Devtools
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1-使用Vue Devtools检查响应式属性
- en: 'There is also the **Timeline** menu item, which we can use to inspect the events
    that are emitted. For example, let''s say we have the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有“时间轴”菜单项，我们可以用它来检查被触发的事件。例如，假设我们有以下代码：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When we click on the **Increment** button, we will see the mouse events logged
    in the **Timelines** section. The time the event is triggered will also be logged.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“增加”按钮时，我们将在“时间轴”部分看到鼠标事件的记录。事件触发的时间也将被记录。
- en: In the **Global Settings** section, we can see the **Normalize Component Names**
    setting, which lets us change how the component names are displayed. We can display
    the original name in Pascal case or Kebab case. The **Theme** option lets us change
    the theme color of the Vue tab.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在**全局设置**部分，我们可以看到**规范化组件名称**设置，它让我们可以改变组件名称的显示方式。我们可以以帕斯卡命名法或短横线命名法显示原始名称。**主题**选项让我们可以改变Vue标签的主题颜色。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned that Vue 3 is a component-based framework, and we
    looked at the different parts of the component. One important part we covered
    was reactive properties. They are properties of the component that we can change
    to update all the parts of the app that reference the reactive property. These
    properties can be watched manually, and any value changes are also picked up automatically
    by Vue 3 so that any parts of the app that reference the reactive property are
    updated automatically. Components are composed in a way that they can be reused
    whenever possible.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到Vue 3是一个基于组件的框架，并且我们看了组件的不同部分。我们涵盖的一个重要部分是响应式属性。它们是组件的属性，我们可以更改以更新引用响应式属性的应用程序的所有部分。这些属性可以手动监视，任何值的更改也会被Vue
    3自动捕捉到，以便自动更新引用响应式属性的应用程序的任何部分。组件被组合在一起，以便在可能的情况下可以重复使用。
- en: We then moved on to understand the role of a template in every component. Templates
    are also a part of every component. They must all render something onto the screen.
    Templates can have HTML elements, other components, and directives that modify
    how the elements and components in the template are rendered. Templates can have
    JavaScript expressions in them so that we can do things such as react to events.
    Then, we looked at the importance of computed properties in a component. Computed
    properties are special reactive properties that depend on other reactive properties.
    They are functions that are synchronous and return a value based on combining
    other reactive properties.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续了解了每个组件中模板的作用。模板也是每个组件的一部分。它们必须在屏幕上渲染出一些东西。模板可以包含HTML元素、其他组件和修改模板中元素和组件渲染方式的指令。模板中可以包含JavaScript表达式，这样我们就可以对事件做出反应。然后，我们看到了组件中计算属性的重要性。计算属性是依赖于其他响应式属性的特殊响应式属性。它们是同步的函数，并根据其他响应式属性的组合返回一个值。
- en: Another important point that we looked at is the `v-model` directive, which
    is built into Vue 3\. Vue 3 provides the `v-model` directive so that we can bind
    reactive properties to form control values. Directives are special Vue code that
    let us change how DOM elements are rendered. Vue 3 provides many built-in directives
    to do things such as render elements from an array, bind form control values to
    reactive properties, and more.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的另一个重要点是内置在Vue 3中的`v-model`指令。Vue 3提供了`v-model`指令，这样我们就可以将响应式属性绑定到表单控件的值上。指令是特殊的Vue代码，让我们可以改变DOM元素的渲染方式。Vue
    3提供了许多内置指令，可以做诸如从数组中渲染元素、将表单控件的值绑定到响应式属性等事情。
- en: In the last section, we looked at how to use Vue.js Devtools to make debugging
    easier. It is a browser extension available for Chromium browsers and Firefox
    that lets us watch the reactive property values of components and see what components
    are rendered. It will also log any events that are triggered by the elements in
    a component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们学习了如何使用Vue.js Devtools来简化调试。这是一个适用于Chromium浏览器和Firefox的浏览器扩展，让我们可以观察组件的响应式属性值，并查看渲染的组件。它还会记录组件中元素触发的任何事件。
- en: In the next chapter, we will look at how to build a simple GitHub app that makes
    HTTP requests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何构建一个简单的GitHub应用程序，进行HTTP请求。
