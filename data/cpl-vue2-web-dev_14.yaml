- en: Vue Communicates with the Internet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue与互联网通信
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下配方：
- en: Sending basic AJAX request with Axios
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Axios发送基本的AJAX请求
- en: Validating user data before sending it
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送之前验证用户数据
- en: Creating a form and sending data to your server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个表单并将数据发送到服务器
- en: Recovering from an error during a request
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求期间从错误中恢复
- en: Creating a REST client (and server!)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建REST客户端（和服务器！）
- en: Implementing infinite scrolling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现无限滚动
- en: Processing a request before sending it out
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送请求之前处理请求
- en: Preventing XSS attacks to your app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止XSS攻击到您的应用程序
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Web applications rarely work all by themselves. What makes them interesting
    is actually the fact that they enable us to communicate with the world in innovative
    ways that didn't exist just a few years ago.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序很少能够独立运行。使它们变得有趣的实际上是它们使我们能够以几年前不存在的创新方式与世界进行交流。
- en: Vue, by itself, doesn't contain any mechanism or library to make AJAX requests
    or open web sockets. In this chapter, we will, therefore, explore how Vue interacts
    with built-in mechanisms and external libraries to connect to external services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Vue本身不包含任何机制或库来发起AJAX请求或打开网络套接字。因此，在本章中，我们将探讨Vue如何与内置机制和外部库进行交互，以连接到外部服务。
- en: You will start by making basic AJAX requests with the help of an external library.
    Then, you'll explore some common patterns with sending and getting data in forms.
    Finally, there are some recipes with real-world applications and how to build
    a RESTful client.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先使用外部库发起基本的AJAX请求。然后，您将探索一些在表单中发送和获取数据的常见模式。最后，有一些具有真实应用程序的配方以及如何构建RESTful客户端。
- en: Sending basic AJAX requests with Axios
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Axios发送基本的AJAX请求
- en: '**Axios** is the recommended library for Vue for making HTTP requests. It''s
    a very simple library, but it has some built-in features that help you in carrying
    out common operations. It implements a REST pattern for making requests with HTTP
    verbs and can also deal with concurrency (spawning multiple requests at the same
    time) in a function call. You can find more information at [https://github.com/mzabriskie/axios](https://github.com/mzabriskie/axios).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Axios是Vue推荐的用于发起HTTP请求的库。它是一个非常简单的库，但它具有一些内置功能，可以帮助您执行常见操作。它实现了使用HTTP动词进行请求的REST模式，并且还可以在函数调用中处理并发（同时发起多个请求）。您可以在[https://github.com/mzabriskie/axios](https://github.com/mzabriskie/axios)找到更多信息。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you don't need any particular knowledge of Vue. We will use
    Axios, which itself uses **JavaScript promises**. If you have never heard of promises,
    you can have a primer at [https://developers.google.com/web/fundamentals/getting-started/primers/promises](https://developers.google.com/web/fundamentals/getting-started/primers/promises).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您不需要对Vue有任何特定的了解。我们将使用Axios，它本身使用JavaScript promises。如果您从未听说过promises，您可以在[https://developers.google.com/web/fundamentals/getting-started/primers/promises](https://developers.google.com/web/fundamentals/getting-started/primers/promises)上了解一些基础知识。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: You will build a simple application that gives you a wise piece of advice every
    time you visit the web page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您将构建一个简单的应用程序，每次访问网页时都会给您一条明智的建议。
- en: 'The first thing you will need is to install Axios in your application. If you
    are using npm, you can just issue the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是在应用程序中安装Axios。如果您使用npm，只需发出以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you are working on a single page, you can import the following file from
    CDN, at [https://unpkg.com/axios/dist/axios.js](https://unpkg.com/axios/dist/axios.js).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在处理单个页面，您可以从CDN导入以下文件，网址为[https://unpkg.com/axios/dist/axios.js](https://unpkg.com/axios/dist/axios.js)。
- en: Unfortunately, the advise slip service we will use will not work with JSFiddle
    because while the service runs on HTTP, JSFiddle is on HTTPS and your browser
    will most likely complain. You can run this recipe on a local HTML file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们将使用的建议服务在JSFiddle上无法工作，因为服务运行在HTTP上，而JSFiddle在HTTPS上，你的浏览器很可能会抱怨。你可以在本地HTML文件上运行这个教程。
- en: 'Our HTML looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our Vue instance is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Vue实例如下：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open your app to have a refreshingly wise slip of advice:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的应用程序，获得一条令人耳目一新的智慧建议：
- en: '![](assets/fe5c736a-4340-4b65-be40-c53492e3e2fc.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fe5c736a-4340-4b65-be40-c53492e3e2fc.png)'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When our application starts up, the created hook is engaged and will run the
    code with Axios. The first line performs a GET request to the API endpoint:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序启动时，创建的钩子被激活，并将使用Axios运行代码。第一行执行一个GET请求到API端点：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will return a promise. We can use the `then` method on any promise to
    act on the result if the promise resolves successfully:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个promise。我们可以在任何promise上使用`then`方法来处理结果，如果promise成功解决：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The response object will contain some data about the result of our request.
    A possible response object is the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 响应对象将包含关于我们请求结果的一些数据。一个可能的响应对象如下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We navigate to the property we want to interact with; in our case, we want `response.data.slip.advice`,
    which is the string. We copied the string in the variable advice in the instance
    state.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导航到我们想要交互的属性；在我们的例子中，我们想要`response.data.slip.advice`，这是一个字符串。我们将字符串复制到实例状态中的建议变量中。
- en: 'The last part is when something wrong happens to our request or to our code
    inside the first branch:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是当我们的请求或者第一分支内的代码出现问题时：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will explore error handling more in depth in the *Recovering from an error
    during a request* recipe. For now, let's trigger an error by hand, just to see
    what happens.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*在请求期间从错误中恢复*的教程中更深入地探讨错误处理。现在，让我们手动触发一个错误，看看会发生什么。
- en: 'The cheapest way to trigger an error is to run the app on JSFiddle. Since the
    browser detects JSFiddle on a secure connection and our API is on HTTP (which
    is not secure), modern browsers will complain and will block the connection. You
    should see the following text:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 触发错误的最便宜的方法是在JSFiddle上运行应用程序。由于浏览器检测到JSFiddle是在安全连接上，而我们的API是在HTTP上（不安全），现代浏览器会抱怨并阻止连接。你应该看到以下文本：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is just one of the many possible errors you can experiment with. Consider
    that you edit the GET endpoint to some non-existent page:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是你可以尝试的许多可能错误之一。考虑到你将GET端点编辑为一些不存在的页面：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, you will get a 404 error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你会得到一个404错误：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Interestingly, you will end up in the error branch even if the request goes
    well but there is an error in the first branch.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，即使请求顺利进行，但第一分支中出现错误，你最终会进入错误分支。
- en: 'Change the `then` branch to this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将`then`分支更改为这样：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As everybody knows, JavaScript cannot read "hello" property  of an undefined
    object:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，JavaScript无法读取未定义对象的“hello”属性：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's just as I told you.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我告诉你的那样。
- en: Validating user data before sending it
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在发送用户数据之前验证它的有效性
- en: Generally, users hate forms. While we can't do much to change that, we can make
    it less frustrating for them by providing relevant instructions on how to fill
    them in. In this recipe, we will create a form, and we will leverage HTML standards
    to provide the user with a nice guidance on how to complete it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，用户讨厌表单。虽然我们无法改变这一点，但我们可以通过提供有关如何填写表单的相关说明来减少他们的挫败感。在这个教程中，我们将创建一个表单，并利用HTML标准为用户提供如何完成它的良好指导。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe does not need previous knowledge to be completed. While we will
    build a form (the *Sending basic AJAX requests with Axios* recipe), we will fake
    the AJAX call and concentrate on the validation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程不需要先前的知识就可以完成。虽然我们将构建一个表单（*使用Axios发送基本AJAX请求*教程），但我们将伪造AJAX调用并集中在验证上。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will build a very simple form: one field for the username and one for the
    user e-mail, plus one button to submit the information.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个非常简单的表单：一个用于用户名的字段，一个用于用户电子邮件的字段，以及一个用于提交信息的按钮。
- en: 'Type in this HTML:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中输入：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The Vue instance is trivial, as shown:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Vue实例很简单，如下所示：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run this app and try to submit the form with an empty field or wrong e-mail.
    You should see help from the browser itself:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个应用程序，尝试提交一个空字段或错误的电子邮件。您应该会看到浏览器本身的帮助：
- en: '![](assets/89b2c210-31e6-4a6e-b06e-fb5fab39ee29.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/89b2c210-31e6-4a6e-b06e-fb5fab39ee29.png)'
- en: 'Then, if you try to enter an invalid e-mail address, you will see the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您尝试输入一个无效的电子邮件地址，您将看到以下内容：
- en: '![](assets/9ae50ef5-524f-432f-82e4-1735525a8179.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9ae50ef5-524f-432f-82e4-1735525a8179.png)'
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are using a native HTML5 validation API, which internally uses pattern matching
    to check whether what we are typing is conformant to certain rules.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用原生的HTML5验证API，它在内部使用模式匹配来检查我们输入的内容是否符合某些规则。
- en: 'Consider the attribute required in the following line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下行中的required属性：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This ensures that when we submit the form, the field is actually populated while
    having `type="email"` in the other input element ensures that the content resembles
    an e-mail format.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以确保当我们提交表单时，字段实际上是填充的，而在另一个输入元素中使用`type="email"`可以确保内容类似于电子邮件格式。
- en: This API is very rich and you can read more at [https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms/Data_form_validation](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms/Data_form_validation).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API非常丰富，您可以在[https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms/Data_form_validation](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms/Data_form_validation)上阅读更多。
- en: 'Many a time, the problem is that to leverage this API, we need to trigger the
    native validation mechanism. This means that we are not allowed to prevent the
    default behavior of the Submit button:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，问题在于要利用这个API，我们需要触发原生验证机制。这意味着我们不能阻止提交按钮的默认行为：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will not trigger the native validation and the form will always be submitted.
    On the other hand, if we do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会触发原生验证，表单将始终被提交。另一方面，如果我们这样做：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The form will get validated but, since we are not preventing the default behavior
    of the submit button, the form will be sent to another page, which will destroy
    the one-page application experience.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表单将被验证，但由于我们没有阻止提交按钮的默认行为，表单将被发送到另一个页面，这将破坏单页面应用程序的体验。
- en: 'The trick is to intercept the submit at form level:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是在表单级别拦截提交：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This way, we can have form native validation and all the modern browsing experience
    we really like.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以拥有表单的原生验证和我们真正喜欢的现代浏览体验。
- en: Creating a form and sending data to your server
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个表单并将数据发送到您的服务器
- en: HTML forms are a standard way to interact with your user. You can gather their
    data to register within the site, make them log in, or even carry out more advanced
    interactions. In this recipe, you will build your first form with Vue.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表单是与用户交互的标准方式。您可以收集他们的数据以在网站内注册，让他们登录，甚至进行更高级的交互。在这个教程中，您将使用Vue构建您的第一个表单。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is very easy, but it assumes that you already know about AJAX and
    you want to apply your knowledge on Vue.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程非常简单，但它假设您已经了解AJAX，并且希望将您的知识应用到Vue上。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s pretend that we have a blog, and we want to write a new post. For that,
    we need a form. Here is how you lay out the HTML:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个博客，并且我们想写一篇新文章。为此，我们需要一个表单。以下是HTML的布局方式：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have a box for the title, one for the body of our new post, and a button
    to send our post.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用于标题的框，一个用于我们新帖子的正文的框，以及一个发送我们的帖子的按钮。
- en: 'In our Vue instance, those three things along with a user ID will be part of
    the state of the app:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Vue实例中，这三个东西以及用户ID将成为应用程序状态的一部分：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, we just need to add a method to send the data to our server when
    we click on the Submit button. Since we don't have a server, we will use a very
    useful service by **Typicode.** It's basically a fake REST server. We will send
    a request and the server will respond in a realistic manner, even if nothing will
    really happen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们只需要在单击“提交”按钮时向服务器发送数据的方法。由于我们没有服务器，我们将使用**Typicode**提供的非常有用的服务。它基本上是一个虚假的REST服务器。我们将发送一个请求，服务器将以真实的方式做出响应，即使实际上什么都不会发生。
- en: 'Here''s our method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的方法：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To see the actual response of the server, we will add the response variable
    to our status:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看服务器的实际响应，我们将把响应变量添加到我们的状态中：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After the form in our HTML, add the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML表单之后，添加以下内容：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you launch your page, you should be able to interact with your server.
    When you write a post, the server will echo the post and answer with the post
    ID:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动页面时，您应该能够与服务器进行交互。当您写一篇文章时，服务器将回显该文章并回复帖子ID：
- en: '![](assets/5b07cbb9-8885-48fa-b2f3-e2722be8aa0b.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5b07cbb9-8885-48fa-b2f3-e2722be8aa0b.png)'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Most of the magic happens in the `submit` method. In the first line, we are
    creating an `XMLHttpRequest` object, which is a native JavaScript mechanism to
    make AJAX requests:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分魔法发生在`submit`方法中。在第一行，我们创建了一个`XMLHttpRequest`对象，这是一个用于发出AJAX请求的本机JavaScript机制：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then use the `open` and `setRequestHeader` methods to configure a new connection;
    we want to send a POST request, and we will send some JSON along with it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`open`和`setRequestHeader`方法来配置一个新的连接；我们要发送一个POST请求，并且我们将随之发送一些JSON：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since we are interacting with a RESTful interface, the POST method means that
    we expect our request to modify data on the server (in particular, create a new
    post), and that issuing the same request more than one time will get different
    results every time (namely we will create a new, different post ID each time).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在与RESTful接口交互，POST方法意味着我们期望我们的请求修改服务器上的数据（特别是创建一个新的帖子），并且多次发出相同的请求将每次都得到不同的结果（换句话说，我们将创建一个新的、不同的帖子ID）。
- en: This is different from the more common GET request that will not modify data
    on the server (except logs maybe) and this will always yield the same results
    (provided that data on the server does not change between requests).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这与更常见的GET请求不同，后者不会修改服务器上的数据（除了可能的日志），并且始终会产生相同的结果（假设服务器上的数据在请求之间没有发生变化）。
- en: For more details about REST, take a look at the *Creating a REST client (and
    server!)* recipe.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有关REST的更多细节，请查看*创建REST客户端（和服务器！）*的内容。
- en: 'The following lines are all about the response:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行都是关于响应的：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will install a handler whenever we get some kind of change in our object.
    If the `readyState` is changed to `DONE` it means, that we have our response from
    the server. Next, we check the status code, which should be `201` to signal that
    a new resource (our new post) has been created. If that is the case, we set the
    variable we put in the mustaches to get a quick feedback. Otherwise, we put the
    error message we received in the same variable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的对象发生某种变化时安装一个处理程序。如果`readyState`变为`DONE`，这意味着我们从服务器得到了响应。接下来，我们检查状态码，应该是`201`，表示已创建了一个新资源（我们的新帖子）。如果是这种情况，我们设置放在双大括号中的变量以获得快速反馈。否则，我们将接收到的错误消息放入同一个变量中。
- en: 'The last thing we need to do, after setting up the event handlers, is to actually
    send the request along with the data of our new post:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置事件处理程序之后，我们需要做的最后一件事是实际发送请求以及我们新帖子的数据：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Another way to approach the same problem is to use Axios for sending the AJAX
    request. If you need to brush up on what Axios is, take a look at the *Sending
    basic AJAX requests with Axios* recipe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决相同问题的方法是使用Axios发送AJAX请求。如果你需要了解Axios是什么，可以看一下*使用Axios发送基本的AJAX请求*这个教程。
- en: 'The code for the `submit` method will become as follows (remember to add Axios
    as a dependency):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit`方法的代码将变成如下（记得将Axios添加为依赖项）：'
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code is perfectly equivalent, but it's much more expressive and concise
    than using native browser objects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码完全等效，但比使用原生浏览器对象更具表现力和简洁。
- en: Recovering from an error during a request
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在请求期间从错误中恢复
- en: Requests to an external service take ages from the perspective of a computer.
    In human terms, it would be like sending a satellite to Jupiter and waiting for
    it to come back to Earth. You can't be 100% sure that the travel will ever be
    complete and how much time will the travel actually take. Networks are notoriously
    flaky and it's better to come prepared in case our request does not complete successfully.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算机的角度来看，对外部服务的请求需要很长时间。从人类的角度来看，就像是把卫星送到木星，然后等待它返回地球。你无法百分之百确定旅行是否会完成，以及旅行实际需要多长时间。网络经常不稳定，最好提前做好准备，以防我们的请求无法成功完成。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is a little complex, but, does not use advanced concepts. You are
    expected, nonetheless, to be familiar with using Vue.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程有点复杂，但并不使用高级概念。然而，你应该熟悉使用Vue。
- en: We will be using Axios for this recipe. You can complete the *Sending basic
    AJAX requests with Axios* recipe if you are unsure of what it exactly entails.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个教程中使用Axios。如果你不确定它具体包含什么，可以完成*使用Axios发送基本的AJAX请求*这个教程。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: You will build a website for ordering pizzas on Mt. Everest. The area has a
    notoriously poor Internet connection, so we may want to retry a couple of times
    before giving up on our pizza.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你将为在珠穆朗玛峰上订购比萨的网站建立一个网站。该地区的互联网连接非常差，所以在放弃我们的比萨之前，我们可能需要重试几次。
- en: 'This is what our HTML looks like:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的HTML代码：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have a button to place orders that will be disabled while an order is in
    progress--a list of orders in progress (that will contain only one order for the
    moment) and a list of pizzas already ordered.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用于下订单的按钮，当订单正在进行时会被禁用--一个正在进行中的订单列表（目前只包含一个订单）和一个已经订购的比萨列表。
- en: 'We can add a spinner to make the waiting a bit more pleasant. Add this CSS
    to make the little pizza spin:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个旋转的小比萨饼来让等待变得更愉快。添加这个CSS来让小比萨饼旋转：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our Vue instance will keep track of a few things; write this code to start
    building the instance:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Vue实例将跟踪一些东西；写下这段代码来开始构建实例：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: I would like to use JavaScript sets for the requests and responses; unfortunately,
    sets are not reactive in Vue; the closest thing we can use is an object, which
    is empty for now, that is, we are initializing requests and responses to an empty
    object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要使用JavaScript集来处理请求和响应；不幸的是，在Vue中，集合不是响应式的；我们可以使用的最接近的东西是一个对象，目前是空的，也就是说，我们正在将请求和响应初始化为空对象。
- en: 'The `impatientAxios` variable will be filled upon creation. Normally, Axios
    waits as long as the browser will wait for a response. Since we are impatient,
    we will create an Axios that will drop the connection after 3 seconds:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`impatientAxios`变量将在创建时填充。通常，Axios会等待浏览器等待响应的时间。由于我们心急，我们将创建一个在3秒后断开连接的Axios：'
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The last thing we need to build is the order method. Since we don''t have a
    web server to make actual requests to, we will use the `http://httpstat.us/200`
    endpoint that simply answers 200 OK to all our requests:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建的最后一件事是订单方法。由于我们没有一个用于实际请求的网络服务器，我们将使用 `http://httpstat.us/200` 端点，它对我们所有的请求都简单地回答200
    OK：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To run this program as intended, open it in Chrome and open the Developer Tools
    with *Cmd* + *Opt* + *I*  (*F12* on Windows):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按预期运行这个程序，用Chrome打开它，并用*Cmd* + *Opt* + *I*（在Windows上是*F12*）打开开发者工具：
- en: '![](assets/a50f7cc7-aa6e-41f7-aaed-00600cf52c1f.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a50f7cc7-aa6e-41f7-aaed-00600cf52c1f.png)'
- en: 'Switch the tab to Network and open the dropdown where you see No Throttling:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到网络选项卡，并打开下拉菜单，你会看到没有节流：
- en: '**![](assets/3839d7cb-8319-4cd7-9198-0ffe81506b27.png)**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](assets/3839d7cb-8319-4cd7-9198-0ffe81506b27.png)**'
- en: 'Click on it to display the drop-down menu:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 点击它以显示下拉菜单：
- en: '![](assets/a76b0d43-9f47-45e6-a471-83e2750189b0.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a76b0d43-9f47-45e6-a471-83e2750189b0.png)'
- en: 'Add a new custom throttling called `Everest` with `1kb/s` for download and
    upload and a latency of `1,000` milliseconds, as in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为`Everest`的新自定义节流，下载和上传速度为`1kb/s`，延迟为`1,000`毫秒，如下面的屏幕截图所示：
- en: '![](assets/4a15fc97-768d-4c46-851b-ed6661401e52.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4a15fc97-768d-4c46-851b-ed6661401e52.png)'
- en: You can then select that type of throttling and try to order some pizzas. If
    you are lucky, you should eventually be able to order some, thanks to the persistency
    of Axios.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以选择那种类型的节流并尝试订购一些披萨。如果你幸运的话，你最终应该能够订购一些，这要归功于Axios的持久性。
- en: If you are not getting success or if all your pizzas are ordered correctly,
    try to adjust the parameters; much of this process is actually random and highly
    dependent on the machine.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有成功或者你的所有披萨都被正确地订购了，尝试调整参数；这个过程中很大一部分实际上是随机的，而且高度依赖于机器。
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are many ways to deal with flaky connections and there are many libraries
    out there that integrate with Axios and have more advanced retry and reattempt
    strategies. Here, we have seen only one basic strategy, but libraries such as **Patience
    JS** have more advanced ones and they are not difficult to use.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多处理不稳定连接的方法，也有许多与Axios集成并具有更高级重试和重试策略的库。在这里，我们只看到了一种基本策略，但是像**Patience JS**这样的库有更高级的策略，它们并不难使用。
- en: Creating a REST client (and server!)
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个REST客户端（和服务器！）
- en: In this recipe, we will learn about REST and how to build a REST client. To
    build a REST client, we will need a server that exposes a REST interface; we will
    build that also. Wait a minute! A whole REST server is a side note in a recipe
    in a book about Vue? Just follow along and you won't be disappointed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习关于REST以及如何构建REST客户端。要构建一个REST客户端，我们需要一个暴露REST接口的服务器；我们也将构建它。等一下！在一本关于Vue的书中，一个完整的REST服务器只是一个附注？只要跟着做，你就不会失望。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is fairly advanced in the sense that you will need to be comfortable
    with the architecture of client and server and at least have heard or read about
    REST interfaces. You will also need to be familiar with the command line and have
    npm installed. You can read all about it in the *Choosing a development environment* recipe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在某种意义上相当高级，您需要熟悉客户端和服务器的架构，并且至少听说过或阅读过REST接口。您还需要熟悉命令行并安装npm。您可以在*选择开发环境*示例中了解所有相关信息。
- en: Axios will also need to be installed; read more about this in the first recipe
    of this chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要安装Axios；在本章的第一个示例中可以了解更多信息。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'I remember when some years ago, building a REST server could take days or weeks.
    You can use `Feather.js`, and it will be quick and (hopefully painless). Open
    a command line and install it through npm with the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我还记得几年前，构建REST服务器可能需要花费几天甚至几周的时间。您可以使用`Feather.js`，它将快速且（希望是）无痛的。打开命令行并使用以下命令通过npm安装它：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After that, create a directory where you will run the server, go inside it,
    and launch Feathers:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，创建一个目录，在其中运行服务器，然后进入该目录并启动Feathers：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Answer all the questions with default values. When the process finishes, type
    in the following command to create a new resource:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有问题的答案都设置为默认值。当进程完成时，键入以下命令以创建新资源：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: One of the questions is the name of the resource; call it `messages`, but other
    than that, use the default for all the other questions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个问题是资源的名称；将其命名为`messages`，但除此之外，其他问题都使用默认值。
- en: 'Exit from the feathers-cli with the  `exit` command and start your new server
    with the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`exit`命令退出feathers-cli，并使用以下命令启动新服务器：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After some seconds, your REST server should be started and should be listening
    on port `3030`. Can you honestly say it was difficult?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，您的REST服务器应该已启动，并且应该正在端口`3030`上进行监听。你能诚实地说这很困难吗？
- en: The preceding sequence of commands works with Feathers version 2.0.0
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令序列适用于Feathers版本2.0.0
- en: It's totally possible that you may be using another version but it should still
    be easy to get the same result with a later version; check the online install
    guide at [https://feathersjs.com/](https://feathersjs.com/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能正在使用另一个版本，但是使用后续版本仍然很容易获得相同的结果；请查看[https://feathersjs.com/](https://feathersjs.com/)上的在线安装指南。
- en: Next, you'll build a Vue app that communicates with the server seamlessly. Now,
    since the server is running in your local environment through HTTP, you will not
    be able to use JSFiddle because it works on HTTPS and considers HTTP insecure.
    You can either use other methods described earlier or use services on HTTP, such
    as [codepen.io](http://codepen.io) or others.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将构建一个与服务器无缝通信的Vue应用程序。现在，由于服务器通过HTTP在本地环境中运行，您将无法使用JSFiddle，因为它在HTTPS上运行，并认为HTTP是不安全的。您可以使用之前描述的其他方法，或者使用HTTP上的服务，例如[codepen.io](http://codepen.io)或其他服务。
- en: You will code an app that manages sticky messages. We want to be able to view,
    add, edit, and delete them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您将编写一个管理便签消息的应用程序。我们希望能够查看、添加、编辑和删除它们。
- en: 'Type the following in this HTML:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中键入以下内容：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our Vue instance state will consist of a list of recorded messages, plus a temporary
    message to be added to the list:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Vue实例状态将包括一系列记录的消息，以及要添加到列表中的临时消息：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first thing that we want to do is ask the server for a list of messages.
    Write the created hook for this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是向服务器请求消息列表。为此编写创建的钩子：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For creating a new message, write a method that binds to the click of the add
    button and send what''s written in the input box to the server:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新消息，请编写一个绑定到添加按钮的点击事件的方法，并将输入框中的内容发送到服务器：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Similarly, write a method for deleting a message and for editing a message:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，编写一个用于删除消息和编辑消息的方法：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Launch your application and you will be able to manage your board of sticky
    messages:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 启动你的应用程序，你将能够管理你的便利贴消息板：
- en: '![](assets/99b328f2-4364-4d96-8c9d-26d0accb2dc6.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/99b328f2-4364-4d96-8c9d-26d0accb2dc6.png)'
- en: To prove to yourself that you are really communicating with the server, you
    can refresh the page or close and reopen the browser and your notes will still
    be there.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明你确实在与服务器通信，你可以刷新页面，或者关闭并重新打开浏览器，你的笔记仍然会在那里。
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '**REST** means **REpresentational State Transfer**, as in you will transfer
    a representation of the state of some resource. In practice, we are using a set
    of **verbs** to transfer the representation of the state of our messages.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**意味着**REpresentational State Transfer**，也就是说你将传输某个资源状态的表示。在实践中，我们使用一组**动词**来传输我们消息状态的表示。'
- en: 'Using the HTTP protocol, we have at our disposal the following verbs:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP协议，我们可以使用以下动词：
- en: '| **Verb** | **Properties** | **Description** |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **动词** | **属性** | **描述** |'
- en: '| `GET` | Idempotent, safe | Used to retrieve the representation of a resource
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 幂等，安全 | 用于检索资源的表示 |'
- en: '| `POST` |  | Used to upload a new resource |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `POST` |  | 用于上传新资源 |'
- en: '| `PUT` | Idempotent | Used to upload an existing resource (to modify it) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 幂等 | 用于上传现有资源（修改它） |'
- en: '| `DELETE` | Idempotent | Used to delete a resource |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 幂等 | 用于删除资源 |'
- en: Idempotent means that if we use the same verb twice, nothing will happen to
    the resource, and safe means that nothing will happen at all.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等意味着如果我们两次使用相同的动词，资源不会发生任何变化，而安全意味着根本不会发生任何变化。
- en: In our application, we use the GET verb only at the beginning during creation.
    When we see the list changing as a result of the other actions, it is only because
    we are mirroring the actions on the server on the frontend.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们只在创建时使用GET动词。当我们看到列表因其他操作而改变时，那只是因为我们在前端上反映了服务器上的操作。
- en: The POST verb is used to add a new message to the list. Note how it's not idempotent,
    as even with the same text in the sticky message, we nonetheless create a new
    message that differs in ID when pressing the add button.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: POST动词用于向列表中添加新消息。请注意，它不是幂等的，因为即使在便利贴消息中使用相同的文本，我们仍然会在按下添加按钮时创建一个ID不同的新消息。
- en: Pressing the edit button triggers a PUT and the Delete button, well, you can
    imagine that it uses the DELETE verb.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按下编辑按钮会触发PUT，而删除按钮，嗯，你可以想象它使用了DELETE动词。
- en: Axios makes this very clear by naming the methods of its API with the verbs
    themselves.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Axios通过使用动词本身来命名其API的方法，使其非常清晰。
- en: Implementing infinite scrolling
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现无限滚动
- en: Infinite scrolling is a fine example of what you can do with Vue and AJAX. It
    is also quite popular and can improve interaction for some kind of content. You
    will build a random word generator that works with infinite scrolling.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 无限滚动是使用Vue和AJAX的一个很好的例子。它也非常受欢迎，可以改善某些类型内容的交互。你将构建一个可以使用无限滚动的随机单词生成器。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use Axios. Take a look at the *Sending basic AJAX requests with Axios*
    recipe to know how to install it and its basic functionality. Other than that,
    you don't need to know much to follow along.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Axios。查看*使用Axios发送基本AJAX请求*的示例，了解如何安装它及其基本功能。除此之外，你不需要了解太多就可以跟着做。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To make our app work, we will ask random words from the [http://www.setgetgo.com/randomword/get.php](http://www.setgetgo.com/randomword/get.php) endpoint.
    Every time you point the browser at this address, you will get a random word.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序工作，我们将从[http://www.setgetgo.com/randomword/get.php](http://www.setgetgo.com/randomword/get.php)端点请求随机单词。每次你将浏览器指向这个地址，你都会得到一个随机单词。
- en: 'The whole page will consist solely of an infinite list of words. Write the
    following HTML:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 整个页面将仅由无限单词列表组成。编写以下HTML：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The list of words needs to grow as we scroll down. So we need two things: understanding
    when the user reaches the bottom of the page, and getting new words.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 随着页面向下滚动，单词列表需要增长。所以我们需要两件事：了解用户何时到达页面底部，以及获取新单词。
- en: 'To know when the user has reached the bottom of the page, we add a method in
    our Vue instance:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道用户何时到达页面底部，我们在Vue实例中添加一个方法：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will return `true` if either the page is scrolled until the bottom of the
    page itself is smaller than the browser.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果页面滚动到底部，或者页面本身比浏览器小，这将返回`true`。
- en: 'Next, we need to add a mechanism to bind the result of this function to a state
    variable bottom and update it every time the user scrolls the page. We can do
    that in the created hook:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个机制，将这个函数的结果绑定到一个状态变量`bottom`，并在用户滚动页面时更新它。我们可以在`created`钩子中做到这一点：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The state will be composed of the `bottom` variable and the list of random
    words:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 状态将由`bottom`变量和随机单词列表组成：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We now need a method to add words to the array. Add the following method to
    the existing method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个方法来向数组中添加单词。将以下方法添加到现有方法中：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The method will recursively call itself until the page has enough words to fill
    the whole browser view.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将递归调用自身，直到页面有足够的单词填满整个浏览器视图。
- en: 'Since this method needs to be called every time we reach the bottom, we will
    watch for the bottom variable and fire the method if it''s `true.` Add the following
    option to the Vue instance just after the data:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个方法需要在每次到达底部时被调用，我们将监视底部变量，并在其为`true`时触发该方法。在`data`之后的Vue实例中添加以下选项：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We also need to call the `addWord` method in the created hook to kick-start
    the page:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`created`钩子中调用`addWord`方法来启动页面：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you launch the page now, you will have an infinite stream of random words,
    which is useful when you need to create a new password!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在启动页面，你将得到一个无限流的随机单词，这在你需要创建新密码时很有用！
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we used an option called `watch`, which uses the following
    syntax:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们使用了一个叫做`watch`的选项，它使用以下语法：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is the counterpart of computed properties when we are not interested in
    a result after some reactive variable changes. As a matter of fact, we used it
    to just fire another method. Had we been interested in the result of some calculations,
    we would have used a computed property.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是计算属性的对应物，当我们对一些响应式变量的变化后不感兴趣。事实上，我们只是用它来触发另一个方法。如果我们对一些计算结果感兴趣，我们会使用计算属性。
- en: Processing a request before sending it out
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在发送请求之前处理请求
- en: This recipe teaches you how to use interceptors to edit your request before
    it goes out to the Internet. This can be useful in some cases, such as when you
    need to supply an authorization token along with all the requests to your server
    or when you need a single point to edit how your API calls are performed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程教你如何使用拦截器在请求发送到互联网之前编辑请求。在某些情况下，这可能很有用，比如当你需要在所有请求到服务器时提供授权令牌，或者当你需要一个单一点来编辑API调用的执行方式时。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses Axios (the *Sending basic AJAX requests with Axios* recipe);
    apart from that, it will be useful to have completed the *How to validate user
    data before sending it* recipe since we will build a small form for demonstration.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程使用了Axios（*使用Axios发送基本AJAX请求*教程）；除此之外，最好已经完成了*在发送数据之前如何验证用户数据*教程，因为我们将构建一个小型表单进行演示。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, you will build a filter for curse words for a hypothetical
    comment system. Suppose there''s an article on our website that can potentially
    start a flame war:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将为一个假设的评论系统构建一个脏话过滤器。假设我们网站上有一篇文章可能会引发争论：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After that article, we place a comment box:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在那篇文章之后，我们放置了一个评论框：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We also added a line after the form to debug the response that we will get from
    the server.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在表单后面添加了一行来调试我们将从服务器获取的响应。
- en: In our Vue instance, we write all the support code to send the comment to our
    server, which, in this case, will be [http://jsonplaceholder.typicode.com/comments](http://www.setgetgo.com/randomword/get.php),
    a fake REST interface that will behave like a real server.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Vue实例中，我们编写所有支持代码将评论发送到我们的服务器，这种情况下，将是[http://jsonplaceholder.typicode.com/comments](http://www.setgetgo.com/randomword/get.php)，一个假的REST接口，将表现得像一个真正的服务器。
- en: 'Here''s the submit method that is triggered by the press of the Submit button:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由按下提交按钮触发的submit方法：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The state of the Vue instance will only be two variables:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Vue实例的状态将只有两个变量：
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As usual, we want to mount it to the `<div>` app:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们希望将其挂载到`<div>`应用程序中：
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As soon as the instance is mounted, we want to install the word filter in Axios;
    for this, we tap into the `mounted` hook of Vue:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例被挂载，我们希望在Axios中安装单词过滤器；为此，我们利用Vue的`mounted`钩子：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can launch our application now and try to write our salty comment:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动我们的应用程序并尝试写我们的脏话评论：
- en: '![](assets/fbf91399-45a4-41e4-88dc-20fe51bfabed.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fbf91399-45a4-41e4-88dc-20fe51bfabed.png)'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the `mounted` hook, we are installing a so-called `interceptor.` In particular,
    it is a request interceptor, which means it will take our request and manipulate
    it before sending it out to the Internet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mounted`钩子中，我们正在安装所谓的`拦截器`。特别是一个请求拦截器，这意味着它将获取我们的请求并在发送到互联网之前对其进行操作：
- en: '[PRE56]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `config` object contains a lot of things we can edit. It contains the headers
    and URL parameters. It also contains Axios configuration variables. You can check
    out the Axios documentation for an up-to-date list.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`config`对象包含许多我们可以编辑的内容。它包含头部和URL参数。它还包含Axios配置变量。您可以查看Axios文档以获取最新列表。'
- en: We are taking what's inside the data part that got sent along with the POST
    request and sniffing if the `punk` word is found. If that is the case, it will
    get substituted with asterisks. The returned object will be the new config for
    the current request.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在获取随POST请求发送的数据部分，并检查是否存在“punk”这个词。如果是这样，它将被替换为星号。返回的对象将成为当前请求的新配置。
- en: Preventing XSS attacks to your app
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止XSS攻击到您的应用程序
- en: Writing applications without thinking about security will inevitably lead to
    vulnerabilities, especially if it has to run on a web server. **Cross site scripting**
    (**XSS**) is among the most popular security issues nowadays; even if you are
    not a security expert, you should be aware of how it works and how to prevent
    it in a Vue application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有考虑安全性的情况下编写应用程序将不可避免地导致漏洞，特别是如果它必须在Web服务器上运行。**跨站脚本**（**XSS**）是当今最流行的安全问题之一；即使您不是安全专家，您也应该了解它的工作原理以及如何在Vue应用程序中防止它。
- en: Getting ready
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe does not need any previous knowledge except for Axios. You can find
    more on Axios and how to install it in the *Sending basic AJAX requests with Axios* recipe.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤不需要任何先前的知识，只需要了解Axios。您可以在*使用Axios发送基本的AJAX请求*中找到更多关于Axios以及如何安装它的信息。
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The first thing you should do is to discover how your backend is giving you
    the CSRF token (more on this in the next paragraph). We will suppose that the
    server will place a cookie in your browser with the name, XSRF-TOKEN.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该首先发现后端是如何给您CSRF令牌的（在下一段中会详细介绍）。我们假设服务器会在您的浏览器中放置一个名为XSRF-TOKEN的cookie。
- en: You can simulate your server, setting a cookie with the `document.cookie = 'XSRF-TOKEN=abc123'` command
    issued in the browser console (in the developer tools).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以模拟您的服务器，在浏览器控制台中使用`document.cookie = 'XSRF-TOKEN=abc123'`命令设置一个cookie（在开发者工具中）。
- en: Axios automatically reads such a cookie and transmits it in the next request.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Axios会自动读取这样的cookie，并在下一次请求中传输它。
- en: 'Consider that we call an Axios `get` request in our code, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们在代码中调用了一个Axios的`get`请求，如下所示：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Axios will pick up that cookie and add a new header to the request called X-XSRF-TOKEN.
    You can see such headers in the Network tab of the Developer Tools in Chrome by
    clicking on the name of the request:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Axios会获取该cookie，并在请求中添加一个名为X-XSRF-TOKEN的新标头。您可以通过在Chrome的开发者工具的网络选项卡中点击请求的名称来查看这样的标头：
- en: '![](assets/ccef71e0-e9d4-4a34-af67-ad1bd4625699.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ccef71e0-e9d4-4a34-af67-ad1bd4625699.png)'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To prevent XSS attacks, you must ensure that no user input can appear as code
    in your app. This means you must be very careful about using the `v-html` attribute
    (the *Output raw HTML* recipe).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止XSS攻击，您必须确保没有用户输入会出现在您的应用程序中。这意味着您必须非常小心地使用`v-html`属性（*输出原始HTML*的方法）。
- en: Unfortunately, you can't control what happens outside your page. If one of your
    users receives a fake e-mail that contains a link that corresponds to an action
    in your application, clicking on the link in the e-mail will trigger the action.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，您无法控制页面外发生的事情。如果您的用户之一收到了包含与您的应用程序中的操作相对应的链接的虚假电子邮件，那么点击邮件中的链接将触发该操作。
- en: 'Let''s make a concrete example; you developed a bank app, *VueBank*, and a
    user of your app receives the following fake e-mail:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个具体的例子；您开发了一个银行应用*VueBank*，您的应用用户收到了以下虚假电子邮件：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, the mail is not even about our application and the `here` hyperlink
    is hidden in the HTML of the mail itself. In reality, it points to the `http://vuebank.com?give_all_my_money_to_account=754839534` address.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这封邮件甚至与我们的应用无关，`here`超链接被隐藏在邮件本身的HTML中。实际上，它指向`http://vuebank.com?give_all_my_money_to_account=754839534`地址。
- en: If we are logged in to VueBank, the link may work right away. It does not look
    good for our finances.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经登录了VueBank，那么链接可能会立即生效。这对我们的财务状况不利。
- en: To prevent these kinds of attacks, we should have our backend generate a **CSRF** (**Cross
    Site Request Forgery**) token for us. We will take the token and send it along
    the request to prove that the request originated from the user. The preceding
    link will become
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这类攻击，我们应该让后端为我们生成一个**CSRF**（**跨站点请求伪造**）令牌。我们将获取该令牌并将其发送到请求中，以证明该请求是由用户发起的。前面的链接将变成
- en: '`http://vuebank.com?give_all_my_money_to_account=754839534&csrf=s83Rnj`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://vuebank.com?give_all_my_money_to_account=754839534&csrf=s83Rnj`。'
- en: Since the token is generated randomly every time, the link in the mail cannot
    be forged correctly because the attacker does not know the token that the server
    gave to the web page.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于令牌每次都是随机生成的，所以邮件中的链接无法被正确伪造，因为攻击者不知道服务器给网页的令牌。
- en: In Vue, we use Axios to send the token. Usually, we won't send it as part of
    the link, but in a header of the request; in fact, Axios does this for us and
    puts in the token in the next request automatically.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue中，我们使用Axios来发送令牌。通常，我们不会将其作为链接的一部分发送，而是作为请求的标头；实际上，Axios会为我们执行此操作，并在下一个请求中自动放入令牌。
- en: You can change the name of the cookie that Axios will pick up by setting the
    `axios.defaults.xsrfCookieName` variable, and you can edit the name of the header
    that will return the token acting on the `axios.defaults.xsrfHeaderName` variable.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过设置`axios.defaults.xsrfCookieName`变量来更改Axios将拾取的cookie的名称，并且您可以通过编辑`axios.defaults.xsrfHeaderName`变量来更改将返回令牌的标头的名称。
