- en: Understanding Vue 3 and Creating Components
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Vue 3和创建组件
- en: '**Vue 3** brings a lot of new features and changes for developers, all of them
    designed to aid development and improve the framework''s overall stability, speed,
    and maintainability. Using other frameworks and libraries as inspiration, the
    Vue core team managed to achieve a great level of abstraction on the API where
    anyone can use Vue now, irrespective of whether they''re a frontend developer
    or a backend developer.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3带来了许多新功能和变化，所有这些都旨在帮助开发并改善框架的整体稳定性、速度和可维护性。借鉴其他框架和库的灵感，Vue核心团队设法在API上实现了很高的抽象水平，现在任何人都可以使用Vue，无论他们是前端开发人员还是后端开发人员。
- en: In this chapter, we will learn how to upgrade our Vue project to the new version,
    and more about some of the new Vue features, such as the multiple root elements,
    the new attribute inheritance engine, how we can use the exposed reactivity API
    outside of Vue in another application, and how to create a component using the
    new composition API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将我们的Vue项目升级到新版本，以及一些新的Vue功能，比如多个根元素，新的属性继承引擎，我们如何在另一个应用程序中使用暴露的响应性API，以及如何使用新的组合API创建组件。
- en: 'In this chapter, you will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: What is new in Vue 3
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue 3有什么新功能
- en: Upgrading your Vue 2 application to Vue 3
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的Vue 2应用程序升级到Vue 3
- en: Creating components with multiple root elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个根元素创建组件
- en: Creating components with attribute inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性继承创建组件
- en: Using the reactivity and observable API outside the scope of Vue
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue范围之外使用响应性和可观察API
- en: Creating a component using the composition API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合API创建组件
- en: What is new in Vue 3
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 3有什么新功能
- en: You may be wondering how a new version of a framework could result in such hype
    on the internet? Imagine taking a car on the highway, doing a complete 360 roll,
    and then continuing to go full speed ahead in the same direction. This would cause
    a theatrical scene, and it's the perfect way to describe how Vue will go from
    version 2 to 3.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道一个框架的新版本怎么会在互联网上引起如此大的轰动？想象一下把一辆汽车开上高速公路，做一个完整的360度翻滚，然后继续朝着同一个方向全速前进。这将引起一场戏剧性的场面，这正是描述Vue将从2版本升级到3版本的完美方式。
- en: In this first part of the chapter, I will introduce you to the improvements
    on Vue, what was added to the framework, what has changed, and how it will impact
    the way you code a Vue application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我将向您介绍Vue的改进，框架中添加了什么，发生了什么变化，以及它将如何影响您编写Vue应用程序的方式。
- en: Improvements to the framework
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架的改进
- en: There are numerous improvements to the Vue framework in this new release; all
    of them focused on making the framework better in every way possible. Here are
    some of the improvements that can impact the everyday development and usage of
    the framework by users and developers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新版本中，Vue框架有许多改进；所有这些改进都集中在尽可能使框架更好。以下是一些可能影响用户和开发人员日常开发和使用框架的改进。
- en: Under the hood
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 底层
- en: The outer shell looks the same as the old one, but the engine is a piece of
    art. In the new version, there is no leftover code from Vue 2\. The core team
    built the framework from the ground up using TypeScript and rewrote everything
    geared to the maximum performance of the framework.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 外壳看起来和旧的一样，但引擎是一件艺术品。在新版本中，没有留下来自Vue 2的代码。核心团队使用TypeScript从头开始构建了框架，并重写了一切，以最大程度地提高框架的性能。
- en: TypeScript was chosen to create a more maintainable code base for the Vue core
    team and the open-source community, and to improve the autocomplete features,
    such as **IntelliSense** or **typeahead** that the IDEs and code editors provide,
    without the need for special plugins and extensions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 选择了TypeScript来创建Vue核心团队和开源社区更易于维护的代码库，并改进自动完成功能，如IDE和代码编辑器提供的**IntelliSense**或**typeahead**，无需特殊的插件和扩展。
- en: Render engine
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染引擎
- en: For Vue 3, a new render engine was developed using a new algorithm for the shadow
    DOM. This new render is totally exposed by the core of the framework by default,
    without the need to be executed by the framework. This makes it possible for new
    implementations of a completely new render function that can be injected into
    the framework and replace the original render engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vue 3，使用了一种新的算法开发了一个新的渲染引擎，用于影子DOM。这个新的渲染引擎默认情况下完全暴露在框架的核心中，无需由框架执行。这使得可以实现一个全新的渲染函数的新实现，可以注入到框架中并替换原始的渲染引擎。
- en: In this new version of Vue, a new template compiler was written from scratch.
    This new compiler uses a new technique for cache manipulation and to manage the
    rendered elements, and a new hoisted method is applied to the creation of VNodes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新版本的Vue中，从头开始编写了一个新的模板编译器。这个新的编译器使用了一种新的缓存操作和管理渲染元素的新技术，并应用了一种新的提升方法来创建VNodes。
- en: For cache manipulation, a new method is applied to control the position of the
    element, where the element can be a dynamic element with computed data or a response
    to a function that can be mutated.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于缓存操作，应用了一种新的方法来控制元素的位置，其中元素可以是具有计算数据的动态元素，也可以是对可以被改变的函数的响应。
- en: The Vue core team has made an explorer where it's possible to see how the new
    template compiler renders the final `render` function. This can be viewed at [https://vue-next-template-explorer.netlify.app/](https://vue-next-template-explorer.netlify.app/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Vue核心团队制作了一个浏览器，可以看到新模板编译器如何渲染最终的`render`函数。可以在[https://vue-next-template-explorer.netlify.app/](https://vue-next-template-explorer.netlify.app/)上查看。
- en: Exposed APIs
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暴露的API
- en: With all these modifications, it was possible to render all the Vue APIs exposed
    to usage within files outside the scope of application of Vue. It's possible to
    use the Vue reactivity or the shadow DOM in a React application, without the need
    to render a Vue application inside the React application. This explosibility is
    a way of transforming Vue into a more versatile framework, where it can be used
    anywhere, not just in frontend development.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些修改，可以在Vue应用程序范围之外的文件中渲染所有暴露给使用的Vue API。可以在React应用程序中使用Vue响应性或影子DOM，而无需在React应用程序内部渲染Vue应用程序。这种可扩展性是将Vue转变为更多功能的框架的一种方式，它可以在任何地方使用，不仅仅是在前端开发中。
- en: New custom components
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的自定义组件
- en: Vue 3 introduces three new custom components that can be used by the developer
    to resolve old problems. These components were present on Vue 2 but as third-party
    plugins and extensions. Now they are made by the Vue core team and added to the
    Vue core framework.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3引入了三个新的自定义组件，开发人员可以使用这些组件来解决旧问题。这些组件在Vue 2中也存在，但作为第三方插件和扩展。现在它们由Vue核心团队制作，并添加到Vue核心框架中。
- en: Fragments
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 片段
- en: In Vue 2, we always needed to have a parent node wrapping the components inside
    the single-file components. This was caused by the way in which the render engine
    of Vue 2 was constructed, requiring a root element on each node.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 2中，我们总是需要在单文件组件内部的组件周围有一个父节点。这是由于Vue 2的渲染引擎的构造方式所致，需要在每个节点上都有一个根元素。
- en: 'In Vue 2, we needed to have a wrapper element, encapsulating the elements that
    will be rendered. In the example, we have a `div` HTML element, wrapping two `p`
    HTML child elements, so we can achieve multiple elements on the page:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 2中，我们需要有一个包装元素，封装将要呈现的元素。在这个例子中，我们有一个`div` HTML元素，包装了两个`p` HTML子元素，这样我们就可以在页面上实现多个元素：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, in Vue 3, it''s possible to declare any number of root elements on the
    single-file components without the need for special plugins using the new Fragments
    API, which will handle the multiple root elements. This helps to maintain a cleaner
    final code for the user, without the need for empty shells just for wrapping elements:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Vue 3中，可以在单文件组件中声明任意数量的根元素，而无需使用新的Fragments API特殊插件，它将处理多个根元素。这有助于为用户保持更清洁的最终代码，而无需为包装元素而创建空壳：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we saw in the Vue 3 code, we were able to have two root `p` HTML elements,
    without the need for a wrapper element.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在Vue 3代码中看到的，我们能够有两个根`p` HTML元素，而无需包装元素。
- en: Teleport
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Teleport
- en: A `Teleport` component, also known as a Portal component, as the name implies,
    is a component that can make an element go from one component to another. This
    may seem strange in the first instance, but it has a lot of applications, including
    dialogs, custom menus, alerts, badges, and many other customs UIs that need to
    appear in special places.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Teleport`组件，也称为Portal组件，顾名思义，是一个可以使元素从一个组件移动到另一个组件的组件。这一开始可能看起来很奇怪，但它有许多应用，包括对话框、自定义菜单、警报、徽章和许多其他需要出现在特殊位置的自定义UI。'
- en: 'Imagine a header component, where you want a custom slot on the component so
    you can place components:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个标题组件，您希望在组件上放置一个自定义插槽，以便放置组件：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, you want to display a custom button on this header, but you want to call
    this button from a page. You just need to execute the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您想在此标题上显示一个自定义按钮，但您希望从页面上调用此按钮。您只需要执行以下代码：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, your button will be displayed on the header, but the code will be executed
    on the page, giving access to the page scope.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的按钮将显示在标题上，但代码将在页面上执行，从而访问页面范围。
- en: Suspense
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 悬念
- en: When the wait for the data is taking longer than you would like, how about showing
    a custom loader for the user? This is now possible without the need for custom
    code; Vue will handle this for you. The `Suspense` component will manage this
    process, with a default view once the data is loaded, and a fallback view when
    the data is being loaded.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当等待数据的时间比您想要的时间长时，如何为用户显示自定义加载程序？现在这是可能的，而无需自定义代码；Vue将为您处理。`Suspense`组件将管理此过程，在数据加载完成后显示默认视图，并在加载数据时显示备用视图。
- en: 'You can write a special wrapper like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写一个特殊的包装器，如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The new Vue composition API will understand the current state of your component,
    so it will be able to differentiate if the component is loading or if it's ready
    to be displayed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Vue组合API将了解组件的当前状态，因此它将能够区分组件是正在加载还是准备好显示。
- en: API changes
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API更改
- en: Some API changes were made in Vue 3 that were necessary in order to clean the
    Vue API and simplify development. Some of them are break changes, and others are
    additions. But don't worry; the Vue 2 object development was not removed, it's
    still there, and will continue to be used. This declaration method was one of
    the reasons why many developers choose Vue over other frameworks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3进行了一些API更改，这些更改是为了清理Vue API并简化开发而必要的。其中一些是破坏性的更改，另一些是新增的。但不用担心；Vue 2对象开发并没有被移除，它仍然存在，并将继续使用。这种声明方法是许多开发人员选择Vue而不是其他框架的原因之一。
- en: There are some break changes that will happen in Vue 3 that are important to
    learn more about. We will discuss the most important break changes that will be
    introduced in Vue 3, and how to deal with then.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3中将出现一些重要的变化，这些变化很重要，需要更多了解。我们将讨论Vue 3中将引入的最重要的变化，以及如何处理它们。
- en: In Vue 3, a new way of creating the components is being introduced – the composition
    API. This method will make the maintainability of your code better, and give you
    a more reliable code, where you will have the full power of TypeScript available.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 3中，正在引入一种创建组件的新方法——组合API。这种方法将使您的代码更易于维护，并为您提供更可靠的代码，您将拥有TypeScript的全部功能。
- en: Some minor break changes
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些较小的变化
- en: There are some minor break changes that are present in Vue 3 that need to be
    mentioned. These changes relate to one method we used previously to write code,
    and that has now been replaced when using Vue 3\. It's not a Herculean job, but
    you need to know about them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 3中存在一些较小的变化，需要提及。这些变化涉及我们以前用来编写代码的一种方法，现在在使用Vue 3时已经被替换。这并不是一项艰巨的工作，但您需要了解这些变化。
- en: Goodbye filters, hello filters! The Vue filters API
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 再见过滤器，你好过滤器！Vue过滤器API
- en: The way we used `filters` on Vue 2 is no longer available. The Vue filter has
    been removed from the API. This change was made to simplify the render process
    and make it faster. All filters, in the end, are functions that receive a string
    and return a string.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 2中，我们使用`filters`的方式已经不再可用。Vue过滤器已从API中删除。这一变化是为了简化渲染过程并加快速度。最终，所有过滤器都是接收一个字符串并返回一个字符串的函数。
- en: 'In Vue 2, we used to use `filters` like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 2中，我们使用`filters`如下：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, in Vue 3, we just need to pass a `function` to manipulate the `string`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Vue 3中，我们只需要传递一个`function`来操作`string`：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The bus just left the station! The event bus API
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公交车刚刚离开车站！事件总线API
- en: In Vue 2, we were able to use the power of the global Vue object to create a
    new Vue instance, and use this instance as an event bus that could transport messages
    between components and functions without any hassle. We just needed to publish
    and subscribe to the event bus, and everything was perfect.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 2中，我们能够利用全局Vue对象的力量创建一个新的Vue实例，并使用这个实例作为一个事件总线，可以在组件和函数之间传输消息而不需要任何麻烦。我们只需要发布和订阅事件总线，一切都很完美。
- en: This was a good way to transfer data between components, but was an anti-pattern
    approach for the Vue framework and components. The correct way to transfer data
    between components in Vue is via a parent-child communication, or state management,
    also known as state-driven architecture.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在组件之间传输数据的一个好方法，但对于Vue框架和组件来说是一种反模式的方法。在Vue中，在组件之间传输数据的正确方式是通过父子通信或状态管理，也被称为状态驱动架构。
- en: In Vue 3, the `$on`, `$off`, and `$once` instance methods were removed. To use
    an event bus strategy now, it is recommended to use a third-party plugin or framework
    such as mitt ([https://github.com/developit/mitt](https://github.com/developit/mitt)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 3中，`$on`、`$off`和`$once`实例方法已被移除。现在，要使用事件总线策略，建议使用第三方插件或框架，如mitt（[https://github.com/developit/mitt](https://github.com/developit/mitt)）。
- en: No more global Vue – the mounting API
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不再有全局Vue——挂载API
- en: 'In Vue 2, we were accustomed to importing Vue, and prior to mounting the application,
    use the global Vue instance to add the `plugins`, `filters`, `components`, `router`,
    and `store`. This was a good technique where we could add anything to the Vue
    instance without needing to attach anything to the mounted application directly.
    It worked like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 2中，我们习惯于导入Vue，并在挂载应用程序之前，使用全局Vue实例来添加`plugins`、`filters`、`components`、`router`和`store`。这是一种很好的技术，我们可以向Vue实例添加任何内容，而无需直接附加到挂载的应用程序上。它的工作原理如下：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, in Vue 3, this is no longer possible. We need to attach every `component`,
    `plugin`, `store`, and `router` to the mounted instance directly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Vue 3中，这是不再可能的。我们需要直接将每个`component`、`plugin`、`store`和`router`附加到挂载的实例上：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using this method, we can create different Vue applications in the same global
    application, without the `plugins`, `store`, or `router` of the applications messing
    with one another.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以在同一个全局应用程序中创建不同的Vue应用程序，而不会相互干扰。
- en: v-model, v-model, v-model – multiple v-model
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: v-model，v-model，v-model - 多个v-model
- en: When developing a single-file component, we were stuck with a single `v-model`
    directive and a `.sync` option for a second update change. This meant us using
    a lot of custom event emitters and huge object payloads to handle data inside
    the component.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发单文件组件时，我们被限制为只能使用一个`v-model`指令和一个`.sync`选项来进行第二次更新更改。这意味着我们需要使用大量自定义事件发射器和巨大的对象负载来处理组件内的数据。
- en: In this breaking change, a collateral break change was introduced that resulted
    in the `model` property ([https://vuejs.org/v2/api/#model](https://vuejs.org/v2/api/#model))
    being removed from the Vue API. This property is used in custom components that
    used to do the same thing that the new v-model directive now does.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次重大变化中，引入了一个相关的破坏性变化，导致Vue API中的`model`属性被移除。这个属性用于自定义组件，以前可以做与新的v-model指令现在所做的相同的事情。
- en: 'The new way to use the `v-model` directive will change how the sugar syntax
    works. In Vue 2, to use a `v-model` directive, we had to create a component expecting
    to receive the `props` as `"value"`, and when there was a change, we needed to
    emit an `''input''` event, like the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`v-model`指令的新方法将改变糖语法的工作方式。在Vue 2中，要使用`v-model`指令，我们需要创建一个组件，期望接收`props`为`"value"`，当有变化时，我们需要发出一个`'input'`事件，就像下面的代码：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In Vue 3, to make the syntactic sugar work, the `props` property that the component
    will receive and the event emitter will change. Now, the component expects a `props`
    named `modelValue` and it emits an event, `''update:modelValue''`, like the following
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 3中，为了使语法糖工作，组件将接收的`props`属性和事件发射器将发生变化。现在，组件期望一个名为`modelValue`的`props`，并发出一个名为`'update:modelValue'`的事件，就像下面的代码：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But how about the multiple `v-model` directives? Understanding the `v-model`
    break change is the first step in getting to know how the new method of multiple
    `v-model` will work.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但是多个`v-model`指令呢？理解`v-model`的破坏性变化是了解多个`v-model`新方法如何工作的第一步。
- en: 'To create multiple `v-model` components, we need to create various `props`
    with the name of the model directive we want and emit `''update:value''` events where
    the value is the name of the model directive:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建多个`v-model`组件，我们需要创建各种`props`，并使用`'update:value'`事件发出值作为模型指令的名称：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the component where we want to use the multiple `v-model` directives, use
    the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想要使用多个`v-model`指令的组件中，使用以下代码：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The component will have each `v-model` directive, bounded to the event the child
    is emitting. In this case, the child component emits `'update:email'` (the parent
    component) in order to be able to use the `v-model` directive with the email modifier.
    For example, you can use `v-model:email` to create the two-way data binding, between
    the component and the data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 组件将有每个`v-model`指令，绑定到子组件正在发出的事件。在这种情况下，子组件发出`'update:email'`（父组件）以便能够使用`v-model`指令与email修饰符。例如，您可以使用`v-model:email`来创建组件和数据之间的双向数据绑定。
- en: Composition API
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合 API
- en: This is one of the most anticipated features of Vue 3\. The composition API
    is a new way of creating Vue components, with an optimized way of writing code,
    and providing full TypeScript type checking support in your component. This method
    organizes the code in a simpler and more efficient way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Vue 3最受期待的功能之一。组合API是创建Vue组件的一种新方式，以优化的方式编写代码，并在组件中提供完整的TypeScript类型检查支持。这种方法以更简单和更高效的方式组织代码。
- en: 'In this new way of declaring a Vue component, you just have a `setup` property
    that will be executed and will return everything your component needs in order
    to be executed, like this example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种声明Vue组件的新方式中，你只需要一个`setup`属性，它将被执行并返回组件执行所需的一切，就像这个例子：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You will import the `reactivity` API from the Vue core to enable it in the object
    type data property, in this case, `state`. The `ref` API enables reactivity in
    the basic type value, like `count`, which is a number.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从Vue核心导入`reactivity` API，以在对象类型数据属性中启用它，例如`state`。`ref` API可以使基本类型值（如`count`）具有反应性，它是一个数字。
- en: Finally, the functions can be declared inside the `setup` functions and passed
    down on the returned object. Then, everything is accessible in the `<template>`
    section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数可以在`setup`函数内部声明，并在返回的对象中传递。然后，所有内容都可以在`<template>`部分中访问。
- en: Now, let's move on to some recipes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行一些示例。
- en: Technical requirements
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be using **Node.js **and **Vue-CLI.**
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**Node.js**和**Vue-CLI**。
- en: 'Attention Windows users! You need to install an NPM package called `windows-build-tools`
    to be able to install the following requisite packages. To do this, open Power
    Shell as an administrator and execute the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Windows用户！您需要安装一个名为`windows-build-tools`的NPM包，以便能够安装以下必需的包。为此，请以管理员身份打开Power
    Shell并执行以下命令：
- en: '`> npm install -g windows-build-tools`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`> npm install -g windows-build-tools`'
- en: 'To install Vue-CLI, you need to open Terminal (macOS or Linux) or Command Prompt/PowerShell
    (Windows) and execute the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Vue-CLI，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating the base file
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本文件
- en: 'In all recipes in this chapter, we will use this base template which we will
    create now. Make sure you follow these steps to create the file before starting
    the example in the recipe:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有示例中，我们将使用这个基本模板，现在我们将创建它。确保在开始示例之前按照以下步骤创建文件：
- en: Create a new `.html` file in any folder and open it.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何文件夹中创建一个新的`.html`文件并打开它。
- en: 'Create an `html` tag and add a `head` HTML element as a child. Inside the `head` HTML
    element, add a `script` HTML element with the `src` attribute defined as `http://unpkg.com/vue@next`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`html`标签，并添加一个`head`HTML元素作为子元素。在`head`HTML元素内部，添加一个带有`src`属性定义为`http://unpkg.com/vue@next`的`script`HTML元素：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As a sibling of the  `head` HTML element, create a `body` HTML element. Inside
    the `body` HTML element, add a `div` HTML element with the attribute `id` defined
    as `"app"`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为`head`HTML元素的同级，创建一个`body`HTML元素。在`body`HTML元素内部，添加一个带有属性`id`定义为`"app"`的`div`HTML元素：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, as a sibling of the `div` HTML element, create a `script` HTML element,
    with empty content. This will be where we will place the code for the recipes:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，作为`div`HTML元素的同级，创建一个带有空内容的`script`HTML元素。这将是我们放置示例代码的地方：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Upgrading your Vue 2 application to Vue 3
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的Vue 2应用程序升级到Vue 3
- en: Upgrading your project from Vue 2 to Vue 3 can sometimes be done automatically,
    but in other cases, this needs to be done manually. This depends on how deep into
    the use of the Vue API you go with your application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的项目从Vue 2升级到Vue 3有时可以自动完成，但在其他情况下，需要手动完成。这取决于您在应用程序中使用Vue API的深度。
- en: With projects made and managed by Vue-CLI, this process will be made seamlessly
    and will have a more straightforward approach compared to projects using a custom
    framework wrapper CLI.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由Vue-CLI制作和管理的项目，这个过程将变得更加顺畅，并且与使用自定义框架包装CLI的项目相比，将有更加简单的方法。
- en: In this recipe, you will learn how to upgrade your application using Vue-CLI
    and how to upgrade the project and the dependencies manually.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何使用Vue-CLI升级您的应用程序以及如何手动升级项目和依赖项。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The prerequisite for this recipe is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的先决条件如下：
- en: Node.js 12+
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: 'The Node.js global objects that are required are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的Node.js全局对象如下：
- en: '`@vue/cli`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli`'
- en: '`@vue/cli-service-global`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@vue/cli-service-global`'
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In order to upgrade your Vue 2 project to Vue 3, you will have to split the
    upgrade into different parts. We have the upgrade of the framework itself, and
    then we have the ecosystem components, such as `vue-router` and `vuex`, and finally,
    the bundler that joins everything in the end.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将您的Vue 2项目升级到Vue 3，您将需要将升级分为不同的部分。我们有框架本身的升级，然后是生态系统组件，比如`vue-router`和`vuex`，最后是将所有内容汇总的捆绑器。
- en: The framework upgrade comes with break changes. There are some break changes
    that are presented in this book in the *What is new in Vue 3* section of this
    chapter, and others that may occur in a more advanced API schema. You have to
    manually update and check whether your components are valid for the upgrade on
    the framework.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 框架升级带来了一些破坏性的变化。本章的*Vue 3中的新内容*部分介绍了一些破坏性的变化，还有一些可能出现在更高级的API模式中。您必须手动更新并检查您的组件是否适用于框架的升级。
- en: Using Vue-CLI to upgrade the project
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Vue-CLI升级项目
- en: Using the latest version of Vue-CLI, you will be able to use Vue 3 in your project,
    out of the box, and you will be able to update your current project to Vue 3.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最新版本的Vue-CLI，您将能够在项目中使用Vue 3，并且您将能够将当前项目更新到Vue 3。
- en: 'To update Vue-CLI to the latest version, you need to open Terminal (macOS or
    Linux) or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Vue-CLI更新到最新版本，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Upgrading the project manually
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动升级项目
- en: 'To upgrade the project manually, you will have to first upgrade the project
    dependencies to their latest versions. You cannot use an old version of a Vue
    ecosystem plugin with Vue 3\. To do this, perform the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动升级项目，您首先需要将项目依赖项升级到它们的最新版本。您不能在Vue 3中使用旧版本的Vue生态系统插件。要做到这一点，请执行以下步骤：
- en: 'We need to upgrade the Vue framework, the ESLint plugin (which Vue depends
    on), and the `vue-loader` for the bundler. To upgrade it, you need to open Terminal (macOS
    or Linux) or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要升级Vue框架、ESLint插件（Vue依赖的插件）和捆绑器的`vue-loader`。要升级它，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We need to add the new Vue single-file component compiler as a dependency to
    the project. To install it, you need to open Terminal (macOS or Linux) or Command
    Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将新的Vue单文件组件编译器作为项目的依赖项添加进去。要安装它，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you are using unit tests and the `@vue/test-utils` package on your project,
    you will also need to upgrade this dependency. To upgrade it, you need to open
    Terminal (macOS or Linux) or Command Prompt/PowerShell (Windows) and execute the
    following command:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在项目中使用单元测试和`@vue/test-utils`包，您还需要升级此依赖项。要升级它，您需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows）并执行以下命令：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For the Vue ecosystem plugins, if you are using `vue-router`, you will need
    to upgrade this too. To upgrade it, you need to open Terminal (macOS or Linux)
    or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Vue生态系统插件，如果你使用`vue-router`，你也需要升级它。要升级它，你需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows），并执行以下命令：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If your application is using `vuex` as the default state management, you will
    need to upgrade this too. To upgrade it, you need to open Terminal (macOS or Linux)
    or Command Prompt/PowerShell (Windows) and execute the following command:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的应用程序使用`vuex`作为默认状态管理，你也需要升级它。要升级它，你需要打开终端（macOS或Linux）或命令提示符/PowerShell（Windows），并执行以下命令：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Changing the starting files
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改起始文件
- en: 'With the new version of the packages, we will need to change our starting files.
    In a Vue project that was created with the Vue-CLI starter kit, you will find
    a file named `main.js` or `main.ts`. If you are using TypeScript, this file is
    located in the `src` folder. Now follow these instructions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新版本的包，我们需要改变我们的起始文件。在使用Vue-CLI起始工具创建的Vue项目中，你会找到一个名为`main.js`或`main.ts`的文件。如果你使用TypeScript，该文件位于`src`文件夹中。现在按照以下说明进行操作：
- en: 'Open the `main.js` file in the `src` folder of your project. At the top of
    the file, where the packages are imported, you will see the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目中`src`文件夹中的`main.js`文件。在文件顶部，导入包的位置，你会看到以下代码：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We need to change this to the new Vue exposed API method. To do this, we need
    to import `createApp` from the Vue package as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其更改为新的Vue暴露的API方法。为此，我们需要从Vue包中导入`createApp`，如下所示：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Remove the global Vue static attribute definition of `Vue.config.productionTip` from
    your code.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的代码中移除全局Vue静态属性定义的`Vue.config.productionTip`。
- en: 'The mounting function of your application needs to be changed. The old API
    will look like this:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该改变你的应用程序的挂载函数。旧的API看起来像这样：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The old API should be changed to the new `createApp` API, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的API应该改为新的`createApp` API，如下所示：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Open your `vuex` store instantiation file (normally, this file is located in `src/store` and
    is named `store.js` or `index.js`).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`vuex`存储实例化文件（通常，该文件位于`src/store`，命名为`store.js`或`index.js`）。
- en: 'Change the creation of the store from the instantiation of a new `vuex` class
    to the new `createStore` API. The vuex v3 class instantiation may look like this:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存储的创建从实例化一个新的`vuex`类改为新的`createStore` API。`vuex` v3类的实例化可能看起来像这样：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You need to replace its content with the `createStore` API, which could look
    like this, for example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要用`createStore` API替换它的内容，例如：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `vue-router` ecosystem, we will need to replace the old API from the
    router creation with the new one. To do this, open the router creation file (in
    the `src/router` folder, normally named `router.js` or `index.js`).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`vue-router`生态系统中，我们需要用新的API替换路由器创建的旧API。为此，打开路由器创建文件（在`src/router`文件夹中，通常命名为`router.js`或`index.js`）。
- en: 'Finally, in the creation file, replace the old `vue-router` class instantiation
    with the new `createRouter` API. The `vue-router` v3 class instantiation may look
    like this:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在创建文件中，用新的`createRouter` API替换旧的`vue-router`类实例化。`vue-router` v3类的实例化可能看起来像这样：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will also need to replace the `new VueRouter` instantiation with the new
    `createRouter` and `createWebHistory` API, as in this example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要用新的`createRouter`和`createWebHistory` API替换`new VueRouter`的实例化，就像这个例子一样：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the upgrading process, Vue has provided us with two ways to update our project.
    The first way is to use the Vue-CLI plugin, which tries to automate almost all
    the processes and changes needed for the upgrade.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在升级过程中，Vue为我们提供了两种更新项目的方式。第一种方式是使用Vue-CLI插件，它试图自动化几乎所有升级所需的过程和更改。
- en: The second way is to upgrade the project manually. This method requires the
    developer to upgrade all the dependencies to the latest version, install the new
    single-file component compiler, `@vue/compiler-sfc`, and change the entry files
    for the Vue application, router, and store to the new API.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是手动升级项目。这种方法需要开发人员将所有依赖项升级到最新版本，安装新的单文件组件编译器`@vue/compiler-sfc`，并将Vue应用程序、路由器和存储的入口文件更改为新的API。
- en: Following the changes to the starter structure of the project, the developer
    needs to check the components to see whether there are any Vue 3 breaking changes
    present, refactor the component to the new Vue 3 APIs, and remove the deprecated
    APIs from Vue 2.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的起始结构更改后，开发人员需要检查组件，看看是否存在任何Vue 3破坏性更改，将组件重构为新的Vue 3 API，并从Vue 2中删除已弃用的API。
- en: Creating components with multiple root elements
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有多个根元素的组件
- en: In Vue 3, it is possible to create components with multiple root elements, without
    the need for a wrapping element. This option is also known as a fragment.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 3中，可以创建具有多个根元素的组件，无需包装元素。这个选项也被称为片段。
- en: In React, this has been possible for a long time, but in Vue, you need to use
    custom third-party plugins such as `vue-fragment` ([https://github.com/Thunberg087/vue-fragment](https://github.com/Thunberg087/vue-fragment))
    to use this feature.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，这已经很久了，但在Vue中，您需要使用自定义的第三方插件，如`vue-fragment`（[https://github.com/Thunberg087/vue-fragment](https://github.com/Thunberg087/vue-fragment)）来使用此功能。
- en: In this recipe, you will learn how to create a component with multiple root
    elements, and how it could be used with a `<template>` section and a `render`
    function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将学习如何创建一个具有多个根元素的组件，以及如何将其与`<template>`部分和`render`函数一起使用。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will create two examples of a multiple root element component,
    one with a `<template>` structure, and another with a `render` function. To do
    this, this recipe will be divided into two parts.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将创建两个多个根元素组件的示例，一个是使用`<template>`结构，另一个是使用`render`函数。为了做到这一点，这个教程将分为两部分。
- en: Creating the component with the <template> structure
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用<template>结构创建组件
- en: 'In order to use the `<template>` structure in our example, we will be using
    the `template` property of the Vue object where we can pass a string or a template
    string as the value, which will be interpolated by the Vue script and rendered
    on the screen:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的示例中使用`<template>`结构，我们将使用Vue对象的`template`属性，我们可以将字符串或模板字符串作为值传递，这将由Vue脚本插值并呈现在屏幕上：
- en: Using the base example from the 'Creating the base file' section, create a new
    file named `template.html` and open it.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“创建基本文件”部分的基本示例，创建一个名为`template.html`的新文件并打开它。
- en: 'In the empty `<script>` HTML element, create the constants `defineComponent` and `createApp`
    by object-destructuring the `Vue` global constant:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空的`<script>` HTML元素中，通过对象解构`Vue`全局常量，创建常量`defineComponent`和`createApp`：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a constant named `component`, defined as the `defineComponent` method,
    passing a JavaScript object as an argument with three properties: `data`, `methods`,
    and `template`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`component`的常量，定义为`defineComponent`方法，传递一个JavaScript对象作为参数，其中有三个属性：`data`、`methods`和`template`：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `data` property, define it as a singleton function, returning a JavaScript
    object, with a property named `count` and with the default value as `0`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data`属性中，将其定义为一个单例函数，返回一个JavaScript对象，其中有一个名为`count`的属性，并且默认值为`0`：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `methods` property, create a property called `addOne`, which is a function
    that will increase the value of `count` by `1`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`methods`属性中，创建一个名为`addOne`的属性，这是一个函数，将通过`1`增加`count`的值：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `template` property, in the template string, create an `h1` HTML element
    with a title. Then, as a sibling, create a `button` HTML element with an event
    listener bound to the `click` event, triggering the `addOne` function when executed:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`template`属性中，在模板字符串中，创建一个带有标题的`h1` HTML元素。然后，作为兄弟元素，创建一个带有绑定到`click`事件的事件监听器的`button`
    HTML元素，当执行时触发`addOne`函数：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, call the `createApp` function, passing the `component` constant as
    an argument. Then, prototype chain the `mount` function and, as an argument of
    the function, pass the `div` HTML element `id` attribute, `("#app")`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`createApp`函数，将`component`常量作为参数传递。然后，原型链连接`mount`函数，并将`div` HTML元素的`id`属性`("#app")`作为函数的参数：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Creating the component with the render function
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用渲染函数创建组件
- en: 'In order to use the `<template>` structure in our example, we will be using
    the `template` property of the Vue object, where we can pass a string or a template
    string as the value, which will be interpolated by the Vue script and rendered
    on the screen:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的示例中使用`<template>`结构，我们将使用Vue对象的`template`属性，我们可以将字符串或模板字符串作为值传递，Vue脚本将对其进行插值处理并在屏幕上呈现：
- en: Using the base example from the 'Creating the base file' section, create a new
    file named `render.html` and open it.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“创建基本文件”部分的基本示例，创建一个名为`render.html`的新文件并打开它。
- en: 'In the empty `<script>` HTML element, create the constants of the functions
    that will be used using the object destructuring method, calling the `defineComponent`,
    `h`, and `createApp` methods from the `Vue` global constant:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空的`<script>` HTML元素中，使用对象解构方法创建将要使用的函数的常量，从`Vue`全局常量中调用`defineComponent`、`h`和`createApp`方法：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a constant named `component`, defined as the `defineComponent` method,
    passing a JavaScript object as an argument with three properties: `data`, `methods`,
    and `render`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`component`的常量，定义为`defineComponent`方法，传递一个JavaScript对象作为参数，该对象有三个属性：`data`、`methods`和`render`：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `data` property, define it as a singleton function, returning a JavaScript
    object with a property named `count` and with the default value as `0`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data`属性中，将其定义为一个单例函数，返回一个具有名为`count`且默认值为`0`的JavaScript对象：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `methods` property, create a property called `addOne`, which is a function
    that will increase the value of `count` by `1`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`methods`属性中，创建一个名为`addOne`的属性，它是一个函数，将`count`的值增加`1`：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `render` property, perform the following steps:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`属性中，执行以下步骤：
- en: Create a constant named `h1` and define it as the `h` function, passing `'h1'` as
    the first argument, and the title that will be used as the second argument.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`h1`的常量，并将其定义为`h`函数，将`'h1'`作为第一个参数传递，将要使用的标题作为第二个参数。
- en: Create a constant named `button`, which will be the `h` function, passing `"button"` as
    the first argument, a JavaScript object with the property `onClick` with a value
    of `this.addOne` as the second argument, and the content of `button` as the third
    argument.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`button`的常量，它将是`h`函数，将`"button"`作为第一个参数传递，将一个具有`onClick`属性且值为`this.addOne`的JavaScript对象作为第二个参数传递，将`button`的内容作为第三个参数。
- en: 'Return an array, with the first value as the `h1` constant, and the second
    value as the `button` constant:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个数组，第一个值为`h1`常量，第二个值为`button`常量：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, call the `createApp` function, passing the `component` constant as
    an argument, prototype chaining the `mount` function, and passing the `div` HTML
    element `id` attribute, `("#app")`, as an argument of the function:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`createApp`函数，将`component`常量作为参数传递，原型链连接`mount`函数，并将`div` HTML元素的`id`属性`("#app")`作为函数的参数：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The new Vue component creation API needs to be executed by a function, `defineComponent`,
    and the JavaScript object that is passed as an argument maintains almost the same
    structure as the old structure in Vue 2\. In the examples, we used the same properties,
    `data`, `render`, `methods`, and `template`, all present in Vue 2.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Vue组件创建API需要由一个函数`defineComponent`执行，并且作为参数传递的JavaScript对象几乎保持与Vue 2中的旧结构相同。在示例中，我们使用了相同的属性`data`、`render`、`methods`和`template`，这些属性都存在于Vue
    2中。
- en: In the example with the `<template>` structure, we didn't have to create a wrapper
    element to encapsulate the content of our application component and were able
    to have two root elements on the component directly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有`<template>`结构的示例中，我们不必创建包装元素来封装应用程序组件的内容，并且可以直接在组件上有两个根元素。
- en: In the `render` function example, the same behavior occurs, but the final example
    used the new exposed `h` API, where it is no longer a parameter of the `render`
    function. A breaking change was present in the example; in the button creation,
    we had to use the `onClick` property inside the data JavaScript object, not the
    `on` property, with the `click` method. This happens because of the new data structure
    of the VNode of Vue 3.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`函数示例中，发生了相同的行为，但最终示例使用了新的暴露的`h` API，它不再是`render`函数的参数。在按钮创建中出现了一个重大变化；我们必须在数据JavaScript对象内部使用`onClick`属性，而不是`on`属性和`click`方法。这是因为Vue
    3的VNode的新数据结构。
- en: Creating components with attribute inheritance
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性继承创建组件。
- en: Since Vue 2, it has been possible to use attribute inheritance on components,
    but in Vue 3, attribute inheritance was made better and with a more reliable API
    to use in the components.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 自Vue 2以来，组件上已经可以使用属性继承，但在Vue 3中，属性继承变得更好，并且具有更可靠的API可用于组件中。
- en: Attribute inheritance in components is a pattern that provides faster development
    of custom components based on HTML elements (such as custom inputs, buttons, text
    wrappers, or links).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 组件中的属性继承是一种模式，它可以更快地开发基于HTML元素的自定义组件（例如自定义输入、按钮、文本包装器或链接）。
- en: In this recipe, we will create a custom input component with attribute inheritance
    applied directly to the `input` HTML element.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个具有属性继承的自定义输入组件，直接应用于`input` HTML元素。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here, we will create a component that will have a full attribute inheritance
    on a selected element on the DOM tree:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个组件，该组件将在DOM树上的选定元素上具有完整的属性继承：
- en: Using the base example from the *Creating the base file* section, create a new
    file named `component.html` and open it.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*创建基本文件*部分的基本示例，创建一个名为`component.html`的新文件并打开它。
- en: 'In the empty `<script>` HTML element, create the constants of the functions
    that will be used using the object destructuring method, calling the `defineComponent` and `createApp` methods
    from the `Vue` global constant:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空的`<script>` HTML元素中，使用对象解构方法创建将要使用的函数的常量，调用`Vue`全局常量的`defineComponent`和`createApp`方法：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a constant named `nameInput`, defined as the `defineComponent` method,
    passing a JavaScript object as an argument with four properties: `name`, `props`, `template`,
    and `inheritAttrs`. Then, we define the value of `inheritAttrs` as `false`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nameInput`的常量，定义为`defineComponent`方法，传递一个JavaScript对象作为参数，具有四个属性：`name`、`props`、`template`和`inheritAttrs`。然后，我们将`inheritAttrs`的值定义为`false`：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `props` property, add a property called `modelValue` and define it as
    `String`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`props`属性中，添加一个名为`modelValue`的属性，并将其定义为`String`：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the template property, within the template string, we need to do the following:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板属性中，在模板字符串内部，我们需要执行以下操作：
- en: Create a `label` HTML element and add an `input` HTML element as a child.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`label` HTML元素，并将一个`input` HTML元素作为子元素添加。
- en: In the `input` HTML element, define the `v-bind` directive as a JavaScript object
    with the destructed value of `this.$attrs`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`input` HTML元素中，将`v-bind`指令定义为一个JavaScript对象，其中包含`this.$attrs`的解构值。
- en: Define the variable attribute `value` as the received prop's `modelValue`.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量属性`value`定义为接收到的prop的`modelValue`。
- en: Set the `input` attribute `type` as `"text"`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`input`属性`type`设置为`"text"`。
- en: 'To the `change` event listener, add an anonymous function, which receives an
    `event` as the argument, and then `emit` an event called `"update:modeValue"`
    with the payload `event.target.value`:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将匿名函数添加到`change`事件监听器中，该函数接收一个`event`作为参数，然后发出一个名为`"update:modeValue"`的事件，载荷为`event.target.value`：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a constant named `appComponent`, defined as the `defineComponent` method,
    passing a JavaScript object as an argument with two properties, `data` and `template`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`appComponent`的常量，定义为`defineComponent`方法，传递一个JavaScript对象作为参数，其中包含两个属性，`data`和`template`：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `data` property, define it as a singleton function, returning a JavaScript
    object with a property named `name`, with the default value as `''''`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data`属性中，将其定义为一个单例函数，返回一个具有名为`name`的属性的JavaScript对象，其默认值为`''`：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the template property, within the template string, we need to do the following:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板属性中，在模板字符串中，我们需要执行以下操作：
- en: Create a `NameInput` component with a `v-model` directive bounded to the `name`
    data property.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`NameInput`组件，其中`v-model`指令绑定到`name`数据属性。
- en: 'Create a `style` attribute with the value `"border:0; border-bottom: 2px solid
    red;"`*.*'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '创建一个带有值`"border:0; border-bottom: 2px solid red;"`的`style`属性。'
- en: 'Create a `data-test` attribute with the value `"name-input"`:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带有值`"name-input"`的`data-test`属性：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a constant named `app`, and define it as the `createApp` function, passing
    the `component` constant as the argument. Then, call the `app.component` function,
    passing as the first argument the name of the component you want to register,
    and as the second argument the component. Finally, call the `app.mount` function,
    passing `"#app"` as the argument:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`app`的常量，并将其定义为`createApp`函数，将`component`常量作为参数传递。然后，调用`app.component`函数，将要注册的组件的名称作为第一个参数传递，组件作为第二个参数传递。最后，调用`app.mount`函数，将`"#app"`作为参数传递：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In Vue 3, in order to create a component, we need to execute the `defineComponent` function,
    passing a JavaScript object as an argument. This object maintains almost the same
    component declaration structure as Vue 2\. In the examples, we used the same properties, `data`, `methods`,
    `props`, and `template`, all present in the V2.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 3中，为了创建一个组件，我们需要执行`defineComponent`函数，传递一个JavaScript对象作为参数。这个对象保持了几乎与Vue
    2相同的组件声明结构。在示例中，我们使用了相同的属性，`data`，`methods`，`props`和`template`，这些属性都存在于V2中。
- en: We used the `inheritAttrs` property to block the auto application of the attributes
    to all elements on the components, applying them just to the element with the
    `v-bind` directive and with the `this.$attrs` object deconstructed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`inheritAttrs`属性来阻止将属性自动应用于组件上的所有元素，仅将其应用于具有`v-bind`指令和解构`this.$attrs`对象的元素。
- en: To register the component in the Vue application, we first created the application
    with the `createApp` API and then executed the `app.component` function to register
    the component globally on the application, prior to rendering our application.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Vue应用程序中注册组件，我们首先使用`createApp` API创建应用程序，然后执行`app.component`函数在应用程序上全局注册组件，然后渲染我们的应用程序。
- en: Using the reactivity and observable API outside the scope of Vue
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Vue范围之外使用响应性和可观察API
- en: In Vue 3, with the exposed APIs, we can use the Vue reactivity and reactive
    variables without the need to create a Vue application. This enables backend and
    frontend developers to take full advantage of the Vue `reactivity` API within
    their application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 3中，使用暴露的API，我们可以在不需要创建Vue应用程序的情况下使用Vue reactivity和reactive变量。这使得后端和前端开发人员可以充分利用Vue
    `reactivity` API。
- en: In this recipe, we will create a simple JavaScript animation using the `reactivity`
    and `watch` APIs.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`reactivity`和`watch` API创建一个简单的JavaScript动画。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here, we will create an application using the Vue exposed `reactivity` API
    to render an animation on the screen:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用Vue暴露的`reactivity` API创建一个应用程序，以在屏幕上呈现动画：
- en: Using the base example from the 'Creating the base file' section, create a new
    file named `reactivity.html` and open it.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“创建基本文件”部分中的基本示例，创建一个名为`reactivity.html`的新文件并打开它。
- en: 'In the `<head>` tag, add a new `<meta>` tag with the attribute `chartset` defined
    as `"utf-8"`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<head>`标签中，添加一个新的`<meta>`标签，属性为`chartset`定义为`"utf-8"`：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the `<body>` tag, remove the `div#app` HTML element, and create a `div`
    HTML element with the `id` defined as `marathon` and the `style` attribute defined
    as `"font-size: 50px;"`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`<body>`标签中，删除`div#app` HTML元素，并创建一个`div` HTML元素，`id`定义为`marathon`，`style`属性定义为`"font-size:
    50px;"`：'
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the empty `<script>` HTML element, create the constants of the functions
    that will be used using the object destructuring method, calling the `reactivity` and `watch` methods
    from the `Vue` global constant:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空的`<script>` HTML元素中，使用对象解构方法创建将要使用的函数的常量，调用`Vue`全局常量中的`reactivity`和`watch`方法：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create a constant named `mod`, defined as a function, which receives two arguments,
    `a` and `b`. This then returns an arithmetic operation, `a` modulus `b`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mod`的常量，定义为一个函数，接收两个参数`a`和`b`。然后返回一个算术运算，`a`模`b`：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a constant named `maxRoadLength` with the value `50`. Then, create a
    constant named `competitor` with the value as the `reactivity` function, passing
    a JavaScript object as the argument, with the `position` property defined as `0` and
    `speed` defined as `1`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`maxRoadLength`的常量，其值为`50`。然后，创建一个名为`competitor`的常量，其值为`reactivity`函数，传递一个JavaScript对象作为参数，其中`position`属性定义为`0`，`speed`定义为`1`：
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a `watch` function, passing an anonymous function as the argument. Inside
    the function, do the following:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`watch`函数，传递一个匿名函数作为参数。在函数内部，执行以下操作：
- en: Create a constant named `street`, and define it as an `Array` with a size of
    `maxRoadLength`, and fill it with `*'_'*`*.*
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`street`的常量，并将其定义为一个大小为`maxRoadLength`的`Array`，并用`*'_'*`*.*填充它。
- en: Create a constant named `marathonEl`, and define it as the HTML DOM node, `#marathon`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`marathonEl`的常量，并将其定义为HTML DOM节点`#marathon`。
- en: Select the element on the `street` in the array index of `competitor.position` and
    define it as `*"![](assets/c8b07311-36a4-4df3-98fd-3b68200deed3.png)"*` if the `competitor.position` number
    is even, or `*"![](assets/562ed724-a630-4193-a9c6-4e143a9690e2.png)"*` if the
    number is odd.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择数组索引中`competitor.position`的`street`元素，并将其定义为`*"![](assets/c8b07311-36a4-4df3-98fd-3b68200deed3.png)"*`，如果`competitor.position`是偶数，或者如果数字是奇数，则定义为`*"![](assets/562ed724-a630-4193-a9c6-4e143a9690e2.png)"*`。
- en: 'Define `marathonEl.innertHTML` as `*""*` and `street.reverse().join('''')`:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`marathonEl.innertHTML`定义为`*""*`和`street.reverse().join('')`：
- en: The emojis used in this recipe are **Person Running** and **Person Walking**.
    The emoji image may vary depending on your OS. The images presented in this recipe
    are the emojis for the Apple OS.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中使用的表情符号是**跑步的人**和**行走的人**。表情符号图像可能因您的操作系统而异。本示例中呈现的图像是苹果操作系统的表情符号。
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create a `setInterval` function, passing an anonymous function as the argument.
    Inside the function, define `competitor.position` as the `mod` function, passing `competitor.position` plus
    `competitor.speed` as the first argument, and `maxRoadLength` as the second argument:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`setInterval`函数，将一个匿名函数作为参数传递。在函数内部，将`competitor.position`定义为`mod`函数，将`competitor.position`加上`competitor.speed`作为第一个参数，将`maxRoadLength`作为第二个参数：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the exposed `reactive` and `watch` APIs from Vue, we were able to create
    an application with the reactivity present in the Vue framework, but without the
    use of a Vue application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue暴露的`reactive`和`watch`API，我们能够创建一个具有Vue框架中的响应性的应用程序，但不使用Vue应用程序。
- en: First, we created a reactive object, `competitor`, that works in the same way
    as the Vue `data` property. Then, we created a `watch` function, which works in
    the same way as the `watch` property, but is used as an anonymous function. In
    the `watch` function, we made the road for the competitor to run on, and created
    a simple animation, using two different emojis, changing it based on the position
    on the road, so that it mimics an animation on the screen.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个响应式对象`competitor`，它的工作方式与Vue的`data`属性相同。然后，我们创建了一个`watch`函数，它的工作方式与`watch`属性相同，但是作为匿名函数使用。在`watch`函数中，我们为竞争者开辟了一条跑道，并创建了一个简单的动画，使用两个不同的表情符号，根据在道路上的位置进行更改，以模拟屏幕上的动画。
- en: 'Finally, we printed the current runner on the screen and created a `setInterval` function
    of every `100ms` to change the position of the competitor on the road:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在屏幕上打印了当前的跑步者，并创建了一个`setInterval`函数，每100毫秒改变竞争者在道路上的位置：
- en: '![](assets/aa026d03-a44e-4d9b-ac15-3246bccda09f.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aa026d03-a44e-4d9b-ac15-3246bccda09f.png)'
- en: Creating a component using the composition API
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组合API创建组件
- en: The composition API is a new way to write Vue components, based on the use of
    functions to compose the component, and it makes the organization and reusability
    of the code better.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 组合API是一种编写Vue组件的新方法，基于使用函数来组合组件，它使代码的组织和可重用性更好。
- en: This method is inspired by React Hooks and introduces the technique of creating
    a special function to compose the applications that can be shared without the
    need to be inside the Vue application because of the use of the exposed Vue APIs.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法受到React Hooks的启发，并引入了创建特殊函数来组合应用程序的技术，这些函数可以在不需要在Vue应用程序内部的情况下共享，因为使用了暴露的Vue
    API。
- en: In this recipe, we will learn how to create an external function that fetches
    the user's geolocation and displays that data on the screen using the composition
    API.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何创建一个外部函数，用于获取用户的地理位置并在屏幕上显示这些数据，使用组合API。
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here, we will create a component using the composition API, which will fetch
    the user GPS position and show that information on the screen:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用组合API创建一个组件，该组件将获取用户的GPS位置并在屏幕上显示该信息：
- en: Using the base example from the 'Creating the base file' section, create a new
    file named `component.html` and open it.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“创建基本文件”部分的基本示例，创建一个名为`component.html`的新文件并打开它。
- en: 'In the empty `<script>` HTML element, create the constants of the functions
    that will be used using the object destructuring method, calling the `createApp`,
    `defineComponent`, `setup`, `ref`, `onMounted`, and `onUnmounted` methods from
    the `Vue` global constant:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空的`<script>` HTML元素中，使用对象解构方法创建将要使用的函数的常量，从`Vue`全局常量中调用`createApp`、`defineComponent`、`setup`、`ref`、`onMounted`和`onUnmounted`方法：
- en: '[PRE59]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a `fetchLocation` function and, inside this, create a `let` variable
    named `watcher`. Then, create a constant named `geoLocation` and define it as `navigator.geolocation`.
    Next, create a constant named `gpsTime` and define it as the `ref` function, passing
    the `Date.now()` function as the argument. Finally, create a constant named `coordinates`
    and define it as the `ref` function, passing a JavaScript object as the argument,
    with the properties `accuracy`, `latitude`, `longitude`, `altitude`, `altitudeAccuracy`,
    `heading`, and `speed` defined as `0`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fetchLocation`函数，在其中创建一个名为`watcher`的`let`变量。然后，创建一个名为`geoLocation`的常量，并将其定义为`navigator.geolocation`。接下来，创建一个名为`gpsTime`的常量，并将其定义为`ref`函数，将`Date.now()`函数作为参数传递。最后，创建一个名为`coordinates`的常量，并将其定义为`ref`函数，将一个JavaScript对象作为参数传递，其中的属性`accuracy`、`latitude`、`longitude`、`altitude`、`altitudeAccuracy`、`heading`和`speed`都定义为`0`：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, inside the `fetchLocation` function, following the creation of the constants,
    create a function named `setPosition` with a parameter named `payload`. Inside
    the function, define `gpsTime.value` as the `payload.timestamp` argument and `coordinates.value`
    as the `payload.coords` argument:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`fetchLocation`函数内部，在常量创建之后，创建一个名为`setPosition`的函数，带有一个名为`payload`的参数。在函数内部，将`gpsTime.value`定义为`payload.timestamp`参数，将`coordinates.value`定义为`payload.coords`参数：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Following creation of the `setPosition` function, call the `onMounted` function,
    passing an anonymous function as the argument. Inside the function, check whether
    the browser has the `geoLocation` API available, and define `watcher` as the `geoLocation.watchPostion`
    function, passing the `setPosition` function as the argument:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`setPosition`函数之后，调用`onMounted`函数，将一个匿名函数作为参数传递。在函数内部，检查浏览器是否可用`geoLocation`
    API，并将`watcher`定义为`geoLocation.watchPostion`函数，将`setPosition`函数作为参数传递：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After calling the `onMounted` function, create an `onUnmounted` function passing an
    anonymous function as the argument. Inside the function, check whether `watcher`
    is defined and then execute the `geoLocation.clearWatch` function, passing `watcher` as
    the argument:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`onMounted`函数后，创建一个`onUnmounted`函数，将一个匿名函数作为参数传递。在函数内部，检查`watcher`是否已定义，然后执行`geoLocation.clearWatch`函数，将`watcher`作为参数传递：
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, in the `fetchLocation` function, return a JavaScript object, and as
    the properties/values define, pass the `coordinates` and `gpsTime` constants:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`fetchLocation`函数中，返回一个JavaScript对象，并将`coordinates`和`gpsTime`常量作为属性/值传递：
- en: '[PRE64]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create a constant named `appComponent` and define it as the `defineComponent` function, passing
    a JavaScript object with the properties `setup` and `template` as the argument:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`appComponent`的常量，并将其定义为`defineComponent`函数，将一个具有`setup`和`template`属性的JavaScript对象作为参数传递：
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the `setup` function, create a constant, which is an object destructuring
    with the properties `coordinates` and `gpsTime` of the `fetchLocation` function:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`函数中，创建一个常量，这是一个对象解构，包括`fetchLocation`函数的`coordinates`和`gpsTime`属性：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Inside the `setup` function, create another constant named `formatOptions`,
    and define it as a JavaScript object with the properties `year`, `month`, `day`, `hour`,
    and `minute` as `''numeric''`. Then, define the property `hour12` as `true`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`函数内部，创建另一个名为`formatOptions`的常量，并将其定义为一个具有`year`、`month`、`day`、`hour`和`minute`属性的JavaScript对象，其值均为`'numeric'`。然后，将属性`hour12`定义为`true`：
- en: '[PRE67]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Following the creation of the `formatOptions` constant, create a constant named
    `formatDate` and define it as a function, which receives a parameter named `date`.
    Then, return a new `Intl.DateTimeFormat` function, passing `navigator.language` as
    the first argument, and the `formatOption` constant as the second argument. Then,
    prototype chain the `format` function, passing the `date` parameter:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`formatOptions`常量之后，创建一个名为`formatDate`的常量，并将其定义为一个函数，该函数接收一个名为`date`的参数。然后，返回一个新的`Intl.DateTimeFormat`函数，将`navigator.language`作为第一个参数，将`formatOption`常量作为第二个参数。然后，原型链连接`format`函数，传递`date`参数：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, at the end of the `setup` function, return a JavaScript object with
    the properties defined as `coordinates`, `gpsTime`, and `formatDate` constants:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`setup`函数的末尾，返回一个JavaScript对象，其属性定义为`coordinates`、`gpsTime`和`formatDate`常量：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the `template` property, do the following:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`template`属性中，进行以下操作：
- en: Create an `h1` HTML element with the text `"My Geo Position at {{ formatDate(new
    Date(gpsTime) }}"`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带有文本“我的地理位置在{{ formatDate(new Date(gpsTime) }}”的`h1` HTML元素。
- en: Create a `ul` HTML element and add three `li` HTML elements as children.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`ul` HTML元素，并添加三个`li` HTML元素作为子元素。
- en: 'In the first child element, add the text `"Latitude: {{ coordinates.latitude
    }}"`.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个子元素中，添加文本“纬度：{{ coordinates.latitude }}”。
- en: 'In the second child element, add the text `"Longitude: {{ coordinates.longitude
    }}"`.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个子元素中，添加文本“经度：{{ coordinates.longitude }}”。
- en: 'In the third child element, add the text `"Altitude: {{ coordinates.altitude
    }}"`:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三个子元素中，添加文本“海拔：{{ coordinates.altitude }}”：
- en: '[PRE70]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, call the `createApp` function, passing the `appComponent` constant
    as an argument. Then, prototype chain the `mount` function, and, as an argument
    of the function, pass the `div` HTML element `id` attribute, `("#app")`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`createApp`函数，传递`appComponent`常量作为参数。然后，原型链连接`mount`函数，并将`div` HTML元素的`id`属性`("#app")`作为函数的参数：
- en: '[PRE71]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works...
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, first, we imported the exposed APIs - `createApp`,  `defineComponent`, `setup`, `ref`, `onMounted`,
    and `onUnmounted,` – as constants, which we will use to create the component.
    Then, we created the `fetchLocation` function, which has the responsibility of
    getting the user's geolocation data and returning it as reactive data that can
    be automatically updated when the user changes their location.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，首先我们导入了暴露的API - `createApp`、`defineComponent`、`setup`、`ref`、`onMounted`和`onUnmounted`
    - 作为常量，我们将使用它们来创建组件。然后，我们创建了`fetchLocation`函数，它负责获取用户的地理位置数据，并将其作为响应式数据返回，当用户更改位置时可以自动更新。
- en: The ability to fetch the user GPS positions was possible because of the `navigator.geolocation`
    API present on modern browsers, which are able to fetch the user's current GPS
    position. Using this data provided by the browser, we were able to use it to define
    the variables created with the Vue `ref` APIs.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 能够获取用户GPS位置是因为现代浏览器上存在的`navigator.geolocation` API，它能够获取用户当前的GPS位置。利用浏览器提供的数据，我们能够用它来定义由Vue
    `ref` API创建的变量。
- en: We created the component using the `setup` function of the Vue object declaration,
    so the rendering knows that we are using the new composition API as the component
    creation method. Inside the `setup` function, we imported the dynamic variables
    of the `fetchLocation` function and created a method that formats the date to
    use as a filter on the template.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Vue对象声明的`setup`函数创建了组件，因此渲染知道我们正在使用新的组合API作为组件创建方法。在`setup`函数内部，我们导入了`fetchLocation`函数的动态变量，并创建了一个方法，用于在模板上使用日期格式化。
- en: Then we returned the imported variables and the filter, so they can be used
    on the template section. In the template section, we created a title adding the
    time of the last GPS position, used the filter to format it, and created a list
    of the user's latitude, longitude, and altitude.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们返回导入的变量和过滤器，以便它们可以在模板部分中使用。在模板部分中，我们创建了一个标题，添加了最后一次GPS位置的时间，使用过滤器进行格式化，并创建了用户的纬度、经度和海拔的列表。
- en: Finally, we created the application using the `createApp` exposed API and mounted
    the Vue application.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`createApp`公开的API创建了应用程序，并挂载了Vue应用程序。
- en: See also
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about `Navigator.geolocation` at [https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation)找到有关`Navigator.geolocation`的更多信息。
- en: You can find more information about `Intl.DateTimeFormat` at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat)找到有关`Intl.DateTimeFormat`的更多信息。
