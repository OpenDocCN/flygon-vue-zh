- en: Writing Route Middlewares and Server Middlewares
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 编写路由中间件和服务器中间件
- en: Remember when you created a middleware on the server side using Koa in [Chapter
    8](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml), *Adding a Server-Side Framework*?
    Middlewares are both useful and powerful, as you will have noted in cascading
    with Koa apps, where you can predict and control the flow of your entire app sequentially.
    So, what about in Nuxt? Well, there are two types of middleware we should explore
    in Nuxt: route middleware and server middleware. In this chapter, you will learn
    how to differentiate between them and create some basic middlewares before moving
    on to the next chapter on authentication, where middlewares are very much needed. We
    will also use middlewares in the chapters after the next one. So, in this chapter,
    just like in many of the previous chapters, you will create some middlewares in
    a Vue app with navigation guards so that you can grasp the middleware mechanism
    in the Vue/Nuxt system before creating the route middlewares and server middlewares in
    a Nuxt app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在[第8章](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml)中使用Koa在服务器端创建中间件吗？中间件非常有用且强大，正如你在Koa应用程序中注意到的那样，你可以预测和控制整个应用程序的流程。那么在Nuxt中呢？嗯，在Nuxt中有两种类型的中间件：路由中间件和服务器中间件。在本章中，您将学习如何区分它们，并在进入下一章关于身份验证的章节之前创建一些基本的中间件，那里中间件是非常需要的。我们还将在接下来的章节中使用中间件。因此，在本章中，就像在许多以前的章节中一样，您将在Vue应用程序中创建一些带有导航守卫的中间件，以便在创建Nuxt应用程序中的路由中间件和服务器中间件之前掌握Vue/Nuxt系统中的中间件机制。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Writing middlewares with Vue Router
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue Router编写中间件
- en: Introducing Vue CLI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Vue CLI
- en: Writing route middlewares in Nuxt
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Nuxt中编写路由中间件
- en: Writing Nuxt server middlewares
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Nuxt服务器中间件
- en: Writing middlewares with Vue Router
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue Router编写中间件
- en: Before learning how middleware works in a Nuxt app, we should understand how
    it works in a standard Vue app. Additionally, before creating middlewares in the
    Vue app, let's first understand what they are.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习Nuxt应用程序中的中间件如何工作之前，我们应该了解它在标准Vue应用程序中是如何工作的。此外，在Vue应用程序中创建中间件之前，让我们先了解它们是什么。
- en: What is middleware?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是中间件？
- en: Put simply, a middleware is a software layer situated between two or more pieces
    of software. This is an old concept in software development. Middleware is a term
    that has been in use since 1968\. It gained popularity in the 1980s as a solution
    to the problem of how to link newer apps to older legacy systems. There are many
    definitions for it, such as (from *Google Dictionary*) "[middleware is a] software
    that acts as a bridge between an operating system or database and apps, especially
    on a network."
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，中间件是位于两个或多个软件之间的软件层。这是软件开发中的一个古老概念。中间件是一个自1968年以来就一直在使用的术语。它在1980年代作为将新应用程序链接到旧的遗留系统的解决方案而变得流行。对于它有许多定义，例如（来自*Google字典*）“[中间件是]在操作系统或数据库与应用程序之间充当桥梁的软件，尤其是在网络上。”
- en: 'In the web development world, server-side software or apps, such as Koa and
    Express, take in a request and output a response. The middlewares are programs
    or functions that are executed in the middle after the incoming request, and they
    produce an output that could either be the final output or be used by the next
    middleware until the cycle is completed. This also means that we can have **more**
    than one middleware, and they will execute in the order they are declared:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发世界中，服务器端软件或应用程序（如Koa和Express）接收请求并输出响应。中间件是在接收请求后执行的程序或函数，它们产生的输出可以是最终输出，也可以被下一个中间件使用，直到循环完成。这也意味着我们可以有**多个**中间件，并且它们将按照声明的顺序执行：
- en: '![](assets/cda0dfde-bb0a-4fe4-9a36-ebc285e49a1b.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cda0dfde-bb0a-4fe4-9a36-ebc285e49a1b.png)'
- en: Furthermore, middleware is not only limited to server-side technologies. It
    is also very common on the client side when you have routing in your app. Vue
    Router by Vue.js is a good example of using this middleware concept. We have studied
    and used Vue Router already in [Chapter 4](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml),* Adding
    Views, Routes, and Transitions*, to create the router for our Vue apps. Now, let's
    dive deeper into the advanced usage of Vue Router – navigation guards.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，中间件不仅限于服务器端技术。当您的应用程序中有路由时，在客户端中也非常常见。Vue.js的Vue Router就是使用这种中间件概念的一个很好的例子。我们已经在[第4章](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml)
    *添加视图、路由和过渡*中学习和使用了Vue Router，为我们的Vue应用程序创建了路由器。现在，让我们深入了解Vue Router的高级用法 - 导航守卫。
- en: Installing Vue Router
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Vue Router
- en: If you have followed the chapters of this book from the beginning, you should
    already know how to install Vue Router from [Chapter 4](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml),
    *Adding Views, Routes, and Transitions*. However, here is a quick recap.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从本书的开头开始就已经跟着章节走了，那么您应该已经知道如何从[第4章](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml)
    *添加视图、路由和过渡*中安装Vue Router。然而，这里是一个快速回顾。
- en: 'Follow these steps to download Vue Router directly:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤直接下载Vue Router：
- en: 'Click on the following link and download the source code:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击以下链接并下载源代码：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Include the router after Vue so that it can be installed automatically by itself:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Vue之后包含路由器，这样它就可以自动安装：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can install Vue Router via npm:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过npm安装Vue Router：
- en: 'Install the router to your project using npm:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用npm将路由器安装到您的项目中：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Register the router explicitly using the `use` method:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`use`方法显式注册路由器：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you have the router in place, you can start creating middlewares using
    the navigation guards that come with Vue Router:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你安装好了路由器，你就可以开始使用Vue Router提供的导航守卫来创建中间件：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `beforeEach` navigation guard in the preceding example is a global navigation
    guard that is called when navigating to any route. Apart from global guards, there
    are navigation guards for specific routes too, and that is what we are going to
    explore in more detail in the next section. So, let's get going!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`beforeEach`导航守卫是一个全局导航守卫，当导航到任何路由时都会被调用。除了全局守卫，还有特定路由的导航守卫，我们将在下一节中更详细地探讨这一点。所以，让我们开始吧！
- en: If you want to find out more information about Vue Router, please visit [https://router.vuejs.org/](https://router.vuejs.org/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Vue Router的信息，请访问[https://router.vuejs.org/](https://router.vuejs.org/)。
- en: Using navigation guards
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用导航守卫
- en: 'Navigation guards are used to guard the navigation in your app. These guards
    allow us to call functions before entering, updating, and leaving a route. When
    certain conditions are not met, they can either redirect or cancel the route.
    There are several ways in which to hook into the route navigation process: globally,
    per-route, or in-component. Let''s explore the global guard in the next section.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 导航守卫用于保护应用程序中的导航。这些守卫允许我们在进入、更新和离开路由之前调用函数。当某些条件不满足时，它们可以重定向或取消路由。有几种方式可以连接到路由导航过程中：全局、每个路由或在组件中。让我们在下一节中探索全局守卫。
- en: Note that you can find all of the following examples in `/chapter-11/vue/non-sfc/`
    from our GitHub repository.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以在我们的GitHub存储库的`/chapter-11/vue/non-sfc/`中找到以下所有示例。
- en: Creating global guards
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建全局守卫
- en: 'There are two global guards offered by Vue Router – global before guards and
    global after guards. Let''s learn how to use them before applying them to our
    app:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Vue Router提供了两种全局守卫 - 全局前置守卫和全局后置守卫。让我们学习如何在应用程序中应用它们之前先了解如何使用它们：
- en: '**Global before guards**: Global before guards are called when a route is being
    entered. They are called in a specific order and can be asynchronous. The navigation
    is always in wait until all the guards are resolved. We can register these guards
    using the `beforeEach` method from Vue Router, as follows:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局前置守卫**：全局前置守卫在路由进入时调用。它们按特定顺序调用，并且可以是异步的。导航总是等待直到所有守卫都被解析。我们可以使用Vue Router的`beforeEach`方法注册这些守卫，如下所示：'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Global after guards**: Global after guards are called after a route has been
    entered. Unlike global before guards, global after guards do not have the `next`
    function, and so they do not affect navigation. We can register these guards using
    the `afterEach` method from Vue Router, as follows:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局后置守卫**：全局后置守卫在路由进入后调用。与全局前置守卫不同，全局后置守卫没有`next`函数，因此它们不会影响导航。我们可以使用Vue Router的`afterEach`方法注册这些守卫，如下所示：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s create a Vue app with a simple HTML page and use these guards in the
    following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个Vue应用程序，使用一个简单的HTML页面，并在以下步骤中使用这些守卫：
- en: 'Create two routes with the `<router-link>` elements, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`<router-link>`元素创建两个路由，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define the components (`Page1` and `Page2`) for the routes, and pass them to
    the router instance in the `<script>` block:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为路由定义组件（`Page1`和`Page2`），并将它们传递给`<script>`块中的路由实例：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare the global before guard and the global after guard **after** the route
    instance, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由实例之后声明全局前置守卫和全局后置守卫，如下所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Mount the root instance after the guards and run our app:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在守卫之后挂载根实例并运行我们的应用程序：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the app in your browser, and you should get the following logs in the browser
    console when you switch between the routes:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中运行应用程序，当您在路由之间切换时，您应该在浏览器控制台中获得以下日志：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Global guards can be useful when you want to apply something common to all routes. However,
    sometimes, we need something specific for certain routes only. For this, you should
    use per-route guards. Let's learn how to deploy them in the next section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 全局守卫在你想要应用到所有路由的共同内容时非常有用。然而，有时我们只需要特定路由的特定内容。为此，您应该使用每个路由的守卫。让我们在下一节中学习如何部署它们。
- en: Creating per-route guards
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建每个路由的守卫
- en: 'We can create per-route guards by using `beforeEnter` as a method or property directly
    on the configuration object of a route. For example, take a look at the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在路由的配置对象上直接使用`beforeEnter`方法或属性来创建每个路由的守卫。例如，看一下以下示例：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s duplicate our previous Vue app and change the configuration of the routes
    to use these per-route guards, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制我们之前的Vue应用程序，并更改路由配置以使用这些每个路由的守卫，如下所示：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should get the `before entering page 1` log on your browser's console when
    you navigate to `/page1` and the `before entering page 2` log when you are on
    `/page2`. So, since we can apply a guard to the route of a page, what about applying
    guards to the route component itself? The answer is yes, we can. Let's move on
    to the next section and learn how to use in-component guards to guard a specific
    component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您导航到“/page1”时，您应该在浏览器控制台上获得“进入页面1之前”的日志，当您在“/page2”上时，您应该获得“进入页面2之前”的日志。因此，我们可以将守卫应用于页面的路由，那么将守卫应用于路由组件本身呢？答案是肯定的，我们可以。让我们继续下一节，学习如何使用组件内守卫来保护特定组件。
- en: Creating in-component guards
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建组件内守卫
- en: We can use the following methods individually or together inside a route component to
    create the navigation guards for a specific component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在路由组件内部单独或一起使用以下方法来创建特定组件的导航守卫。
- en: '**The** **beforeRouteEnter guard**:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**beforeRouteEnter守卫**：'
- en: 'Just like in the global before guard and the `beforeEnter` per-route guard,
    the `beforeRouteEnter` guard is called before the route renders the component,
    but it is applied to the component itself. We can register this type of guard
    using the `beforeRouteEnter` method, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在全局前置守卫和`beforeEnter`每个路由守卫中一样，`beforeRouteEnter`守卫在路由渲染组件之前调用，但它适用于组件本身。我们可以使用`beforeRouteEnter`方法注册这种类型的守卫，如下所示：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because it is called before the component instance, it does not have access
    to the Vue component via the `this` keyword. But this can be resolved by passing
    a callback of the Vue component to the `next` argument:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它在组件实例之前被调用，所以无法通过`this`关键字访问Vue组件。但可以通过将Vue组件的回调传递给`next`参数来解决这个问题：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**The beforeRouteLeave guard**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**beforeRouteLeave守卫**：'
- en: 'In comparison, the `beforeRouteLeave` guard is called when the component that
    is rendered by the route is about to navigate away from it. Since it is called
    when the Vue component is rendered, it can access the Vue component via the `this`
    keyword. We can register this type of guard using the `beforeRouteLeave` method,
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，当由路由渲染的组件即将从中导航离开时，将调用`beforeRouteLeave`守卫。由于它在Vue组件渲染时被调用，因此可以通过`this`关键字访问Vue组件。我们可以使用`beforeRouteLeave`方法注册这种类型的守卫，如下所示：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Usually, this type of guard is best used to prevent the user from leaving the
    route accidentally. So, the navigation can be canceled by calling `next(false)`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这种类型的守卫最适合用于防止用户意外离开路由。因此，可以通过调用`next(false)`来取消导航：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**The beforeRouteUpdate guard**:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**beforeRouteUpdate守卫**：'
- en: 'The `beforeRouteUpdate` guard is called when the component that is rendered
    by the route has changed but the component is reused in the new route; for example,
    if you have subroute components that use the same route component: `/page1/foo`
    and `/page1/bar`. So, navigating from `/page1/foo` to `/page1/bar` will trigger
    this method. And since it is called when the component is rendered, it has access
    to the Vue component via the `this` keyword. We can register this type of guard
    using the `beforeRouteUpdate` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当由路由渲染的组件已更改但组件在新路由中被重用时，将调用`beforeRouteUpdate`守卫；例如，如果您有使用相同路由组件的子路由组件：`/page1/foo`和`/page1/bar`。因此，从`/page1/foo`导航到`/page1/bar`将触发此方法。由于它在组件渲染时被调用，因此可以通过`this`关键字访问Vue组件。我们可以使用`beforeRouteUpdate`方法注册这种类型的守卫：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that the `beforeRouteEnter` method is the only guard that supports a callback
    in the `next` method. The Vue component is already available before calling the
    `beforeRouteUpdate` and `beforeRouteLeave` methods. Therefore, using a callback
    in the `next` method in either of them is unsupported because it is unnecessary.
    So, just use the `this` keyword if you want to access the Vue component:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`beforeRouteEnter`方法是唯一支持在`next`方法中使用回调的守卫。在调用`beforeRouteUpdate`和`beforeRouteLeave`方法之前，Vue组件已经可用。因此，在这两种情况下在`next`方法中使用回调是不受支持的，因为这是不必要的。因此，如果要访问Vue组件，只需使用`this`关键字：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s create a Vue app with a simple HTML page using the following guards:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下守卫创建一个带有简单HTML页面的Vue应用：
- en: 'Create a page component with the `beforeRouteEnter`, `beforeRouteUpdate`, and
    `beforeRouteLeave` methods all together, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个页面组件，其中包含`beforeRouteEnter`、`beforeRouteUpdate`和`beforeRouteLeave`方法，如下所示：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create another page component with just the `beforeRouteEnter` and `beforeRouteLeave`
    methods, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个页面组件，只包含`beforeRouteEnter`和`beforeRouteLeave`方法，如下所示：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define the main routes and the subroute before initiating the router instance,
    as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化路由器实例之前定义主路由和子路由，如下所示：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create the navigation links with the `<router-link>` Vue component, as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`<router-link>` Vue组件创建导航链接，如下所示：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the app in your browser, and you should get the following logs in the browser
    console when switching between the routes:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中运行应用程序，当在路由之间切换时，你应该在浏览器控制台中得到以下日志：
- en: 'When navigating from `/` to `/page1`, you should see the following:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从`/`导航到`/page1`时，你应该看到以下内容：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When navigating from `/page1` to `/page2`, you should see the following:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从`/page1`导航到`/page2`时，你应该看到以下内容：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When navigating from `/page2` to `/page1/foo`, you should see the following:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从`/page2`导航到`/page1/foo`时，你应该看到以下内容：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When navigating from `/page1/foo` to `/page1/bar`, you should see the following:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从`/page1/foo`导航到`/page1/bar`时，你应该看到以下内容：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When navigating from `/page1/bar` to `/`, you should see the following:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从`/page1/bar`导航到`/`时，你应该看到以下内容：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the navigation guards in Vue are simply JavaScript functions
    that allow us to create middlewares with some default arguments. Now, let's take
    a closer look at the arguments (`to`, `from`, and `next`) that each guard method
    gets in the next section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Vue中的导航守卫只是允许我们创建中间件的JavaScript函数，带有一些默认参数。现在，让我们在下一节更仔细地看看每个守卫方法得到的参数（`to`、`from`和`next`）。
- en: 'Understanding the navigation guard arguments: to, from, and next'
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解导航守卫的参数：to、from和next
- en: You have already seen these arguments in the navigation guards used in the previous
    sections, but we haven't walked you through them yet. All guards, except the `afterEach`
    global guard, use these three arguments: `to`, `from`, and `next`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在前面的部分中看到了这些参数在导航守卫中的使用，但我们还没有向你详细介绍它们。所有守卫，除了`afterEach`全局守卫，都使用这三个参数：`to`、`from`和`next`。
- en: '**The** `to` **argument**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**`to`参数**：'
- en: 'This argument is the route object that you navigate to (hence, it is called
    the *to* argument). This object holds the parsed information of the URL and the
    route:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数是你要导航到的路由对象（因此被称为*to*参数）。这个对象保存了URL和路由的解析信息：
- en: '| namemetapathhash | queryparamsfullPathmatched |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| namemetapathhash | queryparamsfullPathmatched |'
- en: If you want to know more about each of these object properties, please visit
    [https://router.vuejs.org/api/the-route-object](https://router.vuejs.org/api/#the-route-object).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解每个这些对象属性的更多信息，请访问[https://router.vuejs.org/api/the-route-object](https://router.vuejs.org/api/#the-route-object)。
- en: '**The** `from` **argument**:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**`from`参数**：'
- en: 'This argument is the current route object that you navigate from. Again, this
    object holds the parsed information of the URL and the route:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数是你从中导航的当前路由对象。同样，这个对象保存了URL和路由的解析信息：
- en: '| namemetapathhash | queryparamsfullPathmatched |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| namemetapathhash | queryparamsfullPathmatched |'
- en: '**The** `next` **argument**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**`next`参数**：'
- en: 'This argument is a function you must call to move on to the next guard (middleware)
    in the queue. If you want to abort the current navigation, you can pass a `false` Boolean to
    this function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数是一个函数，你必须调用它才能继续到队列中的下一个守卫（中间件）。如果你想中止当前的导航，你可以向这个函数传递一个`false`布尔值：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you want to redirect to a different location, you can use the following
    line:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想重定向到不同的位置，你可以使用以下代码：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you want to abort the navigation with an instance of `Error`, you can use
    the following lines:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用`Error`的实例中止导航，你可以使用以下代码：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, you can catch the error from the root:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以从根目录捕获错误：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s create a Vue app with a simple HTML page and experiment with the
    next function in the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个带有简单HTML页面的Vue应用程序，并在以下步骤中尝试使用next函数：
- en: 'Create the following page components with the `beforeRouteEnter` method, as
    follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式创建带有`beforeRouteEnter`方法的页面组件：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we pass the `Error` instance to the next function for
    `Page1` while redirecting the route to the home page for `Page2`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将`Error`实例传递给`Page1`的下一个函数，同时将路由重定向到`Page2`的主页。
- en: 'Define the routes before initiating the router instance, as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化路由实例之前定义路由，如下所示：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create an instance of the router and *listen* to the error using the `onError`
    method:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建路由实例并使用`onError`方法*监听*错误：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create the following navigation links with the `<router-link>` Vue component:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`<router-link>` Vue组件创建以下导航链接：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the app in your browser, and you should get the following logs in the browser
    console when switching between the routes:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中运行应用程序，当在路由之间切换时，你应该在浏览器控制台中看到以下日志：
- en: 'When navigating from `/` to `/page1`, you should see the following:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从`/`导航到`/page1`时，你应该看到以下内容：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When navigating from `/page1` to `/page2`, you should see the following:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`/page1`导航到`/page2`时，你应该看到以下内容：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You will also notice that you are directed to `/` when navigating from `/page1`
    to `/page2` because of this line of code: `next({ path: ''/'' })`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '当从`/page1`导航到`/page2`时，你也会注意到被重定向到`/`，因为有这行代码：`next({ path: ''/'' })`。'
- en: So far, we have created middlewares in a single HTML page. However, in a real-life
    project, we should try creating them with the Vue Single-File Component (SFC)
    that you learned about in previous chapters. So, in the next section, you will
    learn to create middlewares in the Vue SFC with Vue CLI, as opposed to the custom
    webpack build process that you have learned so far. So, let's get to it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在单个HTML页面中创建了中间件。然而，在实际项目中，我们应该尝试使用你在之前章节中学到的Vue单文件组件（SFC）来创建它们。因此，在下一节中，你将学习如何使用Vue
    CLI在Vue SFC中创建中间件，而不是你到目前为止学到的自定义webpack构建过程。所以，让我们开始吧。
- en: Introducing Vue CLI
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Vue CLI
- en: We have used webpack to create our custom Vue SFC apps in [Chapter 5](099c1dc8-8dfa-46f8-bfbd-bfa036eefbb7.xhtml),
    *Adding Vue Components.* As a developer, it is useful to know how to peer into
    the mechanism of a complex thing, and we must also understand how to use common
    and standard patterns to work with others collaboratively. Therefore, these days,
    we are inclined to use frameworks. Vue CLI is the standard tooling for Vue app
    development. It does what our webpack custom tool does and more. If you don't
    want to create your own Vue SFC developing tool, Vue CLI is a great choice. It
    supports Babel, ESLint, TypeScript, PostCSS, PWA, unit testing, and end-to-end
    testing out of the box. To read more about Vue CLI, please visit [https://cli.vuejs.org/](https://cli.vuejs.org/).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](099c1dc8-8dfa-46f8-bfbd-bfa036eefbb7.xhtml)中使用webpack创建了我们的自定义Vue SFC应用程序，*添加Vue组件*。作为开发人员，了解如何查看复杂事物的机制非常有用，我们还必须了解如何使用常见和标准模式与他人合作。因此，这些天，我们倾向于使用框架。Vue
    CLI是Vue应用程序开发的标准工具。它可以执行我们的webpack自定义工具以及更多操作。如果你不想创建自己的Vue SFC开发工具，Vue CLI是一个很好的选择。它支持Babel、ESLint、TypeScript、PostCSS、PWA、单元测试和端到端测试。要了解更多关于Vue
    CLI的信息，请访问[https://cli.vuejs.org/](https://cli.vuejs.org/)。
- en: Installing Vue CLI
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Vue CLI
- en: 'It is very easy to get started with Vue CLI. Perform these steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue CLI非常容易入门。执行以下步骤：
- en: 'Use npm to install it globally:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用npm全局安装它：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a project when you want to:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你想要的时候创建一个项目：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You will be prompted to pick a preset – `default` or `manually select features`,
    as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被提示选择预设 - `default`或`手动选择功能`，如下所示：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Choose the `default` preset as we can install what we need manually later on.
    You should see something similar to the last part of the following output in your
    terminal when the installation is complete:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`default`预设，因为我们可以随后手动安装所需的内容。当安装完成时，你应该在终端中看到类似以下输出的最后部分：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Change your directory to `my-project` and start the development process:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录更改为`my-project`并开始开发过程：
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should get something similar to this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似于这样的东西：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the following sections, we are going to transform the navigation guards that
    you learned about in the previous sections into proper middlewares using Vue CLI.
    That means we will separate all of the hooks and guards into separate `.js` files
    and keep them in a common folder called `middlewares`. However, before we do that,
    we should first understand the project directory structure that Vue CLI generates
    for us and then add our own required directories. Let's get to it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将把你在前几节中学到的导航守卫转换成使用Vue CLI的适当中间件。这意味着我们将把所有的钩子和守卫分开成单独的`.js`文件，并将它们保存在一个名为`middlewares`的常见文件夹中。然而，在我们这样做之前，我们应该先了解Vue
    CLI为我们生成的项目目录结构，然后添加我们自己需要的目录。让我们开始吧。
- en: Understanding Vue CLI's project structure
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Vue CLI的项目结构
- en: 'After creating the project with Vue CLI, if you take a look inside the project
    directory, you''ll see that it provides us with a barebones structure, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue CLI创建项目后，如果你查看项目目录，你会发现它为我们提供了一个基本的结构，如下所示：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'From this basic structure, we can build and grow our app. So, let''s develop
    our app in the `/src/` directory and add the following directories to it using
    a router file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个基本结构开始，我们可以构建和发展我们的应用程序。因此，让我们在`/src/`目录中开发我们的应用程序，并使用路由文件添加以下目录：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will create two route components, login and secured, as SFC pages, and make
    the secured page a 403 protected page, which will require the user to log in to
    provide their name and age to access the page. The following are the files and
    the structure inside the `/src/` directory that we will need for this simple Vue
    app:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个路由组件，登录和安全，作为SFC页面，并将安全页面设置为403受保护页面，这将要求用户登录以提供其姓名和年龄以访问页面。以下是我们这个简单的Vue应用程序所需的`/src/`目录中的文件和结构：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We now have an idea of what directories and files we need for our app. Next,
    we will move on to writing the code for these files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的应用程序需要哪些目录和文件。接下来，我们将继续编写这些文件的代码。
- en: Writing middlewares and a Vuex store with Vue CLI
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Vue CLI编写中间件和Vuex存储
- en: 'If you take a look at `package.json`, you will see that the default dependencies
    that come with Vue CLI are very basic and minimal:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下`package.json`，你会发现Vue CLI默认的依赖项非常基本和最小：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'So, we will install our project dependencies and write the code we need in
    the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将安装我们项目的依赖项，并按以下步骤编写我们需要的代码：
- en: 'Install the following packages via npm:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过npm安装以下软件包：
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that Vue does not support multiple guards per route. So, if you want to
    create more than one guard for a route, Vue Router Multiguard allows you to do
    this. For more information about this package, please visit [https://github.com/atanas-dev/vue-router-multiguard](https://github.com/atanas-dev/vue-router-multiguard).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Vue不支持每个路由多个守卫。因此，如果您想为一个路由创建多个守卫，Vue Router Multiguard允许您这样做。有关此软件包的更多信息，请访问[https://github.com/atanas-dev/vue-router-multiguard](https://github.com/atanas-dev/vue-router-multiguard)。
- en: 'Create the state, actions, and mutations to store the authenticated user details
    in the Vuex store so that these details can be accessed by any component:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建状态、操作和变异以在Vuex存储中存储经过身份验证的用户详细信息，以便任何组件都可以访问这些详细信息：
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For the sake of readability and simplicity, we will separate the store''s actions
    into a separate file, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性和简单性，我们将把存储的操作分成一个单独的文件，如下所示：
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We will also separate the store''s mutations into a separate file, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将把存储的变异分成一个单独的文件，如下所示：
- en: '[PRE52]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a middleware to ensure the user has logged in:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个中间件来确保用户已登录：
- en: '[PRE53]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create another middleware to ensure the user is over 18 years old:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个中间件来确保用户年满18岁：
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Import these two middlewares in the secured route by using `vue-router-multiguard`
    to insert multiple middlewares in `beforeEnter`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`vue-router-multiguard`在`beforeEnter`中插入多个中间件，将这两个中间件导入到secured路由中：
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a client-side authentication with a simple login page. Here are the
    basic input fields we need for the `login` and `logout` methods:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的登录页面进行客户端身份验证。以下是我们需要的`login`和`logout`方法的基本输入字段：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Complete the preceding `login` and `logout` methods by dispatching the `login`
    and `logout` action methods in the `try` and `catch` blocks, as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`try`和`catch`块中分派`login`和`logout`动作方法来完成上述`login`和`logout`方法，如下所示：
- en: '[PRE57]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Import the completed login component into the login route, as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将完成的`login`组件导入到登录路由中，如下所示：
- en: '[PRE58]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that we name this route `login` because we will need this name later to
    redirect the navigation route when we get the authentication error from the preceding
    middlewares.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将此路由命名为`login`，因为我们稍后需要此名称来在前面的中间件中从导航路由重定向时使用。
- en: 'Import the `login` and `secured` routes to the index route, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`login`和`secured`路由导入到索引路由中，如下所示：
- en: '[PRE59]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Import the preceding index route into the Vue Router instance and catch the
    route errors using `router.onError`, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的索引路由导入到Vue Router实例中，并使用`router.onError`捕获路由错误，如下所示：
- en: '[PRE60]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this step, we use `router.onError` to handle the `Error` object that passed
    from the middlewares, and `router.push` to redirect the navigation route to the
    login page when the authentication conditions are not met. The name of the object
    must be the same as the login route in *step 7*, which is *login*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们使用`router.onError`来处理从中间件传递的`Error`对象，并使用`router.push`在不满足身份验证条件时将导航路由重定向到登录页面。对象的名称必须与*步骤7*中的登录路由名称相同，即*login*。
- en: 'Import the router and store it in the `main` file:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`文件中导入路由并存储：
- en: '[PRE61]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Run the project with `npm run serve`, and you should see that the app is loaded
    at `localhost:8080`. If you type a name and a number less than 18 into the input
    fields on the home page and then click on the login button, you should get an
    alert saying that "You must be over 18" when trying to access the secured page.
    On the other hand, if you type in a number higher than 18, you should see the
    name and the number on the secured page:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm run serve`运行项目，您应该看到该应用程序加载在`localhost:8080`上。如果您在主页的输入字段中输入一个名称和小于18的数字，然后点击登录按钮，您应该会收到一个警告，指出“您必须年满18岁”当尝试访问secured页面时。另一方面，如果您输入一个大于18的数字，您应该会在secured页面上看到名称和数字。
- en: '[PRE62]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You can find the entire code for this app in `/chapter-11/vue/vue-cli/basic/`
    from our GitHub repository. You can also find the app with the custom webpack
    in `/chapter-11/vue/webpack/`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的GitHub存储库的`/chapter-11/vue/vue-cli/basic/`中找到此应用程序的完整代码。您还可以在`/chapter-11/vue/webpack/`中找到具有自定义webpack的应用程序。
- en: Well done! You have managed to get through all of the sections on middleware
    for Vue projects. Now, let's apply what you have just learned about Nuxt projects
    in the upcoming section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您已经成功完成了关于Vue项目中间件的所有章节。现在，让我们在接下来的章节中应用您刚刚学到的关于Nuxt项目的知识。
- en: Writing route middlewares in Nuxt
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Nuxt中编写路由中间件
- en: As always, once we understand how middleware works in Vue, it will then be easier
    to work with it in Nuxt as Nuxt has taken care of Vue Router for us. In the coming
    sections, we will learn how to work with global and per-route middlewares for
    Nuxt apps.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了Vue中间件的工作原理后，就更容易在Nuxt中使用它，因为Nuxt已经为我们处理了Vue Router。在接下来的章节中，我们将学习如何在Nuxt应用程序中使用全局和每个路由的中间件。
- en: 'In Nuxt, all middleware should be kept in the `/middleware/` directory, and
    the middleware filename will be the name of the middleware. For example, `/middleware/user.js`
    is the user middleware. A middleware gets the Nuxt context as its first argument:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nuxt中，所有中间件都应该保存在“/middleware/”目录中，中间件的文件名将是中间件的名称。例如，“/middleware/user.js”是用户中间件。中间件将Nuxt上下文作为其第一个参数：
- en: '[PRE63]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Additionally, middleware can be asynchronous:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，中间件可以是异步的。
- en: '[PRE64]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In universal mode, middlewares are called on the server side once (for example,
    when first requesting the Nuxt app or when refreshing a page) and then on the
    client side when navigating to other routes. On the other hand, middlewares are
    always called on the client side whether you are requesting the app for the first
    time or when you are navigating to further routes after the first request. Middlewares
    are executed in the Nuxt configuration file first, then in layouts, and, finally,
    in pages. We will now start writing some global middlewares in the next section.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用模式中，中间件在服务器端只调用一次（例如，当首次请求Nuxt应用程序或刷新页面时），然后在客户端导航到其他路由时再次调用。另一方面，无论您是首次请求应用程序还是在首次请求后导航到更多路由时，中间件始终在客户端调用。中间件首先在Nuxt配置文件中执行，然后在布局中执行，最后在页面中执行。我们现在将在下一节开始编写一些全局中间件。
- en: Writing global middlewares
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写全局中间件
- en: 'Adding global middlewares is very straightforward; you just have to declare
    them in the `middleware` key in the `router` option of the `config` file. For
    example, take a look at the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 添加全局中间件非常简单；您只需在“config”文件的“路由器”选项中的“中间件”键中声明它们。例如，看一下以下内容：
- en: '[PRE65]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, let''s create some global middleware in the following steps. In this exercise,
    we want to to get the information of the user agent from the HTTP request header
    and to track the routes the user is navigating to:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤创建一些全局中间件。在这个练习中，我们想要从HTTP请求头中获取用户代理的信息，并跟踪用户正在导航到的路由：
- en: 'Create two middlewares in the `/middleware/` directory, one for obtaining the
    user agent information and the other for obtaining the route path information
    that the user is navigating to:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“/middleware/”目录中创建两个中间件，一个用于获取用户代理信息，另一个用于获取用户正在导航到的路由路径信息：
- en: '[PRE66]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Declare the preceding middlewares in the `middleware` key in the `router` option,
    as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“路由器”选项中的“中间件”键中声明前面的中间件，如下所示：
- en: '[PRE67]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that, in Nuxt, we do not need a third-party package like we do in the Vue
    app to call multiple guards.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Nuxt中，我们不需要像在Vue应用程序中那样调用多个守卫的第三方包。
- en: 'Create the store''s state and mutations for storing the visited route:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建存储访问路由的存储器状态和变化：
- en: '[PRE68]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Use the `user-agent` middleware in the `about` page:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“about”页面中使用“user-agent”中间件：
- en: '[PRE69]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As for `visits` middleware, we want to use it on a component and then inject
    this component into our layout, that is, the `default.vue` layout. First, create
    the `visits` component in the `/components/` directory:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于“visits”中间件，我们希望在组件上使用它，然后将该组件注入到我们的布局中，即“default.vue”布局。首先，在“/components/”目录中创建“visits”组件：
- en: '[PRE70]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: So, we have created two filters in this component. The `date` filter is used
    to obtain the date from a string. For example, we will get `2019-05-24` from `2019-05-24T21:55:44.673Z`. In
    comparison, the `time` filter is used to obtain the time from a string. For example,
    we will get `21:55:44` from `2019-05-24T21:55:44.673Z`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在此组件中创建了两个过滤器。“date”过滤器用于从字符串中获取日期。例如，我们将从“2019-05-24T21:55:44.673Z”中获得“2019-05-24”。相比之下，“time”过滤器用于从字符串中获取时间。例如，我们将从“2019-05-24T21:55:44.673Z”中获得“21:55:44”。
- en: 'Import the `visits` component into our layout:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“visits”组件导入到我们的布局中：
- en: '[PRE71]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We should get the following results in our browser when we navigate around
    the routes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在路由之间导航时，我们应该在浏览器中获得以下结果：
- en: '[PRE72]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Additionally, we should get the information of the user agent from the request
    headers when you are on the about page:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当您在关于页面时，应该从请求头中获取用户代理的信息：
- en: '[PRE73]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You can find the preceding source code in `/chapter-11/nuxt-universal/route-middleware/global/`
    in our GitHub repository.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的GitHub存储库中的`/chapter-11/nuxt-universal/route-middleware/global/`中找到上述源代码。
- en: That's all for global middleware. Now, let's move on to per-route middlewares in
    the next section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 全局中间件就介绍到这里。现在，让我们继续下一节的路由中间件。
- en: Writing per-route middlewares
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写路由中间件
- en: 'Adding per-route middlewares is also very straightforward; you just have to
    declare them in the `middleware` key in the specific layout or page. For example,
    take a look at the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 添加路由中间件也非常简单；您只需在特定布局或页面的`middleware`键中声明它们。例如，看一下以下内容：
- en: '[PRE74]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: So, let's create some per-route middlewares in the following steps. In this
    exercise, we will use sessions and JSON Web Tokens (JWTs) to access restricted
    pages or a secured API. Although in real life, we can either just use a session
    or a token for an authentication system, we will use both for our exercise so
    that we know how to use them together for potentially more complex production
    systems. In our exercise, we will want the user to log in and get the token from
    the server. The user will be not able to access the secured routes when the token
    is expired or invalid.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在接下来的步骤中，让我们创建一些路由中间件。在这个练习中，我们将使用会话和JSON Web Tokens（JWT）来访问受限页面或受保护的API。虽然在现实生活中，我们可以只使用会话或令牌进行身份验证系统，但我们将在练习中同时使用两者，以便了解如何将它们一起用于潜在更复杂的生产系统。在我们的练习中，我们希望用户登录并从服务器获取令牌。当令牌过期或无效时，用户将无法访问受保护的路由。
- en: 'Additionally, the user will be logged out when the session time is over:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当会话时间结束时，用户将被注销：
- en: 'Create an `auth` middleware to check whether the state in our store has any
    data. If there is no authenticated data, then we use the `error` function in the
    Nuxt context to send the error to the front:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`auth`中间件来检查我们存储中是否有任何数据的状态。如果没有经过身份验证的数据，则我们使用Nuxt上下文中的`error`函数将错误发送到前端：
- en: '[PRE75]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create a `token` middleware to ensure the token is in the store; otherwise,
    it sends the error to the front. If the token is present in the store, we set
    `Authorization` with the token to the default `axios` header:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`token`中间件来确保令牌在存储中；否则，它将错误发送到前端。如果存储中存在令牌，我们将使用令牌将`Authorization`设置为默认的`axios`标头：
- en: '[PRE76]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Add these two preceding middlewares to the `middleware` key on the secured
    page:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两个前置中间件添加到受保护页面的`middleware`键上：
- en: '[PRE77]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: After setting the `Authorization` header with the JWT in the headers, we can
    access the secured API routes, which are guarded by a server-side middleware (we
    will learn more about this in [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml),
    *Creating User Logins and API Authentication*). We will get the data from the
    secured API route that we want to access and will be prompted with the error message
    if the token is incorrect or has expired.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求头中设置带有JWT的`Authorization`标头后，我们可以访问受保护的API路由，这些路由由服务器端中间件保护（我们将在[第12章](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml)中了解更多，*创建用户登录和API身份验证*）。我们将从受保护的API路由获取我们想要访问的数据，并且如果令牌不正确或已过期，将收到错误消息提示。
- en: 'Create the store''s state, mutations, and actions in the `/store/` directory
    to store the authenticated data:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/store/`目录中创建存储的状态、mutations和actions以存储经过身份验证的数据：
- en: '[PRE78]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A known and expected behavior is that, when the​ page is refreshed, the state
    of the store is reset to default. There are a few solutions that we can use if
    we want to persist in the state:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 已知并且预期的行为是，当页面刷新时，存储的状态会重置为默认值。如果我们想要保持状态，有一些解决方案可以使用：
- en: localStorage
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: localStorage
- en: sessionStorage
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: sessionStorage
- en: vuex-persistedstate (a Vuex plugin)
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: vuex-persistedstate（一个 Vuex 插件）
- en: 'In our case, however, since we use the session to store the authenticated information,
    we can actually retrace our data from the session via the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，由于我们使用会话来存储认证信息，我们实际上可以通过以下方式从会话中重新获取我们的数据：
- en: req.ctx.session (Koa) or req.session (Express)
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: req.ctx.session（Koa）或 req.session（Express）
- en: req.headers.cookie
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: req.headers.cookie
- en: 'Once we have decided which solution or option we want to go for (let''s say
    `req.headers.cookie`), then we can refill the state as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定要选择哪种解决方案或选项（比如 `req.headers.cookie`），然后我们可以按照以下方式重新填充状态：
- en: '[PRE79]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You can find the preceding source code in `/chapter-11/nuxt-universal/route-middleware/per-route/` in
    our GitHub repository.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的 GitHub 存储库中的 `/chapter-11/nuxt-universal/route-middleware/per-route/`
    中找到前面的源代码。
- en: When all the preceding steps are followed and the middlewares are created, we
    can run this simple authentication app with `npm run dev` to see how it works.
    We will get to server-side authentication in the next chapter. Right now, we just
    have to focus on the middleware and understand how it works, which will help us
    in the next chapter. Now, let's move on to the final part of this chapter – server
    middlewares.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有前面的步骤都遵循并且中间件已经创建好后，我们可以通过 `npm run dev` 来运行这个简单的认证应用程序，看看它是如何工作的。我们将在下一章中介绍服务器端认证。现在，我们只需要专注于中间件并理解它的工作原理，这将有助于我们在下一章中。现在，让我们继续本章的最后一部分
    - 服务器中间件。
- en: Writing Nuxt server middlewares
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Nuxt 服务器中间件
- en: 'Put simply, server middlewares are server-side apps that are used as middlewares
    in Nuxt. We have been running our Nuxt apps under a server-side framework such
    as Koa since [Chapter 8](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml), *Adding
    a Server-Side Framework*. If you are using Express, this is the `scripts` object in
    your `package.json` file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，服务器中间件是在 Nuxt 中用作中间件的服务器端应用程序。自从[第8章](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml)以来，我们一直在使用像
    Koa 这样的服务器端框架来运行我们的 Nuxt 应用程序，*添加服务器端框架*。如果您使用 Express，这是您 `package.json` 文件中的
    `scripts` 对象：
- en: '[PRE80]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In this npm script, the `dev` and `start` scripts instruct the server to run
    your app from `/server/index.js`. This might not be ideal as we have coupled Nuxt
    and the server-side framework tightly, and it results in extra work in the configuration.
    However, we can tell Nuxt not to attach to the server-side framework''s configurations
    in `/server/index.js` and keep our original Nuxt run scripts as they are shown
    here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 npm 脚本中，`dev` 和 `start` 脚本指示服务器从 `/server/index.js` 运行您的应用程序。这可能不是理想的，因为我们将
    Nuxt 和服务器端框架紧密耦合在一起，这会导致在配置中额外的工作。但是，我们可以告诉 Nuxt 不要附加到 `/server/index.js` 中的服务器端框架配置，并保持我们原始的
    Nuxt 运行脚本如下所示：
- en: '[PRE81]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'On the contrary, we can have the server-side framework running under Nuxt instead,
    by using the `serverMiddleware` property in the Nuxt configuration file. For example,
    take a look at the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以在 Nuxt 配置文件中使用 `serverMiddleware` 属性，使服务器端框架在 Nuxt 下运行。例如，看一下以下内容：
- en: '[PRE82]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Unlike route middlewares, which are called before each route on the client side,
    server middlewares are always called on the server side before `vue-server-renderer`.
    Therefore, server middlewares can be used for server-specific tasks, just like
    we did with Koa or Express in previous chapters. So, let's explore how to use
    Express and Koa as our server middleware in the next sections.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与路由中间件不同，路由中间件在客户端每个路由之前调用，而服务器中间件总是在 `vue-server-renderer` 之前在服务器端调用。因此，服务器中间件可以用于服务器特定的任务，就像我们在之前的章节中使用
    Koa 或 Express 一样。因此，让我们在接下来的章节中探讨如何在 Express 和 Koa 中使用作为我们的服务器中间件。
- en: Using Express as Nuxt's server middleware
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Express 作为 Nuxt 的服务器中间件
- en: 'Let''s create a simple authentication app using Express as Nuxt''s server middleware.
    We will be still using the client-side code from the authentication exercise along
    with the per-route middlewares that you learned about in the preceding section,
    where the user is required to provide a username and password to access a secured page.
    Additionally, we will be using a Vuex store to centralize the authenticated user
    data just like before. The major difference in this exercise is that our Nuxt
    app will be *moved out* of the server-side app as a middleware, and, instead,
    the server-side app will be *moved into* the Nuxt app as middleware. So, let''s
    get started by following these steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Express作为Nuxt的服务器中间件来创建一个简单的身份验证应用程序。我们将继续使用身份验证练习中的客户端代码，以及你在前一节中学到的每个路由中间件，其中用户需要提供用户名和密码才能访问受保护的页面。此外，我们将使用Vuex存储来集中存储认证用户数据，就像以前一样。这个练习的主要区别在于，我们的Nuxt应用程序将作为中间件*移出*服务器端应用程序，而服务器端应用程序将作为中间件*移入*Nuxt应用程序。所以，让我们按照以下步骤开始：
- en: 'Install `cookie-session` and `body-parser` as server middlewares, and add the
    path of our API after them in the Nuxt `config` file, as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`cookie-session`和`body-parser`作为服务器中间件，并在Nuxt的`config`文件中添加它们之后的API路径，如下所示：
- en: '[PRE83]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note that cookie-session is a cookie-based session middleware for Express that
    stores the session in a cookie on the client side. In comparison, body-parser
    is a body-parsing middleware for Express, just like the `koa-bodyparser` for Koa
    that you learned about in [Chapter 8](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml), *Adding
    a Server-Side Framework*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，cookie-session是Express的基于cookie的会话中间件，它将会话存储在客户端的cookie中。相比之下，body-parser是Express的一个用于解析请求体的中间件，就像你在[第8章](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml)中学到的Koa的`koa-bodyparser`一样。
- en: For more information about `cookie-session` and `body-parser` for Express, please
    visit [https://github.com/expressjs/cookie-session](https://github.com/expressjs/cookie-session)
    and [https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Express的`cookie-session`和`body-parser`的更多信息，请访问[https://github.com/expressjs/cookie-session](https://github.com/expressjs/cookie-session)和[https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser)。
- en: 'Create an `/api/` directory using an `index.js` file, in which Express is imported
    and exported as another server middleware:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`index.js`文件创建一个`/api/`目录，在其中导入Express并将其导出为另一个服务器中间件：
- en: '[PRE84]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Run the app using `npm run dev`, and you should get the "Hello World!" message
    in `localhost:3000/api`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm run dev`运行应用程序，你应该在`localhost:3000/api`中收到“Hello World!”消息。
- en: 'Add the `login` and `logout` post methods in `/api/index.js`, as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤在`/api/index.js`中添加`login`和`logout`的post方法：
- en: '[PRE85]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In the preceding code, we store the authenticated payload to the Express session
    as `auth` in the HTTP request object when the user has logged in successfully.
    Then, we will clear the `auth` session by deleting it when the user has logged
    out.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，当用户成功登录时，我们将认证有效载荷存储到Express会话中作为HTTP请求对象中的`auth`。然后，当用户注销时，我们将通过删除它来清除`auth`会话。
- en: 'Create a store with `state.js` and `mutations.js`, just like you did for writing
    a per-route middleware, as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`state.js`和`mutations.js`的存储，就像你为编写每个路由中间件所做的那样，如下所示：
- en: '[PRE86]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Just as with writing per-route middleware, create the `login` and `logout`
    action methods in the `actions.js` file in the store, as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像编写每个路由中间件一样，在存储中的`actions.js`文件中创建`login`和`logout`动作方法，如下所示：
- en: '[PRE87]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Add a `nuxtServerInit` action to `index.js` in the store to repopulate the
    state from the Express session in the HTTP request object when refreshing pages:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储的`index.js`中添加一个`nuxtServerInit`动作，以便在刷新页面时从Express会话中重新填充状态到HTTP请求对象中：
- en: '[PRE88]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, just like in per-route middleware authentication, create a login page
    in the `/pages/` directory with a form. Use the same `login` and `logout` methods
    you did before to dispatch the `login` and `logout` action methods in the store:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，就像在逐路由中间件身份验证中一样，在`/pages/`目录中创建一个登录页面，并使用相同的`login`和`logout`方法来调度存储中的`login`和`logout`操作方法：
- en: '[PRE89]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Run the app with `npm run dev`. You should have an authentication app that works
    just like before, but it is no longer running from `/server/index.js`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm run dev`运行应用程序。您应该有一个与以前一样工作的身份验证应用程序，但它不再是从`/server/index.js`运行的。
- en: You can find the preceding source code in `/chapter-11/nuxt-universal/server-middleware/express/`
    in our GitHub repository.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我们的GitHub存储库的`/chapter-11/nuxt-universal/server-middleware/express/`中找到前面的源代码。
- en: Using the `serverMiddleware` property allows our Nuxt app to look neat and feel
    light again by freeing it from the server-side app, don't you think? With this
    approach, we can make it more flexible too, as we can use any server-side framework
    or app. For example, instead of using Express, we can use Koa, which we will look
    at in the next section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`serverMiddleware`属性使我们的Nuxt应用程序看起来整洁，感觉轻盈，不是吗？通过这种方法，我们也可以使其更加灵活，因为我们可以使用任何服务器端框架或应用程序。例如，我们可以使用Koa，而不是使用Express，我们将在下一节中讨论。
- en: Using Koa as Nuxt's server middleware
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Koa作为Nuxt的服务器中间件
- en: 'Just like Koa and Express, Connect is a simple framework that is used to glue
    together various middlewares for handling HTTP requests. Nuxt internally uses
    Connect as a server, so most Express middleware works with Nuxt''s server middleware.
    In comparison, it is a bit harder for Koa middleware to work as Nuxt''s server
    middleware because the `req` and `res` objects are *tucked away* and kept inside
    `ctx` in Koa. We can compare these three frameworks with a simple "Hello World"
    message, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Koa和Express一样，Connect是一个简单的框架，用于粘合各种中间件来处理HTTP请求。Nuxt在内部使用Connect作为服务器，因此大多数Express中间件都可以与Nuxt的服务器中间件一起使用。相比之下，Koa中间件要作为Nuxt的服务器中间件工作要困难一些，因为在Koa中，`req`和`res`对象被*隐藏*并保存在`ctx`中。我们可以通过一个简单的“Hello
    World”消息来比较这三个框架，如下所示：
- en: '[PRE90]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Notice that `req` is a Node.js HTTP request object, while `res` is a Node.js
    HTTP response object. They can be named anything you like, for example, *request*
    instead of *req* and *response* instead of *res*. From the preceding comparisons,
    you can see how Koa handles these two objects differently from the other frameworks. So,
    we can''t use Koa as Nuxt''s server middleware like in Express, and we can''t
    define any Koa middleware in the `serverMiddleware` property but just add the
    path of the directory where the Koa API is kept. Rest assured, it is not difficult
    to get them working as middleware in our Nuxt app. Let''s proceed with the following
    steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`req`是一个Node.js HTTP请求对象，而`res`是一个Node.js HTTP响应对象。它们可以被命名为任何你喜欢的东西，例如，*request*而不是*req*和*response*而不是*res*。从前面的比较中，你可以看到Koa如何与其他框架不同地处理这两个对象。因此，我们不能像在Express中那样将Koa用作Nuxt的服务器中间件，也不能在`serverMiddleware`属性中定义任何Koa中间件，而只能添加Koa
    API所在目录的路径。请放心，让它们作为Nuxt应用程序中的中间件工作并不困难。让我们继续以下步骤：
- en: 'Add the path where we want to create our API with Koa, as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们想要使用Koa创建API的路径，如下所示：
- en: '[PRE91]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Import `koa` and `koa-router`, create a `Hello World!` message with the router,
    and then export them to the `index.js` file inside the `/api/` directory:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`koa`和`koa-router`，使用路由创建一个`Hello World!`消息，然后将它们导出到`/api/`目录中的`index.js`文件中：
- en: '[PRE92]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Import `koa-bodyparser` and `koa-session`, and register them as middlewares
    in the Koa instance in the `/api/index.js` file, as follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`koa-bodyparser`和`koa-session`，并在`/api/index.js`文件中将它们注册为中间件，如下所示：
- en: '[PRE93]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Create the `login` and `logout` routes using the Koa router, as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Koa路由创建`login`和`logout`路由，如下所示：
- en: '[PRE94]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In the preceding code, just like in the Express example in the previous section,
    we store the authenticated payload to the Koa session as `auth` in the Koa context
    object when the user has logged in successfully. Then, we will clear the `auth` session
    by setting the session to `null` when the user has logged out.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，就像在上一节中的Express示例中一样，当用户成功登录时，我们将经过身份验证的有效负载存储到Koa会话中的`auth`中。然后，当用户注销时，我们将通过将会话设置为`null`来清除`auth`会话。
- en: 'Create a store with the state, mutations, and actions just like you did in
    the Express example. Additionally, create `nuxtServerInit` in the `index.js` file
    in the store just like you did when writing per-route middlewares:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有状态、变异和操作的存储，就像您在Express示例中所做的那样。此外，在存储中的`index.js`文件中创建`nuxtServerInit`，就像您在编写每个路由中间件时所做的那样：
- en: '[PRE95]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Just like before, create the form `login` and `logout` methods in the `/pages/`
    directory to dispatch the action methods from the store:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像以前一样，在`/pages/`目录中创建`login`和`logout`方法来调度存储中的操作方法：
- en: '[PRE96]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Run the app with `npm run dev`. You should have an authentication app that works
    just like the one in Express in the previous section, but it is no longer running
    from `/server/index.js`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm run dev`运行应用程序。您应该有一个身份验证应用程序，其工作方式与上一节中Express中的应用程序相同，但它不再是从`/server/index.js`运行的。
- en: You can find the entire source code for this example in `/chapter-11/nuxt-universal/server-middleware/koa/`
    in our GitHub repository.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的GitHub存储库的`/chapter-11/nuxt-universal/server-middleware/koa/`中找到此示例的整个源代码。
- en: Depending on your preference, you can use Express or Koa as Nuxt's server middleware
    in your next project. In this book, we mostly use Koa for its simplicity. You
    even can create custom server middleware without needing either of them. Let's
    take a look at how to create custom server middleware in the next section.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的喜好，您可以在下一个项目中使用Express或Koa作为Nuxt的服务器中间件。在本书中，我们主要使用Koa因为它简单易用。您甚至可以创建自定义服务器中间件，而无需使用它们中的任何一个。让我们在下一节中看看如何创建自定义服务器中间件。
- en: Creating custom server middleware
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义服务器中间件
- en: 'Since Nuxt internally uses Connect as the server, we can add our custom middlewares
    without the need for an external server such as Koa or Express. You can develop
    a complex Nuxt server middleware just like we did with Koa and Express in the
    previous sections. However, let''s not endlessly repeat what we have already done.
    Let''s create a very basic custom middleware that prints a "Hello World" message
    to confirm the feasibility of building a complex one from a basic middleware in
    the following steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Nuxt在内部使用Connect作为服务器，因此我们可以添加自定义中间件，而无需外部服务器，如Koa或Express。您可以开发一个复杂的Nuxt服务器中间件，就像我们在前几节中使用Koa和Express一样。但是，让我们不要无休止地重复我们已经做过的事情。让我们创建一个非常基本的自定义中间件，以打印“Hello
    World”消息来确认从基本中间件构建复杂中间件的可行性：
- en: 'Add the path where we want to create our custom middleware:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们想要创建自定义中间件的路径：
- en: '[PRE97]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Add the API routes to the `index.js` file inside the `/api/` directory:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将API路由添加到`/api/`目录中的`index.js`文件中：
- en: '[PRE98]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Run the app with `npm run dev` and navigate to `localhost:3000/api`. You should
    see the "Hello World!" message printed on your screen.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm run dev`运行应用程序，并导航到`localhost:3000/api`。您应该在屏幕上看到打印的“Hello World!”消息。
- en: You can refer to the Connect documentation at [https://github.com/senchalabs/connect](https://github.com/senchalabs/connect)
    for more information. Additionally, you can find the source code for this example
    in `/chapter-11/nuxt-universal/server-middleware/custom/` in our GitHub repository.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/senchalabs/connect](https://github.com/senchalabs/connect)上查找Connect文档以获取更多信息。此外，您可以在我们的GitHub存储库的`/chapter-11/nuxt-universal/server-middleware/custom/`中找到此示例的源代码。
- en: Well done! You have managed to get through another big chapter on Nuxt. Before
    moving on to the next chapter, let's summarize what you have learned so far.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！ 你已经成功完成了Nuxt的另一个重要章节。在继续下一章之前，让我们总结一下你到目前为止学到的东西。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the distinction between route middleware and server
    middleware. You used navigation guards from Vue Router to create middlewares for
    Vue apps. You also used Vue CLI to develop a simple Vue authentication app. Taking
    what you learned about Vue apps, you implemented the same concept (of route middleware)
    in Nuxt apps with global and per-route middlewares. After that, you managed to
    learn about Nuxt's server middleware and how to use Express and Koa as server
    middlewares. Middlewares are important and useful, especially for authentication
    and security. We have already made a few authentication apps, and we are going
    to study and understand them in more detail in the next chapter.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了路由中间件和服务器中间件之间的区别。你使用了Vue Router的导航守卫来为Vue应用程序创建中间件。你还使用了Vue CLI来开发一个简单的Vue身份验证应用程序。根据你对Vue应用程序的学习，你在Nuxt应用程序中使用了全局和每个路由的中间件来实现相同的概念（路由中间件）。之后，你学习了Nuxt的服务器中间件以及如何使用Express和Koa作为服务器中间件。中间件对于身份验证和安全非常重要和有用。我们已经制作了一些身份验证应用程序，并将在下一章中更详细地研究和理解它们。
- en: In the next chapter, you will learn, in detail, about developing user logins
    and authentication APIs to improve the authentication apps that you have created
    in this chapter. We will walk you through session-based authentication and token-based
    authentication. While you have created an authentication app using these two technologies,
    we haven't explained what they are yet. But rest assured, you will understand
    them better in the next chapter. Besides this, you will learn how to create backend
    and frontend authentication and signing in with Google OAuth for your Nuxt app.
    So, stay tuned!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将详细学习有关开发用户登录和身份验证API的内容，以改进你在本章中创建的身份验证应用程序。我们将为你介绍基于会话的身份验证和基于令牌的身份验证。虽然你已经使用这两种技术创建了身份验证应用程序，但我们还没有解释它们是什么。但请放心，你将在下一章更好地理解它们。除此之外，你还将学习如何为你的Nuxt应用程序创建后端和前端身份验证，并使用Google
    OAuth进行登录。所以，请继续关注！
