- en: Project 5 - Online Shop and Scaling Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目5 - 在线商店和扩展
- en: 'In this chapter, we will quickly set up a "Fashion Store" app in order to focus
    on more advanced topics, such as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将快速设置一个“时尚商店”应用程序，以便专注于更高级的主题，例如以下内容：
- en: Improving the compatibility of our CSS code with PostCSS and autoprefixer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进我们的CSS代码与PostCSS和autoprefixer的兼容性
- en: Linting our code with ESLint to improve its quality and style
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ESLint对我们的代码进行linting以提高其质量和风格
- en: Unit testing our Vue components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我们的Vue组件进行单元测试
- en: Localizing the app and taking advantage of the code-splitting feature of webpack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化应用程序并利用webpack的代码拆分功能
- en: Enabling server-side rendering of the app in Nodejs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Nodejs中启用应用程序的服务器端渲染
- en: Building the app for production
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为生产构建应用程序
- en: 'The app will be a simple wearable online shop that will look like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将是一个简单的可穿戴在线商店，看起来像这样：
- en: '![](assets/87d90bd9-c55e-4bfc-8d62-64d4d9722836.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/87d90bd9-c55e-4bfc-8d62-64d4d9722836.png)'
- en: Advanced development workflow
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级开发工作流程
- en: In this first section, we will improve our development workflow with new tools
    and packages. However, first, we need to set up our Fashion Store project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用新的工具和包来改进我们的开发工作流程。但是，首先，我们需要设置我们的时尚商店项目。
- en: Setting up the project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Generate a new project using the `vue init` command like we did in [Chapter
    5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml), *Project 3 - Support Center*,
    and [Chapter 6](40d407e7-1556-4265-8385-4afe5fc66430.xhtml), *Project 4 - Geolocated
    Blog*:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`vue init`命令生成一个新项目，就像我们在[第5章](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml)中所做的那样，*项目3
    - 支持中心*，以及[第6章](40d407e7-1556-4265-8385-4afe5fc66430.xhtml)中所做的那样，*项目4 - 地理定位博客*：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will also install stylus:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将安装stylus：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remove the content of the `src` folder. Then, download the sources files ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/src](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/src))
    and extract them in the `src` folder. Those contains all the app source code that
    have been already done so that we can move forward faster.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`src`文件夹的内容。然后，下载源文件（[https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/src](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/src)）并将其解压缩到`src`文件夹中。这些包含了已经完成的所有应用程序源代码，以便我们可以更快地前进。
- en: 'We need to install a few more packages in the dependencies:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在依赖项中安装一些更多的包：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: axios is a great library for making requests to the server and is recommended
    by the Vue.js team.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: axios是一个很棒的库，用于向服务器发出请求，并且被Vue.js团队推荐使用。
- en: Generating a quick development API
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成一个快速开发API
- en: 'Previously, we had a full node server for the backend, but this time we will
    not focus on the app features. So, we will use the `json-server` package to generate
    a very simple local API for the purpose of this chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们有一个完整的用于后端的node服务器，但这次我们不会专注于应用程序功能。因此，我们将使用`json-server`包为本章的目的生成一个非常简单的本地API：
- en: 'Install `json-server` as a dev dependency:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`json-server`作为开发依赖：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we run this package, it will locally expose a simple REST API and use a
    `db.json` file to store the data. You can download it ([https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/db.json](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/db.json))
    and put it in the project root directory. If you open it, you will see a few items
    for sale and a comment.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行这个包时，它将在本地公开一个简单的REST API，并使用`db.json`文件来存储数据。您可以下载它（[https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/db.json](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/db.json)）并将其放在项目根目录中。如果您打开它，您将看到一些待售物品和评论。
- en: 'Then, we will need to add a script to launch the json server. Add a new `db`
    script to the `package.json` file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加一个脚本来启动json服务器。在`package.json`文件中添加一个新的`db`脚本：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding command will run the `json-server` package command-line tool
    and watch the `db.json` file you just downloaded for changes so that you can edit
    it easily. To try it, use `npm run`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将运行`json-server`包的命令行工具，并监视您刚刚下载的`db.json`文件以进行更改，以便您可以轻松编辑它。要尝试它，请使用`npm
    run`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By default, it will listen to the port `3000`. You can already try it by opening
    the `http://localhost:3000/items` REST address in your browser:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它将监听端口`3000`。您可以通过在浏览器中打开`http://localhost:3000/items` REST地址来尝试它：
- en: '![](assets/13a1e3e2-fbe1-426a-a1be-553418aa754d.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/13a1e3e2-fbe1-426a-a1be-553418aa754d.png)'
- en: Launching the app
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: 'We are now ready to start the app. Open a new terminal and use `npm run` as
    usual:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备启动应用程序。打开一个新的终端，像往常一样使用`npm run`：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It should open a new browser window with the right address, and you should
    be able to use the app:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该打开一个新的浏览器窗口，显示正确的地址，您应该能够使用该应用程序：
- en: '![](assets/98d88834-6f0f-41c2-aaca-6b8d287b8682.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/98d88834-6f0f-41c2-aaca-6b8d287b8682.png)'
- en: Auto-prefixing CSS with PostCSS
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PostCSS自动添加CSS前缀
- en: When writing CSS (or Stylus) code, we want it to be compatible with most browsers.
    Fortunately, there are tools that will do this automatically for us, for example,
    by adding vendor-prefixed versions of the CSS properties (such as `-webkit-user-select`
    and `-moz-user-select`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写CSS（或Stylus）代码时，我们希望它与大多数浏览器兼容。幸运的是，有一些工具可以自动为我们完成这项工作，例如，通过添加CSS属性的供应商前缀版本（例如`-webkit-user-select`和`-moz-user-select`）。
- en: PostCSS is a library specialized in CSS postprocessing. It has a very modular
    architecture; it works by adding plugins to it that process the CSS in various
    ways.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS是一个专门用于CSS后处理的库。它具有非常模块化的架构；它通过向其中添加处理CSS的插件来工作。
- en: We don't have to install it. `vue-loader` already has PostCSS included. We only
    have to install the plugins we want. In our case, we need the `autoprefixer` package
    to make our CSS code compatible with more browsers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必安装它。`vue-loader`已经包含了PostCSS。我们只需要安装我们想要的插件。在我们的情况下，我们需要`autoprefixer`包来使我们的CSS代码与更多浏览器兼容。
- en: 'Install the `autoprefixer` package:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`autoprefixer`包：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For PostCSS to be active, we will need to add a configuration file called `postcss.config.js`
    in the project root directory. Let''s tell PostCSS we want to use `autoprefixer`
    in this file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使PostCSS生效，我们需要在项目根目录下添加一个名为`postcss.config.js`的配置文件。让我们在这个文件中告诉PostCSS我们想要使用`autoprefixer`：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That''s it! Our code will now be processed by `autoprefixer`. For example,
    consider this Stylus code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们的代码现在将由`autoprefixer`处理。例如，考虑这段Stylus代码：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final CSS will be as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的CSS将如下所示：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Targeting specific browsers with browserslist
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用browserslist来定位特定的浏览器
- en: 'We can change what browsers are targeted by `autoprefixer` with the `browserslist`
    configuration. It consists of a list of rules to determine which browsers to support.
    Open the `package.json` file and look for the `browserslist` field. It should
    already have the default values of the `webpack-simple` template, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`browserslist`配置更改`autoprefixer`所定位的浏览器。它包括一系列规则，用于确定要支持哪些浏览器。打开`package.json`文件，查找`browserslist`字段。它应该已经具有`webpack-simple`模板的默认值，如下所示：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first rule takes the browsers that have more than 1% of usage share on the
    internet. The second one additionally selects the last two versions of every browsers.
    Finally, we state that we don't support Internet Explorer 8 or older.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个规则获取在互联网上使用份额超过1%的浏览器。第二个规则另外选择每个浏览器的最后两个版本。最后，我们声明不支持Internet Explorer 8或更早版本。
- en: The data used is provided by the site ([https://caniuse.com/](https://caniuse.com/)),
    which is specialized in browser compatibility data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的数据由专门从事浏览器兼容性数据的网站（[https://caniuse.com/](https://caniuse.com/)）提供。
- en: 'You can now target even older browsers by customizing this field. For example,
    to target Firefox 20 and later versions, you would add the following rule:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过自定义此字段来针对甚至更旧的浏览器。例如，要针对Firefox 20及更高版本进行定位，您将添加以下规则：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can find more information about `browserslist` in its repository ([https://github.com/ai/browserslist](https://github.com/ai/browserslist)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其存储库中找到有关`browserslist`的更多信息（[https://github.com/ai/browserslist](https://github.com/ai/browserslist)）。
- en: Improving code quality and style with ESLint
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ESLint改进代码质量和风格
- en: Enforcing good coding practices and quality is essential when working on a project
    with other developers. It ensures that no syntax or basic errors are made (such
    as forgetting to declare a variable), and it helps to keep the source code clean
    and consistent. This process is called **linting**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在与其他开发人员一起开发项目时，强制执行良好的编码实践和质量至关重要。它确保不会出现语法或基本错误（例如忘记声明变量），并有助于保持源代码清洁和一致。这个过程称为**linting**。
- en: ESLint is the recommended linting tool by the Vue.js team. It provides a set
    of linting rules that can be turned on and off to check the code quality. More
    rules can be added by plugins and some packages define a preset of enabled rules.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint是Vue.js团队推荐的linting工具。它提供了一组可以打开和关闭以检查代码质量的linting规则。通过插件可以添加更多规则，并且一些软件包定义了启用规则的预设。
- en: 'We will use the StandardJS preset and the `eslint-plugin-vue` package, which
    adds more rules that help follow the official Vue styleguide ([https://vuejs.org/v2/style-guide/](https://vuejs.org/v2/style-guide/)):'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用StandardJS预设和`eslint-plugin-vue`软件包，该软件包添加了更多规则，有助于遵循官方Vue风格指南（[https://vuejs.org/v2/style-guide/](https://vuejs.org/v2/style-guide/)）。
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `eslint-config-standard` package has four peer dependencies that we need
    to install as well:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`eslint-config-standard`软件包有四个需要安装的对等依赖项：'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to use babel for the JavaScript code when ESLint parses the files,
    we will need an additional package:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在ESLint解析文件时对JavaScript代码使用babel，我们需要安装额外的软件包：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Configuring ESLint
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置ESLint
- en: 'Create a new `.eslintrc.js` file in the project root directory and write the
    following configuration:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录中创建一个新的`.eslintrc.js`文件，并编写以下配置：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we use `vue-eslint-parser` to read the files (including the `.vue` files).
    It uses `babel-eslint` when parsing the JavaScript code. We also specify the EcmaScript
    version of JavaScript and that we use the `import/export` syntax for the modules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`vue-eslint-parser`来读取文件（包括`.vue`文件）。在解析JavaScript代码时，它使用`babel-eslint`。我们还指定了JavaScript的EcmaScript版本，以及我们使用`import/export`语法进行模块化。
- en: Then, we tell ESLint that we expect to be in a browser and ES6 (or ES2015) JavaScript
    environment, which means we should be able to access globals such as `window`
    or Promise without ESLint raising undefined variable errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们告诉ESLint我们期望在浏览器和ES6（或ES2015）JavaScript环境中，这意味着我们应该能够访问全局变量，如`window`或Promise，而不会引发ESLint未定义变量错误。
- en: We also specify which configurations (or presets) we would like to use--`standard`
    and `vue/recommended`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了我们想要使用的配置（或预设）--`standard`和`vue/recommended`。
- en: Customizing the rules
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义规则
- en: 'We can change what rules are enabled and modify their options with the `rules`
    object. Add the following to the ESLint configuration:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rules`对象更改启用的规则以及修改它们的选项。将以下内容添加到ESLint配置中：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line disables the `no-use-before-define` rule, which has a bug when
    using the `...` destructuration operator. The second one changes the `commad-dangle`
    rule to enforce putting a trailing `,` comma at the end of all the array and object
    lines.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行禁用了`no-use-before-define`规则，在使用`...`解构运算符时会出现bug。第二行将`commad-dangle`规则更改为强制在所有数组和对象行的末尾放置逗号`,`。
- en: The rules have a status, which can take on those three values--`'off'` (or `0`),
    `'warn'` (or `1`), and `'error'` (or `2`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 规则有一个状态，可以取这三个值--`'off'`（或`0`），`'warn'`（或`1`），和`'error'`（或`2`）。
- en: Running ESLint
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行ESLint
- en: 'To run eslint on the `src` folder, we will need a new script in the `package.json`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`src`文件夹上运行eslint，我们需要在`package.json`中添加一个新的脚本：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should note some errors in the console:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在控制台中注意到一些错误：
- en: '![](assets/405cf69d-f21a-4c90-b2cd-f1c943e713ed.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/405cf69d-f21a-4c90-b2cd-f1c943e713ed.png)'
- en: 'Some of those issues can be fixed by ESLint by adding the `--fix` argument
    to the preceding `eslint` command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在前面的`eslint`命令中添加`--fix`参数，可以修复其中一些问题：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run it again, and you should see only one error remaining:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行它，你应该只看到一个错误剩下：
- en: '![](assets/9fa11065-ae01-4017-bf71-b27f2df6a266.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9fa11065-ae01-4017-bf71-b27f2df6a266.png)'
- en: 'ESLint tells us we shouldn''t create new objects without keeping their reference
    in a variable. If we look at the corresponding code, we see that we indeed create
    a new instance of Vue in the `main.js` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint告诉我们不应该创建新对象而不保留它们的引用变量。如果我们查看相应的代码，我们会看到我们确实在`main.js`文件中创建了Vue的新实例：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you look at the ESLint error, you can see the code of the rule--`no-new`.
    You can open the [https://eslint.org/](https://eslint.org/) website and type it
    in the search field to get the rule definition. If it's a rule added by a plugin,
    it should have the name of the plugin followed by a slash, for example, `vue/require-v-for-key`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看ESLint错误，你可以看到规则的代码--`no-new`。你可以打开[https://eslint.org/](https://eslint.org/)网站并在搜索字段中输入它以获取规则定义。如果它是由插件添加的规则，它应该有插件名称后跟一个斜杠，例如`vue/require-v-for-key`。
- en: 'This code is written as intended, since this is the standard way of declaring
    a Vue app. So, we need to disable this rule for this specific line of code by
    adding a special comment just before:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是按预期编写的，因为这是声明Vue应用程序的标准方式。因此，我们需要通过在代码的特定行之前添加一个特殊注释来禁用此规则：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ESLint inside Webpack
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack中的ESLint
- en: For now, we have to manually run the `eslint` script to check our code. It would
    be even better if we were able to check our code when it is processed by Webpack,
    so it would be fully automatic. Fortunately, this is possible thanks to the `eslint-loader`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们必须手动运行`eslint`脚本来检查我们的代码。如果我们能够在Webpack处理代码时检查我们的代码，那将更好，这样它将是完全自动的。幸运的是，这是可能的，这要归功于`eslint-loader`。
- en: 'Install it in the dev dependencies alongside the `friendly-errors-webpack-plugin`
    package, which will improve the console messages:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其安装在`friendly-errors-webpack-plugin`包的开发依赖项中，这将改善控制台消息：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we have to change the webpack configuration to add a new ESLint loader rule.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须更改webpack配置以添加新的ESLint加载器规则。
- en: 'Edit the `webpack.config.js` file and add this new rule at the top of the `module.rules`
    option:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`webpack.config.js`文件并在`module.rules`选项的顶部添加这个新规则：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Additionally, we can enable the `friendly-errors-webpack-plugin` package. Import
    it at the top of the file:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们可以启用`friendly-errors-webpack-plugin`包。在文件顶部导入它：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can't use the `import/export` syntax here, since it will be executed in nodejs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在这里使用`import/export`语法，因为它将在nodejs中执行。
- en: 'Then, add this plugin when we are in development mode by adding an `else` condition
    at the end of the configuration file:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在配置文件的末尾添加一个`else`条件时，当我们处于开发模式时添加这个插件：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Restart webpack by rerunning the `dev` script and remove a comma somewhere
    in the code. You should see the ESLint error displayed in the webpack output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新运行`dev`脚本重新启动webpack并删除代码中的逗号。你应该在webpack输出中看到ESLint错误显示：
- en: '![](assets/2a3f551a-d859-475b-a371-c77241e6fa29.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2a3f551a-d859-475b-a371-c77241e6fa29.png)'
- en: 'In the browser, you should now see the error overlay:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，现在你应该看到错误叠加：
- en: '![](assets/3f43e45a-33e9-4dee-8eec-e0324b169115.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3f43e45a-33e9-4dee-8eec-e0324b169115.png)'
- en: 'If you fix the error by putting the comma back again, the overlay will close
    and the console will display a friendly message:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过重新添加逗号来修复错误，覆盖层将关闭，并且控制台将显示友好的消息：
- en: '![](assets/30a0902a-1b0d-4313-85f2-9172ffcb67a4.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/30a0902a-1b0d-4313-85f2-9172ffcb67a4.png)'
- en: Unit testing with Jest
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest进行单元测试
- en: Important code and components should be unit tested to ensure that they are
    working as intended and to prevent most regressions when the code evolves. The
    recommended test runner for Vue components is Jest from Facebook. It is quite
    fast with a cache system and has an handy snapshot feature to help detect regressions
    even more.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的代码和组件应该进行单元测试，以确保它们按预期工作，并在代码演变时防止大多数回归。Vue组件的推荐测试运行器是来自Facebook的Jest。它具有缓存系统，速度相当快，并且具有一个方便的快照功能，可以帮助检测更多的回归。
- en: 'First, install Jest and the official Vue unit testing tools:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装Jest和官方的Vue单元测试工具：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need a few utilities related to Vue to compile the `.vue` files with
    `jest-vue` and to take snapshots of the components:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一些与Vue相关的实用程序，以使用`jest-vue`编译`.vue`文件并对组件进行快照：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The recommended way to get the HTML render of a component in node is using the
    `vue-server-renderer` package used to do server-side rendering as we will see
    later in the chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点中获取组件的HTML渲染的推荐方式是使用`vue-server-renderer`包，用于进行服务器端渲染，我们将在本章后面看到。
- en: 'Finally, we will need some babel packages to support babel compilation and
    webpack dynamic imports inside Jest:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将需要一些babel包来支持Jest内部的babel编译和webpack动态导入：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Configuring Jest
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Jest
- en: 'To configure Jest, let''s create a new `jest.config.js` file in the project
    root directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Jest，让我们在项目根目录中创建一个新的`jest.config.js`文件：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `transform` option defines processors for the JavaScript and Vue files.
    Then, we tell Jest to use `jest-serializer-vue` to serialize the snapshots of
    the components. We will also enable the source maps with the `mapCoverage` option.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform`选项定义了JavaScript和Vue文件的处理器。然后，我们告诉Jest使用`jest-serializer-vue`来序列化组件的快照。我们还将使用`mapCoverage`选项启用源映射。'
- en: You can find more configuration options at the Jest website ([https://facebook.github.io/jest/](https://facebook.github.io/jest/)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Jest网站([https://facebook.github.io/jest/](https://facebook.github.io/jest/))上找到更多配置选项。
- en: Babel configuration for Jest
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jest的Babel配置
- en: To support JavaScript `import/export` modules and dynamic imports inside Jest,
    we will need to change our babel configuration when the tests are run.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持Jest内部的JavaScript `import/export`模块和动态导入，我们需要在测试运行时更改我们的babel配置。
- en: When using Jest, we are not using webpack and the loaders we use to build the
    real application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Jest时，我们不使用webpack和我们用来构建真实应用程序的加载器。
- en: 'We need to add two babel plugins to the configuration, when the `NODE_ENV`
    environment variable is set to `"test"`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当`NODE_ENV`环境变量设置为`"test"`时，我们需要向配置中添加两个babel插件：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `transform-es2015-modules-commonjs` plugin adds support for `import/export`
    syntax to Jest, and the `dynamic-import-node` adds support for dynamic imports.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform-es2015-modules-commonjs`插件为Jest添加了对`import/export`语法的支持，`dynamic-import-node`为动态导入添加了支持。'
- en: When run, Jest will automatically set the `NODE_ENV` environment variable to
    `'test'`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，Jest会自动将`NODE_ENV`环境变量设置为`'test'`。
- en: Our first unit test
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个单元测试
- en: To be recognized by Jest anywhere by default, we need to call our test files
    `.test.js` or `.spec.js`. We will test the `BaseButton.vue` component; go ahead
    and create a new `BaseButton.spec.js` file next to it in the `src/components`
    folder.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Jest默认识别任何地方，我们需要将我们的测试文件命名为`.test.js`或`.spec.js`。我们将测试`BaseButton.vue`组件；继续在`src/components`文件夹中创建一个新的`BaseButton.spec.js`文件。
- en: 'First, we will import the component and the `shallow` method from `vue-test-utils`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从`vue-test-utils`中导入组件和`shallow`方法：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we will create a tests suite with the `describe` function:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`describe`函数创建一个测试套件：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside the tests suite, we can add our first unit test with the `test` function:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试套件内部，我们可以使用`test`函数添加我们的第一个单元测试：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will test whether the `click` event is emitted when we click on the component.
    We need to create a wrapper object around the component that will provide useful
    functions to test the component:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将测试在点击组件时是否会触发`click`事件。我们需要在组件周围创建一个包装对象，该对象将提供有用的函数来测试组件：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we will simulate a click on the component:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将模拟点击组件：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we will check whether the `click` event was emitted using the Jest
    `expect` method:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用Jest的`expect`方法检查`click`事件是否被触发：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s add a script in the `package.json` file to run Jest:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`package.json`文件中添加一个脚本来运行Jest：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, use the usual `npm run` command:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用通常的`npm run`命令：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The tests are launched and should pass as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 测试已启动并应该通过如下：
- en: '![](assets/8ba5e5b4-61b3-472e-a5d8-7061e349368d.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8ba5e5b4-61b3-472e-a5d8-7061e349368d.png)'
- en: To learn more about unit testing Vue components, you can visit the official
    guide at [https://vue-test-utils.vuejs.org/](https://vue-test-utils.vuejs.org/)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关单元测试Vue组件的更多信息，您可以访问官方指南[https://vue-test-utils.vuejs.org/](https://vue-test-utils.vuejs.org/)
- en: ESLint and Jest globals
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ESLint和Jest全局变量
- en: 'If we run ESLint now, we will get errors related to the Jest keywords such
    as `describe`, `test`, and `expect`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行ESLint，我们将会收到与Jest关键字（如`describe`，`test`和`expect`）相关的错误：
- en: '![](assets/cbe5bb34-3fa0-4ec2-845e-665b0927d6f4.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cbe5bb34-3fa0-4ec2-845e-665b0927d6f4.png)'
- en: 'We need to make a tiny change to our ESLint configuration--we have to specify
    the `jest` environment; edit the `.eslintrc.js` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对ESLint配置进行微小更改--我们必须指定`jest`环境；编辑`.eslintrc.js`文件：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, ESLint will know about the Jest keywords and will stop complaining.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，ESLint将了解Jest关键字，并将停止抱怨。
- en: Jest snapshots
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jest快照
- en: Snapshots are strings that are saved and compared each time tests are run to
    detect potential regression. They are mostly used to save the HTML render of component,
    but can be used for any value as long as it make sense to store it between tests
    and compare it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 快照是保存并比较每次运行测试时的字符串，以检测潜在的回归。它们主要用于保存组件的HTML渲染，但只要在测试之间存储它并进行比较就可以用于任何值。
- en: 'For our Vue component, we will snapshot the HTML render of it using the server-side
    Rendering tool called `vue-server-renderer`. We will need the `createRenderer`
    method from this package:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Vue组件，我们将使用名为`vue-server-renderer`的服务器端渲染工具对其进行HTML渲染快照。我们将需要来自此软件包的`createRenderer`方法：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At the start of the test, we instanciate a renderer instance, then we wrap
    the component with `shallow` and start rendering the component to a String. Finally,
    we compare the result with the previous one. Here is an example of snapshot test
    for the `BaseButton` component, passing some props values and the default slot
    content:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试开始时，我们实例化一个渲染器实例，然后用`shallow`包装组件并开始将组件渲染为字符串。最后，我们将结果与先前的结果进行比较。以下是对`BaseButton`组件进行快照测试的示例，传递一些props值和默认插槽内容：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the snapshot test is run for the first time, it will create and save the
    snapshot to a `__snapshots__` folder next to it. If you are using a versioning
    system such as git, you need to add these snapshot files to it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果首次运行快照测试，它将创建并保存快照到其旁边的`__snapshots__`文件夹中。如果您正在使用git等版本控制系统，则需要将这些快照文件添加到其中。
- en: Updating the snapshots
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新快照
- en: If you modify a component, there is a chances that its HTML render will change
    too. This means its snapshots will no longer be valid and the Jest tests will
    fail. Fortunately, the `jest` command has a `--updateSnapshots` argument. When
    used, all the failing snapshots will be resaved and will pass.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您修改了一个组件，那么它的HTML渲染也有可能会发生变化。这意味着它的快照将不再有效，Jest测试将失败。幸运的是，`jest`命令有一个`--updateSnapshots`参数。当使用时，所有失败的快照将被重新保存并通过测试。
- en: 'Let''s add a new script in our `package.json` file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`package.json`文件中添加一个新的脚本：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Modify the `BaseButton` component by changing a CSS class, for example. If your
    run the Jest tests again, you should get an error that says, the snapshots don't
    match anymore.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更改CSS类来修改`BaseButton`组件，例如。如果再次运行Jest测试，您应该会收到一个错误，指出快照不再匹配。
- en: '![](assets/697b17b2-cdb2-499a-a113-e8e3ea3c7301.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/697b17b2-cdb2-499a-a113-e8e3ea3c7301.png)'
- en: 'Now, update the snapshot with the new script:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用新的脚本更新快照：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'All the tests should pass now, and the `BaseButton` snapshot should be updated:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的测试现在应该都通过了，`BaseButton`的快照应该已经更新了：
- en: '![](assets/d00b9be6-1df2-480a-96e8-50533f37de7d.png)You should run this command
    only when you are sure there are no regressions elsewhere. A good idea is to run
    the tests normally just before, to make sure only the modified component snapshot
    fails, as expected. After you have updated the snapshots, use the normal test
    command.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d00b9be6-1df2-480a-96e8-50533f37de7d.png)您应该仅在确定其他地方没有回归时运行此命令。一个好主意是在更新快照之前正常运行测试，以确保只有修改的组件快照失败，这是预期的。更新快照后，使用正常的测试命令。'
- en: Complementary topics
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补充主题
- en: In this section, we will cover a few more topics that can be useful for bigger
    apps.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖一些对于更大型应用程序可能有用的主题。
- en: Internationalization and code-splitting
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化和代码拆分
- en: 'If the app is to be used by people in different countries, it should be translated
    to be more user-friendly and appealing. To localize the texts of the app, you
    can use the recommended `vue-i18n` package:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序将被不同国家的人使用，应该进行翻译以使其更加用户友好和吸引人。为了本地化应用程序的文本，您可以使用推荐的`vue-i18n`包：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using `vue-i18n`, we will add a link in the `AppFooter` component to a new page
    where the user can select the language. Only the link and this page will be translated,
    but you can translate more parts of the app if you wish. `vue-i18n` works by creating
    a `i18n` object from it with the translated messages and injecting it into the
    Vue app.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vue-i18n`，我们将在`AppFooter`组件中添加一个链接到一个新页面，用户可以在该页面中选择语言。只有链接和此页面将被翻译，但如果您愿意，您可以翻译应用程序的更多部分。`vue-i18n`通过使用翻译消息创建一个`i18n`对象，并将其注入到Vue应用程序中。
- en: 'In the `src/plugins.js` file, install the new plugin into Vue:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/plugins.js`文件中，将新的插件安装到Vue中：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Let's create a new folder called `i18n` in the project directory. Download the
    `locales` folder ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/locales](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/locales))
    containing the translation files and put it inside. You should have, for example,
    the `en` translations in the `i18n/locales/en.js` file.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在项目目录中创建一个名为`i18n`的新文件夹。下载包含翻译文件的`locales`文件夹（[https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/locales](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter7-download/locales)）并将其放入其中。例如，您应该在`i18n/locales/en.js`文件中有`en`的翻译。
- en: 'Create a new `index.js` file that exports the list of available languages:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`index.js`文件，导出可用语言的列表：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will need two new utility functions:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要两个新的实用函数：
- en: '`createI18n`: To create the `i18n` object, with a `locale` parameter.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createI18n`：创建`i18n`对象，带有`locale`参数。'
- en: '`getAutoLang`: That returns the two-letter language code set by the user in
    the browser, for example, `en` or `fr`. Most of the time, this will be the OS
    language setting.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAutoLang`：返回用户在浏览器中设置的两字母语言代码，例如`en`或`fr`。大多数情况下，这将是操作系统的语言设置。'
- en: 'In the `src/utils` folder, create a new `i18n.js` file and import both `VueI18n`
    and the list of available locales we defined earlier:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/utils`文件夹中，创建一个新的`i18n.js`文件，并导入之前定义的`VueI18n`和可用区域设置列表：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'At the time of writing, we need the `babel-preset-stage-2` (or less) to allow
    Babel to parse the dynamic imports. In the `package.json` file, change the `babel-preset-stage-3`
    package:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在撰写本文时，我们需要`babel-preset-stage-2`（或更低版本）来允许Babel解析动态导入。在`package.json`文件中，更改`babel-preset-stage-3`包：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Run `npm install` to update your packages.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm install`来更新您的包。
- en: Edit the `.babelrc` file in the root folder and change `stage-3` to `stage-2`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑根文件夹中的`.babelrc`文件，并将`stage-3`更改为`stage-2`。
- en: 'In order to switch to stage-2, do the following installation:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了切换到阶段2，进行以下安装：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Code-splitting with dynamic imports
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态导入进行代码拆分
- en: When we create the `i18n` object, we want to load only the translations of the
    selected locale via the `locale` argument. To do that, we will make a dynamic
    import of the file with the `import` function. It takes the path as the argument
    and returns a Promise, which will eventually resolve to the corresponding JavaScript
    module once it is loaded from the server.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`i18n`对象时，我们希望仅通过`locale`参数加载所选语言环境的翻译。为此，我们将使用`import`函数对文件进行动态导入。它以路径作为参数，并返回一个Promise，一旦从服务器加载，它将最终解析为相应的JavaScript模块。
- en: In webpack, this dynamic import feature is sometimes referred as 'code splitting',
    because webpack will move the asynchronous module to another compiled JavaScript
    file called a chunk.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在webpack中，这种动态导入功能有时被称为'代码拆分'，因为webpack将将异步模块移动到另一个编译后的JavaScript文件中，称为块。
- en: 'Here is an example of an asynchronous module loaded with a dynamic import:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用动态导入加载的异步模块的示例：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can use variables in the imported path, as long as it has some information
    about where webpack can find the files. For example, this code will not work:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在导入路径中使用变量，只要它包含有关webpack可以找到文件的一些信息。例如，这段代码将无法工作：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, the following one will work fine as long as the variable path is simple
    (without `../`):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只要变量路径简单（没有`../`），以下内容将正常工作：
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, all the files with the `json` extension in the `data` folder
    will be added to the build into asynchronous chunks, because webpack can't guess
    which ones you will really use at runtime.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`data`文件夹中所有带有`json`扩展名的文件将被添加到构建中作为异步块，因为webpack无法猜测您在运行时真正会使用哪些文件。
- en: Asynchronously loading big JavaScript modules with dynamic imports can reduce
    the size of the initial JavaScript code sent to the browser when opening the page.
    In our app, it allows us to load only the relevant translations file instead of
    including them all in the initial JavaScript file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态导入异步加载大型JavaScript模块可以减少在打开页面时发送到浏览器的初始JavaScript代码的大小。在我们的应用程序中，它允许我们仅加载所选语言环境的相关翻译文件，而不是在初始JavaScript文件中包含它们。
- en: 'If a module is already imported with a normal `import` in the main code (the
    initial chunk), it will already be loaded and will not be split into another chunk.
    In that case, you won''t have the benefits of the code-splitting feature and the
    initial file size won''t be reduced. Note that you can synchronously use other
    modules with the normal `import` keyword inside the dynamically loaded module:
    they will be put together in the chunk (if they aren''t already included in the
    initial chunk).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块已经在主代码（初始块）中使用普通的`import`导入，它将已经被加载，不会被拆分成另一个块。在这种情况下，你将无法享受代码拆分功能的好处，初始文件大小也不会减小。请注意，你可以在动态加载的模块中同步使用其他模块，使用普通的`import`关键字：它们将被放在同一个块中（如果它们尚未包含在初始块中）。
- en: The `i18n` object is created with the `VueI18n` constructor from the `vue-i18n`
    package. We will pass the `locale` argument.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`i18n`对象是使用`vue-i18n`包中的`VueI18n`构造函数创建的。我们将传递`locale`参数。'
- en: 'Here is what the `createI18n` function should look like:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`createI18n`函数应该是这样的：'
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, we need to take the `default` value of the module, because we
    exported the messages using `export default`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们需要取模块的`default`值，因为我们使用`export default`导出了消息。
- en: 'The code using `async/await` above can be written using Promises:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 上面使用`async/await`的代码可以使用Promises来编写：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Automatically loading the user locale
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动加载用户语言环境
- en: Next, we can use `navigator.language` (or `userLanguage` for Internet Explorer
    compatibility) to retrieve the locale code. Then, we will check whether it is
    available in the `langs` list or if we have to use the default `en` locale.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`navigator.language`（或`userLanguage`用于兼容Internet Explorer）来检索语言环境代码。然后，我们将检查它是否在`langs`列表中可用，或者我们是否必须使用默认的`en`语言环境。
- en: 'The `getAutoLang` function should look like this:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getAutoLang`函数应该是这样的：'
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Some browsers may return the code in the `en-US` format, but we only need the
    first two characters.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器可能以`en-US`格式返回代码，但我们只需要前两个字符。
- en: 'In the `src/main.js` file, import the two new utility functions:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main.js`文件中，导入这两个新的实用函数：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, modify the `main` function:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，修改`main`函数：
- en: Retrieve the preferred locale using `getAutoLang`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getAutoLang`检索首选语言环境。
- en: Create and wait for the `i18n` object with the `createI18n` function.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`createI18n`函数创建并等待`i18n`对象。
- en: Inject the `i18n` object into the root Vue instance.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`i18n`对象注入到根Vue实例中。
- en: 'It should now look like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它应该是这样的：
- en: '[PRE57]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Don't forget the `await` keyword in front of `createI18n`, or else you will
    get the Promise instead.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`createI18n`前面加上`await`关键字，否则你将得到一个Promise。
- en: 'You can now open the network pane in the browser devtools and refresh the page.
    The translations module corresponding to the selected locale will be loaded by
    webpack in a separate request. In this example screenshot, this is the `2.build.js`
    file that is asynchronously loaded:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在浏览器开发工具的网络面板中打开，并刷新页面。webpack将会通过单独的请求加载对应于所选语言环境的翻译模块。在这个示例截图中，这是异步加载的`2.build.js`文件：
- en: '![](assets/7fc40741-5fb8-4dac-b4fe-6b1108ed649e.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7fc40741-5fb8-4dac-b4fe-6b1108ed649e.png)'
- en: Changing Language page
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改语言页面
- en: For now, nothing really changed in the app, so let's add the page that will
    allow us to select the language.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，应用程序并没有真正改变，所以让我们添加一个页面，让我们可以选择语言。
- en: 'In the `src/router.js` file, import the `PageLocale` component:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/router.js`文件中，导入`PageLocale`组件：
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, add the `locale` route in the `routes` array, just before the last one
    (with the `*` path):'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`routes`数组中添加`locale`路由，就在最后一个路由（带有`*`路径）之前：
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the `AppFooter.vue` component, add this router link to the template:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppFooter.vue`组件中，将这个路由链接添加到模板中：
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As you can see in the preceding code, we use the `$t` provided by `vue-i18n`
    to display a translated text. The argument correspond to the key in the locale
    file. You should now see the link in the app footer:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，我们使用了`vue-i18n`提供的`$t`来显示翻译文本。参数对应于区域文件中的键。现在您应该在应用程序页脚中看到该链接：
- en: '![](assets/16f6aa12-ab37-4402-b2ad-68b0ba446978.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/16f6aa12-ab37-4402-b2ad-68b0ba446978.png)'
- en: 'The links takes us to the language selection page, which is already fully translated
    using `vue-i18n`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 链接将我们带到语言选择页面，该页面已经完全使用`vue-i18n`进行了翻译：
- en: '![](assets/ebe4ef49-49c9-4427-b65a-090b56bd23f0.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ebe4ef49-49c9-4427-b65a-090b56bd23f0.png)'
- en: You can look at its source code in the `components/PageLocale.vue` file.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`components/PageLocale.vue`文件中查看其源代码。
- en: 'When you click on a locale button, the corresponding translations are loaded
    if they aren''t already. In the network pane of the browser devtools, you should
    see a request made to other chunks each time:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当您单击区域按钮时，如果尚未加载，将加载相应的翻译。在浏览器开发工具的网络面板中，每次都应该看到对其他块的请求：
- en: '![](assets/be04ca4d-f80a-4f51-94fd-f3a2659730a8.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/be04ca4d-f80a-4f51-94fd-f3a2659730a8.png)'
- en: Server-side rendering
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: '**Server-side Rendering** (**SSR**) consists of running and rendering the app
    on the server, before sending the HTML back to the browser. This has two main
    advantages:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器端渲染**（**SSR**）包括在服务器上运行和渲染应用程序，然后将HTML发送回浏览器。这有两个主要优点：'
- en: Better **Search Engine Optimization** (**SEO**), since the initial content of
    the application will be rendered in the page HTML. This is important since no
    search engine is indexing an asynchronous JavaScript app (for example, when you
    have a spinner).
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的**搜索引擎优化**（**SEO**），因为应用程序的初始内容将在页面HTML中呈现。这很重要，因为没有搜索引擎正在索引异步JavaScript应用程序（例如，当您有一个旋转器时）。
- en: Slower networks or devices will display contents faster--the rendered HTML doesn't
    need the JavaScript to be shown to the user.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较慢的网络或设备将更快地显示内容——渲染的HTML不需要JavaScript才能显示给用户。
- en: 'However, using SSR also brings some trade-offs:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用SSR也带来了一些权衡：
- en: The code need to be able to run on the server (unless it is in client-side only
    hooks such as `mounted`). Also, some libraries may not play well on the browser
    and may require special treatments.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码需要能够在服务器上运行（除非它是在客户端专用的挂钩，比如`mounted`）。此外，一些库可能在浏览器上表现不佳，可能需要特殊处理。
- en: The load will increase on the server, since it is doing more work.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器的负载将增加，因为它要做更多的工作。
- en: The development setup is a bit more complex.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发设置有点复杂。
- en: So using SSR isn't always a good idea, especially if the time the first content
    is shown isn't critical (for example, an admin dashboard).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用SSR并不总是一个好主意，特别是如果第一次显示内容的时间不是关键的话（例如，管理仪表板）。
- en: Universal App Structure
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用应用程序结构
- en: Writing a Universal App that runs both on the client and the server requires
    changing the architecture of the source code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个可以在客户端和服务器上运行的通用应用程序需要改变源代码的架构。
- en: When running on the client, we are in a fresh context each time the page is
    loaded. That's why we used singletons instance of the root instance, the router,
    and the store until now. However, now we need to have a fresh context on the server
    as well--the problem is, Node.js is stateful. The solution is creating a fresh
    new root instance, router, and store for each request handled by the server.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端运行时，每次加载页面时我们都处于一个新的上下文。这就是为什么我们到目前为止都使用根实例、路由器和存储的单例实例。然而，现在我们也需要在服务器上有一个新的上下文——问题是，Node.js是有状态的。解决方案是为服务器处理的每个请求创建一个全新的根实例、路由器和存储。
- en: 'Let''s start with the router. In the `src/router.js` file, wrap the router
    creation into a new exported `createRouter` function:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从路由器开始。在`src/router.js`文件中，将路由器创建包装成一个新的导出的`createRouter`函数：
- en: '[PRE61]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will do the same with the Vuex store. In the `src/store/index.js` file,
    wrap the code into a new exported `createStore` function:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将对Vuex存储执行相同的操作。在`src/store/index.js`文件中，将代码包装到一个新的导出的`createStore`函数中：
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s also rename the `src/main.js` file to `src/app.js`. This will be our
    universal file that creates the router, the store, and the Vue root instance.
    Change the `main` function into an exported `createApp` function, which takes
    a `context` argument and returns the app, the router, and the store:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也将`src/main.js`文件重命名为`src/app.js`。这将是我们的通用文件，用于创建路由器、存储器和Vue根实例。将`main`函数改为导出的`createApp`函数，该函数接受一个`context`参数并返回应用程序、路由器和存储器：
- en: '[PRE63]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Don't forget to change the imports for `createRouter` and `createStore`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更改`createRouter`和`createStore`的导入。
- en: 'On the server, we won''t select the initial locale the same way as in the client
    since we won''t have access to `window.navigator`. That''s why we are passing
    the locale in the `context` argument:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，我们不会像在客户端那样选择初始区域设置，因为我们无法访问`window.navigator`。这就是为什么我们在`context`参数中传递区域设置的原因：
- en: '[PRE64]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We also removed the `el` option from the root instance definition since it doesn't
    make sense on the server.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从根实例定义中删除了`el`选项，因为在服务器上没有意义。
- en: Client entry
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端入口
- en: On the browser, the code will be started in the client entry file that we will
    write now.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器上，代码将在我们现在将编写的客户端入口文件中启动。
- en: 'Create a new `src/entry-client.js` file that will be the entry point for the
    client bundle. It will get the user language, call the `createApp` function, and
    then mount the app into the page:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/entry-client.js`文件，它将成为客户端包的入口点。它将获取用户语言，调用`createApp`函数，然后将应用程序挂载到页面上：
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can now change the entry path in the `webpack.config.js` file:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以更改`webpack.config.js`文件中的入口路径：
- en: '[PRE66]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can restart the `dev` script and check whether the app still works in the
    browser.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重新启动`dev`脚本，并检查应用程序是否仍然在浏览器中运行。
- en: Server entry
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器入口
- en: Create a new `src/entry-server.js` file that will be the entry point for the
    server bundle. It will export a function that gets a `context` object from the
    HTTP server we will build later. It should return a Promise that resolves with
    the Vue app when it's ready.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`src/entry-server.js`文件，它将成为服务器包的入口点。它将导出一个从我们稍后将构建的HTTP服务器获取`context`对象的函数。它应该返回一个Promise，在Vue应用程序准备就绪时解析该Promise。
- en: 'We will pass an `url` attribute to the context so that we can set the current
    route like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在`context`中传递一个`url`属性，以便我们可以设置当前路由，就像这样： '
- en: '[PRE67]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Similarly to the client entry, we also use the `createApp` function to create
    the root app instance, the router, and the store. `entry-server.js` should look
    like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户端入口类似，我们还使用`createApp`函数来创建根应用程序实例、路由器和存储器。`entry-server.js`应该是这样的：
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We return a Promise because we will send the application `app` when we will
    have finished all the operations.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回一个Promise，因为当我们完成所有操作时，我们将发送应用程序`app`。
- en: The `app` root instance will be send back to what we call the renderer (kind
    of like when we did Jest snapshots) using `resolve(app)`. First, we need to take
    care of preloading the Vuex store.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`app`根实例将通过`resolve(app)`发送回我们称之为渲染器的地方（有点像我们做Jest快照时）。首先，我们需要处理预加载Vuex存储。'
- en: State management
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态管理
- en: When processing a request, we need to fetch the data on the relevant components
    before rendering the app. That way, the data will already be displayed when the
    HTML is loaded by the browser. For example, `PageHome.vue` fetches the store items
    and `PageStoreItem.vue` retrieves the item details and comments.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理请求时，我们需要在渲染应用程序之前在相关组件上获取数据。这样，当浏览器加载HTML时，数据已经显示出来。例如，`PageHome.vue`获取存储项，`PageStoreItem.vue`检索项目详细信息和评论。
- en: We will add a new `asyncData` custom option to those, so we can call it on the
    server when doing SSR.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这些组件添加一个新的`asyncData`自定义选项，这样我们可以在进行SSR时在服务器上调用它。
- en: 'Edit the `PageHome.vue` component by adding this function that dispatches the
    `fetchItems` action of the `items` store module:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加此函数来编辑`PageHome.vue`组件，该函数会调度`items`存储模块的`fetchItems`操作：
- en: '[PRE69]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the `PageStoreItem.vue` component, we need to call the `fetchStoreItemDetails`
    action of the `item` store module, with the `id` parameter of the route passed
    by the server:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PageStoreItem.vue`组件中，我们需要调用服务器传递的路由的`id`参数，调用`item`存储模块的`fetchStoreItemDetails`操作：
- en: '[PRE70]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now that our components are ready, we will go back to `entry-server.js`. We
    can use the `router.getMatchedComponents()` method to get the list of components
    that matched with the current route:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的组件已经准备好了，我们将回到`entry-server.js`。我们可以使用`router.getMatchedComponents()`方法获取与当前路由匹配的组件列表：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can then call all the `asyncData` options of these components and wait for
    them to finish. We pass both the store and the current route to them, and when
    they have all completed, we send the Vuex store state back to the renderer with
    `context.state = store.state`. Use `Promise.all(array)` to wait for all the `asyncData`
    calls:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以调用这些组件的所有`asyncData`选项并等待它们完成。我们将store和当前路由传递给它们，当它们全部完成时，我们使用`context.state
    = store.state`将Vuex存储状态发送回渲染器。使用`Promise.all(array)`等待所有`asyncData`调用：
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If an error occurs, it will reject the Promise we returned to the renderer.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，它将拒绝我们返回给渲染器的Promise。
- en: Restoring the Vuex state on the client
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端恢复Vuex状态
- en: The store state is serialized by the server on a `__INITIAL_STATE__` variable
    in the HTML page. We can use this to set the state even before the app is mounted,
    so the components will have access to it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将store状态序列化为HTML页面中的`__INITIAL_STATE__`变量。我们可以使用这个来在应用挂载之前设置状态，这样组件将可以访问它。
- en: 'Edit the `entry-client.js` file and use the `store.replaceState` method before
    mounting the app:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`entry-client.js`文件，并在挂载应用之前使用`store.replaceState`方法：
- en: '[PRE73]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, the store will have the data sent by the server.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，存储将拥有服务器发送的数据。
- en: Webpack configuration
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack配置
- en: Our app code is now ready. Before continuing, we need to refactor our webpack
    configuration.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用代码现在已经准备好了。在继续之前，我们需要重构我们的webpack配置。
- en: We will need a slightly different webpack configuration for the client and the
    server. It is a good idea to have a common configuration file, which is then extended
    for the client and the server. We can do this easily with the `webpack-merge`
    package that merges multiples webpack configuration objects into one.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为客户端和服务器准备稍有不同的webpack配置。最好有一个通用的配置文件，然后为客户端和服务器进行扩展。我们可以使用`webpack-merge`包轻松实现这一点，该包将多个webpack配置对象合并为一个。
- en: For the server configuration, we also need the `webpack-node-externals` package
    to prevent webpack from bundling the packages in `node_modules`--this is not necessary
    since we will run inside nodejs and not in the browser. All the corresponding
    imports will be left as `require` statements so that node will load them itself.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器配置，我们还需要`webpack-node-externals`包来防止webpack打包`node_modules`中的包--这是不必要的，因为我们将在nodejs中运行而不是在浏览器中。所有相应的导入将保留为`require`语句，以便node自己加载它们。
- en: 'Install the packages in the dev dependencies:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发依赖项中安装这些包：
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Create a new `webpack` folder in the project root directory, then move and rename
    the `webpack.config.js` file to `webpack/common.js`. Some changes are needed.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录中创建一个新的`webpack`文件夹，然后将`webpack.config.js`文件移动并重命名为`webpack/common.js`。需要一些更改。
- en: Remove the `entry` option from the configuration. This will be specified in
    the specific extended configurations.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从配置中删除`entry`选项。这将在特定的扩展配置中指定。
- en: 'Update the `output` option to target the correct folder and to generate better
    chunk names:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `output` 选项以定位到正确的文件夹并生成更好的 chunk 名称：
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Client configuration
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端配置
- en: 'Next to `webpack/common.js`, create a new `client.js` file that extends the
    base configuration:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `webpack/common.js` 旁边，创建一个新的 `client.js` 文件，扩展基本配置：
- en: '[PRE76]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `VueSSRClientPlugin` will generate a `vue-ssr-client-manifest.json` file
    that we will give to the renderer. This way, it will know more about the client.
    Also, it will automatically inject the script tags and the critical CSS to the
    HTML.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`VueSSRClientPlugin` 将生成一个 `vue-ssr-client-manifest.json` 文件，我们将其提供给渲染器。这样，它将更多地了解客户端。此外，它将自动将脚本标签和关键
    CSS 注入到 HTML 中。'
- en: The Critical CSS is the style of the components rendered by the server. Those
    styles will be directly injected to the page HTML so that the browser doesn't
    have to wait for the CSS to be loaded; it can display those components sooner.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 关键 CSS 是服务器渲染的组件的样式。这些样式将直接注入到页面 HTML 中，这样浏览器就不必等待 CSS 加载，可以更早地显示这些组件。
- en: The `CommonsChunkPlugin` will put the webpack runtime code into a leading chunk
    so that asynchronous chunks can be injected right after it. It also improves caching
    of the app and vendor code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommonsChunkPlugin` 将 webpack 运行时代码放入一个主要的 chunk 中，这样异步 chunk 就可以在它之后被注入。它还改善了应用程序和供应商代码的缓存。'
- en: Server configuration
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器配置
- en: 'Next to `webpack/common.js`, create a new `server.js` file that extends the
    base configuration:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `webpack/common.js` 旁边，创建一个新的 `server.js` 文件，扩展基本配置：
- en: '[PRE77]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we change multiple options, such as the `target` and `output.libraryTarget`
    ones, to adapt to the node.js environment.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们更改多个选项，例如 `target` 和 `output.libraryTarget`，以适应 node.js 环境。
- en: Using the `webpack-node-externals` package, we tell webpack to ignore the modules
    located in the `node_modules` folder (which means the dependencies). Since we
    are in nodejs and not in a browser, we don't have to bundle all the dependencies
    into the bundle, so this will improve the build times.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `webpack-node-externals` 包，我们告诉 webpack 忽略位于 `node_modules` 文件夹中的模块（这意味着依赖项）。由于我们在
    nodejs 中而不是在浏览器中，我们不必将所有依赖项捆绑到包中，因此这将改善构建时间。
- en: Finally, we use `VueSSRServerPlugin` to generate the server bundle file that
    will be used by the renderer. It contains the compiled server-side code and a
    lot of other informations so that the renderer can support source maps (with the
    `source-map` value of `devtool`), hot-reloading, critical CSS injection, and other
    injections in conjunction with the client manifest data.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `VueSSRServerPlugin` 生成将被渲染器使用的服务器包文件。它包含编译后的服务器端代码和许多其他信息，以便渲染器可以支持源映射（使用
    `devtool` 的 `source-map` 值）、热重新加载、关键 CSS 注入以及与客户端清单数据一起的其他注入。
- en: Server-side setup
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端设置
- en: In development, we can't use `webpack-dev-server` directly anymore with SSR.
    Instead, we will set up the express server with webpack. Download the `server.dev.js`
    file ([https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js))
    and put it in the project root directory. This file exports a `setupDevServer`
    function that we will use to run webpack and update the server.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中，我们不能再直接使用 `webpack-dev-server` 来进行 SSR。相反，我们将使用 webpack 设置 express 服务器。下载
    `server.dev.js` 文件（[https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js)）并将其放在项目根目录中。该文件导出一个
    `setupDevServer` 函数，我们将使用它来运行 webpack 并更新服务器。
- en: 'We will also need some packages for the development setup:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些用于开发设置的包：
- en: '[PRE78]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We can create virtual file systems with `memory-fs`, watch files with `chokidar`,
    and enable webpack Hot Module Replacement in an express server with the last two
    middleware.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`memory-fs`创建虚拟文件系统，使用`chokidar`监视文件，并在express服务器中使用最后两个中间件启用webpack热模块替换。
- en: Page template
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面模板
- en: 'Create a new `index.template.html` file alongside `index.html` and copy its
    contents. Then, replace the body content with the special `<!--vue-ssr-outlet-->`
    comment:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`旁边创建一个新的`index.template.html`文件，并复制其内容。然后，用特殊的`<!--vue-ssr-outlet-->`注释替换body内容：
- en: '[PRE79]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This special comment will be replaced by the rendered markup on the server.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊的注释将被服务器上的渲染标记替换。
- en: Express server
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express服务器
- en: On the nodejs side, we will use `express` package to create our HTTP server.
    We will also need the `reify` package so that we can require files that uses the
    `import/export` syntax inside nodejs (which doesn't support it natively).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在nodejs端，我们将使用`express`包来创建我们的HTTP服务器。我们还需要`reify`包，以便我们可以在nodejs中要求使用`import/export`语法的文件（它不支持原生支持）。
- en: 'Install the new packages:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装新的包：
- en: '[PRE80]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Download this incomplete `server.js` file ([https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js))
    and put it in the project root directory. It already creates an express server
    and configures the necessary express routes.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载这个不完整的`server.js`文件（[https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js](https://github.com/Akryum/packt-vue-project-guide/blob/master/chapter7-download/server.dev.js)）并将其放在项目根目录中。它已经创建了一个express服务器并配置了必要的express路由。
- en: For now, we will focus on the development part.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于开发部分。
- en: Creating and updating the renderer
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和更新渲染器
- en: To render our app, we will need a renderer created with the `createBundleRenderer`
    function from the `vue-server-renderer` package.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染我们的应用程序，我们将需要使用`vue-server-renderer`包中的`createBundleRenderer`函数创建的渲染器。
- en: A bundle renderer is quite different from a normal renderer. It uses a server
    bundle file (that will be generated, thanks to our new webpack configuration)
    with an optional client manifest that allows the renderer to have more information
    about the code. This enables more features such as source maps and hot-reloading.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑渲染器与普通渲染器有很大不同。它使用一个服务器捆绑文件（这将由我们的新webpack配置生成），还有一个可选的客户端清单，允许渲染器对代码有更多的信息。这使得更多功能成为可能，比如源映射和热重新加载。
- en: 'In the `server.js` file, replace the `// TODO development` comment with this
    code:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`文件中，用这段代码替换`// TODO development`注释：
- en: '[PRE81]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Thanks to the `server.dev.js` file, we can add support of webpack hot-reloading
    to our express server. We also specify the path to the HTML page template, so
    we can reload it too when changed.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`server.dev.js`文件，我们可以为我们的express服务器添加webpack热重新加载支持。我们还指定了HTML页面模板的路径，因此当更改时我们也可以重新加载它。
- en: When the setup triggers an update, we create or recreate the bundle renderer.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置触发更新时，我们将创建或重新创建捆绑渲染器。
- en: Rendering the Vue app
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染Vue应用程序
- en: Next, we will need to implement the code that renders the app and send the HTML
    result back to the client.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现渲染应用程序的代码，并将HTML结果发送回客户端。
- en: 'Replace the `// TODO render` comment with this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换`// TODO render`注释：
- en: '[PRE82]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Thanks to the `req.acceptsLanguages` method from express, we can easily select
    the preferred language of the user.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于express的`req.acceptsLanguages`方法，我们可以轻松地选择用户的首选语言。
- en: When performing the request, the web browser will send a list of "accepted languages"
    by the user. This is generally the language set for either their browser or OS.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行请求时，Web浏览器将发送用户的“接受的语言”列表。这通常是他们的浏览器或操作系统设置的语言。
- en: We then use the `renderToString` method that will call the function we exported
    in the `entry-server.js` file, wait for the returned Promise to complete and then
    render the app into an HTML string. Finally, we send the result to the client
    (unless there is an error during the render).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 `renderToString` 方法，该方法将调用我们在 `entry-server.js` 文件中导出的函数，等待返回的 Promise
    完成，然后将应用程序渲染为 HTML 字符串。最后，我们将结果发送给客户端（除非在渲染过程中出现错误）。
- en: Running our SSR app
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的 SSR 应用程序
- en: 'Now is the time to run the app. Change the `dev` script to run our express
    server instead of `webpack-dev-server`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是运行应用程序的时候了。将 `dev` 脚本更改为运行我们的 express 服务器，而不是 `webpack-dev-server`：
- en: '[PRE83]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Restart the script and refresh the app. To be sure that the SSR is working
    correctly, view the source of the page:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动脚本并刷新应用程序。为了确保 SSR 正常工作，请查看页面的源代码：
- en: '![](assets/e6fa9edd-fa17-4311-ad62-3f77f09f2fcb.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e6fa9edd-fa17-4311-ad62-3f77f09f2fcb.png)'
- en: The app is already rendered in HTML by the server.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已经由服务器呈现为 HTML。
- en: Unnecessary fetch
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不必要的获取
- en: Unfortunately, something is wrong with our app. The server sends the Vuex store
    data alongside the HTML of the page, which means the app already has all the data
    it needs when running for the first time, except that the requests to retrieve
    the stored items of the item details and comments are still being made. You can
    see this because of the loading animation that appears when you first load or
    when you refresh one of the corresponding pages.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的应用出了问题。服务器将 Vuex 存储数据与页面的 HTML 一起发送，这意味着应用程序在第一次运行时已经具有了所有需要的数据，只是仍在进行检索项目详细信息和评论的请求。您可以通过加载动画来看到这一点，该动画在首次加载或刷新相应页面时出现。
- en: 'The solution to this is to prevent the components from fetching data if it
    is not necessary:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的方法是防止组件在不必要时获取数据：
- en: 'In the `PageHome.vue` component, we need to fetch the items only if we don''t
    have them already:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PageHome.vue` 组件中，我们只需要在没有这些数据时才获取项目：
- en: '[PRE84]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the `PageStoreItem.vue` component, the details and comments should be fetched
    only if we don''t have the data:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PageStoreItem.vue` 组件中，只有在没有数据时才应获取详细信息和评论：
- en: '[PRE85]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We no longer have the issue now.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不再有这个问题了。
- en: To continue learn more about SSR, you can visit the official documentation at
    [https://ssr.vuejs.org/](https://ssr.vuejs.org/) or use an easy-to-use framework
    called nuxtjs ([https://nuxtjs.org/](https://nuxtjs.org/)), which abstracts a
    lot of boilerplate away from you.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续了解 SSR，您可以访问官方文档 [https://ssr.vuejs.org/](https://ssr.vuejs.org/)，或者使用一个易于使用的框架
    nuxtjs ([https://nuxtjs.org/](https://nuxtjs.org/))，该框架为您抽象了许多样板代码。
- en: Production build
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产构建
- en: Our app is working great in development. Let's say we have finished it and we
    want to deploy it to a real server.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用在开发中运行得很好。假设我们已经完成了它，并且想要将其部署到真实服务器上。
- en: Additional configuration
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外配置
- en: We need to add some configuration for the production build of the app to ensure
    that it is optimized.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为应用程序的生产构建添加一些配置，以确保其优化。
- en: Extracting the style into CSS files
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将样式提取到 CSS 文件中
- en: Until now, the style was added to the page via the JavaScript code. This is
    great in development because it allows hot-reloading with webpack. However, in
    production, it is recommended to extract it into separate CSS files.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，样式是通过 JavaScript 代码添加到页面中的。这在开发中非常好，因为它允许使用 webpack 进行热重载。然而，在生产中，建议将其提取到单独的
    CSS 文件中。
- en: 'Install the `extract-text-webpack-plugin` package in the dev dependencies:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发依赖中安装 `extract-text-webpack-plugin` 包：
- en: '[PRE86]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the `webpack/common.js` configuration file, add a new `isProd` variable:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `webpack/common.js` 配置文件中，添加一个新的 `isProd` 变量：
- en: '[PRE87]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Modify the `vue-loader` rule to enable the CSS extraction if we are in production
    and to ignore the whitespaces between HTML tags:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`vue-loader`规则，以在生产环境下启用CSS提取，并忽略HTML标签之间的空白：
- en: '[PRE88]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Add the `ExtractTextPlugin` and the `ModuleConcatenationPlugin` to the production-only
    plugins list at the bottom of the file:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件底部的仅限生产的插件列表中添加`ExtractTextPlugin`和`ModuleConcatenationPlugin`：
- en: '[PRE89]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`ExtractTextPlugin` will put the style into CSS files and the `ModuleConcatenationPlugin`
    will optimize the compiled JavaScript code to be faster.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtractTextPlugin`将样式放入CSS文件中，而`ModuleConcatenationPlugin`将优化编译后的JavaScript代码以提高速度。'
- en: Production express server
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产环境express服务器
- en: The last changes we need to make to our code is the bundle renderer creation
    in the express server.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对我们的代码进行的最后更改是在express服务器中创建包渲染器。
- en: 'In the `server.js` file, replace the `// TODO production` comment with this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`文件中，用以下内容替换`// TODO production`注释：
- en: '[PRE90]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We will read the HTML page template, the server bundle, and the client manifest.
    Then, we create a new bundle renderer since we won't have hot-reloading in production.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将读取HTML页面模板、服务器包和客户端清单。然后，我们创建一个新的包渲染器，因为在生产环境中我们不会有热重载。
- en: New npm scripts
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的npm脚本
- en: The compiled code will be output to a `dist` directory in the project root.
    Between each build, we need to remove it so we are in a clean state. To do that
    in a cross-platform manner, we will use the `rimraf` package that can recursively
    delete files and folders.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的代码将输出到项目根目录中的`dist`目录。在每次构建之间，我们需要将其删除，以便处于干净的状态。为了以跨平台的方式做到这一点，我们将使用可以递归删除文件和文件夹的`rimraf`包。
- en: 'Install the `rimraf` package to the dev dependencies:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`rimraf`包到开发依赖项中：
- en: '[PRE91]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Add a `build` script for both the client and server bundles:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为客户端和服务器包添加一个`build`脚本：
- en: '[PRE92]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We set the `NODE_ENV` environment variable to `'production'` and run the `webpack`
    command with the corresponding webpack configuration file.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`NODE_ENV`环境变量设置为`'production'`，并使用相应的webpack配置文件运行`webpack`命令。
- en: 'Create a new `build` script that clears the `dist` folder and runs the two
    other `build:client` and `build:server` scripts:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`build`脚本，清空`dist`文件夹，并运行另外两个`build:client`和`build:server`脚本：
- en: '[PRE93]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Add a last script called `start` that runs the express server in production
    mode:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`start`的最后一个脚本，以在生产模式下运行express服务器：
- en: '[PRE94]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You can now run the build; use the usual `npm run` command:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以运行构建；使用通常的`npm run`命令：
- en: '[PRE95]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `dist` folder should now contain all the chunks generated by webpack, plus
    the server bundle and client manifest json files:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`dist`文件夹现在应该包含webpack生成的所有块，以及服务器包和客户端清单json文件：'
- en: '![](assets/b512c29d-758b-4e57-8c09-bee33bb1f435.png)These are the files that
    need to be uploaded to your real nodejs server.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b512c29d-758b-4e57-8c09-bee33bb1f435.png)这些是需要上传到真实nodejs服务器的文件。'
- en: 'We can now start the express server:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以启动express服务器：
- en: '[PRE96]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: You should also upload the `server.js`, `package.json`, and `package-lock.json`
    files to the real server. Don't forget to install the dependencies with `npm install`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该上传`server.js`、`package.json`和`package-lock.json`文件到真实服务器。不要忘记使用`npm install`安装依赖项。
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we improved our development workflow by learning how to autoprefix
    our CSS with PostCSS, lint our code for quality with ESLint, and unit test our
    components with Jest. We went even further by adding localization with the `vue-i18n`
    package and dynamic imports, and by refactoring the project to enable server-side
    rendering while still taking advantage of the awesome webpack features such as
    hot-reloading, code-splitting, and optimizations.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们通过学习如何使用PostCSS自动添加CSS前缀，使用ESLint对代码进行质量检查，以及使用Jest对组件进行单元测试，改进了我们的开发工作流程。我们甚至进一步添加了`vue-i18n`包和动态导入的本地化，并通过重构项目实现了服务器端渲染，同时仍然利用了webpack的热重载、代码分割和优化等强大功能。
- en: In the last chapter, we will create a simple real-time app with the Meteor fullstack
    framework and Vue.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将使用Meteor全栈框架和Vue创建一个简单的实时应用程序。
